<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: AX Language Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('ax.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">AX Language Documentation </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1 class="doxsection"><a class="anchor" id="axlanguage"></a>
Intro</h1>
<dl class="section user"><dt></dt><dd>Welcome to the AX Language documentation. These docs provide detailed information on the AX language including syntax, data types, available functionality (including OpenVDB specific methods) execution structure and control flow. See the <a class="el" href="axcplusplus.html">AX C++ Documentation</a> documentation for the C++ developer documentation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some sections of this document are still to be completed. Please get in touch should you have any questions!</dd></dl>
<h1 class="doxsection"><a class="anchor" id="axcontents"></a>
Contents</h1>
<ul>
<li><a class="el" href="#axintro">Introduction</a></li>
<li><a class="el" href="#axprograms">AX Programs</a><ul>
<li><a class="el" href="#axprogramexample">A Program Example</a></li>
<li><a class="el" href="#axexecutionxcontext">OpenVDB Execution Context</a></li>
</ul>
</li>
<li><a class="el" href="#axdatatypes">Data Types</a><ul>
<li><a class="el" href="#axscalars">Scalars</a></li>
<li><a class="el" href="#axvecmats">Vectors / Matrices</a></li>
<li><a class="el" href="#axstrings">Strings</a></li>
<li><a class="el" href="#axtypeprecedence">Implicit conversion / type precedence</a></li>
</ul>
</li>
<li><a class="el" href="#axoperators">Operators</a><ul>
<li><a class="el" href="#axopbinary">Binary Operators</a><ul>
<li><a class="el" href="#axopassignment">Assignments</a></li>
<li><a class="el" href="#axopbinarithmetic">Arithmetic</a></li>
<li><a class="el" href="#axopcomparison">Comparisons / Relational</a></li>
<li><a class="el" href="#axopbinlogical">Logical</a></li>
</ul>
</li>
<li><a class="el" href="#axopunary">Unary Operators</a><ul>
<li><a class="el" href="#axopunarithmetic">Arithmetic</a></li>
<li><a class="el" href="#axopunlogical">Logical</a></li>
<li><a class="el" href="#axopunincdec">Increment / Decrement</a></li>
</ul>
</li>
<li><a class="el" href="#axopaccess">Container Access</a></li>
<li><a class="el" href="#axopother">Other</a></li>
<li><a class="el" href="#axopprecedence">Operator Precedence</a></li>
</ul>
</li>
<li><a class="el" href="#axtokens">Tokens</a><ul>
<li><a class="el" href="#axvaridentifiers">Variable Identifiers</a></li>
<li><a class="el" href="#axliterals">Literals</a></li>
<li><a class="el" href="#axcomments">Comments</a></li>
<li><a class="el" href="#axkeywords">Keywords</a><ul>
<li><a class="el" href="#axreserved">Reserved Keywords</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="#axsyntax">Syntax</a><ul>
<li><a class="el" href="#axattribaccess">Attribute Access</a></li>
<li><a class="el" href="#axexternalaccess">External Parameter Access</a></li>
<li><a class="el" href="#axdecls">Declarations</a></li>
<li><a class="el" href="#axscopes">Scopes</a></li>
<li><a class="el" href="#axbranching">Branching (if / else)</a></li>
<li><a class="el" href="#axloops">Loops</a></li>
</ul>
</li>
<li><a class="el" href="#axfunctions">Functions</a><ul>
<li><a class="el" href="#axuserfunctions">User Functions</a></li>
</ul>
</li>
<li><a class="el" href="#axvexsupport">AX VEX Support</a></li>
<li><a class="el" href="axexamples.html">AX Code Examples</a></li>
</ul>
<h1 class="doxsection"><a class="anchor" id="axintro"></a>
Introduction</h1>
<dl class="section user"><dt></dt><dd>AX is a fast and portable JIT compiled expression language, designed for writing volume and point kernels represented as OpenVDB grids. It was originally developed by the RNDFX team at <a href="https://www.dneg.com">DNEG</a> to provide a more consistent way for artists to be able to interface with OpenVDB data across a variety of in house and external digital content creation software, whilst retaining the performance achievable by custom C++ operators. </dd></dl>
<dl class="section user"><dt></dt><dd>The language is predominately inspired by <a href="https://www.sidefx.com/docs/houdini/vex/index.html">SideFX's VEX</a> language which itself takes elements from C, C++ and the Renderman Shading Language. The design of AX uses concepts from these languages and refrains from deviating from their syntax too significantly. Specifically, it does not aim to change what are already well established and heavily used language syntaxes within the Visual Effects industry; on the contrary, AX aims to provide an interface to which a user with previous or little programming experience can easily transition to. However, it does introduce new concepts where the creators deemed necessary to provide the best and most representative syntax relating to the design for OpenVDB volume and point modification.</dd></dl>
<h1 class="doxsection"><a class="anchor" id="axprograms"></a>
AX Programs</h1>
<dl class="section user"><dt></dt><dd>AX programs represent a set of statements which read and write to geometry, with each program designed in such a way that it can be executed in a highly parallelized framework to access and update individual geometric components. For example, consider a mesh with point, vertex and primitive attributes. AX programs are designed to run independently across "elements" of input geometry and process "attributes" from a particular element. In this case, the element level would correlate to either points, vertexes or primitives, and a single element would be a unique instance of one of these. These programs are at their most efficient writing to the currently processing element, however do provide varying levels of access to the geometry as a whole. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that native AX only supports the modification of OpenVDB data. Currently, that means that native AX programs can be written and built for execution over OpenVDB Points or OpenVDB Volumes. For any given AX program, the execution context (what it's processing) may change what functionality is available and, more importantly, the behaviour of reading/writing from attributes. See the <a class="el" href="#axexecutionxcontext">OpenVDB Execution Context</a> for details. </dd></dl>
<dl class="section user"><dt></dt><dd>Whilst powerful, AX is not a catch all replacement for all types of VDB operations. Some of this is related to its infancy i.e. missing native support for some useful functions, the foundations of which may be supported by AX but have not yet been exposed. However there may be certain paradigms which AX is better tailored to support than others. Grid reductions, for example, typically require the passing of a state between programs; a design pattern which AX is less equipped to handle. AX kernels can be abstractly thought of as a "foreach()" function (see <a class="el" href="#axprogramexample">A Program Example</a>) and whilst there are ways to achieve reductions, it is an example which would be better suited to a custom C++ implementation. </dd></dl>
<dl class="section user"><dt></dt><dd>For details of extending AX for custom geometry, see the <a class="el" href="axcplusplus.html">AX C++ Documentation</a> developer documentation. Note that custom geometry support requires <span class="tt">C++</span> extension.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="axprogramexample"></a>
A Program Example</h2>
<dl class="section user"><dt></dt><dd>Before getting into the technical depths of the language, it's a good idea to observe a small but complete AX program which could be compiled and executed. To begin with, here is a very simple example of a program that reads and writes to a particular attribute: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="comment">// read a floating point attribute from the value of &quot;myattribute&quot;</span></div>
<div class="line"><span class="keywordtype">float</span> temp = <span class="keywordtype">float</span>@myattribute;</div>
<div class="line"><span class="comment">// if the value is less than 0, clamp it to 0</span></div>
<div class="line"><span class="keywordflow">if</span> (temp &lt; 0.0f) <span class="keywordtype">float</span>@myattribute = 0.0f;</div>
</div><!-- fragment --> Note that there is no other required logic here to make this a compatible program i.e. feeding this code to the <a class="el" href="axcplusplus.html#vdbaxbinary">vdb_ax command line binary</a> will compile and execute over provided OpenVDB files. </dd></dl>
<dl class="section user"><dt></dt><dd>The following explains the above example in relation to OpenVDB data; OpenVDB points and OpenVDB volumes. The example demonstrates reading from a value on some input, either a point attribute or a voxel value, and storing the result in a <a class="el" href="#axdecls">local variable</a>. Importantly, the attribute being accessed has the name <span class="tt">myattribute</span> and the type <span class="tt">float</span>. The first statement: <div class="fragment"><div class="line"><span class="keywordtype">float</span> temp = <span class="keywordtype">float</span>@myattribute;</div>
</div><!-- fragment --> Invokes a <b>read</b> from this attribute (see <a class="el" href="#axattribaccess">Attribute Access</a>), retrieving the value from the geometry and storing it in the variable <span class="tt">temp</span> to be used in the AX program. The second statement: <div class="fragment"><div class="line"><span class="keywordflow">if</span> (temp &gt; 0.0f) <span class="keywordtype">float</span>@myattribute = 0.0f;</div>
</div><!-- fragment --> Performs a comparison of this value with <span class="tt">0.0f</span> and, if the value is greater than <span class="tt">0.0f</span>, performs a <b>write</b> to the geometry in the form of <span class="tt">float@myattribute = 0.0f;</span> which sets the value of this attribute on the geometry to <span class="tt">0.0f</span>. </dd></dl>
<dl class="section user"><dt></dt><dd>For OpenVDB Points, this kernel is run over every point in an OpenVDB Points Grid. In simple pseudo code: <div class="fragment"><div class="line">foreach(point in pointgrid)</div>
<div class="line">    run_ax_kernel(point)</div>
<div class="line">done()</div>
</div><!-- fragment --> Where <span class="tt">pointgrid</span> is a single Point Data Grid. For OpenVDB volumes the kernel is run over each voxel in a provided grid: <div class="fragment"><div class="line">foreach(grid in grids)</div>
<div class="line">    foreach(voxel IN grid)</div>
<div class="line">        run_ax_kernel(voxel)</div>
<div class="line">    done()</div>
<div class="line">done()</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Where <span class="tt">grids</span> can comprise of any number of OpenVDB volumes. In this program, only a floating point grid with the name <span class="tt">myattribute</span> will be updated. Each voxel in this grid will have it's value compared in the same way as the points example given above.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="axexecutionxcontext"></a>
OpenVDB Execution Context</h2>
<dl class="section user"><dt></dt><dd>AX programs are designed to run over different types of grids, specifically OpenVDB points and OpenVDB volumes, the latter of which is the set of all default supported mathematic volume types in OpenVDB. Programs must be compiled separately for points and volumes, or twice to support both (see the <a class="el" href="axcplusplus.html#vdbaxbinary">vdb_ax binary</a>). This is known as compiling for a target <b>Execution Context</b>. There are two main considerations to make when switching between execution contexts:<ul>
<li>Certain <a class="el" href="#axfunctions">functions</a> may not be available under a given context. Some natively supported functions are designed to interface directly with geometry attributes, and a further subset of these are tailored specifically for point attributes <b>or</b> voxel values, not both.</li>
<li>Whilst the AX grammar does not change syntactically, <a class="el" href="#axattribaccess">attribute accesses</a> may be affected. This is due to the fundamental differences of executing over different types of VDBs/geometry. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Execution over Points</dt><dd>AX kernels compiled for OpenVDB Points run <b>individually</b> on <b>each point</b> in every <b>active voxel</b> in a points VDB. Attributes that have been accessed in the program are provided such that the program has access to all data available on the currently processing point. Multiple OpenVDB Point grids can be processed by the same AX program, but only a single OpenVDB Points grid can be processed at a time. The default behaviour for AX point programs is to process every point which exists in active OpenVDB voxels. </dd></dl>
<dl class="section user"><dt>Execution over Volumes</dt><dd>AX kernels for OpenVDB volumes run individually on every <b>active voxel</b> of VDBs which are <b>written</b> to (whilst retaining access to all available VDBs). Volumes can be thought of as only holding a single "attribute". Whilst points hold all attributes within a single VDB points grid (and values for all attributes are are defined for all points in that grid), multiple volume attributes require multiple VDB volumes to be accessed. The location of this access is the <b>world space position</b> of each voxel. Assignment operations determine which volumes will be executed over. </dd></dl>
<dl class="section user"><dt></dt><dd>See the syntax section on <a class="el" href="#axattribaccess">accessing attribute</a> for more information.</dd></dl>
<p><br  />
</p><hr  />
<h1 class="doxsection"><a class="anchor" id="axdatatypes"></a>
Data Types</h1>
<dl class="section user"><dt></dt><dd>AX supports a rich variety of native types to be able to maximise the efficiency of arithmetic operations and facilitate accessing underlying geometry. As AX is designed for OpenVDB, native AX types aim to provide direct access to all supported OpenVDB data types. You may find, however, that some AX types do not exist as OpenVDB volume/point types or refuse to be serialized in some installations of OpenVDB. The table below lists all available types in AX, the exposed <a class="el" href="#axattribaccess">attribute access</a> syntax and whether or not the attribute syntax is valid for both point and volume execution contexts. Developers installing OpenVDB and OpenVDB AX may wish to read the <a class="el" href="axcplusplus.html#vdbaxtoaxtypes">type registry documentation</a> which explains how to enable missing types from OpenVDB. <a class="anchor" id="axdatatypestable"></a></dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Category</th><th>Type</th><th>Definition</th><th>Attribute Syntax</th><th>Points</th><th>Voxels</th></tr>
<tr>
<td rowspan="7"><a class="el" href="#axscalars">Scalars</a> </td><td><span class="tt">bool</span></td><td>Boolean value, true or false</td><td><span class="tt">bool@</span></td><td><b>Yes</b> </td><td><b>Yes</b> </td></tr>
<tr>
<td><span class="tt">int16</span>*</td><td>16-bit signed integer value</td><td><span class="tt">int16@</span></td><td><b>Yes</b> </td><td>No</td></tr>
<tr>
<td><span class="tt">int32</span></td><td>32-bit signed integer value</td><td><span class="tt">int32@,   int@,   i@</span></td><td><b>Yes</b> </td><td><b>Yes</b> </td></tr>
<tr>
<td><span class="tt">int</span></td><td colspan="4">Alias for integer type (typically int32)</td></tr>
<tr>
<td><span class="tt">int64</span></td><td>64-bit signed integer value</td><td><span class="tt">int64@</span></td><td><b>Yes</b> </td><td><b>Yes</b> </td></tr>
<tr>
<td><span class="tt">float</span></td><td>32-bit floating point value</td><td><span class="tt">float@   f@   @</span></td><td><b>Yes</b> </td><td><b>Yes</b> </td></tr>
<tr>
<td><span class="tt">double</span></td><td>64-bit floating point value</td><td><span class="tt">double@</span></td><td><b>Yes</b> </td><td><b>Yes</b> </td></tr>
<tr>
<td style="border-top-width: thick" rowspan="9"><a class="el" href="#axvecmats">Vectors</a> </td><td style="border-top-width: thick"><span class="tt">vec2i</span></td><td style="border-top-width: thick">2-element vector of integer values</td><td style="border-top-width: thick"><span class="tt">vec2i@</span></td><td style="border-top-width: thick">No</td><td style="border-top-width: thick">No</td></tr>
<tr>
<td><span class="tt">vec2f</span></td><td>2-element vector of float values </td><td><span class="tt">vec2f@</span></td><td>No</td><td>No</td></tr>
<tr>
<td><span class="tt">vec2d</span></td><td>2-element vector of double values </td><td><span class="tt">vec2d@</span></td><td>No</td><td>No</td></tr>
<tr>
<td><span class="tt">vec3i</span></td><td>3-element vector of integer values</td><td><span class="tt">vec3i@</span></td><td><b>Yes</b> </td><td><b>Yes</b> </td></tr>
<tr>
<td><span class="tt">vec3f</span></td><td>3-element vector of float values </td><td><span class="tt">vec3f@    v@</span></td><td><b>Yes</b> </td><td><b>Yes</b> </td></tr>
<tr>
<td><span class="tt">vec3d</span></td><td>3-element vector of double values </td><td><span class="tt">vec3d@</span></td><td><b>Yes</b> </td><td><b>Yes</b> </td></tr>
<tr>
<td><span class="tt">vec4i</span></td><td>4-element vector of integer values</td><td><span class="tt">vec4i@</span></td><td>No</td><td>No</td></tr>
<tr>
<td><span class="tt">vec4f</span></td><td>4-element vector of float values </td><td><span class="tt">vec4f@</span></td><td>No</td><td>No</td></tr>
<tr>
<td><span class="tt">vec4d</span></td><td>4-element vector of double values </td><td><span class="tt">vec4d@</span></td><td>No</td><td>No</td></tr>
<tr>
<td style="border-top-width: thick" rowspan="4"><a class="el" href="#axvecmats">Matrices</a> </td><td style="border-top-width: thick"><span class="tt">mat3f</span></td><td style="border-top-width: thick">3x3-matrix of float values </td><td style="border-top-width: thick"><span class="tt">mat3f@</span> </td><td style="border-top-width: thick"><b>Yes</b> </td><td style="border-top-width: thick">No </td></tr>
<tr>
<td><span class="tt">mat3d</span></td><td>3x3-matrix of double values</td><td><span class="tt">mat3d@</span></td><td><b>Yes</b> </td><td>No</td></tr>
<tr>
<td><span class="tt">mat4f</span></td><td>4x4-matrix of float values </td><td><span class="tt">mat4f@</span></td><td><b>Yes</b> </td><td>No</td></tr>
<tr>
<td><span class="tt">mat4d</span></td><td>4x4-matrix of double values</td><td><span class="tt">mat4d@</span></td><td><b>Yes</b> </td><td>No</td></tr>
<tr>
<td style="border-top-width: thick" rowspan="1"><a class="el" href="#axstrings">Strings</a> </td><td style="border-top-width: thick"><span class="tt">string</span></td><td style="border-top-width: thick">A string of characters </td><td style="border-top-width: thick"><span class="tt">string@</span> </td><td style="border-top-width: thick"><b>Yes</b> </td><td style="border-top-width: thick"><b>Yes</b> </td></tr>
</table>
<ul>
<li><b>Note*</b> - There is no support for int16 local variables or integer literals.</li>
</ul>
</dd></dl>
<h2 class="doxsection"><a class="anchor" id="axscalars"></a>
Scalars</h2>
<dl class="section user"><dt></dt><dd>AX Supports boolean, integer and floating point scalar types. <span class="tt">int</span> and <span class="tt">int32</span> represent 32-bit integer values and <span class="tt">int64</span> represents a 64-bit value. <span class="tt">float</span> and <span class="tt">double</span> represent 32-bit and 64-bit floating point values respectively. All scalars, excluding bools, are signed; there are no other unsigned scalar types in AX. </dd></dl>
<dl class="section user"><dt>Integer Overflow and Floating Point Truncation</dt><dd>Scalars may be cast from one type to another, either explicitly using the <a class="el" href="#axopother">cast</a> operator or implicitly during <a class="el" href="#axopassignment">assignments</a> or <a class="el" href="#axopbinarithmetic">binary arthimetic</a> operations (in which case the order of <a class="el" href="#axtypeprecedence">type precedence</a> is observed). Data can be truncated (converting floats to integrals) or overflow (conversions from integers of larger bit widths to integers of smaller bit widths) depending on the source and target types. See the below examples: </dd></dl>
<dl class="section user"><dt></dt><dd>This example demonstrates floating point truncation in AX. <div class="fragment"><div class="line"><span class="keywordtype">float</span> a = 1.1f;</div>
<div class="line"><span class="keywordtype">int</span> b = 5.5f; <span class="comment">// implict conversion from literal 5.5f. &quot;b&quot; is set to 5</span></div>
<div class="line">b = a; <span class="comment">// implicit conversion from float &quot;a&quot;. &quot;b&quot; is set to 1</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>This example demonstrates integer overflow in AX. <div class="fragment"><div class="line">int64 a = 2147483648l; <span class="comment">// one more than can be held in an int (note the last letter &quot;l&quot;)</span></div>
<div class="line"><span class="keywordtype">int</span> b = a; <span class="comment">// implicit conversion. &quot;b&quot; is set to -2147483648</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Infinite and NaN values</dt><dd>Floating point values have two additional intrinsic states; <span class="tt">inf</span> and <span class="tt">nan</span>. These states can occur during invalid floating point arithmetic. AX performs no checks on arithmetic to catch these values. A typical example of both <span class="tt">inf</span> and <span class="tt">nan</span> values are division by zero expressions: <div class="fragment"><div class="line"><span class="keywordtype">float</span> a = 1.0f/0.0f;</div>
<div class="line">print(a); <span class="comment">// prints &quot;inf&quot;</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">float</span> a = 0.0f/0.0f;</div>
<div class="line">print(a); <span class="comment">// prints some version of &quot;nan&quot;</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Generally these values are not desired and can cause problems as they propagate throughout your program.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="axvecmats"></a>
Vectors / Matrices</h2>
<dl class="section user"><dt></dt><dd>All vector and matrix types in AX are implemented as flat arrays of a given size, with all elements stored contiguously in memory. Both container types are represented by <a class="el" href="#axdatatypestable">specific tokens</a> which tell AX functions and operators how to handle various arithmetic. </dd></dl>
<dl class="section user"><dt>Vectors</dt><dd>There is currently support for vectors of sizes 2, 3 and 4 elements. The suffix letter on the vector types denotes the contained elements precision, with the number corresponding to the vector size. For example, <b>`vec2i`</b> denotes a vector of two 32-bit integer elements. There are no native types for vectors with <span class="tt">bool</span>, <span class="tt">int16</span> or <span class="tt">int64</span> elements, so these are not supported. </dd></dl>
<dl class="section user"><dt>Matrices</dt><dd>Matrices are stored in row major layout (lexographical access order) which matches the representation of a matrix in OpenVDB. Matrix support consists of <span class="tt">float</span> and <span class="tt">double</span> precision elements with dimensions either <span class="tt">3x3</span> or <span class="tt">4x4</span> (total size of 9 and 16 elements respectively). There are no integer or boolean matrix types. Similiar to vectors, the suffix letter on the type denotes the contained elements precision, with the number corresponding to the matrix dimension. A matrix of type <span class="tt">mat3d</span> therefor corresponds to a <span class="tt">3x3</span> matrix (9 elements) with <span class="tt">double</span> precision elements. </dd></dl>
<dl class="section user"><dt>Element Access</dt><dd>As elements of all matrix and vector types are stored contiguously, they can be accessed by the <a class="el" href="#axvecaccessop">[]&#160;operator</a>. Vector elements can also be accessed by supported <a class="el" href="#axopaccess">.&#160;operator</a> components and matrix elements can be accessed with the <a class="el" href="#axmataccessop">[,]&#160;operator</a>. </dd></dl>
<dl class="section user"><dt>Initialization</dt><dd>Both matrices and vector declarations can be flat initialized from scalars or component initialized from containers of the same size (see <a class="el" href="#axopassignment">assignments</a>). However both types can also be represented as temporary containers without declarations using the <a class="el" href="#axvecmatinit">{,} syntax.</a> </dd></dl>
<dl class="section user"><dt>A Note on Operators</dt><dd>Most <a class="el" href="#axopbinary">binary operators</a> only accept vectors of <b>equal</b> sizes as valid left and right operands - however there exists valid <a class="el" href="#axopbinarithmetic">arithmetic</a> for combinations of vectors/matrices with scalars and, importantly, <a class="el" href="#axbinmultop">multiplicative arithmetic</a> for vectors with matrices, the latter performing matrix projections (transformations) on vector arguments.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="axstrings"></a>
Strings</h2>
<dl class="section user"><dt></dt><dd>Strings are an array of characters stored in a unique AX type which is incompatible with <a class="el" href="#axopaccess">container accesses</a>. As such, string support is currently fairly limited. Characters themselves (users may know this as a <span class="tt">char</span> type) have no frontend type, so a <span class="tt">string</span> type must be used for any number of characters (including the empty string). String literals are represented by enclosing any number of <a class="el" href="#axtokens">supported AX characters</a> by quotes&#160;<span class="tt">" "</span>.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="axtypeprecedence"></a>
Implicit conversion / type precedence</h2>
<dl class="section user"><dt></dt><dd>All operators that perform on two or more types must internally run the operation at a single precision. When mixing different types (e.g. <span class="tt">int +
float</span>) values may need to be converted to another type before the operation is performed. To allow for easier writing of expressions, AX will automatically detect these cases and convert values when necessary. This is known as <b>implicit type conversion</b> and the way in which the target operation type is chosen is known as <b>type precedence</b>. </dd></dl>
<dl class="section user"><dt></dt><dd>When referring to type precedence, we are primarily refering to the conversion of one <b>scalar</b> type to another. For vectors, matrices and other containers, this refers to the conversion of their element type e.g. <span class="tt">mat3f</span> to <span class="tt">mat3d</span>. The conversion rules for more than the element type (e.g. <span class="tt">int</span> to <span class="tt">mat4f</span>) are governed by AX's assignment and operator rules, detailed in the <a class="el" href="#axoperators">Operators</a> section of this documentation. </dd></dl>
<dl class="section user"><dt></dt><dd>Type precedence <b>only</b> applies to the <b>element</b> type of the type in question. Containers (such as vectors or matrices) may change their element type precision (e.g. <span class="tt">vec2i</span> to <span class="tt">vec2f</span>). Each scalar type has a ranking which is compared, and the resulting highest rank is chosen as the target type for all values. These rankings are defined as follows:<ul>
<li>If any element types are of type <span class="tt">double</span>, all other element types are converted to <span class="tt">double</span></li>
<li>else, if any element types are of type <span class="tt">float</span>, all other element types are converted to <span class="tt">float</span></li>
<li>else, if any element types are of type <span class="tt">int64</span>, all other element types are converted to <span class="tt">int64</span></li>
<li>else, if any element types are of type <span class="tt">int32</span>, all other element types are converted to <span class="tt">int32</span></li>
<li>else, all element types are <span class="tt">bool</span> </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>For example: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> a = 0;</div>
<div class="line"><span class="keywordtype">float</span> b = 0.0f;</div>
<div class="line"><span class="comment">// In the following, the arithmetic a + b chooses floating point precision as</span></div>
<div class="line"><span class="comment">// defined by the above type precedence rules (i.e. float(a) + b). The temporary</span></div>
<div class="line"><span class="comment">// value created by the arithmetic + will be at float precision. The subsequent</span></div>
<div class="line"><span class="comment">// assignment must then convert the final result back an integer, resulting in</span></div>
<div class="line"><span class="comment">// an expression equal to: a = int(float(a) + b);</span></div>
<div class="line">a = a + b;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This example shows arithmetic minus with a float scalar and vec4d. Minus is a</span></div>
<div class="line"><span class="comment">// supported operator of vec4d, however as the element types do not match</span></div>
<div class="line"><span class="comment">// (float vs double), implicit conversion must be observed. With the above rules,</span></div>
<div class="line"><span class="comment">// we can determine the following expression: c = double(b) + c. Note that</span></div>
<div class="line"><span class="comment">// as the result of &quot;double(b) + c&quot; is a vec4d and the target of the subsequent</span></div>
<div class="line"><span class="comment">// assignment (&quot;c&quot;) is a vec4d, no further conversion needs to be performed.</span></div>
<div class="line">vec4d c = 0.0; <span class="comment">// double element type</span></div>
<div class="line">c = b - c;</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Strings are not included in this precedence as there are no supported arithmetic binary operations for strings with operand types other than string.</dd></dl>
<p><br  />
</p><hr  />
<h1 class="doxsection"><a class="anchor" id="axoperators"></a>
Operators</h1>
<dl class="section user"><dt></dt><dd>The below table lists all available operators supported by AX. Note that not all AX types support all operators and some operators have unique functionality depending on the operand types. </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th colspan="9">Operators </th></tr>
<tr style="text-align:center">
<td style="border-right-width: thick" colspan="4"><a class="el" href="#axopbinary">Binary Operators</a> </td><td style="border-right-width: thick" colspan="3"><a class="el" href="#axopunary">Unary Operators</a> </td><td colspan="2">Other </td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axopassignment">Assignments</a> </td><td><a class="el" href="#axopbinarithmetic">Arithmetic</a> </td><td><a class="el" href="#axopcomparison">Comparisons / Relational</a> </td><td style="border-right-width: thick"><a class="el" href="#axopbinlogical">Logical</a> </td><td><a class="el" href="#axopunarithmetic">Arithmetic</a> </td><td><a class="el" href="#axopunlogical">Logical</a> </td><td style="border-right-width: thick"><a class="el" href="#axopunincdec">Increment / Decrement</a> </td><td><a class="el" href="#axopaccess">Container Access</a> </td><td><a class="el" href="#axopother">Other</a> </td></tr>
<tr style="text-align:center">
<td><p class="starttd"></p>
<p class="intertd"><span class="tt">a = b</span><br  />
<span class="tt">a += b</span><br  />
<span class="tt">a -= b</span><br  />
<span class="tt">a *= b</span><br  />
<span class="tt">a /= b</span><br  />
<span class="tt">a %= b</span><br  />
 <span class="tt">a &amp;= b</span><br  />
<span class="tt">a |= b</span><br  />
<span class="tt">a ^= b</span><br  />
<span class="tt">a &lt;&lt;= b</span><br  />
<span class="tt">a &gt;&gt;= b</span> </p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd"><span class="tt">a + b</span><br  />
<span class="tt">a - b</span><br  />
<span class="tt">a * b</span><br  />
<span class="tt">a / b</span><br  />
<span class="tt">a % b</span><br  />
<span class="tt">a &amp; b</span><br  />
<span class="tt">a | b</span><br  />
 <span class="tt">a ^ b</span><br  />
<span class="tt">a &lt;&lt; b</span><br  />
<span class="tt">a &gt;&gt; b</span> </p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd"><span class="tt">a == b</span><br  />
<span class="tt">a != b</span><br  />
<span class="tt">a &lt; b</span><br  />
<span class="tt">a &gt; b</span><br  />
<span class="tt">a &lt;= b</span><br  />
<span class="tt">a &gt;= b</span> </p>
<p class="endtd"></p>
</td><td style="border-right-width: thick"><p class="starttd"></p>
<p class="intertd"><span class="tt">a &amp;&amp; b</span><br  />
<span class="tt">a || b</span> </p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd"><span class="tt">+a</span><br  />
<span class="tt">-a</span><br  />
<span class="tt">~a</span> </p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd"><span class="tt">!a</span> </p>
<p class="endtd"></p>
</td><td style="border-right-width: thick"><p class="starttd"></p>
<p class="intertd"><span class="tt">++a</span><br  />
<span class="tt">--a</span><br  />
<span class="tt">a++</span><br  />
<span class="tt">a--</span> </p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd"><span class="tt">a[]</span><br  />
<span class="tt">a[,]</span><br  />
<span class="tt">a.b</span> </p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p class="intertd"><span class="tt">a(...)</span><br  />
<span class="tt">a, b</span><br  />
<span class="tt">a ? b : c</span><br  />
<span class="tt">a ?: c</span><br  />
<span class="tt">{ a,b ... }</span> </p>
<p class="endtd"></p>
</td></tr>
</table>
</dd></dl>
<h2 class="doxsection"><a class="anchor" id="axopbinary"></a>
Binary Operators</h2>
<dl class="section user"><dt></dt><dd>Binary operators are the most common inbuilt operators for AX types. These operators take two inputs; a left hand side and a right hand side. There exists a number of valid combinations of AX types with different binary operators, as well as different implicit casting schemes depending on the binary operation being performed.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="axopassignment"></a>
Assignments</h3>
<dl class="section user"><dt></dt><dd>Assignment operators are the only way to directly modify the value of local and external data (except for <a class="el" href="#axfunctions">Functions</a> which take <b>references</b>). The assignment operators have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator Name</th><th>Operator Syntax</th><th>Returns</th></tr>
<tr>
<td>Simple assignment</td><td><em class="arg">lhs</em> <b><span class="tt">=</span></b> <em class="arg">rhs</em> </td><td rowspan="11">Reference to <em class="arg">lhs</em> </td></tr>
<tr>
<td>Addition assignment</td><td><em class="arg">lhs</em> <b><span class="tt">+=</span></b> <em class="arg">rhs</em> </td></tr>
<tr>
<td>Subtraction assignment</td><td><em class="arg">lhs</em> <b><span class="tt">-=</span></b> <em class="arg">rhs</em> </td></tr>
<tr>
<td>Multiplication assignment</td><td><em class="arg">lhs</em> <b><span class="tt">*=</span></b> <em class="arg">rhs</em> </td></tr>
<tr>
<td>Division assignment</td><td><em class="arg">lhs</em> <b><span class="tt">/=</span></b> <em class="arg">rhs</em> </td></tr>
<tr>
<td>Modulo assignment</td><td><em class="arg">lhs</em> <b><span class="tt">%=</span></b> <em class="arg">rhs</em> </td></tr>
<tr>
<td>Bitwise AND assignment</td><td><em class="arg">lhs</em> <b><span class="tt">&amp;=</span></b> <em class="arg">rhs</em> </td></tr>
<tr>
<td>Bitwise OR assignment</td><td><em class="arg">lhs</em> <b><span class="tt">|=</span></b> <em class="arg">rhs</em> </td></tr>
<tr>
<td>Bitwise XOR assignment</td><td><em class="arg">lhs</em> <b><span class="tt">^=</span></b> <em class="arg">rhs</em> </td></tr>
<tr>
<td>Bitwise shift left assignment</td><td><em class="arg">lhs</em> <b><span class="tt">&lt;&lt;=</span></b> <em class="arg">rhs</em> </td></tr>
<tr>
<td>Bitwise shift right assignment</td><td><em class="arg">lhs</em> <b><span class="tt">&gt;&gt;=</span></b> <em class="arg">rhs</em> </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>These can be further categorised into two types; direct assignment, which is comprised only of the <b>simple assignment</b> operator, and compound assignments, which is the set of all other assignment operators. </dd></dl>
<dl class="section user"><dt>Direct Assignment</dt><dd>Direct assignments replace the contents of the <span class="tt">lhs</span> with a copy of the <span class="tt">rhs</span>: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em class="arg">lhs</em> <b>=</b> <em class="arg">rhs</em> </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>The <span class="tt">rhs</span> side is not modified and the <span class="tt">lhs</span> is not read - only written to. If the <span class="tt">rhs</span> type does not match the <span class="tt">lhs</span> type, the <span class="tt">rhs</span> is first implicitly converted into a new temporary with the <span class="tt">lhs</span> type before being copied into the <span class="tt">lhs</span>. The following combination of AX type categories are supported for direct assignment (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Left Operand Type</th><th>Binary Op(s)</th><th>Right Operand Type</th><th>Description</th></tr>
<tr style="text-align:center">
<td rowspan="1"><a class="el" href="#axscalars">scalar</a></td><td rowspan="1"><span class="tt">=</span></td><td><a class="el" href="#axscalars">scalar</a></td><td style="text-align:left">On type mismatch, right hand side is copied and <a class="el" href="#axtypeprecedence">implicitly cast</a> to the left hand side type.</td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="2"><a class="el" href="#axvecmats">vector</a></td><td style="border-top-width: thick; text-align:center" rowspan="2"><span class="tt">=</span></td><td style="border-top-width: thick"><a class="el" href="#axscalars">scalar</a></td><td style="border-top-width:thick;text-align:left">Each element of the vector is set to the right hand side scalar. i.e. <span class="tt">a[0] = b; ... a[n-1] = b;</span> where <span class="tt">n</span> is the size of the vector. If the scalar type does not match element type of vector, the scalar is copied and <a class="el" href="#axtypeprecedence">implicitly cast</a> to that type.</td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axvecmats">vector</a></td><td style="text-align:left">Component wise assignment i.e. <span class="tt">a[0] = b; ... a[n-1] = b;</span> where <span class="tt">n</span> is the size of the vector. <div class="fragment"><div class="line">vec3f a = 0, b = 1;</div>
<div class="line">a = b;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 0, b = 1;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) a[i] = b[i];</div>
</div><!-- fragment --> If the right hand side element type does not match the left hand side element type, each element of the right hand side is copied and <a class="el" href="#axtypeprecedence">implicitly cast </a>to the target left hand side element type. <b>Operand sizes must match.</b></td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="2"><a class="el" href="#axvecmats">matrix</a></td><td style="border-top-width: thick;text-align:center" rowspan="2"><span class="tt">=</span></td><td style="border-top-width: thick"><a class="el" href="#axscalars">scalar</a></td><td style="border-top-width:thick;text-align:left">Diagonal matrix construction. Each diagonal component of the left hand side matrix is set to to the right hand side scalar. All other components are zero initialized i.e. <div class="fragment"><div class="line">mat3f a;</div>
<div class="line"><span class="keywordtype">int</span> dim = 3, b = 1;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div>
<div class="line">    a[i] = (i % (dim+1) == 0) ? b : 0;</div>
</div><!-- fragment --> Where <span class="tt">a</span> is the matrix, <span class="tt">dim</span> is the dimension of the matrix (e.g. 3 for <span class="tt">mat3f</span>) and <span class="tt">b</span> is the scalar. If the scalar type does not match element type of matrix, the scalar is copied and <a class="el" href="#axtypeprecedence">implicitly cast</a> to that type.</td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axvecmats">matrix</a></td><td style="text-align:left">Component wise assignment i.e. <br  />
 <span class="tt">a[0] = b[0]; ... a[n-1] = b[n-1];</span> <br  />
 where <span class="tt">n</span> is the <b>total</b> size of the matrix. <div class="fragment"><div class="line">mat4f a = 0, b = 1;</div>
<div class="line">a = b;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">mat4f a = 0, b = 1;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; ++i) a[i] = b[i];</div>
</div><!-- fragment --> If the right hand side element type does not match the left hand side element type, each element of the right hand side is copied and <a class="el" href="#axtypeprecedence">implicitly cast</a> to the target left hand side element type. <b>Operand sizes must match.</b></td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick"><a class="el" href="#axstrings">string</a></td><td style="border-top-width: thick;text-align:center"><span class="tt">=</span></td><td style="border-top-width: thick"><a class="el" href="#axstrings">string</a></td><td style="border-top-width: thick;text-align:left">Replaces the contents of the left hand side string with a copy of the contents in the right hand side string. </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keywordtype">float</span> b;</div>
<div class="line">vec3f c = 0.0f; <span class="comment">// assign components of c (x/y/z) to an floating point literal of value 0.0f</span></div>
<div class="line"><span class="keywordtype">int</span> a = 1; <span class="comment">// assign a from an integer literal of value 1</span></div>
<div class="line">c = a; <span class="comment">// assign components of c (x/y/z) to the result of float(a)</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Compound Assignment</dt><dd>Compound assignments replace the the contents of the <span class="tt">lhs</span> with the result of a <a class="el" href="#axopbinarithmetic">binary arithmetic</a> operation of the <span class="tt">lhs</span> with the <span class="tt">rhs</span>: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em class="arg">lhs</em> <b>op</b> <em class="arg">rhs</em> </td></tr>
</table>
</dd></dl>
<p>Where <b>op</b> is one of:</p>
<table class="doxtable">
<tr>
<td><b><span class="tt">+=</span></b></td><td><b><span class="tt">-=</span></b></td><td><b><span class="tt">*=</span></b></td><td><b><span class="tt">/=</span></b></td><td><b><span class="tt">%=</span></b></td><td><b><span class="tt">&amp;=</span></b></td><td><b><span class="tt">|=</span></b></td><td><b><span class="tt">^=</span></b></td><td><b><span class="tt">&lt;&lt;=</span></b></td><td><b><span class="tt">&gt;&gt;= </span></b></td></tr>
</table>
<dl class="section user"><dt></dt><dd>The behaviour of a given compound assignment (for example <span class="tt">a += b</span>) is similar to replacing the compound assignment with a <a class="el" href="#axopassignment">direct assignment</a> followed by a <a class="el" href="#axopbinarithmetic">binary expression</a> with the same operands and given arithmetic token (i.e. <span class="tt">a = a + b</span>). However, compound assignments imporantly do <b>not</b> evaluate the <b>`lhs`</b> twice. This is important when assigning to an expression which is not an attribute or local value. The best example of this is assigning to a <a class="el" href="#axopunincdec">pre-crement</a> operation: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> a = 1;</div>
<div class="line">++a += 1; <span class="comment">// equal to a = ++a + 1 which is equal to 3</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>The <span class="tt">rhs</span> side is not modified, however the <span class="tt">lhs</span> is both read from and written to. Note that the arithmetic operation may cast either <span class="tt">lhs</span> or <span class="tt">rhs</span> following the rules of AX's <a class="el" href="#axopbinarithmetic">arithmetic type precedence</a>. See the <a class="el" href="#axopbinarithmetic">arithmetic operations</a> section for more information on arithmetic type precedence and explanations on the above compound operators. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> a = 3;</div>
<div class="line">a += a; <span class="comment">// the same as a = a + a; a will be set to 6</span></div>
<div class="line"><span class="keywordtype">float</span> b = 0;</div>
<div class="line">b -= a; <span class="comment">// the same as b = b - float(a);</span></div>
<div class="line">a *= b; <span class="comment">// the same as a = float(a) * b; Note that although the target type is int, the binary op is performed at float precision</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Assignment Chains</dt><dd>As assignments return a <b>reference</b> to the left hand side, all assignment operators can be <b>chained</b>. Note however that the return result will be at the type of the left hand side. For example: </dd></dl>
<dl class="section user"><dt></dt><dd>Given </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keywordtype">float</span> a;</div>
<div class="line"><span class="keywordtype">int</span> b, c;</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>This </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">a = b = c = 4.5f;</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>is fundamentally the same as: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">c = 4.5f; <span class="comment">// c of type int. 4.5f will be floored (int(4.5)). c becomes 4</span></div>
<div class="line">b = c;    <span class="comment">// b becomes 4</span></div>
<div class="line">a = b;    <span class="comment">// a becomes float(4)</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Importantly, <span class="tt">a</span> receives the result of any previous implicit casts to the right hand side of its binary assignment.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="axopbinarithmetic"></a>
Arithmetic</h3>
<dl class="section user"><dt></dt><dd>Binary arithmetic operations compute the result of a arithmetic operand token on two inputs and returns the result. The inputs are not modified, however may be copied and <a class="el" href="#axtypeprecedence">implicitly cast</a> to temporary values if the types do not match. All results are returned as new temporary values. If <b>integral</b> is explicitly stated, the operation is only valid on types which have an integer element type and will involve and implicit cast to integer types for floating point operands (the operation may be further restricted for container types). Binary arithmetic operations have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator&#160;Name</th><th>Operator&#160;Syntax</th><th>Returns</th></tr>
<tr>
<td>Addition</td><td><em class="arg">lhs</em> <b><span class="tt">+</span></b> <em class="arg">rhs</em> </td><td>The sum of both operands</td></tr>
<tr>
<td>Subtraction</td><td><em class="arg">lhs</em> <b><span class="tt">-</span></b> <em class="arg">rhs</em> </td><td>The first operand minus the second operand</td></tr>
<tr>
<td>Multiplication</td><td><em class="arg">lhs</em> <b><span class="tt">*</span></b> <em class="arg">rhs</em> </td><td>The product of both operands</td></tr>
<tr>
<td>Division</td><td><em class="arg">lhs</em> <b><span class="tt">/</span></b> <em class="arg">rhs</em> </td><td>The first operand divided by the second operand</td></tr>
<tr>
<td>Modulo</td><td><em class="arg">lhs</em> <b><span class="tt">%</span></b> <em class="arg">rhs</em> </td><td>The <b>floored</b> modulo operator. See <a class="el" href="#axbinmultop">Multiplicative operands</a></td></tr>
<tr>
<td>Bitwise AND</td><td><em class="arg">lhs</em> <b><span class="tt">&amp;</span></b> <em class="arg">rhs</em> </td><td>The <b>integral</b> bitwise AND result of each bit in the first operand applied to the bit at the same location in the second operand</td></tr>
<tr>
<td>Bitwise OR</td><td><em class="arg">lhs</em> <b><span class="tt">|</span></b> <em class="arg">rhs</em> </td><td>The <b>integral</b> bitwise OR result of each bit in the first operand applied to the bit at the same location in the second operand</td></tr>
<tr>
<td>Bitwise XOR</td><td><em class="arg">lhs</em> <b><span class="tt">^</span></b> <em class="arg">rhs</em> </td><td>The <b>integral</b> bitwise XOR result of each bit in the first operand applied to the bit at the same location in the second operand</td></tr>
<tr>
<td>Bitwise shift left</td><td><em class="arg">lhs</em> <b><span class="tt">&lt;&lt;</span></b> <em class="arg">rhs</em> </td><td>The <b>integral</b> bitwise left shift of the first operand by the second operand</td></tr>
<tr>
<td>Bitwise shift right</td><td><em class="arg">lhs</em> <b><span class="tt">&gt;&gt;</span></b> <em class="arg">rhs</em> </td><td>The <b>integral</b> bitwise right shift of the first operand by the second operand</td></tr>
</table>
<a class="anchor" id="axbinadditiveop"></a></dd></dl>
<dl class="section user"><dt>Additive operands</dt><dd>Binary additive operations perform summations on the input arguments. They have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em class="arg">lhs</em> <b>+</b> <em class="arg">rhs</em> </td></tr>
<tr>
<td><em class="arg">lhs</em> <b>-</b> <em class="arg">rhs</em> </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>After <a class="el" href="#axtypeprecedence">implicit conversion</a>, the result of the binary operation with the arithmetic <span class="tt">+</span> (<a class="el" href="#axtokens">plus token</a>) is the sum of the operands, and the result of the binary operation with the arithmetic <span class="tt">-</span> (<a class="el" href="#axtokens">minus token</a>) token is the second operand subtracted from the first operand. The following combination of AX type categories are supported for additive operations (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Left Operand Type</th><th>Binary Op(s)</th><th>Right Operand Type</th><th>Description</th></tr>
<tr style="text-align:center">
<td rowspan="3"><a class="el" href="#axscalars">scalar</a></td><td rowspan="3"><span class="tt">+</span> <span class="tt">-</span></td><td><a class="el" href="#axscalars">scalar</a></td><td style="text-align:left">Returns the result of the scalar addition or subtraction.</td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axvecmats">vector</a></td><td style="text-align:left" rowspan="2">Performs per component binary operations (after <a class="el" href="#axtypeprecedence">implicit conversion</a>) with the left hand side scalar to every element of the right hand side vector or matrix, returning a vector or matrix. <div class="fragment"><div class="line">vec3f a = 2.0f;</div>
<div class="line"><span class="keywordtype">int</span> b = 1;</div>
<div class="line">vec3f c = b + a;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 2.0f;</div>
<div class="line"><span class="keywordtype">int</span> b = 1;</div>
<div class="line">vec3f c;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) c[i] = b + a[i];</div>
</div><!-- fragment --> </td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axvecmats">matrix</a></td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="2"><a class="el" href="#axvecmats">vector</a></td><td style="border-top-width: thick; text-align:center" rowspan="2"><span class="tt">+</span> <span class="tt">-</span></td><td style="border-top-width: thick"><a class="el" href="#axscalars">scalar</a></td><td style="border-top-width: thick;text-align:left">Same as <span class="tt">scalar op vector</span></td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axvecmats">vector</a></td><td style="text-align:left">Performs per component binary operations (after <a class="el" href="#axtypeprecedence">implicit conversion</a>), returning a new vector with each element holding the corresponding result. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">vec3f a = 2, b = 1;</div>
<div class="line">vec3f c = a - b;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 2, b = 1;</div>
<div class="line">vec3f c;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) c[i] = a[i] - b[i];</div>
</div><!-- fragment --> </td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="2"><a class="el" href="#axvecmats">matrix</a></td><td style="border-top-width: thick;text-align:center" rowspan="2"><span class="tt">+</span> <span class="tt">-</span></td><td style="border-top-width: thick"><a class="el" href="#axscalars">scalar</a></td><td style="border-top-width: thick;text-align:left">Same as <span class="tt">scalar op matrix</span></td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axvecmats">matrix</a></td><td style="text-align:left">Performs per component binary operations (after <a class="el" href="#axtypeprecedence">implicit conversion</a>), returning a new matrix with each element holding the corresponding result. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">mat4f a = 0, b = 1;</div>
<div class="line">mat4f c = a - b;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">mat4f a = 0, b = 1;</div>
<div class="line">mat4f c;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; ++i) c[i] = a[i] - b[i];</div>
</div><!-- fragment --> </td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick"><a class="el" href="#axstrings">string</a></td><td style="border-top-width: thick;text-align:center"><span class="tt">+</span></td><td style="border-top-width: thick"><a class="el" href="#axstrings">string</a></td><td style="border-top-width: thick;text-align:left">Performs string concatenation</td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Floating point addition and subtraction is communicative (<span class="tt">a + b = b + a</span>) but is not <b>necessarily</b> associative. i.e. <span class="tt">(a + b) + c</span> is not necessarily equal to <span class="tt">a + (b + c)</span>. </dd></dl>
<dl class="section user"><dt></dt><dd>Examples of validity of additive operations: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> a = 0;</div>
<div class="line">vec2f b = 1.0f;</div>
<div class="line">vec2i c = 2;</div>
<div class="line">mat4d d = 0.0;</div>
<div class="line">c + a; <span class="comment">// valid vec + scalar</span></div>
<div class="line">c + d; <span class="comment">// invalid vec + matrix</span></div>
<div class="line">c - b; <span class="comment">// valid vec - scalar</span></div>
</div><!-- fragment --> <a class="anchor" id="axbinmultop"></a></dd></dl>
<dl class="section user"><dt>Multiplicative operands</dt><dd>The binary multiplicative operands have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em class="arg">lhs</em> <span class="tt">*</span> <em class="arg">rhs</em> </td></tr>
<tr>
<td><em class="arg">lhs</em> <span class="tt">/</span> <em class="arg">rhs</em> </td></tr>
<tr>
<td><em class="arg">lhs</em> <span class="tt">%</span> <em class="arg">rhs</em> </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>After <a class="el" href="#axtypeprecedence">implicit conversion</a>, the result of the binary operation:<ul>
<li>with the arithmetic <span class="tt">*</span> (<a class="el" href="#axtokens">asterisk token</a>) is:<ul>
<li>the product of the operands</li>
<li><b>OR</b> performs matrix multiplication for vector and matrix types.</li>
</ul>
</li>
<li>with the arithmetic <span class="tt">/</span> (<a class="el" href="#axtokens">forward slash token</a>) is the first operand divided by the second operand.</li>
<li>with the arithmetic <span class="tt">%</span> (<a class="el" href="#axtokens">percentage token</a>) is the <b>floored</b> modulo operations .i.e. the expression <span class="tt">d % D</span> returns the result <span class="tt">D - d * floor(D/d)</span>. This is in contrast to truncated modulo operations <span class="tt">D - d * (D/d)</span> where the division is truncated. </li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Floored modulo has been chosen to provide better expected behaviour with signed dividends. In such cases the result will always be positive; in other words, the sign of the result is <b>always</b> taken from the divisor. This does however mean that the relationship properties between <span class="tt">%</span> and <span class="tt">/</span> differ when either <b>`d`</b> or <b>`D`</b> is negative. i.e.: <span class="tt">(d/D)*D + (dD) != d</span> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The multiplicative operation <span class="tt">*</span> has important behaviour for vectors and matrix types. </dd></dl>
<dl class="section user"><dt></dt><dd>The following combination of AX type categories are supported for multiplicative operations (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Left Operand Type</th><th>Binary Op(s)</th><th>Right Operand Type</th><th>Description</th></tr>
<tr style="text-align:center">
<td rowspan="3"><a class="el" href="#axscalars">scalar</a></td><td rowspan="2"><span class="tt">* / %</span></td><td rowspan="1"><a class="el" href="#axscalars">scalar</a></td><td style="text-align:left">Returns the result of the scalar multiplication, division or remainder of the division respectively. </td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axvecmats">vector</a></td><td style="text-align:left" rowspan="1">Performs per component binary operations (after <a class="el" href="#axtypeprecedence">implicit conversion</a>) with the left hand side scalar to every element of the right hand side vector. The scalar is effectively treated as a vector of the same size as the right hand side type. <div class="fragment"><div class="line">vec3f a = 2.0f;</div>
<div class="line"><span class="keywordtype">int</span> b = 1;</div>
<div class="line">vec3f c = b * a;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 2.0f;</div>
<div class="line"><span class="keywordtype">int</span> b = 1;</div>
<div class="line">vec3f c;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) c[i] = b * a[i];</div>
</div><!-- fragment --> </td></tr>
<tr style="text-align:center">
<td rowspan="1"><span class="tt">*</span></td><td><a class="el" href="#axvecmats">matrix</a></td><td style="text-align:left" rowspan="1">Performs matrix multiplication after diagonal matrix construction from the left hand side scalar. <div class="fragment"><div class="line">mat3f a = 1;</div>
<div class="line"><span class="keywordtype">float</span> b = 1;</div>
<div class="line">mat3f c = a * b;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">mat3f a = 1;</div>
<div class="line"><span class="keywordtype">float</span> b = 1;</div>
<div class="line">mat3f tmp = b; <span class="comment">// diagonal matrix</span></div>
<div class="line">mat3f c = a * tmp;</div>
</div><!-- fragment --> </td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="3"><a class="el" href="#axvecmats">vector</a></td><td style="border-top-width: thick; text-align:center" rowspan="2"><span class="tt">* / %</span></td><td style="border-top-width: thick"><a class="el" href="#axscalars">scalar</a></td><td style="border-top-width: thick;text-align:left">Same as <span class="tt">scalar op vector</span> with the operands reversed (importantly for division and modulus)</td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axvecmats">vector</a></td><td style="text-align:left">Performs per component binary operations (after <a class="el" href="#axtypeprecedence">implicit conversion</a>), returning a new vector with each element holding the corresponding result. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">vec3f a = 2, b = 1;</div>
<div class="line">vec3f c = a * b;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 2, b = 1;</div>
<div class="line">vec3f c;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) c[i] = a[i] * b[i];</div>
</div><!-- fragment --> </td></tr>
<tr style="text-align:center">
<td><span class="tt">*</span></td><td><a class="el" href="#axvecmats">matrix</a></td><td style="text-align:left">Transforms the left hand side vector by the right hand side matrix using matrix multiplication. This is the same as calling the <a class="el" href="axfunctionlist.html#axtransform">transform</a> function. e.g: <div class="fragment"><div class="line">mat4f a = identity4();</div>
<div class="line">vec3f b = { 1, 2, 3 };</div>
<div class="line">b = b * a;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">mat4f a = identity4();</div>
<div class="line">vec3f b = { 1, 2, 3 };</div>
<div class="line">b = transform(b, a);</div>
</div><!-- fragment --> Typically, matrix multiplication requires arguments of the same dimension sizes - that is, a <span class="tt">mat4</span> can only be applied to a <span class="tt">vec4</span>. However, it is often useful to be able to directly apply <span class="tt">mat4</span> transformations to <span class="tt">vec3</span> types, most often due to positions being represented as <span class="tt">vec3</span>. <span class="tt">vec3 * mat4</span> multiplication is supported, where by the <span class="tt">vec3</span> is extended with a <span class="tt">1</span> component and the resulting last last component is dropped from the return value: <div class="fragment"><div class="line">mat4f a = identity4();</div>
<div class="line">vec3f b = { 1, 2, 3 };</div>
<div class="line"><span class="comment">// b * a is equal to:</span></div>
<div class="line">vec4f tmp;</div>
<div class="line">tmp[0] = b[0];</div>
<div class="line">tmp[1] = b[1];</div>
<div class="line">tmp[2] = b[2];</div>
<div class="line">tmp[3] = 1;</div>
<div class="line">tmp = tmp * a;</div>
<div class="line">b[0] = tmp[0];</div>
<div class="line">b[1] = tmp[1];</div>
<div class="line">b[2] = tmp[2];</div>
</div><!-- fragment --> <b>Note:</b> Valid operand sizes and return types match those of the <a class="el" href="axfunctionlist.html#axtransform">transform</a> function i.e:<ul>
<li><span class="tt">vec3 * mat3 = vec3</span></li>
<li><span class="tt">vec3 * mat4 = vec3</span></li>
<li><span class="tt">vec4 * mat4 = vec4</span> </li>
</ul>
</td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="3"><a class="el" href="#axvecmats">matrix</a></td><td style="border-top-width: thick;text-align:center" rowspan="3"><span class="tt">*</span></td><td style="border-top-width: thick"><a class="el" href="#axscalars">scalar</a></td><td style="border-top-width: thick;text-align:left">Same as <span class="tt">scalar * matrix</span></td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axvecmats">vector</a></td><td style="text-align:left">Transforms the right hand side vector by the left hand side matrix using matrix multiplication. This is the same as calling the <a class="el" href="axfunctionlist.html#axpretransform">pretransform</a> function. e.g: <div class="fragment"><div class="line">mat4f a = identity4();</div>
<div class="line">vec3f b = { 1, 2, 3 };</div>
<div class="line">b = a * b;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">mat4f a = identity4();</div>
<div class="line">vec3f b = { 1, 2, 3 };</div>
<div class="line">b = pretransform(a, b);</div>
</div><!-- fragment --> Typically, matrix multiplication requires arguments of the same dimension sizes - that is, a <span class="tt">mat4</span> can only be applied to a <span class="tt">vec4</span>. However, it is often useful to be able to directly apply <span class="tt">mat4</span> transformations to <span class="tt">vec3</span> types, most often due to positions being represented as <span class="tt">vec3</span>. <span class="tt">mat4 * vec3</span> multiplication is supported, where by the <span class="tt">vec3</span> is extended with a <span class="tt">1</span> component and the resulting last last component is dropped from the return value: <div class="fragment"><div class="line">mat4f a = identity4();</div>
<div class="line">vec3f b = { 1, 2, 3 };</div>
<div class="line"><span class="comment">// a * b is equal to:</span></div>
<div class="line">vec4f tmp;</div>
<div class="line">tmp[0] = b[0];</div>
<div class="line">tmp[1] = b[1];</div>
<div class="line">tmp[2] = b[2];</div>
<div class="line">tmp[3] = 1;</div>
<div class="line">tmp = a * tmp;</div>
<div class="line">b[0] = tmp[0];</div>
<div class="line">b[1] = tmp[1];</div>
<div class="line">b[2] = tmp[2];</div>
</div><!-- fragment --> <b>Note:</b> Valid operand sizes and return types match those of the <a class="el" href="axfunctionlist.html#axpretransform">pretransform</a> function i.e:<ul>
<li><span class="tt">mat3 * vec3 = vec3</span></li>
<li><span class="tt">mat4 * vec3 = vec3</span></li>
<li><span class="tt">mat4 * vec4 = vec4</span> </li>
</ul>
</td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axvecmats">matrix</a></td><td style="text-align:left">Performs matrix multiplication and returns the matrix product, which is matrix of matchign size and type. <b>Operand sizes must match.</b> e.g: <div class="fragment"><div class="line">mat4f a = 1, b = 2;</div>
<div class="line">mat4f c = a * b;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">mat4f a = 1, b = 2;</div>
<div class="line">mat4f c;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) {</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 4; ++j) {</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 4; ++k) {</div>
<div class="line">            c[i,j] += a[i,k] * b[k,j];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Floating point multiplication is communicative (<span class="tt">a * b = b * a</span>) but is not <b>necessarily</b> associative. i.e. <span class="tt">(a * b) * c</span> is not necessarily equal to <span class="tt">a * (b * c)</span>.</dd></dl>
<p><a class="anchor" id="axbinbitwiseop"></a></p><dl class="section user"><dt>Bitwise operands</dt><dd>Binary bitwise operations have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em class="arg">lhs</em> <b> <span class="tt">&amp;</span> </b> <em class="arg">rhs</em> </td></tr>
<tr>
<td><em class="arg">lhs</em> <b> <span class="tt">|</span> </b> <em class="arg">rhs</em> </td></tr>
<tr>
<td><em class="arg">lhs</em> <b> <span class="tt">^</span> </b> <em class="arg">rhs</em> </td></tr>
<tr>
<td><em class="arg">lhs</em> <b> <span class="tt">&lt;&lt;</span> </b> <em class="arg">rhs</em> </td></tr>
<tr>
<td><em class="arg">lhs</em> <b> <span class="tt">&gt;&gt;</span> </b> <em class="arg">rhs</em> </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>These operations only run on <b>integral</b> operands. After <a class="el" href="#axtypeprecedence">implicit conversion</a>, the result of the binary operation:<ul>
<li>with the <b>&amp;</b> (<a class="el" href="#axtokens">ampersand token</a>) is the result of the logical AND operation on each pair of the corresponding bits of the input operands.</li>
<li>with the <b> | </b> (<a class="el" href="#axtokens">pipe token</a>) is the result of the logical OR operation on each pair of the corresponding bits of the input operands.</li>
<li>with the <b>^</b> (<a class="el" href="#axtokens">hat token</a>) is the result of the logical XOR operation on each pair of the corresponding bits of the input operands.</li>
<li>with the <b>&lt;&lt;</b> (<a class="el" href="#axtokens">less than tokens</a>) is the value shifted left with zeros shifted in on the right.</li>
<li>with the <b>&gt;&gt;</b> (<a class="el" href="#axtokens">greater than tokens</a>) is the value shifted right with zeros shifted in on the left. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Left Operand Type</th><th>Binary Op(s)</th><th>Right Operand Type</th><th>Description</th></tr>
<tr style="text-align:center">
<td><a class="el" href="#axscalars">intergral</a></td><td><span class="tt">&amp; | ^ &lt;&lt; &gt;&gt;</span></td><td><a class="el" href="#axscalars">intergral</a></td><td style="text-align:left">Returns the result of the bitwise operation as described above. If either operand is not an integral type (<span class="tt">bool</span> <span class="tt">int32</span> or <span class="tt">int64</span>), the program is ill formed. </td></tr>
</table>
</dd></dl>
<h3 class="doxsection"><a class="anchor" id="axopcomparison"></a>
Comparisons / Relational</h3>
<dl class="section user"><dt></dt><dd>Binary comparison and relational operations compute the result of a equality operand token on two inputs and returns the result. The inputs are not modified, however may be copied and <a class="el" href="#axtypeprecedence">implicitly cast</a> to temporary values if the types do not match. The result type of all comparison operators is of type <b>`bool`</b>. Binary comparison operations have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator&#160;Name</th><th>Operator&#160;Syntax</th><th>Returns</th></tr>
<tr>
<td>Equal to</td><td><em class="arg">lhs</em> <b><span class="tt">==</span></b> <em class="arg">rhs</em> </td><td>Returns <span class="tt">true</span> if both operands are equal</td></tr>
<tr>
<td>Not equal to</td><td><em class="arg">lhs</em> <b><span class="tt">!=</span></b> <em class="arg">rhs</em> </td><td>Returns <span class="tt">true</span> if operands are not equal</td></tr>
<tr>
<td>Less than</td><td><em class="arg">lhs</em> <b><span class="tt">&lt;</span></b> <em class="arg">rhs</em> </td><td>Returns <span class="tt">true</span> the left hand side value is less than the right hand side</td></tr>
<tr>
<td>Greater than</td><td><em class="arg">lhs</em> <b><span class="tt">&gt;</span></b> <em class="arg">rhs</em> </td><td>Returns <span class="tt">true</span> the left hand side value is greater than the right hand side</td></tr>
<tr>
<td>Less than or equal to</td><td><em class="arg">lhs</em> <b><span class="tt">&lt;=</span></b> <em class="arg">rhs</em> </td><td>Returns <span class="tt">true</span> the left hand side value is less than or equal to the right hand side</td></tr>
<tr>
<td>Greater than or equal to</td><td><em class="arg">lhs</em> <b><span class="tt">&gt;=</span></b> <em class="arg">rhs</em> </td><td>Returns <span class="tt">true</span> the left hand side value is greater than or equal to the right hand side</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>The following combination of AX type categories are supported for comparison operations (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Left Operand Type</th><th>Binary Op(s)</th><th>Right Operand Type</th><th>Description</th></tr>
<tr style="text-align:center">
<td rowspan="3"><a class="el" href="#axscalars">scalar</a></td><td rowspan="1"><span class="tt">== != &lt; &gt; &lt;= &gt;=</span></td><td><a class="el" href="#axscalars">scalar</a></td><td style="text-align:left">Returns the result of the scalar comparison.</td></tr>
<tr style="text-align:center">
<td rowspan="2"><span class="tt">== !=</span></td><td><a class="el" href="#axvecmats">vector</a></td><td style="text-align:left" rowspan="2">Performs per component comparisons (after <a class="el" href="#axtypeprecedence">implicit conversion</a>) with the lefthand side scalar to every element of the right hand side vector or matrix and perform a logical AND combination on the results of these comparisons. This effectively returns true if every element of the vector or matrix is equal to the scalar. <div class="fragment"><div class="line">vec3f a = 2.0f;</div>
<div class="line"><span class="keywordtype">int</span> b = 1;</div>
<div class="line"><span class="keywordtype">bool</span> c = b == a;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 2.0f;</div>
<div class="line"><span class="keywordtype">int</span> b = 1;</div>
<div class="line"><span class="keywordtype">bool</span> c = a[0] == b;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 3; ++i) c &amp;= a[i] == b;</div>
</div><!-- fragment --> </td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axvecmats">matrix</a></td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="2"><a class="el" href="#axvecmats">vector</a></td><td style="border-top-width: thick; text-align:center" rowspan="1"><span class="tt">== != &lt; &gt; &lt;= &gt;=</span></td><td style="border-top-width: thick"><a class="el" href="#axscalars">scalar</a></td><td style="border-top-width: thick;text-align:left">Same as <span class="tt">scalar op vector</span></td></tr>
<tr style="text-align:center">
<td rowspan="1"><span class="tt">== !=</span></td><td><a class="el" href="#axvecmats">vector</a></td><td style="text-align:left">Performs binary comparison operations (after <a class="el" href="#axtypeprecedence">implicit conversion</a>) on each pair corresponding components in the vector operands and returns true if all component pairs are equal. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">vec3f a = 1, b = 2;</div>
<div class="line"><span class="keywordtype">bool</span> c = a == b;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 1, b = 2;</div>
<div class="line"><span class="keywordtype">bool</span> c = a[0] == b[0];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 3; ++i) c &amp;= a[i] == b[i];</div>
</div><!-- fragment --> </td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="2"><a class="el" href="#axvecmats">matrix</a></td><td style="border-top-width: thick; text-align:center" rowspan="1"><span class="tt">== != &lt; &gt; &lt;= &gt;=</span></td><td style="border-top-width: thick"><a class="el" href="#axscalars">scalar</a></td><td style="border-top-width: thick;text-align:left">Same as <span class="tt">scalar op matrix</span></td></tr>
<tr style="text-align:center">
<td rowspan="1"><span class="tt">== !=</span></td><td><a class="el" href="#axvecmats">matrix</a></td><td style="text-align:left">Performs binary comparison operations (after <a class="el" href="#axtypeprecedence">implicit conversion</a>) on each pair corresponding components in the matrix operands and returns true if all component pairs are equal. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">mat4f a = 1, b = 2;</div>
<div class="line"><span class="keywordtype">bool</span> c = a == b;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">mat4f a = 1, b = 2;</div>
<div class="line"><span class="keywordtype">bool</span> c = a[0] == b[0];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 16; ++i) c &amp;= a[i] == b[i];</div>
</div><!-- fragment --> </td></tr>
</table>
</dd></dl>
<h3 class="doxsection"><a class="anchor" id="axopbinlogical"></a>
Logical</h3>
<dl class="section user"><dt></dt><dd>Binary logical operations compute and return the result of a boolean operation on two operands. Both operands are implicitly converted to <b>`bool`</b> types if they are not already. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>These operators are short-circuiting; for logical AND, the second operand is only evaluated if the first is <b>true</b>. For logical OR, the second operand is only evaluated if the first is <b>false</b>. In both cases, the first operand is always evaluated. </dd></dl>
<dl class="section user"><dt></dt><dd>They have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator&#160;Name</th><th>Operator&#160;Syntax</th><th>Returns</th></tr>
<tr>
<td>AND</td><td><em class="arg">lhs</em> <b><span class="tt">&amp;&amp;</span></b> <em class="arg">rhs</em> </td><td>Returns true if both operands are true. Otherwise, the result is false. This operator is short-circuiting.</td></tr>
<tr>
<td>Inclusive OR</td><td><em class="arg">lhs</em> <b><span class="tt">||</span></b> <em class="arg">rhs</em> </td><td>Returns true if either the first or the second operand is true. This operator is short-circuiting.</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>The following combination of AX type categories are supported for comparison operations (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Left Operand Type</th><th>Binary Op(s)</th><th>Right Operand Type</th><th>Description</th></tr>
<tr style="text-align:center">
<td><a class="el" href="#axscalars">scalar</a></td><td><span class="tt">&amp;&amp; ||</span></td><td><a class="el" href="#axscalars">scalar</a></td><td style="text-align:left">Returns the result of the scalar logical operation. Both scalars are converted to bools if they are not already.</td></tr>
</table>
</dd></dl>
<h2 class="doxsection"><a class="anchor" id="axopunary"></a>
Unary Operators</h2>
<dl class="section user"><dt></dt><dd>Unary operators only execute on a single value. The operator token(s) may come before or after the value, precedence of which is defined by AX's <a class="el" href="#axopprecedence">operator precedence</a>. Arithmetic, logical and increment / decrement operators are supported.</dd></dl>
<h3 class="doxsection"><a class="anchor" id="axopunarithmetic"></a>
Arithmetic</h3>
<dl class="section user"><dt></dt><dd>Arithmetic unary operators are comprised of arithemtic and bitwise operators. </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator Name</th><th>Operator Syntax</th><th>Returns</th></tr>
<tr>
<td>Unary plus</td><td><span class="tt">+a</span> </td><td>Returns the value of its operand, <span class="tt">a</span></td></tr>
<tr>
<td>Unary minus</td><td><span class="tt">-a</span> </td><td>Returns the negative representation of <span class="tt">a</span></td></tr>
<tr>
<td>Bitwise NOT</td><td><span class="tt">~a</span> </td><td>Returns the bitwise NOT (one's complement) value of <span class="tt">a</span>. This operator is only valid on integral element types.</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>The following combination of AX type categories are supported for unary arithmetic operations (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Operand Type</th><th>Binary Op(s)</th><th>Description</th></tr>
<tr style="text-align:center">
<td><a class="el" href="#axscalars">scalar</a></td><td rowspan="2"><span class="tt">+ - ~</span></td><td style="text-align:left">Returns the result of the scalar unary operations.</td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axvecmats">vector</a></td><td style="text-align:left">Performs per component unary operations, returning a new vector with each element holding the corresponding result. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">vec3f a = 2;</div>
<div class="line">vec3f b = -a;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 2;</div>
<div class="line">vec3f b;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) b[i] = -a[i];</div>
</div><!-- fragment --> <b>Note:</b> The bitwise not <span class="tt">~</span> operator is only valid on integer vector types; <span class="tt">vec2i</span>, <span class="tt">vec3i</span> and <span class="tt">vec4i</span>. </td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axvecmats">matrix</a></td><td><span class="tt">+ -</span></td><td style="text-align:left">Performs per component unary operations, returning a new matrix with each element holding the corresponding result. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">vec3f a = 2;</div>
<div class="line">vec3f b = -a;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 2;</div>
<div class="line">vec3f b;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) b[i] = -a[i];</div>
</div><!-- fragment --> </td></tr>
</table>
</dd></dl>
<h3 class="doxsection"><a class="anchor" id="axopunlogical"></a>
Logical</h3>
<dl class="section user"><dt></dt><dd>Logical unary operators consist of a single operand. </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator Name</th><th>Operator Syntax</th><th>Returns</th></tr>
<tr>
<td>Logical NOT</td><td><span class="tt">!a</span> </td><td>Returns true if the operand is false. Otherwise, returns false.</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>The following combination of AX type categories are supported for logical unary operations (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Operand Type</th><th>Binary Op(s)</th><th>Description</th></tr>
<tr style="text-align:center">
<td><a class="el" href="#axscalars">scalar</a></td><td rowspan="2"><span class="tt">!</span></td><td style="text-align:left">Returns the result of the scalar logical operation. The scalar operand is converted to a bool if it is not already.</td></tr>
<tr style="text-align:center">
<td><a class="el" href="#axvecmats">vector</a></td><td style="text-align:left">Performs per component unary operations, returning a new vector with each element holding the corresponding result. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">vec3i a = 2;</div>
<div class="line">vec3i b = !a;</div>
</div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3i a = 2;</div>
<div class="line">vec3i b;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) b[i] = !a[i];</div>
</div><!-- fragment --> <b>Note:</b> The logical not <span class="tt">!</span> operator is only valid on integer vector types; <span class="tt">vec2i</span>, <span class="tt">vec3i</span> and <span class="tt">vec4i</span>. </td></tr>
</table>
</dd></dl>
<h3 class="doxsection"><a class="anchor" id="axopunincdec"></a>
Increment / Decrement</h3>
<dl class="section user"><dt></dt><dd>Increment/decrement operators increment or decrement the value of a scalar, or each component of a vector or matrix. They have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator Name</th><th>Operator Syntax</th><th>Returns</th></tr>
<tr>
<td>Pre-increment</td><td><span class="tt">++a</span> </td><td>Returns a reference to the incremented result.</td></tr>
<tr>
<td>Post-increment</td><td><span class="tt">a++</span> </td><td>Returns a copy of the incremented result.</td></tr>
<tr>
<td>Pre-decrement</td><td><span class="tt">--a</span> </td><td>Returns a reference to the decremented result.</td></tr>
<tr>
<td>Post-decrement</td><td><span class="tt">a--</span> </td><td>Returns a copy of the decremented result.</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>Importantly, pre evaluation returns a reference to the value operand, where as post evaluation returns a copy of the operand. The following combination of AX type categories are supported for logical unary operations (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Operand Type</th><th>Binary Op(s)</th><th>Description</th></tr>
<tr style="text-align:center">
<td><a class="el" href="#axscalars">scalar</a></td><td><span class="tt">++(pre) (post)++</span> <br  />
 <span class="tt">--(pre) (post)--</span></td><td style="text-align:left">Returns the result (reference or copy) of the scalar increment or decrement operation.<br  />
<b>Note:</b> boolean incrementation and decrementation is not supported. Only <span class="tt">int32</span>, <span class="tt">int64</span>, <span class="tt">float</span> and <span class="tt">double</span> types are valid. </td></tr>
</table>
</dd></dl>
<h2 class="doxsection"><a class="anchor" id="axopaccess"></a>
Container Access</h2>
<dl class="section user"><dt></dt><dd>Container access operators are valid on AX Vector and matrix types. They have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator Name</th><th>Operator Syntax</th><th>Returns</th></tr>
<tr style="text-align:left">
<td>Dot&#160;Component&#160;Access</td><td><em><span class="tt">vector</span></em>&#160;<b>.</b>&#160;<span class="tt">component</span> </td><td>Reference to component <span class="tt">component</span> of <span class="tt">vector</span></td></tr>
<tr style="text-align:left">
<td>Container&#160;Component&#160;Access</td><td><em><span class="tt">container</span></em>&#160;<b>[</b>&#160;<span class="tt">exp</span> <b>]</b> </td><td>Reference to component at index <span class="tt">exp</span> of <span class="tt">container</span></td></tr>
<tr style="text-align:left">
<td>Matrix&#160;Component&#160;Access</td><td><em><span class="tt">matrix</span></em>&#160;<b>[</b>&#160;<span class="tt">exp1</span>,&#160;<em><span class="tt">exp2</span></em>&#160;<b>]</b> </td><td>Reference to component in row <b><em><span class="tt">exp1</span></em></b>, column <b><em><span class="tt">exp2</span></em></b>. Also equal to returning a reference to component at index: <b><em> <span class="tt">[exp1 * dimension + exp2]</span> </em></b> of <span class="tt">matrix</span> where <span class="tt">dimension</span> is the the size of the matrix</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>As data is stored contiguously for both vectors and matrices, the <b><span class="tt">[]</span></b> operator is valid for both types. However the <b>.</b> operator is only valid on vector types, and the <b><span class="tt">[,]</span></b> operator is only valid on matrix types. As return values for these operators are references, any modifications through <a class="el" href="#axopassignment">assignments</a> will update the stored value in the container. </dd></dl>
<dl class="section user"><dt>. operator</dt><dd>The dot operator <b>.</b> is only valid for vector types. It has the form: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><span class="tt">vector</span> <b>.</b> <span class="tt">component</span> </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>Where component is one of the below supported component letters. It only provides access for the first three elements of any vector (for <span class="tt">vec2</span> types, only the first 2 components are accessible). Accessing a vector using the dot operator is fundamentally the same as using the <b><span class="tt">[]</span></b> operator with the corresponding integer index. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">vec4i a = { 6, 7, 8, 9 };</div>
<div class="line"><span class="keywordtype">int</span> b = a.z; <span class="comment">// get the the third elements value (8)</span></div>
</div><!-- fragment --> <center>     <p class="formulaDsp">
<img class="formulaDsp" alt="\[A=\begin{bmatrix}
a_{0}\quad a_{1}\quad a_{2}
\end{bmatrix}
\]" src="form_3.png"/>
</p>
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Component  </th><th class="markdownTableHeadCenter">Access Index  </th><th class="markdownTableHeadCenter">Result  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><span class="tt">A.x</span>  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter"><img class="formulaInl" alt="$ a_{0} $" src="form_4.png"/>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><span class="tt">A.r</span>  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter"><img class="formulaInl" alt="$ a_{0} $" src="form_4.png"/>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><span class="tt">A.y</span>  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter"><img class="formulaInl" alt="$ a_{1} $" src="form_5.png"/>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><span class="tt">A.g</span>  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter"><img class="formulaInl" alt="$ a_{1} $" src="form_5.png"/>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><span class="tt">A.z</span>  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter"><img class="formulaInl" alt="$ a_{2} $" src="form_6.png"/>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><span class="tt">A.b</span>  </td><td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter"><img class="formulaInl" alt="$ a_{2} $" src="form_6.png"/>  </td></tr>
</table>
</center> </dd></dl>
<dl class="section user"><dt></dt><dd>This operator can provide more immediately readability when working with expressions that focus on colour or Cartesian coordinate systems. <a class="anchor" id="axvecaccessop"></a></dd></dl>
<dl class="section user"><dt>[] operator</dt><dd>The <b><span class="tt">[]</span></b> operator is valid for both vectors and matrices. It has the form: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><span class="tt">container</span> <b>[</b><em><span class="tt">exp</span></em><b>]</b> </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd><span class="tt">exp</span> is expected to evaluate to a value which is castable to an integer following the <a class="el" href="#axopassignment">assignment casting</a> rules and falls within the valid size of the <span class="tt">container</span>. <b>No bounds checking is performed</b>. </dd></dl>
<dl class="section user"><dt></dt><dd>As matrices are also an array of contigous values, they can be accessed in the same way. This can make some operations much simplier; a typical example being iterating through all matrix elements and performing some logic: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">vec3f a = 0;</div>
<div class="line">a[0] = 1; <span class="comment">// valid</span></div>
<div class="line">a[<span class="stringliteral">&quot;&quot;</span>] = 1; <span class="comment">// invalid - can&#39;t cast to int</span></div>
<div class="line">a[1.2f] = 1; <span class="comment">// valid - float exp will be clamped to an int</span></div>
<div class="line">a[a[0]] = 1; <span class="comment">// valid - use the value of a[0] to index into a</span></div>
<div class="line"><span class="comment">// assign each element its actual index value i.e. b[5] = 5;</span></div>
<div class="line">mat4d b;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; ++i) b[i] = i;</div>
</div><!-- fragment --> <a class="anchor" id="axmataccessop"></a></dd></dl>
<dl class="section user"><dt>[,] operator</dt><dd>The <b><span class="tt">[,]</span></b> operator is only valid for matrices. It has the form: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><span class="tt">matrix</span> <b>[</b><em><span class="tt">exp1</span></em>, <em><span class="tt">exp2</span></em><b>]</b> </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd><span class="tt">exp1</span> and <span class="tt">exp2</span> are expected to evaluate to a value which is castable to an integer following the <a class="el" href="#axopassignment">assignment casting</a> rules and falls within the valid size of the <span class="tt">matrix</span> dimensions. <b>No bounds checking is performed</b>. In general it is more readable to use this operator when accessing specific elements, where <span class="tt">exp1</span> is the row index and <span class="tt">exp2</span> is the column index. The tables below show the different access patterns for <span class="tt">3x3</span> and <span class="tt">4x4</span> matrices. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">mat3f a;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 3; ++j)</div>
<div class="line">        a[i,j] = i*j; <span class="comment">// assign matrix element the product of its index</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<td style="border:none" colspan="3"><p class="formulaDsp">
<img class="formulaDsp" alt="\[{
A=\begin{bmatrix}
a_{00}\quad a_{01}\quad a_{02}\\
a_{10}\quad a_{11}\quad a_{12}\\
a_{20}\quad a_{21}\quad a_{22}\\
\end{bmatrix}
}
\]" src="form_7.png"/>
</p>
 </td><td style="border:none"></td><td style="border:none" colspan="3"><p class="formulaDsp">
<img class="formulaDsp" alt="\[{
A=\begin{bmatrix}
a_{00}\quad a_{01}\quad a_{02}\quad a_{03}\\
a_{10}\quad a_{11}\quad a_{12}\quad a_{13}\\
a_{20}\quad a_{21}\quad a_{22}\quad a_{23}\\
a_{30}\quad a_{31}\quad a_{32}\quad a_{33}\\
\end{bmatrix}
}
\]" src="form_8.png"/>
</p>
 </td></tr>
<tr style="text-align:center">
<th>Access [a]</th><th>Access [a,b]</th><th style="border-right-style:none;">Result</th><td style="border:none" rowspan="17"></td><th>Access [a]</th><th>Access [a,b]</th><th>Result</th></tr>
<tr style="text-align:center">
<td><span class="tt">A[0]</span></td><td><span class="tt">A[0,0]</span></td><td><img class="formulaInl" alt="$ a_{00} $" src="form_9.png"/></td><td><span class="tt">A[0]</span></td><td><span class="tt">A[0,0]</span></td><td><img class="formulaInl" alt="$ a_{00} $" src="form_9.png"/></td></tr>
<tr style="text-align:center">
<td><span class="tt">A[1]</span></td><td><span class="tt">A[0,1]</span></td><td><img class="formulaInl" alt="$ a_{01} $" src="form_10.png"/></td><td><span class="tt">A[1]</span></td><td><span class="tt">A[0,1]</span></td><td><img class="formulaInl" alt="$ a_{01} $" src="form_10.png"/></td></tr>
<tr style="text-align:center">
<td><span class="tt">A[2]</span></td><td><span class="tt">A[0,2]</span></td><td><img class="formulaInl" alt="$ a_{02} $" src="form_11.png"/></td><td><span class="tt">A[2]</span></td><td><span class="tt">A[0,2]</span></td><td><img class="formulaInl" alt="$ a_{02} $" src="form_11.png"/></td></tr>
<tr style="text-align:center">
<td><span class="tt">A[3]</span></td><td><span class="tt">A[1,0]</span></td><td><img class="formulaInl" alt="$ a_{10} $" src="form_12.png"/></td><td><span class="tt">A[3]</span></td><td><span class="tt">A[0,3]</span></td><td><img class="formulaInl" alt="$ a_{03} $" src="form_13.png"/></td></tr>
<tr style="text-align:center">
<td><span class="tt">A[4]</span></td><td><span class="tt">A[1,1]</span></td><td><img class="formulaInl" alt="$ a_{10} $" src="form_12.png"/></td><td><span class="tt">A[4]</span></td><td><span class="tt">A[1,0]</span></td><td><img class="formulaInl" alt="$ a_{10} $" src="form_12.png"/></td></tr>
<tr style="text-align:center">
<td><span class="tt">A[5]</span></td><td><span class="tt">A[1,2]</span></td><td><img class="formulaInl" alt="$ a_{12} $" src="form_14.png"/></td><td><span class="tt">A[5]</span></td><td><span class="tt">A[1,1]</span></td><td><img class="formulaInl" alt="$ a_{11} $" src="form_15.png"/></td></tr>
<tr style="text-align:center">
<td><span class="tt">A[6]</span></td><td><span class="tt">A[2,0]</span></td><td><img class="formulaInl" alt="$ a_{20} $" src="form_16.png"/></td><td><span class="tt">A[6]</span></td><td><span class="tt">A[1,2]</span></td><td><img class="formulaInl" alt="$ a_{12} $" src="form_14.png"/></td></tr>
<tr style="text-align:center">
<td><span class="tt">A[7]</span></td><td><span class="tt">A[2,1]</span></td><td><img class="formulaInl" alt="$ a_{21} $" src="form_17.png"/></td><td><span class="tt">A[7]</span></td><td><span class="tt">A[1,3]</span></td><td><img class="formulaInl" alt="$ a_{13} $" src="form_18.png"/></td></tr>
<tr style="text-align:center">
<td><span class="tt">A[8]</span></td><td><span class="tt">A[2,2]</span></td><td><img class="formulaInl" alt="$ a_{22} $" src="form_19.png"/></td><td><span class="tt">A[8]</span></td><td><span class="tt">A[2,0]</span></td><td><img class="formulaInl" alt="$ a_{20} $" src="form_16.png"/></td></tr>
<tr style="text-align:center">
<td style="border:right;" colspan="4" rowspan="7"></td><td><span class="tt">A[9]</span></td><td><span class="tt">A[2,1]</span></td><td><img class="formulaInl" alt="$ a_{21} $" src="form_17.png"/></td></tr>
<tr style="text-align:center">
<td><span class="tt">A[10]</span></td><td><span class="tt">A[2,2]</span></td><td><img class="formulaInl" alt="$ a_{22} $" src="form_19.png"/></td></tr>
<tr style="text-align:center">
<td><span class="tt">A[11]</span></td><td><span class="tt">A[2,3]</span></td><td><img class="formulaInl" alt="$ a_{23} $" src="form_20.png"/></td></tr>
<tr style="text-align:center">
<td><span class="tt">A[12]</span></td><td><span class="tt">A[3,0]</span></td><td><img class="formulaInl" alt="$ a_{30} $" src="form_21.png"/></td></tr>
<tr style="text-align:center">
<td><span class="tt">A[13]</span></td><td><span class="tt">A[3,1]</span></td><td><img class="formulaInl" alt="$ a_{31} $" src="form_22.png"/></td></tr>
<tr style="text-align:center">
<td><span class="tt">A[14]</span></td><td><span class="tt">A[3,2]</span></td><td><img class="formulaInl" alt="$ a_{32} $" src="form_23.png"/></td></tr>
<tr style="text-align:center">
<td><span class="tt">A[15]</span></td><td><span class="tt">A[3,3]</span></td><td><img class="formulaInl" alt="$ a_{33} $" src="form_24.png"/></td></tr>
</table>
</dd></dl>
<h2 class="doxsection"><a class="anchor" id="axopother"></a>
Other</h2>
<dl class="section user"><dt></dt><dd>A number of uncategorised operators that are more general are documented in this section. They have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator Name</th><th>Operator Syntax</th><th>Returns</th></tr>
<tr style="text-align:left">
<td>Call / Explicit Cast</td><td><span class="tt">a(...)</span> </td><td>Returns the result of a function call or inbuilt explicit cast</td></tr>
<tr style="text-align:left">
<td>Comma</td><td><span class="tt">a, b, ...</span> </td><td>Returns the value of the last expression after chained evaluation</td></tr>
<tr style="text-align:left">
<td>Ternary Conditional</td><td><span class="tt">a ? b : c</span> </td><td><span class="tt">b</span> if <span class="tt">a</span> is true, <span class="tt">c</span> otherwise.</td></tr>
<tr style="text-align:left">
<td>Ternary Conditional</td><td><span class="tt">a ? : c</span> </td><td><span class="tt">a</span> if <span class="tt">a</span> is true, <span class="tt">c</span> otherwise.</td></tr>
<tr>
<td>Vector/Matrix Initializer</td><td><span class="tt">{ a, b, ... }</span></td><td>Returns a temporary vector or matrix</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Call / Explicit Cast</dt><dd>The function call operator provides the ability to invoke functions <b>or</b> invoke a supported explicit cast. It has the form: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><span class="tt">func(a, b, c, ...)</span> </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>Where <span class="tt">func</span> is a function name <b>or</b> a valid explicit cast typename. Explicit casts are only supported for <a class="el" href="#axscalars">scalar types</a>. For example: <div class="fragment"><div class="line"><span class="keywordtype">int</span> a = int(1.1f);</div>
<div class="line">vec3f b = 1.0f;</div>
<div class="line">a = int(b.x);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Whilst explicit casts take only a single argument, the operator itself supports multiple or empty arguments for function calls. When multiple arguments are provided, they are parsed from first to last and processed in reverse order. <b>However</b>, the order of runtime evaluation is <b>unspecified</b> i.e. they may evaluate in any order. Each function parameter is initialized with its corresponding argument after following implicit conversion of assignments where necessary. </dd></dl>
<dl class="section user"><dt></dt><dd>See the <a class="el" href="#axfunctions">function documentation</a> for more information on functions. </dd></dl>
<dl class="section user"><dt>Comma</dt><dd>The Comma operator has the form: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><span class="tt">a, b, ...</span></td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>Where <span class="tt">a</span> and <span class="tt">b</span> are expressions. Chained expressions evaluate each expression in syntactical order (first to last), discarding any return value except for the last expression, which is returned from the entire list. Note that although return values for any expression but the last are discarded, their side effects are still applied before subsequent expression are evaluated. For example: <div class="fragment"><div class="line"><span class="keywordtype">int</span> a = 5;</div>
<div class="line">a-=1, a+=2; <span class="comment">// a = 6</span></div>
<div class="line">a = a--, ++a; <span class="comment">// exp1: a = a--, exp2: ++a. a = 7</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Although you may consider the comma operator as a type of binary operator, it is fundamentally different as the types either side of the operator do <b>not</b> interact. Each expression in the comma operator is evaluated independently of all other expressions.</dd></dl>
<p><a class="anchor" id="axopternary"></a></p><dl class="section user"><dt>Ternary Conditional</dt><dd>The ternary conditional operator can be thought of as an in-line <a class="el" href="#axbranching">if-else statement</a> that returns a value, where each of the if/else branches has a single expression that will be returned. It has the form: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><span class="tt">a ? b : c</span></td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>Where <span class="tt">a</span> is the condition, evaluated and converted to <b>bool</b>, and <span class="tt">b</span> and <span class="tt">c</span> are expressions of the same or implicit-castable types. <span class="tt">b</span> is evaluated and returned if the condition is <b>true</b>, <span class="tt">c</span> is evaluated and returned if the condition is <b>false</b>. Only the expression out of <span class="tt">b</span> and <span class="tt">c</span> that is returned will be evaluated. Expressions with no return value (a.k.a <span class="tt">void</span>) are supported as long as <span class="tt">b</span> and <span class="tt">c</span> are both of this type. </dd></dl>
<dl class="section user"><dt></dt><dd>Also supported is the 'Elvis' operator, <span class="tt">a ? : c</span> (or <span class="tt">?:</span>). Here, <span class="tt">a</span> is evaluated once, and if when converted to <b>bool</b> is <b>true</b>, <span class="tt">a</span> is returned, otherwise <span class="tt">c</span> is evaluated and returned. In this case, <span class="tt">a</span> and <span class="tt">c</span> must be the same or implicit-castable types, and both implicit-castable to <b>bool</b>.</dd></dl>
<p><a class="anchor" id="axvecmatinit"></a></p><dl class="section user"><dt>Vector/Matrix Initializer</dt><dd><a class="el" href="#axvecmats">Vectors and matrices</a> can be represented as local variables (e.g. <span class="tt">vec3f</span>), external attributes or parameters (e.g. <span class="tt">vec3f@attrib</span>) or as temporary values using the vector/matrix initializer syntax. This operator has the form: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><span class="tt">{ a, b, ... }</span></td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>Where <span class="tt">a</span> and <span class="tt">b</span> are expressions returning a scalar value. When this operator is invoked with a specific number of arguments, a vector or matrix is implicitly created with a copy of those arguments which can be assigned to an existing container of matching size. Expression in the operator are evaluated from first to last. This operator is only valid with argument lists of sizes 2, 3, 4, 9 and 16, which implicitly represent <b>vec2, vec3, vec4, mat3,</b> and <b>mat4</b> types respectively. For example: <div class="fragment"><div class="line">vec3f a = { 1.0f, 2.0f, 3.0f }; <span class="comment">// right hand side of assignment creates a vec3f</span></div>
<div class="line">vec3f b = dot(a, { a[0], 5.0, 6.0 }); <span class="comment">// second argument creates a vec3d</span></div>
</div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the above examples, the value of <b><span class="tt">a[0]</span></b> is copied into the initializer operator. </dd></dl>
<dl class="section user"><dt>Initialization Type</dt><dd>A mixture of arbitrary scalar types can be used in the initializer operator e.g: <div class="fragment"><div class="line">mat3f a = {</div>
<div class="line">    <span class="keyword">true</span>, 0s, 0,</div>
<div class="line">    0l, 0.0f, 0.0,</div>
<div class="line">    <span class="keyword">false</span>, 1, 2</div>
<div class="line">};</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>The temporary container evaluates all expressions and uses the <b>highest</b> ranking type (as defined by <a class="el" href="#axtypeprecedence">arithmetic type precedence</a>) to infer the element type of the container, implicitly casting all other types to that type where necessary. In the above example, the temporary created forms a <span class="tt">mat3d</span>, before being implicitly cast to a <span class="tt">mat3f</span> due to the assignment.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="axopprecedence"></a>
Operator Precedence</h2>
<dl class="section user"><dt></dt><dd>The below table shows the precedence and associativity of all AX operators. Operators are listed in descending precedence. </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th style="text-align: left">Precedence</th><th style="text-align: left">Operator</th><th style="text-align: left">Description</th><th style="text-align: left">Associativity</th></tr>
<tr>
<th>1</th><td><code>()</code> </td><td>Parenthesis </td><td style="vertical-align: top" rowspan="5">Left-to-right</td></tr>
<tr>
<th rowspan="4">2</th><td style="border-bottom-style: none"><code>a++</code> <code>a--</code></td><td style="border-bottom-style: none">Suffix/postfix <a class="el" href="#axopunincdec">Increment / Decrement</a> </td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code><em>type</em>()</code></td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="#axopother">Functional cast</a></td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>a()</code></td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="#axopother">Function call</a></td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>a[]</code> <code>.</code></td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="#axopaccess">Container Access</a> </td></tr>
<tr>
<th rowspan="3">3</th><td style="border-bottom-style: none"><code>++a</code> <code>--a</code></td><td style="border-bottom-style: none">Prefix <a class="el" href="#axopunincdec">Increment / Decrement</a> </td><td style="vertical-align: top" rowspan="3">Right-to-left</td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>+a</code> <code>-a</code></td><td style="border-bottom-style: none; border-top-style: none">Unary <a class="el" href="#axopbinarithmetic">plus and minus</a></td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>!</code> <code>~</code></td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="#axopbinlogical">Logical</a> NOT and <a class="el" href="#axopunlogical">Logical</a> NOT</td></tr>
<tr>
<th>4</th><td><code>a*b</code> <code>a/b</code> <code>ab</code></td><td><a class="el" href="#axopbinarithmetic">Multiplication, division, and remainder</a> </td><td style="vertical-align: top" rowspan="11">Left-to-right</td></tr>
<tr>
<th>5</th><td><code>a+b</code> <code>ab</code></td><td><a class="el" href="#axopbinarithmetic">Addition and subtraction</a> </td></tr>
<tr>
<th>6</th><td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td><td><a class="el" href="#axopbinarithmetic">Bitwise left shift and right shift</a> </td></tr>
<tr>
<th rowspan="2">7</th><td style="border-bottom-style: none"><code>&lt;</code> <code>&lt;=</code></td><td style="border-bottom-style: none">For <a class="el" href="#axopcomparison">Comparisons / Relational</a> operators &lt; and  respectively</td></tr>
<tr>
<td style="border-top-style: none"><code>&gt;</code> <code>&gt;=</code></td><td style="border-top-style: none">For <a class="el" href="#axopcomparison">Comparisons / Relational</a> operators &gt; and  respectively</td></tr>
<tr>
<th>8</th><td><code>==</code> <code>!=</code></td><td>For <a class="el" href="#axopcomparison">Comparisons / Relational</a> operators = and  respectively</td></tr>
<tr>
<th>9</th><td><code>&amp;</code></td><td><a class="el" href="#axopbinarithmetic">Arithmetic</a> AND</td></tr>
<tr>
<th>10</th><td><code>^</code></td><td><a class="el" href="#axopbinarithmetic">Arithmetic</a> XOR (exclusive or)</td></tr>
<tr>
<th>11</th><td><code>|</code></td><td><a class="el" href="#axopbinarithmetic">Arithmetic</a> OR (inclusive or)</td></tr>
<tr>
<th>12</th><td><code>&amp;&amp;</code></td><td><a class="el" href="#axopbinlogical">Logical</a> AND</td></tr>
<tr>
<th>13</th><td><code>||</code></td><td><a class="el" href="#axopbinlogical">Logical</a> OR</td></tr>
<tr>
<th rowspan="6">14</th><td style="border-bottom-style: none; border-top-style: none"><code>a?b:c</code></td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="#axopternary">Ternary operator</a> </td><td style="vertical-align: top" rowspan="6">Right-to-left</td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>=</code></td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="#axopassignment">Direct assignment</a> </td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>+=</code> <code>-=</code></td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="#axopassignment">Compound assignment</a> by sum and difference</td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>*=</code> <code>/=</code> <code>%=</code></td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="#axopassignment">Compound assignment</a> by product, quotient, and remainder</td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="#axopassignment">Compound assignment</a> by bitwise left shift and right shift</td></tr>
<tr>
<td style="border-top-style: none"><code>&amp;=</code> <code>^=</code> <code>|=</code></td><td style="border-top-style: none"><a class="el" href="#axopassignment">Compound assignment</a> by bitwise AND, XOR, and OR</td></tr>
<tr>
<th>15</th><td><code>,</code></td><td><a class="el" href="#axopother">Comma</a> </td><td>Left-to-right</td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>Note that associativity of unary operators is redundant (unary prefix operators are always right-to-left and unary postfix operators are always left-to-right). Operators that have the same precedence are bound to their arguments in the direction of their associativity. For example, the expression <b><span class="tt">a = b = c</span></b> is parsed as <b><span class="tt">a = (b = c)</span></b>, and not as <b><span class="tt">(a = b) = c</span></b> because of right-to-left associativity of assignment, but <b><span class="tt">a + b  c</span></b> is parsed <b><span class="tt">(a + b)  c</span></b> and not <b><span class="tt">a + (b  c)</span></b> because of left-to-right associativity of addition and subtraction. <b>Note</b> that this is based off the <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">C++ operator precedence</a>.</dd></dl>
<p><br  />
</p><hr  />
<h1 class="doxsection"><a class="anchor" id="axtokens"></a>
Tokens</h1>
<h2 class="doxsection"><a class="anchor" id="axvaridentifiers"></a>
Variable Identifiers</h2>
<h2 class="doxsection"><a class="anchor" id="axliterals"></a>
Literals</h2>
<dl class="section user"><dt></dt><dd>Literals can be thought of as constant values that are known at compile time. e.g. <div class="fragment"><div class="line">i@a = 1; <span class="comment">// the number 1 is a literal</span></div>
</div><!-- fragment --> As AX supports different bit width scalar literals, it also supports suffix literal tokens which, when using with a scalar literal, represent a literal of a specific size. AX also supports implicit casting for all <a class="el" href="#axopassignment">assignment</a> and <a class="el" href="#axopbinarithmetic">arithmetic</a> operations, so any literal can be used to assign any scalar a value. </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Type</th><th>Literal Tokens</th></tr>
<tr>
<td><span class="tt">bool</span></td><td>Tokens <span class="tt">true</span> and <span class="tt">false</span></td></tr>
<tr>
<td><span class="tt">int32</span></td><td>No suffix, automatically infered from integral literals</td></tr>
<tr>
<td><span class="tt">int64</span></td><td>The letter <span class="tt">l</span> e.g. <div class="fragment"><div class="line">int64 a = 10l; </div>
</div><!-- fragment --></td></tr>
<tr>
<td><span class="tt">float</span></td><td>The letter <span class="tt">f</span> e.g. <div class="fragment"><div class="line"><span class="keywordtype">float</span> a = 0.0f; </div>
</div><!-- fragment --></td></tr>
<tr>
<td><span class="tt">double</span></td><td>No suffix, automatically infered from floating point literals.</td></tr>
<tr>
<td><span class="tt">string</span></td><td>Character strings wrapped in double quotes <b>"</b> <b>"</b> </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<h2 class="doxsection"><a class="anchor" id="axcomments"></a>
Comments</h2>
<h2 class="doxsection"><a class="anchor" id="axkeywords"></a>
Keywords</h2>
<h2 class="doxsection"><a class="anchor" id="axreserved"></a>
Reserved Keywords</h2>
<p><br  />
</p><hr  />
<h1 class="doxsection"><a class="anchor" id="axsyntax"></a>
Syntax</h1>
<h2 class="doxsection"><a class="anchor" id="axattribaccess"></a>
Attribute Access</h2>
<p>Further, the active states of OpenVDB voxels change which voxels AX will process. The defined behavior for all cases is shown below. </p><dl class="section user"><dt></dt><dd>Consider a simple assignment example: <div class="fragment"><div class="line"><span class="keywordtype">float</span>@surface = <span class="keywordtype">float</span>@density;</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Assignment operations determine which volumes will be executed over. Here, the AX program will only execute on the <b>surface</b> VDB whilst retaining access to all available VDBs. There exists a number of possible states of both the <b>surface</b> and <b>density</b> volumes.<ul>
<li>Volumes have the same transform and the same topology</li>
<li>Volumes have the same transform, but different topologies</li>
<li>Volumes have different transforms, but the same topology</li>
<li>Volumes have different transforms and different topologies </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Matching Transforms</dt><dd>In the simplest case, all volumes processed have the same transform. Active voxels in the <b>surface</b> VDB will receive a value sampled (<a class="el" href="#axattribaccess">point sampled</a>) at the corresponding <b>index</b> space position in the <b>density</b> VDB. As the transforms match, this is guaranteed to be at the same <b>world</b> space position. The topology of the <b>density</b> VDB does not influence which values are assigned, AX simply queries the <b>density</b> VDB at the computed position and uses whatever value is returned. This may be the VDB <b>Background</b> value. </dd></dl>
<dl class="section user"><dt>Different Transforms</dt><dd>When transforms differ, AX performs coordinate transformations from the source VDB to the target VDB. Using some simple pseudo code, we can represent each voxel's coordinate query: <div class="fragment"><div class="line">foreach(ActiveVoxel in surface)</div>
<div class="line">    SurfaceIndexSpaceCoord = ActiveVoxel.indexSpaceCoordinate();</div>
<div class="line">    SurfaceWorldSpaceCoord = surface.transformToWorld(SurfaceIndexSpaceCoord);</div>
<div class="line">    DensityIndexSpaceCoord = density.transformToIndex(SurfaceWorldSpaceCoord);</div>
<div class="line">    ActiveVoxel = density.getValue(DensityIndexSpaceCoord);</div>
</div><!-- fragment --></dd></dl>
<h2 class="doxsection"><a class="anchor" id="axexternalaccess"></a>
External Parameter Access</h2>
<h2 class="doxsection"><a class="anchor" id="axdecls"></a>
Declarations</h2>
<h2 class="doxsection"><a class="anchor" id="axscopes"></a>
Scopes</h2>
<h2 class="doxsection"><a class="anchor" id="axbranching"></a>
Branching (if / else)</h2>
<h2 class="doxsection"><a class="anchor" id="axloops"></a>
Loops</h2>
<p><br  />
</p><hr  />
<h1 class="doxsection"><a class="anchor" id="axfunctions"></a>
Functions</h1>
<dl class="section user"><dt></dt><dd>For a list of all functions, see the <a class="el" href="axfunctionlist.html">AX Function List</a>. </dd></dl>
<dl class="section user"><dt></dt><dd>AX supports a variety of mathematical, string, utility and custom function calls which can be used from within an AX program. Native function support is constantly growing and we encourage users who wish to see particular methods exposed and supported natively by AX to contact us. Whilst we can't guarantee to accommodate every function, these requests provide the developers insights into how the language is being used. </dd></dl>
<dl class="section user"><dt>Function Execution Context</dt><dd>Some functions depend on the currently processing <a class="el" href="#axexecutionxcontext">OpenVDB Execution Context</a> to work correctly and will fail if called from an "invalid" context. Specifically, there exists functions which operate on OpenVDB points or OpenVDB volume grids and interact with the point or voxel data. Some of these methods are incompatible for the other grid type (for example, <a class="el" href="axfunctionlist.html#axdeletepoint">deleting a point from a Point Data Grid</a>) and will result in the compilation failure of an AX program if an attempt is made it use them.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="axuserfunctions"></a>
User Functions</h2>
<dl class="section user"><dt></dt><dd>User function declarations are not currently supported, but exist on the AX Roadmap as a near future feature.</dd></dl>
<p><br  />
</p><hr  />
<h1 class="doxsection"><a class="anchor" id="axvexsupport"></a>
AX VEX Support</h1>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">OpenVDB</a></li><li class="navelem"><a href="openvdbax.html">OpenVDB AX</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
