<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: SRetFunction&lt; SignatureT, DerivedFunction &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html','','structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">SRetFunction&lt; SignatureT, DerivedFunction &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Templated interface class for SRET functions. This struct provides the interface for functions that wish to return arrays (vectors or matrices) by internally remapping the first argument for the user. As far as LLVM and any bindings are concerned, the function signature remains unchanged - however the first argument becomes "invisible" to the user and is instead allocated by LLVM before the function is executed. Importantly, the argument has no impact on the user facing AX signature and doesn't affect declaration selection.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="FunctionTypes_8h_source.html">openvdb_ax/codegen/FunctionTypes.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1f0369aa802ea699423de0552c44a42b" id="r_a1f0369aa802ea699423de0552c44a42b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f0369aa802ea699423de0552c44a42b">Ptr</a> = std::shared_ptr&lt;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html">SRetFunction</a>&lt;SignatureT, DerivedFunction&gt;&gt;</td></tr>
<tr class="memitem:a2846ade648824cd69bd0fdc3d2cee4ca" id="r_a2846ade648824cd69bd0fdc3d2cee4ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2846ade648824cd69bd0fdc3d2cee4ca">Traits</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionTraits.html">FunctionTraits</a>&lt;SignatureT&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeeedef433759fed9cd7d72a6e1e56c9f" id="r_aeeedef433759fed9cd7d72a6e1e56c9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html">ArgInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeeedef433759fed9cd7d72a6e1e56c9f">types</a> (<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;args, llvm::LLVMContext &amp;C) const override</td></tr>
<tr class="memdesc:aeeedef433759fed9cd7d72a6e1e56c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overide the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html" title="Metadata associated with a function argument or return value.">ArgInfo</a> type method. This does NOT change the arg order, it simply marks the first argument as a return argument. Note that the void ret type is also left as a return type.  <br /></td></tr>
<tr class="memitem:a431456d47fdcb019ab9db247b9989a38" id="r_a431456d47fdcb019ab9db247b9989a38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">Function::SignatureMatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a431456d47fdcb019ab9db247b9989a38">match</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;args, llvm::LLVMContext &amp;C) const override</td></tr>
<tr class="memdesc:a431456d47fdcb019ab9db247b9989a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of match which inserts the SRET type such that the base class methods ignore it.  <br /></td></tr>
<tr class="memitem:aae8daf0986a2751029d10dc5a318465e" id="r_aae8daf0986a2751029d10dc5a318465e"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae8daf0986a2751029d10dc5a318465e">call</a> (const std::vector&lt; llvm::Value * &gt; &amp;args, llvm::IRBuilder&lt;&gt; &amp;B) const override</td></tr>
<tr class="memdesc:aae8daf0986a2751029d10dc5a318465e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of call which allocates the required SRET llvm::Value for this function.  <br /></td></tr>
<tr class="memitem:a160d941a6104d6c46c3da98584a8a265" id="r_a160d941a6104d6c46c3da98584a8a265"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a160d941a6104d6c46c3da98584a8a265">call</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html">Arguments</a> &amp;args, llvm::IRBuilder&lt;&gt; &amp;B) const override</td></tr>
<tr class="memitem:a02be931d9569d33334a4032a421d9c52" id="r_a02be931d9569d33334a4032a421d9c52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02be931d9569d33334a4032a421d9c52">print</a> (llvm::LLVMContext &amp;C, std::ostream &amp;os, const char *name=nullptr, const bool axTypes=true) const override</td></tr>
<tr class="memdesc:a02be931d9569d33334a4032a421d9c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of print to avoid printing out the SRET type.  <br /></td></tr>
<tr class="memitem:a9527ef3e0f61abd8b26dba4d2648ad21" id="r_a9527ef3e0f61abd8b26dba4d2648ad21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">Function::SignatureMatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9527ef3e0f61abd8b26dba4d2648ad21">match</a> (const std::vector&lt; llvm::Type * &gt; &amp;args, llvm::LLVMContext &amp;C) const override</td></tr>
<tr class="memitem:a3eb5e0f696f0d8de2c9ce35ef725272f" id="r_a3eb5e0f696f0d8de2c9ce35ef725272f"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3eb5e0f696f0d8de2c9ce35ef725272f">call</a> (const std::vector&lt; llvm::Value * &gt; &amp;args, llvm::IRBuilder&lt;&gt; &amp;B, const bool cast) const override</td></tr>
<tr class="memitem:aeb7c9936016e2c09aab2e6f8e039a16a" id="r_aeb7c9936016e2c09aab2e6f8e039a16a"><td class="memItemLeft" align="right" valign="top">virtual llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb7c9936016e2c09aab2e6f8e039a16a">types</a> (std::vector&lt; llvm::Type * &gt; &amp;, llvm::LLVMContext &amp;) const=0</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a849ad93faaa7d7fb2d6b1fe94faae0ca" id="r_a849ad93faaa7d7fb2d6b1fe94faae0ca"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a849ad93faaa7d7fb2d6b1fe94faae0ca template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a849ad93faaa7d7fb2d6b1fe94faae0ca">SRetFunction</a> (Args &amp;&amp;... ts)</td></tr>
<tr class="memdesc:a849ad93faaa7d7fb2d6b1fe94faae0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward all arguments to the derived class.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename SignatureT, typename DerivedFunction&gt;<br />
struct openvdb::v13_0::ax::codegen::SRetFunction&lt; SignatureT, DerivedFunction &gt;</div><p>Templated interface class for SRET functions. This struct provides the interface for functions that wish to return arrays (vectors or matrices) by internally remapping the first argument for the user. As far as LLVM and any bindings are concerned, the function signature remains unchanged - however the first argument becomes "invisible" to the user and is instead allocated by LLVM before the function is executed. Importantly, the argument has no impact on the user facing AX signature and doesn't affect declaration selection. </p>
<dl class="section note"><dt>Note</dt><dd>This class is not intended to be instantiated directly, but instead used by derived implementation which hold a valid implementations of member functions required to create a llvm::Function (such as <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aa7be69eba606cab147a0162591c13e6f" title="Populate a vector of ArgInfos which describe this function signature. This method is used by Function...">Function::types</a> and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a8260c8666f1cbbb10279dd0f7b44e643" title="Uses the IRBuilder to create a call to this function with the given arguments, creating the function ...">Function::call</a>). This exists as an interface to avoid virtual inheritance. </dd></dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a1f0369aa802ea699423de0552c44a42b" name="a1f0369aa802ea699423de0552c44a42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0369aa802ea699423de0552c44a42b">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT, typename DerivedFunction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1f0369aa802ea699423de0552c44a42b">Ptr</a> = std::shared_ptr&lt;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html">SRetFunction</a>&lt;SignatureT, DerivedFunction&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2846ade648824cd69bd0fdc3d2cee4ca" name="a2846ade648824cd69bd0fdc3d2cee4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2846ade648824cd69bd0fdc3d2cee4ca">&#9670;&#160;</a></span>Traits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT, typename DerivedFunction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2846ade648824cd69bd0fdc3d2cee4ca">Traits</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionTraits.html">FunctionTraits</a>&lt;SignatureT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a849ad93faaa7d7fb2d6b1fe94faae0ca" name="a849ad93faaa7d7fb2d6b1fe94faae0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849ad93faaa7d7fb2d6b1fe94faae0ca">&#9670;&#160;</a></span>SRetFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT, typename DerivedFunction&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html">SRetFunction</a> </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>ts</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward all arguments to the derived class. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a160d941a6104d6c46c3da98584a8a265" name="a160d941a6104d6c46c3da98584a8a265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160d941a6104d6c46c3da98584a8a265">&#9670;&#160;</a></span>call() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT, typename DerivedFunction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> call </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html">Arguments</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aae8daf0986a2751029d10dc5a318465e" name="aae8daf0986a2751029d10dc5a318465e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8daf0986a2751029d10dc5a318465e">&#9670;&#160;</a></span>call() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT, typename DerivedFunction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * call </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override of call which allocates the required SRET llvm::Value for this function. </p>
<dl class="section note"><dt>Note</dt><dd>Unlike other function where the returned llvm::Value* is a llvm::CallInst (which also represents the return value), SRET functions return the allocated 1st argument i.e. not a llvm::CallInst </dd></dl>

</div>
</div>
<a id="a3eb5e0f696f0d8de2c9ce35ef725272f" name="a3eb5e0f696f0d8de2c9ce35ef725272f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb5e0f696f0d8de2c9ce35ef725272f">&#9670;&#160;</a></span>call() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT, typename DerivedFunction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * call </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>cast</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is deprecated! Omitting the warning as it invokes the parent function which is also deprecated. Use <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html" title="Wrapper struct to represent &quot;native&quot; function arguments; that is, the set of Value type that the AX g...">NativeArguments</a> to perform argument casting </dd></dl>

</div>
</div>
<a id="a431456d47fdcb019ab9db247b9989a38" name="a431456d47fdcb019ab9db247b9989a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431456d47fdcb019ab9db247b9989a38">&#9670;&#160;</a></span>match() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT, typename DerivedFunction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">Function::SignatureMatch</a> match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override of match which inserts the SRET type such that the base class methods ignore it. </p>

</div>
</div>
<a id="a9527ef3e0f61abd8b26dba4d2648ad21" name="a9527ef3e0f61abd8b26dba4d2648ad21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9527ef3e0f61abd8b26dba4d2648ad21">&#9670;&#160;</a></span>match() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT, typename DerivedFunction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">Function::SignatureMatch</a> match </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Type * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is deprecated! Omitting the warning as it invokes the parent function which is also deprecated. Use <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html" title="Wrapper struct to represent &quot;native&quot; function arguments; that is, the set of Value type that the AX g...">NativeArguments</a> to perform argument casting </dd></dl>

</div>
</div>
<a id="a02be931d9569d33334a4032a421d9c52" name="a02be931d9569d33334a4032a421d9c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02be931d9569d33334a4032a421d9c52">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT, typename DerivedFunction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void print </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>axTypes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override of print to avoid printing out the SRET type. </p>

</div>
</div>
<a id="aeeedef433759fed9cd7d72a6e1e56c9f" name="aeeedef433759fed9cd7d72a6e1e56c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeedef433759fed9cd7d72a6e1e56c9f">&#9670;&#160;</a></span>types() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT, typename DerivedFunction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html">ArgInfo</a> types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overide the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html" title="Metadata associated with a function argument or return value.">ArgInfo</a> type method. This does NOT change the arg order, it simply marks the first argument as a return argument. Note that the void ret type is also left as a return type. </p>

</div>
</div>
<a id="aeb7c9936016e2c09aab2e6f8e039a16a" name="aeb7c9936016e2c09aab2e6f8e039a16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7c9936016e2c09aab2e6f8e039a16a">&#9670;&#160;</a></span>types() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT, typename DerivedFunction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Type * types </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Type * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Bring in deprecated type methods </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax.html">ax</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html">codegen</a></li><li class="navelem"><a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html">SRetFunction</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
