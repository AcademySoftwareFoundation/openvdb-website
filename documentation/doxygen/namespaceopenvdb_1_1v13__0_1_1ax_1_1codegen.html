<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: openvdb::v13_0::ax::codegen Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">openvdb::v13_0::ax::codegen Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:AliasTypeMap" id="r_AliasTypeMap"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1AliasTypeMap.html">AliasTypeMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias mapping between two types, a frontend type T1 and a backend type T2. This class is the intended interface for binding objects which implement supported backend AX/IR types to this given backend type. More specifically, it's current and expected usage is limited to objects which hold a single member of a supported backend type and implements a StandardLayoutType as defined by the standard. Fundamentally, T1-&gt;T2 mapping should be supported by reinterpret_cast&lt;&gt; as defined by the type aliasing rules.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1AliasTypeMap.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArgInfo" id="r_ArgInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html">ArgInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classopenvdb_1_1v13__0_1_1Metadata.html" title="Base class for storing metadata information in a grid.">Metadata</a> associated with a function argument or return value.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArgInfoVector" id="r_ArgInfoVector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of ArgInfos. This class makes up part of the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a> API for querying signature information.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArgType" id="r_ArgType"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object to array conversion methods to allow functions to return vector types. These containers provided an interface for automatic conversion of C++ objects to LLVM types as array types.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArgumentIterator" id="r_ArgumentIterator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgumentIterator.html">ArgumentIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated argument iterator which implements various small functions per argument type, resolved at compile time.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgumentIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArgumentIterator_3C_20SignatureT_2C_200_20_3E" id="r_ArgumentIterator_3C_20SignatureT_2C_200_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgumentIterator_3_01SignatureT_00_010_01_4.html">ArgumentIterator&lt; SignatureT, 0 &gt;</a></td></tr>
<tr class="memitem:Arguments" id="r_Arguments"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html">Arguments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitrary, potentially "non-native" arguments. This wrapper struct can be used when generating function which cannot be called from AX itself (e.g. VDB accessor functions or Volume/Point kernels etc). They do not support implicit function signature matching or casting.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html#details">More...</a><br /></td></tr>
<tr class="memitem:CFunction" id="r_CFunction"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html">CFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a concrete C function binding.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html#details">More...</a><br /></td></tr>
<tr class="memitem:CFunctionBase" id="r_CFunctionBase"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionBase.html">CFunctionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all C bindings.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:CFunctionSRet" id="r_CFunctionSRet"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionSRet.html">CFunctionSRet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a concrete C function binding with the first argument as its return type.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionSRet.html#details">More...</a><br /></td></tr>
<tr class="memitem:Codec" id="r_Codec"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Codec.html">Codec</a></td></tr>
<tr class="memitem:ComputeKernel" id="r_ComputeKernel"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ComputeKernel.html">ComputeKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function definition and signature which is built by the ComputeGenerator.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ComputeKernel.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConstantFolder" id="r_ConstantFolder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ConstantFolder.html">ConstantFolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant folding support structure.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ConstantFolder.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConstantFolder_3C_20SignatureT_2C_200_20_3E" id="r_ConstantFolder_3C_20SignatureT_2C_200_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ConstantFolder_3_01SignatureT_00_010_01_4.html">ConstantFolder&lt; SignatureT, 0 &gt;</a></td></tr>
<tr class="memitem:CountNPtrs" id="r_CountNPtrs"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CountNPtrs.html">CountNPtrs</a></td></tr>
<tr class="memitem:CountNPtrs_3C_20T_20_2A_20_3E" id="r_CountNPtrs_3C_20T_20_2A_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CountNPtrs_3_01T_01_5_01_4.html">CountNPtrs&lt; T * &gt;</a></td></tr>
<tr class="memitem:CountNPtrs_3C_20T_20_2Aconst_20_3E" id="r_CountNPtrs_3C_20T_20_2Aconst_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CountNPtrs_3_01T_01_5const_01_4.html">CountNPtrs&lt; T *const &gt;</a></td></tr>
<tr class="memitem:CountNPtrs_3C_20T_20_2Aconst_20volatile_20_3E" id="r_CountNPtrs_3C_20T_20_2Aconst_20volatile_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CountNPtrs_3_01T_01_5const_01volatile_01_4.html">CountNPtrs&lt; T *const volatile &gt;</a></td></tr>
<tr class="memitem:CountNPtrs_3C_20T_20_2Avolatile_20_3E" id="r_CountNPtrs_3C_20T_20_2Avolatile_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CountNPtrs_3_01T_01_5volatile_01_4.html">CountNPtrs&lt; T *volatile &gt;</a></td></tr>
<tr class="memitem:Function" id="r_Function"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base/abstract representation of an AX function. Derived classes must implement the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aa7be69eba606cab147a0162591c13e6f" title="Populate a vector of ArgInfos which describe this function signature. This method is used by Function...">Function::types</a> call to describe their signature.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#details">More...</a><br /></td></tr>
<tr class="memitem:FunctionBuilder" id="r_FunctionBuilder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionBuilder.html">FunctionBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionBuilder.html" title="The FunctionBuilder class provides a builder pattern framework to allow easy and valid construction o...">FunctionBuilder</a> class provides a builder pattern framework to allow easy and valid construction of AX functions. There are a number of complex tasks which may need to be performed during construction of C or IR function which are delegated to this builder, whilst ensuring that the constructed functions are guaranteed to be valid.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionBuilder.html#details">More...</a><br /></td></tr>
<tr class="memitem:FunctionGroup" id="r_FunctionGroup"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html">FunctionGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A group of functions which all have the same name but different signatures. For example: float abs(float) double abs(double) As well as serving as a way of grouping common functions, this class provides an API for selecting the best possible function signature, should a match exist, against a provided set of argument types.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html#details">More...</a><br /></td></tr>
<tr class="memitem:FunctionRegistry" id="r_FunctionRegistry"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionRegistry.html">FunctionRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function registry which is used for function code generation. Each time a function is visited within the AST, its identifier is used as a key into this registry for the corresponding function retrieval and execution. Functions can be inserted into the registry using <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionRegistry.html#abaf1891724f1dc8b9769d863916ac114" title="Insert and register a function object to a function identifier.">insert()</a> with a given identifier and pointer.  <a href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionRegistry.html#details">More...</a><br /></td></tr>
<tr class="memitem:FunctionTraits" id="r_FunctionTraits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionTraits.html">FunctionTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated function traits which provides compile-time index access to the types of the function signature.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionTraits.html#details">More...</a><br /></td></tr>
<tr class="memitem:FunctionTraits_3C_20R_28_26_29_28Args_2E_2E_2E_29_3E" id="r_FunctionTraits_3C_20R_28_26_29_28Args_2E_2E_2E_29_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionTraits_3_01R_07_6_08_07Args_8_8_8_08_4.html">FunctionTraits&lt; R(&amp;)(Args...)&gt;</a></td></tr>
<tr class="memitem:FunctionTraits_3C_20R_28_2A_29_28Args_2E_2E_2E_29_3E" id="r_FunctionTraits_3C_20R_28_2A_29_28Args_2E_2E_2E_29_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionTraits_3_01R_07_5_08_07Args_8_8_8_08_4.html">FunctionTraits&lt; R(*)(Args...)&gt;</a></td></tr>
<tr class="memitem:FunctionTraits_3C_20ReturnT_28Args_2E_2E_2E_29_3E" id="r_FunctionTraits_3C_20ReturnT_28Args_2E_2E_2E_29_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionTraits_3_01ReturnT_07Args_8_8_8_08_4.html">FunctionTraits&lt; ReturnT(Args...)&gt;</a></td></tr>
<tr class="memitem:int_5Ft" id="r_int_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1int__t.html">int_t</a></td></tr>
<tr class="memitem:int_5Ft_3C_2016_20_3E" id="r_int_5Ft_3C_2016_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1int__t_3_0116_01_4.html">int_t&lt; 16 &gt;</a></td></tr>
<tr class="memitem:int_5Ft_3C_2032_20_3E" id="r_int_5Ft_3C_2032_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1int__t_3_0132_01_4.html">int_t&lt; 32 &gt;</a></td></tr>
<tr class="memitem:int_5Ft_3C_2064_20_3E" id="r_int_5Ft_3C_2064_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1int__t_3_0164_01_4.html">int_t&lt; 64 &gt;</a></td></tr>
<tr class="memitem:int_5Ft_3C_208_20_3E" id="r_int_5Ft_3C_208_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1int__t_3_018_01_4.html">int_t&lt; 8 &gt;</a></td></tr>
<tr class="memitem:IRFunction" id="r_IRFunction"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunction.html">IRFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a concrete IR function.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunction.html#details">More...</a><br /></td></tr>
<tr class="memitem:IRFunctionBase" id="r_IRFunctionBase"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html">IRFunctionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base/abstract definition for an IR function.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:IRFunctionSRet" id="r_IRFunctionSRet"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionSRet.html">IRFunctionSRet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a concrete IR function with the first argument as its return type.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionSRet.html#details">More...</a><br /></td></tr>
<tr class="memitem:LLVMType" id="r_LLVMType"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType.html">LLVMType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LLVM type mapping from pod types.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType.html#details">More...</a><br /></td></tr>
<tr class="memitem:LLVMType_3C_20ArgType_3C_20T_2C_20S_20_3E_20_3E" id="r_LLVMType_3C_20ArgType_3C_20T_2C_20S_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01ArgType_3_01T_00_01S_01_4_01_4.html">LLVMType&lt; ArgType&lt; T, S &gt; &gt;</a></td></tr>
<tr class="memitem:LLVMType_3C_20char_20_3E" id="r_LLVMType_3C_20char_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01char_01_4.html">LLVMType&lt; char &gt;</a></td></tr>
<tr class="memitem:LLVMType_3C_20codegen_3A_3AString_20_3E" id="r_LLVMType_3C_20codegen_3A_3AString_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01codegen_1_1String_01_4.html">LLVMType&lt; codegen::String &gt;</a></td></tr>
<tr class="memitem:LLVMType_3C_20const_20T_20_2A_20_3E" id="r_LLVMType_3C_20const_20T_20_2A_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01const_01T_01_5_01_4.html">LLVMType&lt; const T * &gt;</a></td></tr>
<tr class="memitem:LLVMType_3C_20const_20T_20_3E" id="r_LLVMType_3C_20const_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01const_01T_01_4.html">LLVMType&lt; const T &gt;</a></td></tr>
<tr class="memitem:LLVMType_3C_20openvdb_3A_3Amath_3A_3Ahalf_20_3E" id="r_LLVMType_3C_20openvdb_3A_3Amath_3A_3Ahalf_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01openvdb_1_1math_1_1half_01_4.html">LLVMType&lt; openvdb::math::half &gt;</a></td></tr>
<tr class="memitem:LLVMType_3C_20openvdb_3A_3Amath_3A_3AMat3_3C_20T_20_3E_20_3E" id="r_LLVMType_3C_20openvdb_3A_3Amath_3A_3AMat3_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01openvdb_1_1math_1_1Mat3_3_01T_01_4_01_4.html">LLVMType&lt; openvdb::math::Mat3&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:LLVMType_3C_20openvdb_3A_3Amath_3A_3AMat4_3C_20T_20_3E_20_3E" id="r_LLVMType_3C_20openvdb_3A_3Amath_3A_3AMat4_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01openvdb_1_1math_1_1Mat4_3_01T_01_4_01_4.html">LLVMType&lt; openvdb::math::Mat4&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:LLVMType_3C_20openvdb_3A_3Amath_3A_3AVec2_3C_20T_20_3E_20_3E" id="r_LLVMType_3C_20openvdb_3A_3Amath_3A_3AVec2_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01openvdb_1_1math_1_1Vec2_3_01T_01_4_01_4.html">LLVMType&lt; openvdb::math::Vec2&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported aliasing for VDB math types, allowing use in external function signatures.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01openvdb_1_1math_1_1Vec2_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:LLVMType_3C_20openvdb_3A_3Amath_3A_3AVec3_3C_20T_20_3E_20_3E" id="r_LLVMType_3C_20openvdb_3A_3Amath_3A_3AVec3_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01openvdb_1_1math_1_1Vec3_3_01T_01_4_01_4.html">LLVMType&lt; openvdb::math::Vec3&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:LLVMType_3C_20openvdb_3A_3Amath_3A_3AVec4_3C_20T_20_3E_20_3E" id="r_LLVMType_3C_20openvdb_3A_3Amath_3A_3AVec4_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01openvdb_1_1math_1_1Vec4_3_01T_01_4_01_4.html">LLVMType&lt; openvdb::math::Vec4&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:LLVMType_3C_20T_20_2A_20_3E" id="r_LLVMType_3C_20T_20_2A_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01T_01_5_01_4.html">LLVMType&lt; T * &gt;</a></td></tr>
<tr class="memitem:LLVMType_3C_20T_5BS_5D_3E" id="r_LLVMType_3C_20T_5BS_5D_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01T_0fS_0e_4.html">LLVMType&lt; T[S]&gt;</a></td></tr>
<tr class="memitem:LLVMType_3C_20void_20_2A_20_3E" id="r_LLVMType_3C_20void_20_2A_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01void_01_5_01_4.html">LLVMType&lt; void * &gt;</a></td></tr>
<tr class="memitem:LLVMType_3C_20void_20_3E" id="r_LLVMType_3C_20void_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01void_01_4.html">LLVMType&lt; void &gt;</a></td></tr>
<tr class="memitem:NativeArguments" id="r_NativeArguments"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html">NativeArguments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper struct to represent "native" function arguments; that is, the set of <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> type that the AX grammar supports. <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html" title="Wrapper struct to represent &quot;native&quot; function arguments; that is, the set of Value type that the AX g...">NativeArguments</a> have two benefits; they support casting and implicit function matching through FunctionGroups and can be used directly in IR generators (to leverage the AX <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> API). Functions can still be generated and called with "non-native" arguments, but in these cases <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html#a559782c89d155504fd859c39530bfd15" title="Given a set of Arguments, find an EXPLICIT signature match, generate and execute the function body....">FunctionGroup::execute</a> must result in an explicit signature match.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html#details">More...</a><br /></td></tr>
<tr class="memitem:PointKernelAttributeArray" id="r_PointKernelAttributeArray"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1PointKernelAttributeArray.html">PointKernelAttributeArray</a></td></tr>
<tr class="memitem:PointKernelBuffer" id="r_PointKernelBuffer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1PointKernelBuffer.html">PointKernelBuffer</a></td></tr>
<tr class="memitem:PointKernelBufferRange" id="r_PointKernelBufferRange"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1PointKernelBufferRange.html">PointKernelBufferRange</a></td></tr>
<tr class="memitem:PointKernelValue" id="r_PointKernelValue"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1PointKernelValue.html">PointKernelValue</a></td></tr>
<tr class="memitem:RemoveAllPtrTypes" id="r_RemoveAllPtrTypes"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1RemoveAllPtrTypes.html">RemoveAllPtrTypes</a></td></tr>
<tr class="memitem:RemoveAllPtrTypes_3C_20T_20_2A_20_3E" id="r_RemoveAllPtrTypes_3C_20T_20_2A_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1RemoveAllPtrTypes_3_01T_01_5_01_4.html">RemoveAllPtrTypes&lt; T * &gt;</a></td></tr>
<tr class="memitem:RemoveAllPtrTypes_3C_20T_20_2Aconst_20_3E" id="r_RemoveAllPtrTypes_3C_20T_20_2Aconst_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1RemoveAllPtrTypes_3_01T_01_5const_01_4.html">RemoveAllPtrTypes&lt; T *const &gt;</a></td></tr>
<tr class="memitem:RemoveAllPtrTypes_3C_20T_20_2Aconst_20volatile_20_3E" id="r_RemoveAllPtrTypes_3C_20T_20_2Aconst_20volatile_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1RemoveAllPtrTypes_3_01T_01_5const_01volatile_01_4.html">RemoveAllPtrTypes&lt; T *const volatile &gt;</a></td></tr>
<tr class="memitem:RemoveAllPtrTypes_3C_20T_20_2Avolatile_20_3E" id="r_RemoveAllPtrTypes_3C_20T_20_2Avolatile_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1RemoveAllPtrTypes_3_01T_01_5volatile_01_4.html">RemoveAllPtrTypes&lt; T *volatile &gt;</a></td></tr>
<tr class="memitem:SRetFunction" id="r_SRetFunction"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html">SRetFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated interface class for SRET functions. This struct provides the interface for functions that wish to return arrays (vectors or matrices) by internally remapping the first argument for the user. As far as LLVM and any bindings are concerned, the function signature remains unchanged - however the first argument becomes "invisible" to the user and is instead allocated by LLVM before the function is executed. Importantly, the argument has no impact on the user facing AX signature and doesn't affect declaration selection.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#details">More...</a><br /></td></tr>
<tr class="memitem:String" id="r_String"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1String.html">String</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An extremely basic but native representation of a string class with SSO support. This exists to provide an interface between the AX C++ API and backend IR string logic. It is not designed to fulfill any other use and should very rarely be used directly.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1String.html#details">More...</a><br /></td></tr>
<tr class="memitem:SymbolTable" id="r_SymbolTable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SymbolTable.html">SymbolTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbol table which can be used to represent a single scoped set of a programs variables. This is simply an unordered map of strings to llvm::Values.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SymbolTable.html#details">More...</a><br /></td></tr>
<tr class="memitem:SymbolTableBlocks" id="r_SymbolTableBlocks"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SymbolTableBlocks.html">SymbolTableBlocks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of unique ids to symbol tables which can be used to represent local variables within a program. New scopes can be added and erased where necessary and iterated through using <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SymbolTableBlocks.html#a186986c63c6559b1f1f7532ef465775c" title="Find a variable within the program starting at a given table index. If the given index does not exist...">find()</a>. Find assumes that tables are added through parented ascending ids.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SymbolTableBlocks.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeToSymbol" id="r_TypeToSymbol"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol.html">TypeToSymbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to symbol conversions - these characters are used to build each functions unique signature. They differ from standard AX or LLVM syntax to be as short as possible i.e. vec4d, [4 x double] = d4.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeToSymbol_3C_20ArgType_3C_20T_2C_20S_20_3E_20_3E" id="r_TypeToSymbol_3C_20ArgType_3C_20T_2C_20S_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01ArgType_3_01T_00_01S_01_4_01_4.html">TypeToSymbol&lt; ArgType&lt; T, S &gt; &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20char_20_3E" id="r_TypeToSymbol_3C_20char_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01char_01_4.html">TypeToSymbol&lt; char &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20codegen_3A_3AString_20_3E" id="r_TypeToSymbol_3C_20codegen_3A_3AString_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01codegen_1_1String_01_4.html">TypeToSymbol&lt; codegen::String &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20const_20T_20_2A_20_3E" id="r_TypeToSymbol_3C_20const_20T_20_2A_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01const_01T_01_5_01_4.html">TypeToSymbol&lt; const T * &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20const_20T_20_3E" id="r_TypeToSymbol_3C_20const_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01const_01T_01_4.html">TypeToSymbol&lt; const T &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20double_20_3E" id="r_TypeToSymbol_3C_20double_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01double_01_4.html">TypeToSymbol&lt; double &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20float_20_3E" id="r_TypeToSymbol_3C_20float_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01float_01_4.html">TypeToSymbol&lt; float &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20int16_5Ft_20_3E" id="r_TypeToSymbol_3C_20int16_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01int16__t_01_4.html">TypeToSymbol&lt; int16_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20int32_5Ft_20_3E" id="r_TypeToSymbol_3C_20int32_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01int32__t_01_4.html">TypeToSymbol&lt; int32_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20int64_5Ft_20_3E" id="r_TypeToSymbol_3C_20int64_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01int64__t_01_4.html">TypeToSymbol&lt; int64_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20int8_5Ft_20_3E" id="r_TypeToSymbol_3C_20int8_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01int8__t_01_4.html">TypeToSymbol&lt; int8_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20math_3A_3AMat3_3C_20T_20_3E_20_3E" id="r_TypeToSymbol_3C_20math_3A_3AMat3_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Mat3_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Mat3&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20math_3A_3AMat4_3C_20T_20_3E_20_3E" id="r_TypeToSymbol_3C_20math_3A_3AMat4_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Mat4_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Mat4&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20math_3A_3AVec2_3C_20T_20_3E_20_3E" id="r_TypeToSymbol_3C_20math_3A_3AVec2_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Vec2_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Vec2&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20math_3A_3AVec3_3C_20T_20_3E_20_3E" id="r_TypeToSymbol_3C_20math_3A_3AVec3_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Vec3_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Vec3&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20math_3A_3AVec4_3C_20T_20_3E_20_3E" id="r_TypeToSymbol_3C_20math_3A_3AVec4_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Vec4_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Vec4&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20T_20_2A_20_3E" id="r_TypeToSymbol_3C_20T_20_2A_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01T_01_5_01_4.html">TypeToSymbol&lt; T * &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20T_5BS_5D_3E" id="r_TypeToSymbol_3C_20T_5BS_5D_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01T_0fS_0e_4.html">TypeToSymbol&lt; T[S]&gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20uint16_5Ft_20_3E" id="r_TypeToSymbol_3C_20uint16_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01uint16__t_01_4.html">TypeToSymbol&lt; uint16_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20uint32_5Ft_20_3E" id="r_TypeToSymbol_3C_20uint32_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01uint32__t_01_4.html">TypeToSymbol&lt; uint32_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20uint64_5Ft_20_3E" id="r_TypeToSymbol_3C_20uint64_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01uint64__t_01_4.html">TypeToSymbol&lt; uint64_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20uint8_5Ft_20_3E" id="r_TypeToSymbol_3C_20uint8_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01uint8__t_01_4.html">TypeToSymbol&lt; uint8_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20void_20_3E" id="r_TypeToSymbol_3C_20void_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01void_01_4.html">TypeToSymbol&lt; void &gt;</a></td></tr>
<tr class="memitem:Value" id="r_Value"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate representation wrapper for supported value types in AX as immutable instances.  <a href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeKernelBuffer" id="r_VolumeKernelBuffer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1VolumeKernelBuffer.html">VolumeKernelBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The second volume kernel, responsible for providing the core layer of SIMD optimisations by invoking this kernel across a range of values.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1VolumeKernelBuffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeKernelNode" id="r_VolumeKernelNode"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1VolumeKernelNode.html">VolumeKernelNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The third volume kernel, providing an agnostic way to modify a single tile value without passing through the buffer states. Note that this kernel is mainly utility and one of the value kernels should almost always be preferred.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1VolumeKernelNode.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeKernelValue" id="r_VolumeKernelValue"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1VolumeKernelValue.html">VolumeKernelValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The primary volume kernel. This function holds the generated body of AX programs.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1VolumeKernelValue.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8c409fca565988bc9bac850cfb3308bd" id="r_a8c409fca565988bc9bac850cfb3308bd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c409fca565988bc9bac850cfb3308bd">CodecNameMap</a> = std::map&lt;const std::string, const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Codec.html">Codec</a>*&gt;</td></tr>
<tr class="memitem:a03ba0b877b7f82b74884d3bb7f20b63f" id="r_a03ba0b877b7f82b74884d3bb7f20b63f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03ba0b877b7f82b74884d3bb7f20b63f">CodecTypeMap</a> = std::map&lt;const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a>, <a class="el" href="#a8c409fca565988bc9bac850cfb3308bd">CodecNameMap</a>&gt;</td></tr>
<tr class="memitem:afcf64452a12e459b18f2baf5f6ab8ac4" id="r_afcf64452a12e459b18f2baf5f6ab8ac4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcf64452a12e459b18f2baf5f6ab8ac4">Codecs</a> = std::vector&lt;const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Codec.html">Codec</a>*&gt;</td></tr>
<tr class="memitem:acc2e13670241c2002b01d5c4daeeaa51" id="r_acc2e13670241c2002b01d5c4daeeaa51"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:acc2e13670241c2002b01d5c4daeeaa51 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc2e13670241c2002b01d5c4daeeaa51">SmallArgumentVector</a> = llvm::SmallVector&lt;T, 3&gt;</td></tr>
<tr class="memdesc:acc2e13670241c2002b01d5c4daeeaa51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef a stack allocated array with malloc grow support for anything which is relatively small and bases its container size on the number of function arguments.  <br /></td></tr>
<tr class="memitem:a19491c62dae10fc5b97850b29231b0ef" id="r_a19491c62dae10fc5b97850b29231b0ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19491c62dae10fc5b97850b29231b0ef">V2D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 2&gt;</td></tr>
<tr class="memitem:adf19fc2ebfc31df1b136083c7051c524" id="r_adf19fc2ebfc31df1b136083c7051c524"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf19fc2ebfc31df1b136083c7051c524">V2F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 2&gt;</td></tr>
<tr class="memitem:ac39e79e84de78fa6188c1b812ef7c9c0" id="r_ac39e79e84de78fa6188c1b812ef7c9c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac39e79e84de78fa6188c1b812ef7c9c0">V2I</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;int32_t, 2&gt;</td></tr>
<tr class="memitem:afe076b1a292d8635a2e144ecb285be2c" id="r_afe076b1a292d8635a2e144ecb285be2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe076b1a292d8635a2e144ecb285be2c">V3D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 3&gt;</td></tr>
<tr class="memitem:a3a93313e37930c7ec565dc4f3eb36fd6" id="r_a3a93313e37930c7ec565dc4f3eb36fd6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a93313e37930c7ec565dc4f3eb36fd6">V3F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 3&gt;</td></tr>
<tr class="memitem:a7b46918e9d7dca7ca333e39d3a80f525" id="r_a7b46918e9d7dca7ca333e39d3a80f525"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b46918e9d7dca7ca333e39d3a80f525">V3I</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;int32_t, 3&gt;</td></tr>
<tr class="memitem:a96a5962a96d7ca3f39ad565d8fffd335" id="r_a96a5962a96d7ca3f39ad565d8fffd335"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96a5962a96d7ca3f39ad565d8fffd335">V4D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 4&gt;</td></tr>
<tr class="memitem:a5289743e2fa6d363751795a25ec6dd19" id="r_a5289743e2fa6d363751795a25ec6dd19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5289743e2fa6d363751795a25ec6dd19">V4F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 4&gt;</td></tr>
<tr class="memitem:a1da87a694970da5888f4db38a93c2ffb" id="r_a1da87a694970da5888f4db38a93c2ffb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1da87a694970da5888f4db38a93c2ffb">V4I</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;int32_t, 4&gt;</td></tr>
<tr class="memitem:a4b2463f1262305b6a40aface8a10d5ff" id="r_a4b2463f1262305b6a40aface8a10d5ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b2463f1262305b6a40aface8a10d5ff">M3D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 9&gt;</td></tr>
<tr class="memitem:aa54db21251983c9e341b3da7635e9766" id="r_aa54db21251983c9e341b3da7635e9766"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa54db21251983c9e341b3da7635e9766">M3F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 9&gt;</td></tr>
<tr class="memitem:a50d45a6bbe207f32a91d91d9a3f545bb" id="r_a50d45a6bbe207f32a91d91d9a3f545bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50d45a6bbe207f32a91d91d9a3f545bb">M4D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 16&gt;</td></tr>
<tr class="memitem:a013d7b6412643a11b959eb75b974ef6c" id="r_a013d7b6412643a11b959eb75b974ef6c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a013d7b6412643a11b959eb75b974ef6c">M4F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 16&gt;</td></tr>
<tr class="memitem:a7c96829104e9f5004d71306c0a6b235b" id="r_a7c96829104e9f5004d71306c0a6b235b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c96829104e9f5004d71306c0a6b235b">CastFunction</a></td></tr>
<tr class="memitem:ab32b2155b53b74b41ba82c7c41401aa7" id="r_ab32b2155b53b74b41ba82c7c41401aa7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab32b2155b53b74b41ba82c7c41401aa7">BinaryFunction</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af0a9ecf49ef90196b55a1d164d0d807f" id="r_af0a9ecf49ef90196b55a1d164d0d807f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> const <a class="el" href="#a03ba0b877b7f82b74884d3bb7f20b63f">CodecTypeMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0a9ecf49ef90196b55a1d164d0d807f">getCodecTypeMap</a> ()</td></tr>
<tr class="memdesc:af0a9ecf49ef90196b55a1d164d0d807f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global codec map.  <br /></td></tr>
<tr class="memitem:af15f0049b002c4028762f98104e69b5a" id="r_af15f0049b002c4028762f98104e69b5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Codec.html">Codec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af15f0049b002c4028762f98104e69b5a">getCodec</a> (const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a> type, const std::string &amp;name)</td></tr>
<tr class="memdesc:af15f0049b002c4028762f98104e69b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific codec. Returns a nullptr if no codec exists.  <br /></td></tr>
<tr class="memitem:a1421b6fbacb574a3645bb9eff6e5070d" id="r_a1421b6fbacb574a3645bb9eff6e5070d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> const <a class="el" href="#a8c409fca565988bc9bac850cfb3308bd">CodecNameMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1421b6fbacb574a3645bb9eff6e5070d">getTypeSupportedCodecs</a> (const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a> type)</td></tr>
<tr class="memdesc:a1421b6fbacb574a3645bb9eff6e5070d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific set of codecs which encode a given type. Returns a nullptr if no codec exists.  <br /></td></tr>
<tr class="memitem:a4a9ee9a0ec0a79d08c610b2d30d2c5d3" id="r_a4a9ee9a0ec0a79d08c610b2d30d2c5d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionRegistry.html#af87f2a1a2395918a71eed11c61f94fc8">FunctionRegistry::UniquePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a9ee9a0ec0a79d08c610b2d30d2c5d3">createDefaultRegistry</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *op=nullptr)</td></tr>
<tr class="memdesc:a4a9ee9a0ec0a79d08c610b2d30d2c5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a registry with the default set of registered functions including math functions, point functions and volume functions.  <br /></td></tr>
<tr class="memitem:af54a8471846646ade77358b73c749f73" id="r_af54a8471846646ade77358b73c749f73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af54a8471846646ade77358b73c749f73">insertStandardFunctions</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionRegistry.html">FunctionRegistry</a> &amp;reg, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *options=nullptr)</td></tr>
<tr class="memdesc:af54a8471846646ade77358b73c749f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a function registry with all available "standard" AX library function. This primarily consists of all mathematical ops on AX containers (scalars, vectors, matrices) and other stl built-ins.  <br /></td></tr>
<tr class="memitem:a632f40e928ae9c4558294751388ff0df" id="r_a632f40e928ae9c4558294751388ff0df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a632f40e928ae9c4558294751388ff0df">insertVDBPointFunctions</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionRegistry.html">FunctionRegistry</a> &amp;reg, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *options=nullptr)</td></tr>
<tr class="memdesc:a632f40e928ae9c4558294751388ff0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a function registry with all available OpenVDB Point AX library function.  <br /></td></tr>
<tr class="memitem:aae3e1398fcd7d4382d439d92302f0666" id="r_aae3e1398fcd7d4382d439d92302f0666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae3e1398fcd7d4382d439d92302f0666">insertVDBVolumeFunctions</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionRegistry.html">FunctionRegistry</a> &amp;reg, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *options=nullptr)</td></tr>
<tr class="memdesc:aae3e1398fcd7d4382d439d92302f0666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a function registry with all available OpenVDB Volume AX library function.  <br /></td></tr>
<tr class="memitem:a105446c95a7ce98ce3f73dfde0206226" id="r_a105446c95a7ce98ce3f73dfde0206226"><td class="memTemplParams" colspan="2">template&lt;typename SignatureT&gt; </td></tr>
<tr class="memitem:a105446c95a7ce98ce3f73dfde0206226 template"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a105446c95a7ce98ce3f73dfde0206226">llvmTypesFromSignature</a> (llvm::LLVMContext &amp;C, std::vector&lt; llvm::Type * &gt; *types=nullptr)</td></tr>
<tr class="memdesc:a105446c95a7ce98ce3f73dfde0206226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a vector of llvm types from a function signature declaration.  <br /></td></tr>
<tr class="memitem:a1eeceafcca5526a3fae05aa99c8580db" id="r_a1eeceafcca5526a3fae05aa99c8580db"><td class="memTemplParams" colspan="2">template&lt;typename SignatureT&gt; </td></tr>
<tr class="memitem:a1eeceafcca5526a3fae05aa99c8580db template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html">ArgInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eeceafcca5526a3fae05aa99c8580db">llvmArgTypesFromSignature</a> (llvm::LLVMContext &amp;C, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> *types=nullptr)</td></tr>
<tr class="memdesc:a1eeceafcca5526a3fae05aa99c8580db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a vector of ArgInfos from a function signature declaration.  <br /></td></tr>
<tr class="memitem:a9542678f89fe09c6cc12b93d2ed61208" id="r_a9542678f89fe09c6cc12b93d2ed61208"><td class="memTemplParams" colspan="2">template&lt;typename SignatureT&gt; </td></tr>
<tr class="memitem:a9542678f89fe09c6cc12b93d2ed61208 template"><td class="memItemLeft" align="right" valign="top">llvm::FunctionType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9542678f89fe09c6cc12b93d2ed61208">llvmFunctionTypeFromSignature</a> (llvm::LLVMContext &amp;C)</td></tr>
<tr class="memdesc:a9542678f89fe09c6cc12b93d2ed61208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an LLVM FunctionType from a function signature.  <br /></td></tr>
<tr class="memitem:aa1fdf8da42ec61c8bae2a73419879629" id="r_aa1fdf8da42ec61c8bae2a73419879629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1fdf8da42ec61c8bae2a73419879629">printSignature</a> (std::ostream &amp;os, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;types, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html">ArgInfo</a> &amp;returnType, const char *name=nullptr, const llvm::ArrayRef&lt; const char * &gt; &amp;names={}, const bool axTypes=false)</td></tr>
<tr class="memdesc:aa1fdf8da42ec61c8bae2a73419879629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a function signature to the provided ostream.  <br /></td></tr>
<tr class="memitem:a4ddb10635251f8f3b8988a1d9f9886bd" id="r_a4ddb10635251f8f3b8988a1d9f9886bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ddb10635251f8f3b8988a1d9f9886bd">printSignature</a> (std::ostream &amp;os, const std::vector&lt; llvm::Type * &gt; &amp;types, const llvm::Type *returnType, const char *name=nullptr, const std::vector&lt; const char * &gt; &amp;names={}, const bool axTypes=false)</td></tr>
<tr class="memitem:a6e071cb438c1c2f9e19984457c7867d5" id="r_a6e071cb438c1c2f9e19984457c7867d5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e071cb438c1c2f9e19984457c7867d5">ir_load</a> (llvm::IRBuilder&lt;&gt; &amp;B, llvm::Value *ptr, const char *<a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a>=&quot;&quot;)</td></tr>
<tr class="memitem:a06d250b8a226d7bc716078d3244308d6" id="r_a06d250b8a226d7bc716078d3244308d6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06d250b8a226d7bc716078d3244308d6">ir_gep</a> (llvm::IRBuilder&lt;&gt; &amp;B, llvm::Value *ptr, llvm::ArrayRef&lt; llvm::Value * &gt; IdxList, const char *<a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a>=&quot;&quot;)</td></tr>
<tr class="memitem:ae14fdea230fa1062a4d2a1a9f36b500b" id="r_ae14fdea230fa1062a4d2a1a9f36b500b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae14fdea230fa1062a4d2a1a9f36b500b">ir_constgep2_64</a> (llvm::IRBuilder&lt;&gt; &amp;B, llvm::Value *ptr, uint64_t Idx0, uint64_t Idx1, const char *<a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a>=&quot;&quot;)</td></tr>
<tr class="memitem:ac7f4818d23410060515a7db35b778496" id="r_ac7f4818d23410060515a7db35b778496"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7f4818d23410060515a7db35b778496">ir_constinboundsgep2_64</a> (llvm::IRBuilder&lt;&gt; &amp;B, llvm::Value *ptr, uint64_t Idx0, uint64_t Idx1, const char *<a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a>=&quot;&quot;)</td></tr>
<tr class="memitem:af7d1295dd0caef35dff8ca7fadd49fec" id="r_af7d1295dd0caef35dff8ca7fadd49fec"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7d1295dd0caef35dff8ca7fadd49fec">getBaseContainedType</a> (llvm::Type *const type)</td></tr>
<tr class="memdesc:af7d1295dd0caef35dff8ca7fadd49fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base llvm value which is being pointed to through any number of layered pointers.  <br /></td></tr>
<tr class="memitem:ab8371506c0853b404af6701903a0846c" id="r_ab8371506c0853b404af6701903a0846c"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8371506c0853b404af6701903a0846c">arrayCast</a> (llvm::Value *ptrToArray, llvm::Type *targetElementType, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:ab8371506c0853b404af6701903a0846c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts an array to another array of equal size but of a different element type. Both source and target array element types must be scalar types. The source array llvm <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> should be a pointer to the array to cast.  <br /></td></tr>
<tr class="memitem:a43d53f041562eebe216cd998aacca1bc" id="r_a43d53f041562eebe216cd998aacca1bc"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43d53f041562eebe216cd998aacca1bc">arrayIndexUnpack</a> (llvm::Value *ptrToArray, const int16_t index, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a43d53f041562eebe216cd998aacca1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a particular element of an array and return a pointer to that element The provided llvm <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is expected to be a pointer to an array.  <br /></td></tr>
<tr class="memitem:a8367fdea9ffc5a00c802b43fd9384c4d" id="r_a8367fdea9ffc5a00c802b43fd9384c4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8367fdea9ffc5a00c802b43fd9384c4d">arrayUnpack</a> (llvm::Value *ptrToArray, std::vector&lt; llvm::Value * &gt; &amp;values, llvm::IRBuilder&lt;&gt; &amp;builder, const bool loadElements=false)</td></tr>
<tr class="memdesc:a8367fdea9ffc5a00c802b43fd9384c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack an array type into llvm Values which represent all its elements The provided llvm <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is expected to be a pointer to an array If loadElements is true, values will store loaded llvm values instead of pointers to the array elements.  <br /></td></tr>
<tr class="memitem:a52c8a0835c5e7d4cc34bafd3d215ae6c" id="r_a52c8a0835c5e7d4cc34bafd3d215ae6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52c8a0835c5e7d4cc34bafd3d215ae6c">array3Unpack</a> (llvm::Value *ptrToArray, llvm::Value *&amp;value1, llvm::Value *&amp;value2, llvm::Value *&amp;value3, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a52c8a0835c5e7d4cc34bafd3d215ae6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack the first three elements of an array. The provided llvm <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is expected to be a pointer to an array.  <br /></td></tr>
<tr class="memitem:a616b251ff2138f5fd680c0c09b3ba268" id="r_a616b251ff2138f5fd680c0c09b3ba268"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a616b251ff2138f5fd680c0c09b3ba268">array3Pack</a> (llvm::Value *value1, llvm::Value *value2, llvm::Value *value3, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a616b251ff2138f5fd680c0c09b3ba268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack three values into a new array and return a pointer to the newly allocated array. If the values are of a mismatching type, the highets order type is uses, as defined by typePrecedence. All llvm values are expected to a be a loaded scalar type.  <br /></td></tr>
<tr class="memitem:aff3a0a55c4be188a0b19cdc729324d77" id="r_aff3a0a55c4be188a0b19cdc729324d77"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff3a0a55c4be188a0b19cdc729324d77">arrayPack</a> (llvm::Value *value, llvm::IRBuilder&lt;&gt; &amp;builder, const size_t size=3)</td></tr>
<tr class="memdesc:aff3a0a55c4be188a0b19cdc729324d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a loaded llvm scalar value into a new array of a specified size and return a pointer to the newly allocated array. Each element of the new array will have the value of the given scalar.  <br /></td></tr>
<tr class="memitem:a95396ba44c3ea25039cbfba9411ea853" id="r_a95396ba44c3ea25039cbfba9411ea853"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95396ba44c3ea25039cbfba9411ea853">arrayPack</a> (const std::vector&lt; llvm::Value * &gt; &amp;values, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a95396ba44c3ea25039cbfba9411ea853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a vector of loaded llvm scalar values into a new array of equal size and return a pointer to the newly allocated array.  <br /></td></tr>
<tr class="memitem:ac93f0a3579beb04642ba6b8835345592" id="r_ac93f0a3579beb04642ba6b8835345592"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac93f0a3579beb04642ba6b8835345592">arrayPackCast</a> (std::vector&lt; llvm::Value * &gt; &amp;values, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:ac93f0a3579beb04642ba6b8835345592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a vector of loaded llvm scalar values into a new array of equal size and return a pointer to the newly allocated array. arrayPackCast first checks all the contained types in values and casts all types to the highest order type present. All llvm values in values are expected to be loaded scalar types.  <br /></td></tr>
<tr class="memitem:a6ea6b1eaeb31e098fb2bfe2d983b3ddd" id="r_a6ea6b1eaeb31e098fb2bfe2d983b3ddd"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ea6b1eaeb31e098fb2bfe2d983b3ddd">scalarToMatrix</a> (llvm::Value *scalar, llvm::IRBuilder&lt;&gt; &amp;builder, const size_t dim=3)</td></tr>
<tr class="memitem:ab94bc16221864698424a5684650a542a" id="r_ab94bc16221864698424a5684650a542a"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ab94bc16221864698424a5684650a542a template"><td class="memItemLeft" align="right" valign="top">llvm::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab94bc16221864698424a5684650a542a">llvmConstant</a> (const T t, llvm::Type *type)</td></tr>
<tr class="memdesc:ab94bc16221864698424a5684650a542a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an llvm Constant holding a scalar value.  <br /></td></tr>
<tr class="memitem:a3945190d5cee87e97f0974cdeb1de327" id="r_a3945190d5cee87e97f0974cdeb1de327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> llvm::IntegerType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3945190d5cee87e97f0974cdeb1de327">llvmIntType</a> (const uint32_t size, llvm::LLVMContext &amp;C)</td></tr>
<tr class="memdesc:a3945190d5cee87e97f0974cdeb1de327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an llvm IntegerType given a requested size and context.  <br /></td></tr>
<tr class="memitem:a0f46c3f7251169a4271ec676eb1036f9" id="r_a0f46c3f7251169a4271ec676eb1036f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f46c3f7251169a4271ec676eb1036f9">llvmFloatType</a> (const uint32_t size, llvm::LLVMContext &amp;C)</td></tr>
<tr class="memdesc:a0f46c3f7251169a4271ec676eb1036f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an llvm floating point Type given a requested size and context.  <br /></td></tr>
<tr class="memitem:a83fc38a6be035a8e4b84f74502244180" id="r_a83fc38a6be035a8e4b84f74502244180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83fc38a6be035a8e4b84f74502244180">llvmTypeFromToken</a> (const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a> &amp;type, llvm::LLVMContext &amp;C)</td></tr>
<tr class="memdesc:a83fc38a6be035a8e4b84f74502244180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an llvm type representing a type defined by a string.  <br /></td></tr>
<tr class="memitem:a947af1e58ee346ee1388dfc9478cd582" id="r_a947af1e58ee346ee1388dfc9478cd582"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a947af1e58ee346ee1388dfc9478cd582">tokenFromLLVMType</a> (const llvm::Type *type)</td></tr>
<tr class="memdesc:a947af1e58ee346ee1388dfc9478cd582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a corresponding AX token which represents the given LLVM Type.  <br /></td></tr>
<tr class="memitem:a0827dadf5278f692acb4a08a07ddab5a" id="r_a0827dadf5278f692acb4a08a07ddab5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0827dadf5278f692acb4a08a07ddab5a">AssertOpaquePtrs</a> (llvm::Value *opaque, llvm::Type *type)</td></tr>
<tr class="memitem:a1efd215ef1704ac839b518224dbdb2db" id="r_a1efd215ef1704ac839b518224dbdb2db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1efd215ef1704ac839b518224dbdb2db">valuesToTypes</a> (const std::vector&lt; llvm::Value * &gt; &amp;values, std::vector&lt; llvm::Type * &gt; &amp;types)</td></tr>
<tr class="memdesc:a1efd215ef1704ac839b518224dbdb2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a vector of llvm Types from a vector of llvm values.  <br /></td></tr>
<tr class="memitem:a423038ff573156cc611eea42d310e833" id="r_a423038ff573156cc611eea42d310e833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a423038ff573156cc611eea42d310e833">llvmTypeToString</a> (const llvm::Type *const type, std::string &amp;str)</td></tr>
<tr class="memdesc:a423038ff573156cc611eea42d310e833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints an llvm type to a std string.  <br /></td></tr>
<tr class="memitem:a0e5a0a3df16a21d529f6a831075910ae" id="r_a0e5a0a3df16a21d529f6a831075910ae"><td class="memTemplParams" colspan="2">template&lt;typename ValueT&gt; </td></tr>
<tr class="memitem:a0e5a0a3df16a21d529f6a831075910ae template"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e5a0a3df16a21d529f6a831075910ae">llvmPointerFromAddress</a> (const ValueT *const &amp;ptr, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a0e5a0a3df16a21d529f6a831075910ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an llvm value representing a pointer to the provided ptr builtin ValueT.  <br /></td></tr>
<tr class="memitem:a3d4cff3f7a2fa47ecffbf69657761aa9" id="r_a3d4cff3f7a2fa47ecffbf69657761aa9"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d4cff3f7a2fa47ecffbf69657761aa9">insertStaticAlloca</a> (llvm::IRBuilder&lt;&gt; &amp;B, llvm::Type *type, llvm::Value *size=nullptr)</td></tr>
<tr class="memdesc:a3d4cff3f7a2fa47ecffbf69657761aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a stack allocation at the beginning of the current function of the provided type and size. The IRBuilder's insertion point must be set to a BasicBlock with a valid <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a> parent.  <br /></td></tr>
<tr class="memitem:a95f4653d4218684469474275c042552d" id="r_a95f4653d4218684469474275c042552d"><td class="memItemLeft" align="right" valign="top">llvm::Argument *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95f4653d4218684469474275c042552d">extractArgument</a> (llvm::Function *F, const size_t idx)</td></tr>
<tr class="memitem:a93413fe331f9ba8703b3c77ef3eb3604" id="r_a93413fe331f9ba8703b3c77ef3eb3604"><td class="memItemLeft" align="right" valign="top">llvm::Argument *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93413fe331f9ba8703b3c77ef3eb3604">extractArgument</a> (llvm::Function *F, const std::string &amp;name)</td></tr>
<tr class="memitem:ab8ecdddc340b394a1984ae5a80e4f571" id="r_ab8ecdddc340b394a1984ae5a80e4f571"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8ecdddc340b394a1984ae5a80e4f571">typePrecedence</a> (llvm::Type *const typeA, llvm::Type *const typeB)</td></tr>
<tr class="memdesc:ab8ecdddc340b394a1984ae5a80e4f571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest order type from two LLVM Scalar types.  <br /></td></tr>
<tr class="memitem:afa1e921eaeb658bc90a09c4bd8549e38" id="r_afa1e921eaeb658bc90a09c4bd8549e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7c96829104e9f5004d71306c0a6b235b">CastFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa1e921eaeb658bc90a09c4bd8549e38">llvmArithmeticConversion</a> (const llvm::Type *const sourceType, const llvm::Type *const targetType, const std::string &amp;twine=&quot;&quot;)</td></tr>
<tr class="memdesc:afa1e921eaeb658bc90a09c4bd8549e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="#a7c96829104e9f5004d71306c0a6b235b">CastFunction</a> which represents the corresponding instruction to convert a source llvm Type to a target llvm Type. If the conversion is unsupported, throws an error.  <br /></td></tr>
<tr class="memitem:aa9685db14520bd9c9f5156cbf5cb2d44" id="r_aa9685db14520bd9c9f5156cbf5cb2d44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab32b2155b53b74b41ba82c7c41401aa7">BinaryFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9685db14520bd9c9f5156cbf5cb2d44">llvmBinaryConversion</a> (const llvm::Type *const type, const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">ast::tokens::OperatorToken</a> &amp;token, const std::string &amp;twine=&quot;&quot;)</td></tr>
<tr class="memdesc:aa9685db14520bd9c9f5156cbf5cb2d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="#ab32b2155b53b74b41ba82c7c41401aa7">BinaryFunction</a> representing the corresponding instruction to perform on two scalar values, relative to a provided operator token. Note that not all operations are supported on floating point types! If the token is not supported, or the llvm type is not a scalar type, throws an error.  <br /></td></tr>
<tr class="memitem:a44714a47e796030ef73e0982944016a5" id="r_a44714a47e796030ef73e0982944016a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44714a47e796030ef73e0982944016a5">isValidCast</a> (llvm::Type *from, llvm::Type *to)</td></tr>
<tr class="memdesc:a44714a47e796030ef73e0982944016a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the llvm Type 'from' can be safely cast to the llvm Type 'to'.  <br /></td></tr>
<tr class="memitem:a20bb9ae4a63f5ba45c6cecce35bb2adc" id="r_a20bb9ae4a63f5ba45c6cecce35bb2adc"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20bb9ae4a63f5ba45c6cecce35bb2adc">arithmeticConversion</a> (llvm::Value *value, llvm::Type *targetType, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a20bb9ae4a63f5ba45c6cecce35bb2adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a scalar llvm <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> to a target scalar llvm Type. Returns the cast scalar value of type targetType.  <br /></td></tr>
<tr class="memitem:aab41ca2854bc02af9a39c4293e8e2f63" id="r_aab41ca2854bc02af9a39c4293e8e2f63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab41ca2854bc02af9a39c4293e8e2f63">arithmeticConversion</a> (std::vector&lt; llvm::Value * &gt; &amp;values, llvm::Type *targetElementType, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:aab41ca2854bc02af9a39c4293e8e2f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of loaded llvm scalar values of the same type to a target scalar type. Each value is converted individually and the loaded result stored in the same location within values.  <br /></td></tr>
<tr class="memitem:aee5785a9c525d15caa558abda700f824" id="r_aee5785a9c525d15caa558abda700f824"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee5785a9c525d15caa558abda700f824">arithmeticConversion</a> (std::vector&lt; llvm::Value * &gt; &amp;values, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:aee5785a9c525d15caa558abda700f824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of loaded llvm scalar values to the highest precision type stored amongst them. Any values which are not scalar types are ignored.  <br /></td></tr>
<tr class="memitem:ab588dca12090ce30096157c631a2f625" id="r_ab588dca12090ce30096157c631a2f625"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab588dca12090ce30096157c631a2f625">arithmeticConversion</a> (llvm::Value *&amp;valueA, llvm::Value *&amp;valueB, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:ab588dca12090ce30096157c631a2f625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses the highest order llvm Type as defined by typePrecedence from either of the two incoming values and casts the other value to the choosen type if it is not already. The types of valueA and valueB are guaranteed to match. Both values must be scalar LLVM types.  <br /></td></tr>
<tr class="memitem:ae6862cd8ee104f11bcfc89ad30e3d84e" id="r_ae6862cd8ee104f11bcfc89ad30e3d84e"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6862cd8ee104f11bcfc89ad30e3d84e">boolComparison</a> (llvm::Value *value, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:ae6862cd8ee104f11bcfc89ad30e3d84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a C style boolean comparison from a given scalar LLVM value.  <br /></td></tr>
<tr class="memitem:a4308d3560569fc5d6fb0d6434b19e73c" id="r_a4308d3560569fc5d6fb0d6434b19e73c"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4308d3560569fc5d6fb0d6434b19e73c">binaryOperator</a> (llvm::Value *lhs, llvm::Value *rhs, const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">ast::tokens::OperatorToken</a> &amp;token, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ab32b2155b53b74b41ba82c7c41401aa7" name="ab32b2155b53b74b41ba82c7c41401aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32b2155b53b74b41ba82c7c41401aa7">&#9670;&#160;</a></span>BinaryFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab32b2155b53b74b41ba82c7c41401aa7">BinaryFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;llvm::Value*</div>
<div class="line">    (llvm::IRBuilder&lt;&gt;&amp;, llvm::Value*, llvm::Value*)&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c96829104e9f5004d71306c0a6b235b" name="a7c96829104e9f5004d71306c0a6b235b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c96829104e9f5004d71306c0a6b235b">&#9670;&#160;</a></span>CastFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7c96829104e9f5004d71306c0a6b235b">CastFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;llvm::Value*</div>
<div class="line">    (llvm::IRBuilder&lt;&gt;&amp;, llvm::Value*, llvm::Type*)&gt;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a> definitions for some types returned from automatic token to llvm IR operations. See llvmArithmeticConversion and llvmBianryConversion </dd></dl>

</div>
</div>
<a id="a8c409fca565988bc9bac850cfb3308bd" name="a8c409fca565988bc9bac850cfb3308bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c409fca565988bc9bac850cfb3308bd">&#9670;&#160;</a></span>CodecNameMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8c409fca565988bc9bac850cfb3308bd">CodecNameMap</a> = std::map&lt;const std::string, const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Codec.html">Codec</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afcf64452a12e459b18f2baf5f6ab8ac4" name="afcf64452a12e459b18f2baf5f6ab8ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf64452a12e459b18f2baf5f6ab8ac4">&#9670;&#160;</a></span>Codecs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afcf64452a12e459b18f2baf5f6ab8ac4">Codecs</a> = std::vector&lt;const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Codec.html">Codec</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03ba0b877b7f82b74884d3bb7f20b63f" name="a03ba0b877b7f82b74884d3bb7f20b63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ba0b877b7f82b74884d3bb7f20b63f">&#9670;&#160;</a></span>CodecTypeMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a03ba0b877b7f82b74884d3bb7f20b63f">CodecTypeMap</a> = std::map&lt;const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a>, <a class="el" href="#a8c409fca565988bc9bac850cfb3308bd">CodecNameMap</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b2463f1262305b6a40aface8a10d5ff" name="a4b2463f1262305b6a40aface8a10d5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2463f1262305b6a40aface8a10d5ff">&#9670;&#160;</a></span>M3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4b2463f1262305b6a40aface8a10d5ff">M3D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 9&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa54db21251983c9e341b3da7635e9766" name="aa54db21251983c9e341b3da7635e9766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54db21251983c9e341b3da7635e9766">&#9670;&#160;</a></span>M3F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa54db21251983c9e341b3da7635e9766">M3F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 9&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50d45a6bbe207f32a91d91d9a3f545bb" name="a50d45a6bbe207f32a91d91d9a3f545bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d45a6bbe207f32a91d91d9a3f545bb">&#9670;&#160;</a></span>M4D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a50d45a6bbe207f32a91d91d9a3f545bb">M4D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 16&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a013d7b6412643a11b959eb75b974ef6c" name="a013d7b6412643a11b959eb75b974ef6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013d7b6412643a11b959eb75b974ef6c">&#9670;&#160;</a></span>M4F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a013d7b6412643a11b959eb75b974ef6c">M4F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 16&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc2e13670241c2002b01d5c4daeeaa51" name="acc2e13670241c2002b01d5c4daeeaa51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2e13670241c2002b01d5c4daeeaa51">&#9670;&#160;</a></span>SmallArgumentVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acc2e13670241c2002b01d5c4daeeaa51">SmallArgumentVector</a> = llvm::SmallVector&lt;T, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef a stack allocated array with malloc grow support for anything which is relatively small and bases its container size on the number of function arguments. </p>
<dl class="section note"><dt>Note</dt><dd>LLVM computes N as 3 (currently) for <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> types, but we explicitly set this as this is a well-motivates choice for average/median amount of function arguments in builtin AX functions. </dd></dl>

</div>
</div>
<a id="a19491c62dae10fc5b97850b29231b0ef" name="a19491c62dae10fc5b97850b29231b0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19491c62dae10fc5b97850b29231b0ef">&#9670;&#160;</a></span>V2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a19491c62dae10fc5b97850b29231b0ef">V2D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf19fc2ebfc31df1b136083c7051c524" name="adf19fc2ebfc31df1b136083c7051c524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf19fc2ebfc31df1b136083c7051c524">&#9670;&#160;</a></span>V2F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#adf19fc2ebfc31df1b136083c7051c524">V2F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac39e79e84de78fa6188c1b812ef7c9c0" name="ac39e79e84de78fa6188c1b812ef7c9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39e79e84de78fa6188c1b812ef7c9c0">&#9670;&#160;</a></span>V2I</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac39e79e84de78fa6188c1b812ef7c9c0">V2I</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;int32_t, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe076b1a292d8635a2e144ecb285be2c" name="afe076b1a292d8635a2e144ecb285be2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe076b1a292d8635a2e144ecb285be2c">&#9670;&#160;</a></span>V3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afe076b1a292d8635a2e144ecb285be2c">V3D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a93313e37930c7ec565dc4f3eb36fd6" name="a3a93313e37930c7ec565dc4f3eb36fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a93313e37930c7ec565dc4f3eb36fd6">&#9670;&#160;</a></span>V3F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3a93313e37930c7ec565dc4f3eb36fd6">V3F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b46918e9d7dca7ca333e39d3a80f525" name="a7b46918e9d7dca7ca333e39d3a80f525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b46918e9d7dca7ca333e39d3a80f525">&#9670;&#160;</a></span>V3I</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7b46918e9d7dca7ca333e39d3a80f525">V3I</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;int32_t, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96a5962a96d7ca3f39ad565d8fffd335" name="a96a5962a96d7ca3f39ad565d8fffd335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a5962a96d7ca3f39ad565d8fffd335">&#9670;&#160;</a></span>V4D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a96a5962a96d7ca3f39ad565d8fffd335">V4D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5289743e2fa6d363751795a25ec6dd19" name="a5289743e2fa6d363751795a25ec6dd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5289743e2fa6d363751795a25ec6dd19">&#9670;&#160;</a></span>V4F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5289743e2fa6d363751795a25ec6dd19">V4F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1da87a694970da5888f4db38a93c2ffb" name="a1da87a694970da5888f4db38a93c2ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da87a694970da5888f4db38a93c2ffb">&#9670;&#160;</a></span>V4I</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1da87a694970da5888f4db38a93c2ffb">V4I</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;int32_t, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ab588dca12090ce30096157c631a2f625" name="ab588dca12090ce30096157c631a2f625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab588dca12090ce30096157c631a2f625">&#9670;&#160;</a></span>arithmeticConversion() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void arithmeticConversion </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&amp;</td>          <td class="paramname"><span class="paramname"><em>valueA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&amp;</td>          <td class="paramname"><span class="paramname"><em>valueB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chooses the highest order llvm Type as defined by typePrecedence from either of the two incoming values and casts the other value to the choosen type if it is not already. The types of valueA and valueB are guaranteed to match. Both values must be scalar LLVM types. </p>
<dl class="section warning"><dt>Warning</dt><dd>This assumes any integer types are signed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valueA</td><td>The first llvm value </td></tr>
    <tr><td class="paramname">valueB</td><td>The second llvm value </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20bb9ae4a63f5ba45c6cecce35bb2adc" name="a20bb9ae4a63f5ba45c6cecce35bb2adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20bb9ae4a63f5ba45c6cecce35bb2adc">&#9670;&#160;</a></span>arithmeticConversion() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * arithmeticConversion </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>targetType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a scalar llvm <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> to a target scalar llvm Type. Returns the cast scalar value of type targetType. </p>
<dl class="section warning"><dt>Warning</dt><dd>This assumes any integer types are signed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A llvm scalar value to convert </td></tr>
    <tr><td class="paramname">targetType</td><td>The target llvm scalar type to convert to </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee5785a9c525d15caa558abda700f824" name="aee5785a9c525d15caa558abda700f824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5785a9c525d15caa558abda700f824">&#9670;&#160;</a></span>arithmeticConversion() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void arithmeticConversion </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a vector of loaded llvm scalar values to the highest precision type stored amongst them. Any values which are not scalar types are ignored. </p>
<dl class="section warning"><dt>Warning</dt><dd>This assumes any integer types are signed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of llvm scalar values to convert </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab41ca2854bc02af9a39c4293e8e2f63" name="aab41ca2854bc02af9a39c4293e8e2f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab41ca2854bc02af9a39c4293e8e2f63">&#9670;&#160;</a></span>arithmeticConversion() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void arithmeticConversion </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>targetElementType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a vector of loaded llvm scalar values of the same type to a target scalar type. Each value is converted individually and the loaded result stored in the same location within values. </p>
<dl class="section warning"><dt>Warning</dt><dd>This assumes any integer types are signed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of llvm scalar values to convert </td></tr>
    <tr><td class="paramname">targetElementType</td><td>The target llvm scalar type to convert each value of the input vector </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a616b251ff2138f5fd680c0c09b3ba268" name="a616b251ff2138f5fd680c0c09b3ba268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616b251ff2138f5fd680c0c09b3ba268">&#9670;&#160;</a></span>array3Pack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * array3Pack </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>value1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>value2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>value3</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack three values into a new array and return a pointer to the newly allocated array. If the values are of a mismatching type, the highets order type is uses, as defined by typePrecedence. All llvm values are expected to a be a loaded scalar type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value1</td><td>The first array value </td></tr>
    <tr><td class="paramname">value2</td><td>The second array value </td></tr>
    <tr><td class="paramname">value3</td><td>The third array value </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a52c8a0835c5e7d4cc34bafd3d215ae6c" name="a52c8a0835c5e7d4cc34bafd3d215ae6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c8a0835c5e7d4cc34bafd3d215ae6c">&#9670;&#160;</a></span>array3Unpack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void array3Unpack </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>ptrToArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&amp;</td>          <td class="paramname"><span class="paramname"><em>value1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&amp;</td>          <td class="paramname"><span class="paramname"><em>value2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&amp;</td>          <td class="paramname"><span class="paramname"><em>value3</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack the first three elements of an array. The provided llvm <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is expected to be a pointer to an array. </p>
<dl class="section note"><dt>Note</dt><dd>The elements are note loaded</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrToArray</td><td>A llvm value which is a pointer to a llvm array </td></tr>
    <tr><td class="paramname">value1</td><td>The first array value </td></tr>
    <tr><td class="paramname">value2</td><td>The second array value </td></tr>
    <tr><td class="paramname">value3</td><td>The third array value </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="ab8371506c0853b404af6701903a0846c" name="ab8371506c0853b404af6701903a0846c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8371506c0853b404af6701903a0846c">&#9670;&#160;</a></span>arrayCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * arrayCast </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>ptrToArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>targetElementType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts an array to another array of equal size but of a different element type. Both source and target array element types must be scalar types. The source array llvm <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> should be a pointer to the array to cast. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrToArray</td><td>A llvm value which is a pointer to a llvm array </td></tr>
    <tr><td class="paramname">targetElementType</td><td>The target llvm scalar type to convert each element of the input array </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a43d53f041562eebe216cd998aacca1bc" name="a43d53f041562eebe216cd998aacca1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d53f041562eebe216cd998aacca1bc">&#9670;&#160;</a></span>arrayIndexUnpack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * arrayIndexUnpack </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>ptrToArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a particular element of an array and return a pointer to that element The provided llvm <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is expected to be a pointer to an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrToArray</td><td>A llvm value which is a pointer to a llvm array </td></tr>
    <tr><td class="paramname">index</td><td>The index at which to access the array </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a95396ba44c3ea25039cbfba9411ea853" name="a95396ba44c3ea25039cbfba9411ea853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95396ba44c3ea25039cbfba9411ea853">&#9670;&#160;</a></span>arrayPack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * arrayPack </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a vector of loaded llvm scalar values into a new array of equal size and return a pointer to the newly allocated array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of loaded llvm scalar values to pack </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="aff3a0a55c4be188a0b19cdc729324d77" name="aff3a0a55c4be188a0b19cdc729324d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3a0a55c4be188a0b19cdc729324d77">&#9670;&#160;</a></span>arrayPack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * arrayPack </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a loaded llvm scalar value into a new array of a specified size and return a pointer to the newly allocated array. Each element of the new array will have the value of the given scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The uniform scalar llvm value to pack into the array </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
    <tr><td class="paramname">size</td><td>The size of the newly allocated array </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="ac93f0a3579beb04642ba6b8835345592" name="ac93f0a3579beb04642ba6b8835345592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93f0a3579beb04642ba6b8835345592">&#9670;&#160;</a></span>arrayPackCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * arrayPackCast </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a vector of loaded llvm scalar values into a new array of equal size and return a pointer to the newly allocated array. arrayPackCast first checks all the contained types in values and casts all types to the highest order type present. All llvm values in values are expected to be loaded scalar types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of loaded llvm scalar values to pack </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a8367fdea9ffc5a00c802b43fd9384c4d" name="a8367fdea9ffc5a00c802b43fd9384c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8367fdea9ffc5a00c802b43fd9384c4d">&#9670;&#160;</a></span>arrayUnpack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void arrayUnpack </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>ptrToArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>loadElements</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack an array type into llvm Values which represent all its elements The provided llvm <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is expected to be a pointer to an array If loadElements is true, values will store loaded llvm values instead of pointers to the array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrToArray</td><td>A llvm value which is a pointer to a llvm array </td></tr>
    <tr><td class="paramname">values</td><td>A vector of llvm values where to store the array elements </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
    <tr><td class="paramname">loadElements</td><td>Whether or not to load each array element into a register </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a0827dadf5278f692acb4a08a07ddab5a" name="a0827dadf5278f692acb4a08a07ddab5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0827dadf5278f692acb4a08a07ddab5a">&#9670;&#160;</a></span>AssertOpaquePtrs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AssertOpaquePtrs </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>opaque</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4308d3560569fc5d6fb0d6434b19e73c" name="a4308d3560569fc5d6fb0d6434b19e73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4308d3560569fc5d6fb0d6434b19e73c">&#9670;&#160;</a></span>binaryOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * binaryOperator </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">ast::tokens::OperatorToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@ brief Performs a binary operation on two loaded llvm scalar values of the same type. The type of operation performed is defined by the token (see the list of supported tokens in <a class="el" href="Tokens_8h.html" title="Various function and operator tokens used throughout the AST and code generation.">ast/Tokens.h</a>. Returns a loaded llvm scalar result</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side value of the binary operation </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side value of the binary operation </td></tr>
    <tr><td class="paramname">token</td><td>The token representing the binary operation to perform </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6862cd8ee104f11bcfc89ad30e3d84e" name="ae6862cd8ee104f11bcfc89ad30e3d84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6862cd8ee104f11bcfc89ad30e3d84e">&#9670;&#160;</a></span>boolComparison()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * boolComparison </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a C style boolean comparison from a given scalar LLVM value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar llvm value to convert to a boolean </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a9ee9a0ec0a79d08c610b2d30d2c5d3" name="a4a9ee9a0ec0a79d08c610b2d30d2c5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9ee9a0ec0a79d08c610b2d30d2c5d3">&#9670;&#160;</a></span>createDefaultRegistry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionRegistry.html#af87f2a1a2395918a71eed11c61f94fc8">FunctionRegistry::UniquePtr</a> createDefaultRegistry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a registry with the default set of registered functions including math functions, point functions and volume functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The current function options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95f4653d4218684469474275c042552d" name="a95f4653d4218684469474275c042552d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f4653d4218684469474275c042552d">&#9670;&#160;</a></span>extractArgument() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Argument * extractArgument </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *</td>          <td class="paramname"><span class="paramname"><em>F</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93413fe331f9ba8703b3c77ef3eb3604" name="a93413fe331f9ba8703b3c77ef3eb3604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93413fe331f9ba8703b3c77ef3eb3604">&#9670;&#160;</a></span>extractArgument() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Argument * extractArgument </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *</td>          <td class="paramname"><span class="paramname"><em>F</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7d1295dd0caef35dff8ca7fadd49fec" name="af7d1295dd0caef35dff8ca7fadd49fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d1295dd0caef35dff8ca7fadd49fec">&#9670;&#160;</a></span>getBaseContainedType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * getBaseContainedType </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *const</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the base llvm value which is being pointed to through any number of layered pointers. </p>
<dl class="section note"><dt>Note</dt><dd>This function does not check for cyclical pointer dependencies</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>A llvm pointer type to traverse </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="af15f0049b002c4028762f98104e69b5a" name="af15f0049b002c4028762f98104e69b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15f0049b002c4028762f98104e69b5a">&#9670;&#160;</a></span>getCodec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Codec.html">Codec</a> * getCodec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific codec. Returns a nullptr if no codec exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type the codec encodes </td></tr>
    <tr><td class="paramname">name</td><td>The name of the codec </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0a9ecf49ef90196b55a1d164d0d807f" name="af0a9ecf49ef90196b55a1d164d0d807f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a9ecf49ef90196b55a1d164d0d807f">&#9670;&#160;</a></span>getCodecTypeMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> const <a class="el" href="#a03ba0b877b7f82b74884d3bb7f20b63f">CodecTypeMap</a> &amp; getCodecTypeMap </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the global codec map. </p>

</div>
</div>
<a id="a1421b6fbacb574a3645bb9eff6e5070d" name="a1421b6fbacb574a3645bb9eff6e5070d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1421b6fbacb574a3645bb9eff6e5070d">&#9670;&#160;</a></span>getTypeSupportedCodecs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> const <a class="el" href="#a8c409fca565988bc9bac850cfb3308bd">CodecNameMap</a> * getTypeSupportedCodecs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific set of codecs which encode a given type. Returns a nullptr if no codec exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type the codecs encode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af54a8471846646ade77358b73c749f73" name="af54a8471846646ade77358b73c749f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54a8471846646ade77358b73c749f73">&#9670;&#160;</a></span>insertStandardFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void insertStandardFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionRegistry.html">FunctionRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates a function registry with all available "standard" AX library function. This primarily consists of all mathematical ops on AX containers (scalars, vectors, matrices) and other stl built-ins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The function registry to populate </td></tr>
    <tr><td class="paramname">options</td><td>The current function options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d4cff3f7a2fa47ecffbf69657761aa9" name="a3d4cff3f7a2fa47ecffbf69657761aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4cff3f7a2fa47ecffbf69657761aa9">&#9670;&#160;</a></span>insertStaticAlloca()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * insertStaticAlloca </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a stack allocation at the beginning of the current function of the provided type and size. The IRBuilder's insertion point must be set to a BasicBlock with a valid <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a> parent. </p>
<dl class="section note"><dt>Note</dt><dd>If a size is provided, the size must not depend on any other instructions. If it does, invalid LLVM IR will bb generated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td>The IRBuilder </td></tr>
    <tr><td class="paramname">type</td><td>The type to allocate </td></tr>
    <tr><td class="paramname">size</td><td>Optional count of allocations. If nullptr, runs a single allocation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a632f40e928ae9c4558294751388ff0df" name="a632f40e928ae9c4558294751388ff0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632f40e928ae9c4558294751388ff0df">&#9670;&#160;</a></span>insertVDBPointFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void insertVDBPointFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionRegistry.html">FunctionRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates a function registry with all available OpenVDB Point AX library function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The function registry to populate </td></tr>
    <tr><td class="paramname">options</td><td>The current function options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae3e1398fcd7d4382d439d92302f0666" name="aae3e1398fcd7d4382d439d92302f0666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3e1398fcd7d4382d439d92302f0666">&#9670;&#160;</a></span>insertVDBVolumeFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void insertVDBVolumeFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionRegistry.html">FunctionRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates a function registry with all available OpenVDB Volume AX library function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The function registry to populate </td></tr>
    <tr><td class="paramname">options</td><td>The current function options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae14fdea230fa1062a4d2a1a9f36b500b" name="ae14fdea230fa1062a4d2a1a9f36b500b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14fdea230fa1062a4d2a1a9f36b500b">&#9670;&#160;</a></span>ir_constgep2_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto ir_constgep2_64 </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Idx0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Idx1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>Name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="ac7f4818d23410060515a7db35b778496" name="ac7f4818d23410060515a7db35b778496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f4818d23410060515a7db35b778496">&#9670;&#160;</a></span>ir_constinboundsgep2_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto ir_constinboundsgep2_64 </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Idx0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>Idx1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>Name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a06d250b8a226d7bc716078d3244308d6" name="a06d250b8a226d7bc716078d3244308d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d250b8a226d7bc716078d3244308d6">&#9670;&#160;</a></span>ir_gep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto ir_gep </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::ArrayRef&lt; llvm::Value * &gt;</td>          <td class="paramname"><span class="paramname"><em>IdxList</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>Name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a6e071cb438c1c2f9e19984457c7867d5" name="a6e071cb438c1c2f9e19984457c7867d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e071cb438c1c2f9e19984457c7867d5">&#9670;&#160;</a></span>ir_load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto ir_load </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>Name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a44714a47e796030ef73e0982944016a5" name="a44714a47e796030ef73e0982944016a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44714a47e796030ef73e0982944016a5">&#9670;&#160;</a></span>isValidCast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValidCast </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the llvm Type 'from' can be safely cast to the llvm Type 'to'. </p>

</div>
</div>
<a id="a1eeceafcca5526a3fae05aa99c8580db" name="a1eeceafcca5526a3fae05aa99c8580db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eeceafcca5526a3fae05aa99c8580db">&#9670;&#160;</a></span>llvmArgTypesFromSignature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html">ArgInfo</a> llvmArgTypesFromSignature </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> *</td>          <td class="paramname"><span class="paramname"><em>types</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a vector of ArgInfos from a function signature declaration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The llvm context </td></tr>
    <tr><td class="paramname">types</td><td>A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html" title="Container of ArgInfos. This class makes up part of the Function API for querying signature informatio...">ArgInfoVector</a> to populate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa1e921eaeb658bc90a09c4bd8549e38" name="afa1e921eaeb658bc90a09c4bd8549e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1e921eaeb658bc90a09c4bd8549e38">&#9670;&#160;</a></span>llvmArithmeticConversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7c96829104e9f5004d71306c0a6b235b">CastFunction</a> llvmArithmeticConversion </td>
          <td>(</td>
          <td class="paramtype">const llvm::Type *const</td>          <td class="paramname"><span class="paramname"><em>sourceType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Type *const</td>          <td class="paramname"><span class="paramname"><em>targetType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>twine</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="#a7c96829104e9f5004d71306c0a6b235b">CastFunction</a> which represents the corresponding instruction to convert a source llvm Type to a target llvm Type. If the conversion is unsupported, throws an error. </p>
<dl class="section warning"><dt>Warning</dt><dd>This assumes any integer types are signed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceType</td><td>The source type to cast </td></tr>
    <tr><td class="paramname">targetType</td><td>The target type to cast to </td></tr>
    <tr><td class="paramname">twine</td><td>An optional string description of the cast function. This can be used for for more verbose llvm information on IR compilation failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9685db14520bd9c9f5156cbf5cb2d44" name="aa9685db14520bd9c9f5156cbf5cb2d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9685db14520bd9c9f5156cbf5cb2d44">&#9670;&#160;</a></span>llvmBinaryConversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab32b2155b53b74b41ba82c7c41401aa7">BinaryFunction</a> llvmBinaryConversion </td>
          <td>(</td>
          <td class="paramtype">const llvm::Type *const</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">ast::tokens::OperatorToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>twine</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="#ab32b2155b53b74b41ba82c7c41401aa7">BinaryFunction</a> representing the corresponding instruction to perform on two scalar values, relative to a provided operator token. Note that not all operations are supported on floating point types! If the token is not supported, or the llvm type is not a scalar type, throws an error. </p>
<dl class="section note"><dt>Note</dt><dd>Various default arguments are bound to provide a simple function call signature. For floating point operations, this includes a null pointer to the optional metadata node. For integer operations, this includes disabling all overflow/rounding optimisations</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type defining the precision of the binary operation </td></tr>
    <tr><td class="paramname">token</td><td>The token used to create the relative binary operation </td></tr>
    <tr><td class="paramname">twine</td><td>An optional string description of the binary function. This can be used for for more verbose llvm information on IR compilation failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab94bc16221864698424a5684650a542a" name="ab94bc16221864698424a5684650a542a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94bc16221864698424a5684650a542a">&#9670;&#160;</a></span>llvmConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Constant * llvmConstant </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an llvm Constant holding a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The scalar constant </td></tr>
    <tr><td class="paramname">type</td><td>The LLVM type. Can differ from the type of t, in which case the value will be cast to the llvm type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f46c3f7251169a4271ec676eb1036f9" name="a0f46c3f7251169a4271ec676eb1036f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f46c3f7251169a4271ec676eb1036f9">&#9670;&#160;</a></span>llvmFloatType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> llvm::Type * llvmFloatType </td>
          <td>(</td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an llvm floating point Type given a requested size and context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the float to request, i.e. float - 32, double - 64 etc. </td></tr>
    <tr><td class="paramname">C</td><td>The LLVMContext to request the Type from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9542678f89fe09c6cc12b93d2ed61208" name="a9542678f89fe09c6cc12b93d2ed61208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9542678f89fe09c6cc12b93d2ed61208">&#9670;&#160;</a></span>llvmFunctionTypeFromSignature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::FunctionType * llvmFunctionTypeFromSignature </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate an LLVM FunctionType from a function signature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The llvm context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3945190d5cee87e97f0974cdeb1de327" name="a3945190d5cee87e97f0974cdeb1de327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3945190d5cee87e97f0974cdeb1de327">&#9670;&#160;</a></span>llvmIntType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> llvm::IntegerType * llvmIntType </td>
          <td>(</td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an llvm IntegerType given a requested size and context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of bits of the integer type </td></tr>
    <tr><td class="paramname">C</td><td>The LLVMContext to request the Type from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e5a0a3df16a21d529f6a831075910ae" name="a0e5a0a3df16a21d529f6a831075910ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5a0a3df16a21d529f6a831075910ae">&#9670;&#160;</a></span>llvmPointerFromAddress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * llvmPointerFromAddress </td>
          <td>(</td>
          <td class="paramtype">const ValueT *const &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an llvm value representing a pointer to the provided ptr builtin ValueT. </p>
<dl class="section note"><dt>Note</dt><dd>This is probably not a suitable solution for anything other than POD types and should be used with caution.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to a type of ValueT whose address will be computed and returned </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83fc38a6be035a8e4b84f74502244180" name="a83fc38a6be035a8e4b84f74502244180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fc38a6be035a8e4b84f74502244180">&#9670;&#160;</a></span>llvmTypeFromToken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> llvm::Type * llvmTypeFromToken </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an llvm type representing a type defined by a string. </p>
<dl class="section note"><dt>Note</dt><dd>For string types, this function returns the element type, not the object type! The llvm type representing a char block of memory is LLVMType&lt;char*&gt;::get(C); </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The AX token type </td></tr>
    <tr><td class="paramname">C</td><td>The LLVMContext to request the Type from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a105446c95a7ce98ce3f73dfde0206226" name="a105446c95a7ce98ce3f73dfde0206226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105446c95a7ce98ce3f73dfde0206226">&#9670;&#160;</a></span>llvmTypesFromSignature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * llvmTypesFromSignature </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; llvm::Type * &gt; *</td>          <td class="paramname"><span class="paramname"><em>types</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a vector of llvm types from a function signature declaration. </p>
<dl class="section warning"><dt>Warning</dt><dd>From LLVM 16 onwards, pointer argument type cannot be introspected</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The llvm context </td></tr>
    <tr><td class="paramname">types</td><td>A vector of types to populate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a423038ff573156cc611eea42d310e833" name="a423038ff573156cc611eea42d310e833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423038ff573156cc611eea42d310e833">&#9670;&#160;</a></span>llvmTypeToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llvmTypeToString </td>
          <td>(</td>
          <td class="paramtype">const llvm::Type *const</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints an llvm type to a std string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The llvm type to convert </td></tr>
    <tr><td class="paramname">str</td><td>The string to store the type info to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1fdf8da42ec61c8bae2a73419879629" name="aa1fdf8da42ec61c8bae2a73419879629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fdf8da42ec61c8bae2a73419879629">&#9670;&#160;</a></span>printSignature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void printSignature </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html">ArgInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>returnType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::ArrayRef&lt; const char * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>names</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>axTypes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a function signature to the provided ostream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The stream to print to </td></tr>
    <tr><td class="paramname">types</td><td>The function argument types </td></tr>
    <tr><td class="paramname">returnType</td><td>The return type of the function. Must not be a nullptr </td></tr>
    <tr><td class="paramname">name</td><td>The name of the function. If not provided, the return type neighbours the first parenthesis </td></tr>
    <tr><td class="paramname">names</td><td>Names of the function parameters. If a name is nullptr, it skipped </td></tr>
    <tr><td class="paramname">axTypes</td><td>Whether to try and convert the llvm::Types provided to AX types. If false, the llvm types are used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ddb10635251f8f3b8988a1d9f9886bd" name="a4ddb10635251f8f3b8988a1d9f9886bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddb10635251f8f3b8988a1d9f9886bd">&#9670;&#160;</a></span>printSignature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void printSignature </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; llvm::Type * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>returnType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const char * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>names</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>axTypes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated</a></b></dt><dd>"Switch to AX's internal ArgInfo types for LLVM 16 onwards" <br  />
 </dd></dl>

</div>
</div>
<a id="a6ea6b1eaeb31e098fb2bfe2d983b3ddd" name="a6ea6b1eaeb31e098fb2bfe2d983b3ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea6b1eaeb31e098fb2bfe2d983b3ddd">&#9670;&#160;</a></span>scalarToMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * scalarToMatrix </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a947af1e58ee346ee1388dfc9478cd582" name="a947af1e58ee346ee1388dfc9478cd582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947af1e58ee346ee1388dfc9478cd582">&#9670;&#160;</a></span>tokenFromLLVMType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a> tokenFromLLVMType </td>
          <td>(</td>
          <td class="paramtype">const llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a corresponding AX token which represents the given LLVM Type. </p>
<dl class="section note"><dt>Note</dt><dd>If the type does not exist in AX, <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7a6ce26a62afab55d7606ad4e92428b30c">ast::tokens::UNKNOWN</a> is returned. Must not be a nullptr. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>From LLVM 16+, the input type must not be a pointer type </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>a valid LLVM Type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8ecdddc340b394a1984ae5a80e4f571" name="ab8ecdddc340b394a1984ae5a80e4f571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ecdddc340b394a1984ae5a80e4f571">&#9670;&#160;</a></span>typePrecedence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * typePrecedence </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *const</td>          <td class="paramname"><span class="paramname"><em>typeA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *const</td>          <td class="paramname"><span class="paramname"><em>typeB</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest order type from two LLVM Scalar types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeA</td><td>The first scalar llvm type </td></tr>
    <tr><td class="paramname">typeB</td><td>The second scalar llvm type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1efd215ef1704ac839b518224dbdb2db" name="a1efd215ef1704ac839b518224dbdb2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efd215ef1704ac839b518224dbdb2db">&#9670;&#160;</a></span>valuesToTypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void valuesToTypes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; llvm::Type * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a vector of llvm Types from a vector of llvm values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of llvm values to retrieve types from </td></tr>
    <tr><td class="paramname">types</td><td>A vector of llvm types to populate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax.html">ax</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html">codegen</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
