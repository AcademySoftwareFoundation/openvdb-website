<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: OpenVDB Python</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('python.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">OpenVDB Python </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section describes the OpenVDB Python module and includes Python code snippets and some complete programs that illustrate how to perform common tasks. The Python module exposes most of the functionality of the C++ <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html">Grid</a> class, including I/O, metadata management, voxel access and iteration, but almost none of the many <a class="el" href="overview.html#secToolUtils">tools</a>. We expect to add support for tools in forthcoming releases.</p>
<p>The Python module supports a fixed set of grid types. If the symbol <code>PY_OPENVDB_WRAP_ALL_GRID_TYPES</code> is defined at compile time, most of the grid types declared in <a class="el" href="openvdb_8h.html">openvdb.h</a> are accessible in Python, otherwise only <b>FloatGrid</b>, <b>BoolGrid</b> and <b>Vec3SGrid</b> are accessible. To add support for grids with other value types or configurations, search for <code>PY_OPENVDB_WRAP_ALL_GRID_TYPES</code> in the module source code, update the code as appropriate and recompile the module. (It is possible that this process will be streamlined in the future with a plugin mechanism.) Note however that adding grid types can significantly increase the time and memory needed to compile the module and can significantly increase the size of the resulting executable. In addition, grids of custom types that are saved to <span class="tt">.vdb</span> files or pickled will not be readable by clients using the standard version of the module.</p>
<p>Also note that the <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1Tree.html">Tree</a> class is not exposed in Python. Much of its functionality is either available through the <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html">Grid</a> or is too low-level to be generally useful in Python. Although trees are not accessible in Python, they can of course be operated on indirectly. Of note are the grid methods <b>copy</b>, which returns a new grid that shares its tree with the original grid, <b>deepCopy</b>, which returns a new grid that owns its own tree, and <b>sharesWith</b>, which reports whether two grids share a tree.</p>
<h1 class="doxsection"><a class="anchor" id="sPyContents"></a>
Contents</h1>
<ul>
<li><a class="el" href="#sPyBasics">Getting started</a></li>
<li><a class="el" href="#sPyHandlingMetadata">Handling metadata</a></li>
<li><a class="el" href="#sPyAccessors">Voxel access</a></li>
<li><a class="el" href="#sPyIteration">Iteration</a></li>
<li><a class="el" href="#sPyNumPy">Working with NumPy arrays</a></li>
<li><a class="el" href="#sPyMeshConversion">Mesh conversion</a></li>
<li><a class="el" href="#sPyCppAPI">C++ glue routines</a></li>
</ul>
<h1 class="doxsection"><a class="anchor" id="sPyBasics"></a>
Getting started</h1>
<p>The following example is a complete program that illustrates some of the basic steps to create grids and write them to disk: </p><div class="fragment"><div class="line"><span class="keyword">import</span> pyopenvdb <span class="keyword">as</span> vdb</div>
<div class="line"> </div>
<div class="line"><span class="comment"># A grid comprises a sparse tree representation of voxel data,</span></div>
<div class="line"><span class="comment"># user-supplied metadata and a voxel space to world space transform,</span></div>
<div class="line"><span class="comment"># which defaults to the identity transform.</span></div>
<div class="line"><span class="comment"># A FloatGrid stores one single-precision floating point value per voxel.</span></div>
<div class="line"><span class="comment"># Other grid types include BoolGrid and Vec3SGrid.  The module-level</span></div>
<div class="line"><span class="comment"># attribute pyopenvdb.GridTypes gives the complete list.</span></div>
<div class="line">cube = vdb.FloatGrid()</div>
<div class="line">cube.fill(min=(100, 100, 100), max=(199, 199, 199), value=1.0)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Name the grid &quot;cube&quot;.</span></div>
<div class="line">cube.name = <span class="stringliteral">&#39;cube&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Populate another FloatGrid with a sparse, narrow-band level set</span></div>
<div class="line"><span class="comment"># representation of a sphere with radius 50 voxels, located at</span></div>
<div class="line"><span class="comment"># (1.5, 2, 3) in index space.</span></div>
<div class="line">sphere = vdb.createLevelSetSphere(radius=50, center=(1.5, 2, 3))</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Associate some metadata with the grid.</span></div>
<div class="line">sphere[<span class="stringliteral">&#39;radius&#39;</span>] = 50.0</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Associate a scaling transform with the grid that sets the voxel size</span></div>
<div class="line"><span class="comment"># to 0.5 units in world space.</span></div>
<div class="line">sphere.transform = vdb.createLinearTransform(voxelSize=0.5)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Name the grid &quot;sphere&quot;.</span></div>
<div class="line">sphere.name = <span class="stringliteral">&#39;sphere&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Write both grids to a VDB file.</span></div>
<div class="line">vdb.write(<span class="stringliteral">&#39;mygrids.vdb&#39;</span>, grids=[cube, sphere])</div>
</div><!-- fragment --><p>This example shows how to read grids from files, and some ways to modify grids: </p><div class="fragment"><div class="line"><span class="keyword">import</span> pyopenvdb <span class="keyword">as</span> vdb</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Read a .vdb file and return a list of grids populated with</span></div>
<div class="line"><span class="comment"># their metadata and transforms, but not their trees.</span></div>
<div class="line">filename = <span class="stringliteral">&#39;mygrids.vdb&#39;</span></div>
<div class="line">grids = vdb.readAllGridMetadata(filename)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Look for and read in a level-set grid that has certain metadata.</span></div>
<div class="line">sphere = <span class="keywordtype">None</span></div>
<div class="line"><span class="keywordflow">for</span> grid <span class="keywordflow">in</span> grids:</div>
<div class="line">    <span class="keywordflow">if</span> (grid.gridClass == vdb.GridClass.LEVEL_SET <span class="keywordflow">and</span> <span class="stringliteral">&#39;radius&#39;</span> <span class="keywordflow">in</span> grid</div>
<div class="line">        <span class="keywordflow">and</span> grid[<span class="stringliteral">&#39;radius&#39;</span>] &gt; 10.0):</div>
<div class="line">        sphere = vdb.read(filename, grid.name)</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        <span class="keywordflow">print</span> <span class="stringliteral">&#39;skipping grid&#39;</span>, grid.name</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> sphere:</div>
<div class="line">    <span class="comment"># Convert the level set sphere to a narrow-band fog volume, in which</span></div>
<div class="line">    <span class="comment"># interior voxels have value 1, exterior voxels have value 0, and</span></div>
<div class="line">    <span class="comment"># narrow-band voxels have values varying linearly from 0 to 1.</span></div>
<div class="line"> </div>
<div class="line">    outside = sphere.background</div>
<div class="line">    width = 2.0 * outside</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Visit and update all of the grid&#39;s active values, which correspond to</span></div>
<div class="line">    <span class="comment"># voxels in the narrow band.</span></div>
<div class="line">    <span class="keywordflow">for</span> iter <span class="keywordflow">in</span> sphere.iterOnValues():</div>
<div class="line">        dist = iter.value</div>
<div class="line">        iter.value = (outside - dist) / width</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Visit all of the grid&#39;s inactive tile and voxel values and update</span></div>
<div class="line">    <span class="comment"># the values that correspond to the interior region.</span></div>
<div class="line">    <span class="keywordflow">for</span> iter <span class="keywordflow">in</span> sphere.iterOffValues():</div>
<div class="line">        <span class="keywordflow">if</span> iter.value &lt; 0.0:</div>
<div class="line">            iter.value = 1.0</div>
<div class="line">            iter.active = <span class="keyword">False</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Set exterior voxels to 0.</span></div>
<div class="line">    sphere.background = 0.0</div>
<div class="line"> </div>
<div class="line">    sphere.gridClass = vdb.GridClass.FOG_VOLUME</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="sPyHandlingMetadata"></a>
Handling metadata</h1>
<p>Metadata of various types (string, bool, int, float, and 2- and 3-element sequences of ints or floats) can be attached both to individual grids and to files on disk, either by supplying a Python dictionary of (name,&#160;value) pairs or, in the case of grids, through a dictionary-like interface.</p>
<p>Add (name,&#160;value) metadata pairs to a grid as you would to a dictionary. A new value overwrites an existing value if the name matches an existing name. </p><div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">import</span> pyopenvdb <span class="keyword">as</span> vdb</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; grid = vdb.Vec3SGrid()</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; grid[<span class="stringliteral">&#39;vector&#39;</span>] = <span class="stringliteral">&#39;gradient&#39;</span></div>
<div class="line">&gt;&gt;&gt; grid[<span class="stringliteral">&#39;radius&#39;</span>] = 50.0</div>
<div class="line">&gt;&gt;&gt; grid[<span class="stringliteral">&#39;center&#39;</span>] = (10, 15, 10)</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; grid.metadata</div>
<div class="line">{<span class="stringliteral">&#39;vector&#39;</span>: <span class="stringliteral">&#39;gradient&#39;</span>, <span class="stringliteral">&#39;radius&#39;</span>: 50.0, <span class="stringliteral">&#39;center&#39;</span>: (10, 15, 10)}</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; grid[<span class="stringliteral">&#39;radius&#39;</span>]</div>
<div class="line">50.0</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; <span class="stringliteral">&#39;radius&#39;</span> <span class="keywordflow">in</span> grid, <span class="stringliteral">&#39;misc&#39;</span> <span class="keywordflow">in</span> grid</div>
<div class="line">(<span class="keyword">True</span>, <span class="keyword">False</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># OK to overwrite an existing value with a value of another type:</span></div>
<div class="line">&gt;&gt;&gt; grid[<span class="stringliteral">&#39;center&#39;</span>] = 0.0</div>
<div class="line"> </div>
<div class="line"><span class="comment"># A 4-element sequence is not a supported metadata value type:</span></div>
<div class="line">&gt;&gt;&gt; grid[<span class="stringliteral">&#39;center&#39;</span>] = (0, 0, 0, 0)</div>
<div class="line">  File <span class="stringliteral">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keywordflow">in</span> &lt;module&gt;</div>
<div class="line">TypeError: metadata value <span class="stringliteral">&quot;(0, 0, 0, 0)&quot;</span> of type tuple <span class="keywordflow">is</span> <span class="keywordflow">not</span> allowed</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Metadata names must be strings:</span></div>
<div class="line">&gt;&gt;&gt; grid[0] = (10.5, 15, 30)</div>
<div class="line">  File <span class="stringliteral">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keywordflow">in</span> &lt;module&gt;</div>
<div class="line">TypeError: expected str, found int <span class="keyword">as</span> argument 1 to __setitem__()</div>
</div><!-- fragment --><p> Alternatively, replace all or some of a grid&rsquo;s metadata by supplying a (name,&#160;value) dictionary: </p><div class="fragment"><div class="line">&gt;&gt;&gt; metadata = {</div>
<div class="line">...    <span class="stringliteral">&#39;vector&#39;</span>: <span class="stringliteral">&#39;gradient&#39;</span>,</div>
<div class="line">...    <span class="stringliteral">&#39;radius&#39;</span>: 50.0,</div>
<div class="line">...    <span class="stringliteral">&#39;center&#39;</span>: (10, 15, 10)</div>
<div class="line">... }</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Replace all of the grid&#39;s metadata.</span></div>
<div class="line">&gt;&gt;&gt; grid.metadata = metadata</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; metadata = {</div>
<div class="line">...     <span class="stringliteral">&#39;center&#39;</span>: [10.5, 15, 30],</div>
<div class="line">...     <span class="stringliteral">&#39;scale&#39;</span>: 3.14159</div>
<div class="line">... }</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Overwrite &quot;center&quot; and add &quot;scale&quot;:</span></div>
<div class="line">&gt;&gt;&gt; grid.updateMetadata(metadata)</div>
</div><!-- fragment --><p>Iterate over a grid&rsquo;s metadata as you would over a dictionary: </p><div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keywordflow">for</span> key <span class="keywordflow">in</span> grid:</div>
<div class="line">...     <span class="keywordflow">print</span> <span class="stringliteral">&#39;%s = %s&#39;</span> % (key, grid[key])</div>
<div class="line">...</div>
<div class="line">vector = gradient</div>
<div class="line">radius = 50.0</div>
<div class="line">scale = 3.14159</div>
<div class="line">center = (10.5, 15.0, 30.0)</div>
</div><!-- fragment --><p>Removing metadata is also straightforward: </p><div class="fragment"><div class="line">&gt;&gt;&gt; del grid[<span class="stringliteral">&#39;vector&#39;</span>]</div>
<div class="line">&gt;&gt;&gt; del grid[<span class="stringliteral">&#39;center&#39;</span>]</div>
<div class="line">&gt;&gt;&gt; del grid[<span class="stringliteral">&#39;vector&#39;</span>]  <span class="comment"># error: already removed</span></div>
<div class="line">  File <span class="stringliteral">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keywordflow">in</span> &lt;module&gt;</div>
<div class="line">KeyError: <span class="stringliteral">&#39;vector&#39;</span></div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; grid.metadata = {}  <span class="comment"># remove all metadata</span></div>
</div><!-- fragment --><p>Some grid metadata is exposed in the form of properties, either because it might be frequently accessed (a grid&rsquo;s name, for example) or because its allowed values are somehow restricted: </p><div class="fragment"><div class="line">&gt;&gt;&gt; grid = vdb.createLevelSetSphere(radius=10.0)</div>
<div class="line">&gt;&gt;&gt; grid.metadata</div>
<div class="line">{<span class="stringliteral">&#39;class&#39;</span>: <span class="stringliteral">&#39;level set&#39;</span>}</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; grid.gridClass = vdb.GridClass.FOG_VOLUME</div>
<div class="line">&gt;&gt;&gt; grid.metadata</div>
<div class="line">{<span class="stringliteral">&#39;class&#39;</span>: <span class="stringliteral">&#39;fog volume&#39;</span>}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># The gridClass property requires a string value:</span></div>
<div class="line">&gt;&gt;&gt; grid.gridClass = 123</div>
<div class="line">  File <span class="stringliteral">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keywordflow">in</span> &lt;module&gt;</div>
<div class="line">TypeError: expected str, found int <span class="keyword">as</span> argument 1 to setGridClass()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Only certain strings are recognized; see pyopenvdb.GridClass</span></div>
<div class="line"><span class="comment"># for the complete list.</span></div>
<div class="line">&gt;&gt;&gt; grid.gridClass = <span class="stringliteral">&#39;Hello, world.&#39;</span></div>
<div class="line">&gt;&gt;&gt; grid.metadata</div>
<div class="line">{<span class="stringliteral">&#39;class&#39;</span>: <span class="stringliteral">&#39;unknown&#39;</span>}</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; grid.metadata = {}</div>
<div class="line">&gt;&gt;&gt; grid.vectorType = vdb.VectorType.COVARIANT</div>
<div class="line">&gt;&gt;&gt; grid.metadata</div>
<div class="line">{<span class="stringliteral">&#39;vector_type&#39;</span>: <span class="stringliteral">&#39;covariant&#39;</span>}</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; grid.name = <span class="stringliteral">&#39;sphere&#39;</span></div>
<div class="line">&gt;&gt;&gt; grid.creator = <span class="stringliteral">&#39;Python&#39;</span></div>
<div class="line">&gt;&gt;&gt; grid.metadata</div>
<div class="line">{<span class="stringliteral">&#39;vector_type&#39;</span>: <span class="stringliteral">&#39;covariant&#39;</span>, <span class="stringliteral">&#39;name&#39;</span>: <span class="stringliteral">&#39;sphere&#39;</span>, <span class="stringliteral">&#39;creator&#39;</span>: <span class="stringliteral">&#39;Python&#39;</span>}</div>
</div><!-- fragment --><p> Setting these properties to <code>None</code> removes the corresponding metadata, but the properties retain default values: </p><div class="fragment"><div class="line">&gt;&gt;&gt; grid.creator = grid.vectorType = <span class="keywordtype">None</span></div>
<div class="line">&gt;&gt;&gt; grid.metadata</div>
<div class="line">{<span class="stringliteral">&#39;name&#39;</span>: <span class="stringliteral">&#39;sphere&#39;</span>}</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; grid.creator, grid.vectorType</div>
<div class="line">(<span class="stringliteral">&#39;&#39;</span>, <span class="stringliteral">&#39;invariant&#39;</span>)</div>
</div><!-- fragment --><p>Metadata can be associated with a <span class="tt">.vdb</span> file at the time the file is written, by supplying a (name,&#160;value) dictionary as the optional <code>metadata</code> argument to the <b>write</b> function: </p><div class="fragment"><div class="line">&gt;&gt;&gt; metadata = {</div>
<div class="line">...     <span class="stringliteral">&#39;creator&#39;</span>: <span class="stringliteral">&#39;Python&#39;</span>,</div>
<div class="line">...     <span class="stringliteral">&#39;time&#39;</span>: <span class="stringliteral">&#39;11:05:00&#39;</span></div>
<div class="line">... }</div>
<div class="line">&gt;&gt;&gt; vdb.write(<span class="stringliteral">&#39;mygrids.vdb&#39;</span>, grids=grid, metadata=metadata)</div>
</div><!-- fragment --><p> File-level metadata can be retrieved with either the <b>readMetadata</b> function or the <b>readAll</b> function: </p><div class="fragment"><div class="line">&gt;&gt;&gt; metadata = vdb.readMetadata(<span class="stringliteral">&#39;mygrids.vdb&#39;</span>)</div>
<div class="line">&gt;&gt;&gt; metadata</div>
<div class="line">{<span class="stringliteral">&#39;creator&#39;</span>: <span class="stringliteral">&#39;Python&#39;</span>, <span class="stringliteral">&#39;time&#39;</span>: <span class="stringliteral">&#39;11:05:00&#39;</span>}</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; grids, metadata = vdb.readAll(<span class="stringliteral">&#39;mygrids.vdb&#39;</span>)</div>
<div class="line">&gt;&gt;&gt; metadata</div>
<div class="line">{<span class="stringliteral">&#39;creator&#39;</span>: <span class="stringliteral">&#39;Python&#39;</span>, <span class="stringliteral">&#39;time&#39;</span>: <span class="stringliteral">&#39;11:05:00&#39;</span>}</div>
<div class="line">&gt;&gt;&gt; [grid.name <span class="keywordflow">for</span> grid <span class="keywordflow">in</span> grids]</div>
<div class="line">[<span class="stringliteral">&#39;sphere&#39;</span>]</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="sPyAccessors"></a>
Voxel access</h1>
<p>Grids provide read-only and read/write accessors for voxel lookup via (<em>i</em>,&#160;<em>j</em>,&#160;<em>k</em>) index coordinates. Accessors store references to their parent grids, so a grid will not be deleted while it has accessors in use.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">import</span> pyopenvdb <span class="keyword">as</span> vdb</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Read two grids from a file.</span></div>
<div class="line">&gt;&gt;&gt; grids, metadata = vdb.readAll(<span class="stringliteral">&#39;smoke2.vdb&#39;</span>)</div>
<div class="line">&gt;&gt;&gt; [grid.name <span class="keywordflow">for</span> grid <span class="keywordflow">in</span> grids]</div>
<div class="line">[<span class="stringliteral">&#39;density&#39;</span>, <span class="stringliteral">&#39;v&#39;</span>]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Get read/write accessors to the two grids.</span></div>
<div class="line">&gt;&gt;&gt; dAccessor = grids[0].getAccessor()</div>
<div class="line">&gt;&gt;&gt; vAccessor = grids[1].getAccessor()</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; ijk = (100, 103, 101)</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; dAccessor.probeValue(ijk)</div>
<div class="line">(0.17614534497261047, <span class="keyword">True</span>)</div>
<div class="line"><span class="comment"># Change the value of a voxel.</span></div>
<div class="line">&gt;&gt;&gt; dAccessor.setValueOn(ijk, 0.125)</div>
<div class="line">&gt;&gt;&gt; dAccessor.probeValue(ijk)</div>
<div class="line">(0.125, <span class="keyword">True</span>)</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; vAccessor.probeValue(ijk)</div>
<div class="line">((-2.90625, 9.84375, 0.84228515625), <span class="keyword">True</span>)</div>
<div class="line"><span class="comment"># Change the active state of a voxel.</span></div>
<div class="line">&gt;&gt;&gt; vAccessor.setActiveState(ijk, <span class="keyword">False</span>)</div>
<div class="line">&gt;&gt;&gt; vAccessor.probeValue(ijk)</div>
<div class="line">((-2.90625, 9.84375, 0.84228515625), <span class="keyword">False</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Get a read-only accessor to one of the grids.</span></div>
<div class="line">&gt;&gt;&gt; dAccessor = grids[0].getConstAccessor()</div>
<div class="line">&gt;&gt;&gt; dAccessor.setActiveState(ijk, <span class="keyword">False</span>)</div>
<div class="line">  File <span class="stringliteral">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keywordflow">in</span> &lt;module&gt;</div>
<div class="line">TypeError: accessor <span class="keywordflow">is</span> read-only</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Delete the accessors once they are no longer needed,</span></div>
<div class="line"><span class="comment"># so that the grids can be garbage-collected.</span></div>
<div class="line">&gt;&gt;&gt; del dAccessor, vAccessor</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="sPyIteration"></a>
Iteration</h1>
<p>Grids provide read-only and read/write iterators over their values. Iteration is over sequences of value objects (<b>BoolGrid.Value</b>s, <b>FloatGrid.Value</b>s, etc.) that expose properties such as the number of voxels spanned by a value (one, for a voxel value, more than one for a tile value), its coordinates and its active state. Value objects returned by read-only iterators are immutable; those returned by read/write iterators permit assignment to their active state and value properties, which modifies the underlying grid. Value objects store references to their parent grids, so a grid will not be deleted while one of its value objects is in use.</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">import</span> pyopenvdb <span class="keyword">as</span> vdb</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; grid = vdb.read(<span class="stringliteral">&#39;smoke2.vdb&#39;</span>, gridname=<span class="stringliteral">&#39;v&#39;</span>)</div>
<div class="line">&gt;&gt;&gt; grid.__class__.__name__</div>
<div class="line"><span class="stringliteral">&#39;Vec3SGrid&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Iterate over inactive values and print the coordinates of the first</span></div>
<div class="line"><span class="comment"># five voxel values and the bounding boxes of the first five tile values.</span></div>
<div class="line">&gt;&gt;&gt; voxels = tiles = 0</div>
<div class="line">... N = 5</div>
<div class="line">... <span class="keywordflow">for</span> item <span class="keywordflow">in</span> grid.citerOffValues():  <span class="comment"># read-only iterator</span></div>
<div class="line">...     <span class="keywordflow">if</span> voxels == N <span class="keywordflow">and</span> tiles == N:</div>
<div class="line">...         <span class="keywordflow">break</span></div>
<div class="line">...     <span class="keywordflow">if</span> item.count == 1:</div>
<div class="line">...         <span class="keywordflow">if</span> voxels &lt; N:</div>
<div class="line">...             voxels += 1</div>
<div class="line">...             <span class="keywordflow">print</span> <span class="stringliteral">&#39;voxel&#39;</span>, item.min</div>
<div class="line">...     <span class="keywordflow">else</span>:</div>
<div class="line">...         <span class="keywordflow">if</span> tiles &lt; N:</div>
<div class="line">...             tiles += 1</div>
<div class="line">...             <span class="keywordflow">print</span> <span class="stringliteral">&#39;tile&#39;</span>, item.min, item.max</div>
<div class="line">...</div>
<div class="line">tile (0, 0, 0) (7, 7, 7)</div>
<div class="line">tile (0, 0, 8) (7, 7, 15)</div>
<div class="line">tile (0, 0, 16) (7, 7, 23)</div>
<div class="line">tile (0, 0, 24) (7, 7, 31)</div>
<div class="line">tile (0, 0, 32) (7, 7, 39)</div>
<div class="line">voxel (40, 96, 88)</div>
<div class="line">voxel (40, 96, 89)</div>
<div class="line">voxel (40, 96, 90)</div>
<div class="line">voxel (40, 96, 91)</div>
<div class="line">voxel (40, 96, 92)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Iterate over and normalize all active values.</span></div>
<div class="line">&gt;&gt;&gt; <span class="keyword">from</span> math <span class="keyword">import</span> sqrt</div>
<div class="line">&gt;&gt;&gt; <span class="keywordflow">for</span> item <span class="keywordflow">in</span> grid.iterOnValues():  <span class="comment"># read/write iterator</span></div>
<div class="line">...     vector = item.value</div>
<div class="line">...     magnitude = sqrt(sum(x * x <span class="keywordflow">for</span> x <span class="keywordflow">in</span> vector))</div>
<div class="line">...     item.value = [x / magnitude <span class="keywordflow">for</span> x <span class="keywordflow">in</span> vector]</div>
<div class="line">...</div>
</div><!-- fragment --><p>For some operations, it might be more convenient to use one of the grid methods <b>mapOn</b>, <b>mapOff</b> or <b>mapAll</b>. These methods iterate over a grid&rsquo;s tiles and voxels (active, inactive or both, respectively) and replace each value <em>x</em> with <em>f</em>(<em>x</em>), where <em>f</em> is a callable object. These methods are not multithreaded. </p><div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">import</span> pyopenvdb <span class="keyword">as</span> vdb</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">from</span> math <span class="keyword">import</span> sqrt</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; grid = vdb.read(<span class="stringliteral">&#39;smoke2.vdb&#39;</span>, gridname=<span class="stringliteral">&#39;v&#39;</span>)</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; <span class="keyword">def </span>normalize(vector):</div>
<div class="line">...     magnitude = sqrt(sum(x * x <span class="keywordflow">for</span> x <span class="keywordflow">in</span> vector))</div>
<div class="line">...     <span class="keywordflow">return</span> [x / magnitude <span class="keywordflow">for</span> x <span class="keywordflow">in</span> vector]</div>
<div class="line">...</div>
<div class="line">&gt;&gt;&gt; grid.mapOn(normalize)</div>
</div><!-- fragment --><p>Similarly, the <b>combine</b> method iterates over corresponding pairs of values (tile and voxel) of two grids <em>A</em> and <em>B</em> of the same type (<b>FloatGrid</b>, <b>Vec3SGrid</b>, etc.), replacing values in <em>A</em> with <em>f</em>(<em>a</em>, <em>b</em>), where <em>f</em> is a callable object. This operation assumes that index coordinates (<em>i</em>,&#160;<em>j</em>,&#160;<em>k</em>) in both grids correspond to the same physical, world space location. Also, the operation always leaves grid <em>B</em> empty. </p><div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">import</span> pyopenvdb <span class="keyword">as</span> vdb</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; density = vdb.read(<span class="stringliteral">&#39;smoke2.vdb&#39;</span>, gridname=<span class="stringliteral">&#39;density&#39;</span>)</div>
<div class="line">&gt;&gt;&gt; density.__class__.__name__</div>
<div class="line"><span class="stringliteral">&#39;FloatGrid&#39;</span></div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; sphere = vdb.createLevelSetSphere(radius=50.0, center=(100, 300, 100))</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; density.combine(sphere, <span class="keyword">lambda</span> a, b: min(a, b))</div>
</div><!-- fragment --><p> For now, <b>combine</b> operates only on tile and voxel values, not on their active states or other attributes.</p>
<h1 class="doxsection"><a class="anchor" id="sPyNumPy"></a>
Working with NumPy arrays</h1>
<p>Large data sets are often handled in Python using <a href="http://www.numpy.org/">NumPy</a>. The <b>copyFromArray</b> and <b>copyToArray</b> grid methods can be used to exchange data efficiently between scalar-valued grids and three-dimensional NumPy arrays and between vector-valued grids and four-dimensional NumPy arrays. </p><div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">import</span> pyopenvdb <span class="keyword">as</span> vdb</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">import</span> numpy</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; array = numpy.random.rand(200, 200, 200)</div>
<div class="line">&gt;&gt;&gt; array.dtype</div>
<div class="line">dtype(<span class="stringliteral">&#39;float64&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Copy values from a three-dimensional array of doubles</span></div>
<div class="line"><span class="comment"># into a grid of floats.</span></div>
<div class="line">&gt;&gt;&gt; grid = vdb.FloatGrid()</div>
<div class="line">&gt;&gt;&gt; grid.copyFromArray(array)</div>
<div class="line">&gt;&gt;&gt; grid.activeVoxelCount() == array.size</div>
<div class="line"><span class="keyword">True</span></div>
<div class="line">&gt;&gt;&gt; grid.evalActiveVoxelBoundingBox()</div>
<div class="line">((0, 0, 0), (199, 199, 199))</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Copy values from a four-dimensional array of ints</span></div>
<div class="line"><span class="comment"># into a grid of float vectors.</span></div>
<div class="line">&gt;&gt;&gt; vecarray = numpy.ndarray((60, 70, 80, 3), int)</div>
<div class="line">&gt;&gt;&gt; vecarray.fill(42)</div>
<div class="line">&gt;&gt;&gt; vecgrid = vdb.Vec3SGrid()</div>
<div class="line">&gt;&gt;&gt; vecgrid.copyFromArray(vecarray)</div>
<div class="line">&gt;&gt;&gt; vecgrid.activeVoxelCount() == 60 * 70 * 80</div>
<div class="line"><span class="keyword">True</span></div>
<div class="line">&gt;&gt;&gt; vecgrid.evalActiveVoxelBoundingBox()</div>
<div class="line">((0, 0, 0), (59, 69, 79))</div>
</div><!-- fragment --><p>When copying from a NumPy array, values in the array that are equal to the destination grid&rsquo;s background value (or close to it, if the <code>tolerance</code> argument to <b>copyFromArray</b> is nonzero) are set to the background value and are marked inactive. All other values are marked active. </p><div class="fragment"><div class="line">&gt;&gt;&gt; grid.clear()</div>
<div class="line">&gt;&gt;&gt; grid.copyFromArray(array, tolerance=0.2)</div>
<div class="line">&gt;&gt;&gt; <span class="keywordflow">print</span> <span class="stringliteral">&#39;%d%% of copied voxels are active&#39;</span> % (</div>
<div class="line">...     round(100.0 * grid.activeVoxelCount() / array.size))</div>
<div class="line">80% of copied voxels are active</div>
</div><!-- fragment --><p>The optional <code>ijk</code> argument specifies the index coordinates of the voxel in the destination grid into which to start copying values. That is, array index (0,&#160;0,&#160;0) maps to voxel (<em>i</em>,&#160;<em>j</em>,&#160;<em>k</em>). </p><div class="fragment"><div class="line">&gt;&gt;&gt; grid.clear()</div>
<div class="line">&gt;&gt;&gt; grid.copyFromArray(array, ijk=(-1, 2, 3))</div>
<div class="line">&gt;&gt;&gt; grid.evalActiveVoxelBoundingBox()</div>
<div class="line">((-1, 2, 3), (198, 201, 202))</div>
</div><!-- fragment --><p>The <b>copyToArray</b> method also accepts an <code>ijk</code> argument. It specifies the index coordinates of the voxel to be copied to array index (0,&#160;0,&#160;0). </p><div class="fragment"><div class="line">&gt;&gt;&gt; grid = vdb.createLevelSetSphere(radius=10.0)</div>
<div class="line">&gt;&gt;&gt; array = numpy.ndarray((40, 40, 40), int)</div>
<div class="line">&gt;&gt;&gt; array.fill(0)</div>
<div class="line"><span class="comment"># Copy values from a grid of floats into</span></div>
<div class="line"><span class="comment"># a three-dimensional array of ints.</span></div>
<div class="line">&gt;&gt;&gt; grid.copyToArray(array, ijk=(-15, -20, -35))</div>
<div class="line">&gt;&gt;&gt; array[15, 20]</div>
<div class="line">array([ 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,</div>
<div class="line">        3,  3,  3,  3,  3,  3,  3,  3,  3,  3,</div>
<div class="line">        3,  3,  3,  2,  1,  0, -1, -2, -3, -3,</div>
<div class="line">       -3, -3, -3, -3, -3, -3, -3, -3, -3, -3])</div>
</div><!-- fragment --><p> <b>copyToArray</b> has no <code>tolerance</code> argument, because there is no distinction between active and inactive values in the destination array.</p>
<h1 class="doxsection"><a class="anchor" id="sPyMeshConversion"></a>
Mesh conversion</h1>
<p>Also available if the OpenVDB Python module is compiled with NumPy support (see <a class="el" href="#sPyNumPy">above</a>) are grid methods to convert polygonal meshes to level sets (see <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tools.html#a49d6517666da8e1ec1175651ebf12f32">tools::meshToLevelSet</a> for some restrictions) and to convert isosurfaces of scalar-valued grids to meshes. </p><div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">import</span> pyopenvdb <span class="keyword">as</span> vdb</div>
<div class="line">&gt;&gt;&gt; <span class="keyword">import</span> numpy</div>
<div class="line"> </div>
<div class="line">&gt;&gt;&gt; grid = vdb.read(<span class="stringliteral">&#39;bunny.vdb&#39;</span>, <span class="stringliteral">&#39;ls_bunny&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Convert a volume to a quadrilateral mesh.</span></div>
<div class="line">&gt;&gt;&gt; points, quads = grid.convertToQuads()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># World-space vertices of the mesh:</span></div>
<div class="line">&gt;&gt;&gt; points</div>
<div class="line">array([[-14.05082607,  -0.10118673,  -0.40250054],</div>
<div class="line">       [-14.05230808,  -0.05570767,  -0.45693323],</div>
<div class="line">       [-14.05613995,  -0.0734246 ,  -0.42150033],</div>
<div class="line">       ...,</div>
<div class="line">       [  7.25201273,  13.25417805,   6.45283508],</div>
<div class="line">       [  7.25596714,  13.31225586,   6.40827513],</div>
<div class="line">       [  7.30518484,  13.21096039,   6.40724468]], dtype=float32)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Quadrilateral faces of the mesh, given by</span></div>
<div class="line"><span class="comment"># 4-tuples of indices into the vertex list:</span></div>
<div class="line">&gt;&gt;&gt; quads</div>
<div class="line">array([[      5,       2,       1,       4],</div>
<div class="line">       [     11,       7,       6,      10],</div>
<div class="line">       [     14,       9,       8,      13],</div>
<div class="line">       ...,</div>
<div class="line">       [1327942, 1327766, 1339685, 1339733],</div>
<div class="line">       [1339728, 1327921, 1327942, 1339733],</div>
<div class="line">       [1339733, 1339685, 1339661, 1339728]], dtype=uint32)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Convert the mesh back to a (single-precision) volume.</span></div>
<div class="line"><span class="comment"># Give the resulting grid the original grid&#39;s transform.</span></div>
<div class="line">&gt;&gt;&gt; gridFromQuads = vdb.FloatGrid.createLevelSetFromPolygons(</div>
<div class="line">...     points, quads=quads, transform=grid.transform)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># Alternatively, mesh a volume adaptively for a lower polygon count.</span></div>
<div class="line"><span class="comment"># Adaptive meshing generates both triangular and quadrilateral faces.</span></div>
<div class="line">&gt;&gt;&gt; points, triangles, quads = grid.convertToPolygons(adaptivity=0.5)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># World-space vertices of the mesh:</span></div>
<div class="line">&gt;&gt;&gt; points</div>
<div class="line">array([[-14.02906322,  -0.07213751,  -0.49265194],</div>
<div class="line">       [-14.11877823,  -0.11127799,  -0.17118289],</div>
<div class="line">       [-13.85006142,  -0.08145611,  -0.86669081],</div>
<div class="line">       ...,</div>
<div class="line">       [  7.31098318,  12.97358608,   6.55133963],</div>
<div class="line">       [  7.20240211,  12.80632019,   6.80356836],</div>
<div class="line">       [  7.23679161,  13.28100395,   6.45595646]], dtype=float32)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Triangular faces of the mesh, given by</span></div>
<div class="line"><span class="comment"># triples of indices into the vertex list:</span></div>
<div class="line">&gt;&gt;&gt; triangles</div>
<div class="line">array([[    8,     7,     0],</div>
<div class="line">       [   14,     9,     8],</div>
<div class="line">       [   14,    11,     9],</div>
<div class="line">       ...,</div>
<div class="line">       [22794, 22796, 22797],</div>
<div class="line">       [22784, 22783, 22810],</div>
<div class="line">       [22796, 22795, 22816]], dtype=uint32)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Quadrilateral faces of the mesh, given by</span></div>
<div class="line"><span class="comment"># 4-tuples of indices into the vertex list:</span></div>
<div class="line">&gt;&gt;&gt; quads</div>
<div class="line">array([[    4,     3,     6,     5],</div>
<div class="line">       [    8,     9,    10,     7],</div>
<div class="line">       [   11,    12,    10,     9],</div>
<div class="line">       ...,</div>
<div class="line">       [23351, 23349, 23341, 23344],</div>
<div class="line">       [23344, 23117, 23169, 23351],</div>
<div class="line">       [23169, 23167, 23349, 23351]], dtype=uint32)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Convert the mesh to a double-precision volume.</span></div>
<div class="line">&gt;&gt;&gt; doubleGridFromPolys = vdb.DoubleGrid.createLevelSetFromPolygons(</div>
<div class="line">...     points, triangles, quads, transform=grid.transform)</div>
</div><!-- fragment --><p>The mesh representation is similar to that of the commonly-used <a href="http://en.wikipedia.org/wiki/Wavefront_.obj_file">Wavefront&#160;<span class="tt">.obj</span></a> file format, except that the vertex array is indexed starting from 0 rather than 1. To output mesh data to a file in <span class="tt">.obj</span> format, one might do the following: </p><div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">def </span>writeObjFile(filename, points, triangles=[], quads=[]):</div>
<div class="line">...     f = open(filename, <span class="stringliteral">&#39;w&#39;</span>)</div>
<div class="line">...     <span class="comment"># Output vertices.</span></div>
<div class="line">...     <span class="keywordflow">for</span> xyz <span class="keywordflow">in</span> points:</div>
<div class="line">...         f.write(<span class="stringliteral">&#39;v %g %g %g\n&#39;</span> % tuple(xyz))</div>
<div class="line">...     f.write(<span class="stringliteral">&#39;\n&#39;</span>)</div>
<div class="line">...     <span class="comment"># Output faces.</span></div>
<div class="line">...     <span class="keywordflow">for</span> ijk <span class="keywordflow">in</span> triangles:</div>
<div class="line">...         f.write(<span class="stringliteral">&#39;f %d %d %d\n&#39;</span> %</div>
<div class="line">...             (ijk[0]+1, ijk[1]+1, ijk[2]+1)) <span class="comment"># offset vertex indices by one</span></div>
<div class="line">...     <span class="keywordflow">for</span> ijkl <span class="keywordflow">in</span> quads:</div>
<div class="line">...         f.write(<span class="stringliteral">&#39;f %d %d %d %d\n&#39;</span> %</div>
<div class="line">...             (ijkl[0]+1, ijkl[1]+1, ijkl[2]+1, ijkl[3]+1))</div>
<div class="line">...     f.close()</div>
<div class="line">...</div>
<div class="line">&gt;&gt;&gt; mesh = grid.convertToPolygons(adaptivity=0.8)</div>
<div class="line">&gt;&gt;&gt; writeObjFile(<span class="stringliteral">&#39;bunny.obj&#39;</span>, *mesh)</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="sPyCppAPI"></a>
C++ glue routines</h1>
<p>Python objects of type <b>FloatGrid</b>, <b>Vec3SGrid</b>, etc. are backed by C structs that &ldquo;inherit&rdquo; from <code>PyObject</code>. The OpenVDB Python extension module includes public functions that you can call in your own extension modules to convert between <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html">openvdb::Grids</a> and <span class="tt">PyObject</span>s. See the pyopenvdb.h reference for a description of these functions and a usage example.</p>
<p>Your extension module might need to link against the OpenVDB extension module in order to access these functions. On UNIX systems, it might also be necessary to specify the <code>RTLD_GLOBAL</code> flag when importing the OpenVDB module, to allow its symbols to be shared across modules. See <b>setdlopenflags</b> in the Python <b>sys</b> module for one way to do this. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="index.html">OpenVDB</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
