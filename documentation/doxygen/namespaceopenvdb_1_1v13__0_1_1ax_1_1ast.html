<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: openvdb::v13_0::ax::ast Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespaceopenvdb_1_1v13__0_1_1ax_1_1ast.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">openvdb::v13_0::ax::ast Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:tokens" id="r_tokens"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html">tokens</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:ArrayPack" id="r_ArrayPack"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayPack.html">ArrayPack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ArrayPacks represent temporary container creations of arbitrary sizes, typically generated through the use of curly braces {}.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayPack.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArrayUnpack" id="r_ArrayUnpack"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html">ArrayUnpack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html" title="ArrayUnpack represent indexing operations into AX container types, primarily vectors and matrices ind...">ArrayUnpack</a> represent indexing operations into AX container types, primarily vectors and matrices indexed by the square brackets [] syntax. Multiple levels of indirection (multiple components) can be specified but current construction is limited to either a single or double component lookup. Providing two components infers a matrix indexing operation.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html#details">More...</a><br /></td></tr>
<tr class="memitem:AssignExpression" id="r_AssignExpression"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1AssignExpression.html">AssignExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AssignExpressions represents a similar object construction to a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html" title="A BinaryOperator represents a single binary operation between a left hand side (LHS) and right hand s...">BinaryOperator</a>. AssignExpressions can be chained together and are thus derived as Expressions rather than Statements.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1AssignExpression.html#details">More...</a><br /></td></tr>
<tr class="memitem:Attribute" id="r_Attribute"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes represent any access to a primitive value, typically associated with the '@' symbol syntax. Note that the AST does not store any additional information on the given attribute other than its name and type, which together form a unique <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html" title="Attributes represent any access to a primitive value, typically associated with the &#39;@&#39; symbol syntax...">Attribute</a> identifier known as the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html" title="Attributes represent any access to a primitive value, typically associated with the &#39;@&#39; symbol syntax...">Attribute</a> 'token'. A 'primitive value' in this instance refers to a value on an OpenVDB Volume or OpenVDB Points tree.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html#details">More...</a><br /></td></tr>
<tr class="memitem:BinaryOperator" id="r_BinaryOperator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html">BinaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html" title="A BinaryOperator represents a single binary operation between a left hand side (LHS) and right hand s...">BinaryOperator</a> represents a single binary operation between a left hand side (LHS) and right hand side (RHS) expression. The operation type is stored as a <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">tokens::OperatorToken</a> enumerated type on the node. AX grammar guarantees that this token will only ever be a valid binary operator token type when initialized by the parser.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html#details">More...</a><br /></td></tr>
<tr class="memitem:Block" id="r_Block"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html" title="A Block node represents a scoped list of statements. It may comprise of 0 or more statements,...">Block</a> node represents a scoped list of statements. It may comprise of 0 or more statements, and specifically indicates that a new scope is activated, typically represented by curly braces. Note that a block does not alway have to be encapsulated by curly braces, but always represents a new scope.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html#details">More...</a><br /></td></tr>
<tr class="memitem:Cast" id="r_Cast"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html" title="Cast nodes represent the conversion of an underlying expression to a target type. Cast nodes are typi...">Cast</a> nodes represent the conversion of an underlying expression to a target type. <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html" title="Cast nodes represent the conversion of an underlying expression to a target type. Cast nodes are typi...">Cast</a> nodes are typically constructed from functional notation and do not represent construction of the target type, rather a type-casted conversion.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html#details">More...</a><br /></td></tr>
<tr class="memitem:CommaOperator" id="r_CommaOperator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1CommaOperator.html">CommaOperator</a></td></tr>
<tr class="memitem:ConditionalStatement" id="r_ConditionalStatement"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html">ConditionalStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ConditionalStatements represents all combinations of 'if', 'else' and 'else if' syntax and semantics. A single <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html" title="ConditionalStatements represents all combinations of &#39;if&#39;, &#39;else&#39; and &#39;else if&#39; syntax and semantics....">ConditionalStatement</a> only ever represents up to two branches; an 'if' (true) and an optional 'else' (false). ConditionalStatements are nested within the second 'else' branch to support 'else if' logic. As well as both 'if' and 'else' branches, a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html" title="ConditionalStatements represents all combinations of &#39;if&#39;, &#39;else&#39; and &#39;else if&#39; syntax and semantics....">ConditionalStatement</a> also holds an <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Expression.html" title="Expressions are comprised of full or potentially partial parts of a full statement that may not neces...">Expression</a> related to its primary condition.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html#details">More...</a><br /></td></tr>
<tr class="memitem:Crement" id="r_Crement"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html">Crement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html" title="A Crement node represents a single increment &#39;++&#39; and decrement &#39;â€“&#39; operation. As well as it&#39;s cremen...">Crement</a> node represents a single increment '++' and decrement '&ndash;' operation. As well as it's crement type, it also stores whether the semantics constructed a post or pre-crement i.e. ++a or a++.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html#details">More...</a><br /></td></tr>
<tr class="memitem:DeclareLocal" id="r_DeclareLocal"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html">DeclareLocal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html" title="DeclareLocal AST nodes symbolize a single type declaration of a local variable. These store the local...">DeclareLocal</a> AST nodes symbolize a single type declaration of a local variable. These store the local variables that They also however store its specified type. These have the important distinction of representing the initial creation and allocation of a variable, in comparison to a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Local.html" title="Local AST nodes represent a single accesses to a local variable. The only store the name of the varia...">Local</a> node which only represents access.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html#details">More...</a><br /></td></tr>
<tr class="memitem:Expression" id="r_Expression"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expressions are comprised of full or potentially partial parts of a full statement that may not necessary make up an entire valid statement on their own. For example, while a Binary Operator such as "3 + 5;"" is a valid statement on its own, the full statement
       "3 + 5 + 6;" must be broken down into two expressions which together form the statement as well as determining precedence.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Expression.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExternalVariable" id="r_ExternalVariable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> represent any access to external (custom) data, typically associated with the '$' symbol syntax. Note that the AST does not store any additional information on the given external other than its name and type, which together form a unique external identifier known as the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> 'token'. This token is used by the compiler to map user provided values to these external values.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ExternalVariable.html#details">More...</a><br /></td></tr>
<tr class="memitem:FunctionCall" id="r_FunctionCall"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1FunctionCall.html">FunctionCall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FunctionCalls represent a single call to a function and any provided arguments. The argument list can be empty. The function name is expected to exist in the AX function registry.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1FunctionCall.html#details">More...</a><br /></td></tr>
<tr class="memitem:Keyword" id="r_Keyword"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Keyword.html">Keyword</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keywords represent keyword statements defining changes in execution. These include those that define changes in loop execution such as break and continue, as well as return statements.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Keyword.html#details">More...</a><br /></td></tr>
<tr class="memitem:Local" id="r_Local"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Local.html">Local</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Local.html" title="Local AST nodes represent a single accesses to a local variable. The only store the name of the varia...">Local</a> AST nodes represent a single accesses to a local variable. The only store the name of the variable being accessed.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Local.html#details">More...</a><br /></td></tr>
<tr class="memitem:Loop" id="r_Loop"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Loop.html">Loop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loops represent for, while and do-while loop constructs. These all consist of a condition - evaluated to determine if loop iteration should continue, and a body which is the logic to be repeated. For loops also have initial statements which are evaluated prior to loop execution (at loop scope) and commonly used to set up iterators, and iteration expressions which are evaluated between iterations after the body and before the condition. Both conditions and initial statements can be declarations or expressions, so are Statements, and iteration expressions can consist of multiple expressions. The loop body is a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html" title="A Block node represents a scoped list of statements. It may comprise of 0 or more statements,...">Block</a> defining its own scope (encapsulated by initial statement scope for for-loops).  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Loop.html#details">More...</a><br /></td></tr>
<tr class="memitem:Node" id="r_Node"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base abstract node which determines the interface and required methods for all derived concrete nodes which comprise a valid AST.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="memitem:Statement" id="r_Statement"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Statement.html">Statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract (pure-virtual) AST nodes.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Statement.html#details">More...</a><br /></td></tr>
<tr class="memitem:StatementList" id="r_StatementList"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1StatementList.html">StatementList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete AST nodes.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1StatementList.html#details">More...</a><br /></td></tr>
<tr class="memitem:TernaryOperator" id="r_TernaryOperator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html">TernaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html" title="A TernaryOperator represents a ternary (conditional) expression &#39;a ? b : c&#39; which evaluates to &#39;b&#39; if...">TernaryOperator</a> represents a ternary (conditional) expression 'a ? b : c' which evaluates to 'b' if 'a' is true and 'c' if 'a' is false. Requires 'b' and 'c' to be convertibly typed expressions, or both void. The 'true' expression ('b') is optional with the conditional expression 'a' returned if it evaluates to true, otherwise returning 'c'. Note that 'a' will only be evaluated once in this case.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html#details">More...</a><br /></td></tr>
<tr class="memitem:Tree" id="r_Tree"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html">Tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy....">Tree</a> is the highest concrete (non-abstract) node in the entire AX AST hierarchy. It represents an entire conversion of a valid AX string.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html#details">More...</a><br /></td></tr>
<tr class="memitem:UnaryOperator" id="r_UnaryOperator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html">UnaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html" title="A UnaryOperator represents a single unary operation on an expression. The operation type is stored as...">UnaryOperator</a> represents a single unary operation on an expression. The operation type is stored as a <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">tokens::OperatorToken</a> enumerated type on the node. AX grammar guarantees that this token will only every be a valid unary operator token type when initialized by the parser.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html#details">More...</a><br /></td></tr>
<tr class="memitem:Value" id="r_Value"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value.html" title="A Value (literal) AST node holds either literal text or absolute value information on all numerical,...">Value</a> (literal) AST node holds either literal text or absolute value information on all numerical, string and boolean constants. A single instance of a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value.html" title="A Value (literal) AST node holds either literal text or absolute value information on all numerical,...">Value</a> is templated on the requested scalar, boolean or string type. If scalar or boolean value is constructed from a string (as typically is the case in the parser), the value is automatically converted to its numerical representation. If this fails, the original text is stored instead.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value.html#details">More...</a><br /></td></tr>
<tr class="memitem:Value_3C_20std_3A_3Astring_20_3E" id="r_Value_3C_20std_3A_3Astring_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value_3_01std_1_1string_01_4.html">Value&lt; std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of Values for strings.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value_3_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueBase" id="r_ValueBase"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ValueBase.html">ValueBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ValueBases are a base class for anything that holds a value (literal). Derived classes store the actual typed values.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ValueBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:Variable" id="r_Variable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variables are a base type for Locals, Attributes and ExternalVariables. Unlike other abstract types, they also consolidate data for the derived types.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html#details">More...</a><br /></td></tr>
<tr class="memitem:VisitNodeType" id="r_VisitNodeType"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1VisitNodeType.html">VisitNodeType</a></td></tr>
<tr class="memitem:Visitor" id="r_Visitor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Visitor.html">Visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Visitor.html" title="The Visitor class uses the Curiously Recursive Template Pattern (CRTP) to provide a customizable inte...">Visitor</a> class uses the Curiously Recursive Template Pattern (CRTP) to provide a customizable interface intended to be used by clients wishing to perform custom operations over an AX Abstract Syntax <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy....">Tree</a> (AST). By default the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Visitor.html" title="The Visitor class uses the Curiously Recursive Template Pattern (CRTP) to provide a customizable inte...">Visitor</a> implements simple traversal of all nodes, ensuring that each node on a well formed AST is visited at least once. By deriving from the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Visitor.html" title="The Visitor class uses the Curiously Recursive Template Pattern (CRTP) to provide a customizable inte...">Visitor</a>, users are able to customize this default behavior and further manually override specific node behavior to their needs. The function options at the top of visitor can be overridden using CRTP to control the prior default behavior, with the ability to override the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Visitor.html#abf72acb00ab34838ffcfed86693b7ba3" title="Default traversals for a given concrete AST node type.">traverse()</a> and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Visitor.html#a1bc78d9f4efd54a75f8c6266040b447b" title="Visits for abstract (pure-virtual) Node types.">visit()</a> methods for the latter more granular control.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Visitor.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abd4260bbc0930a89c7f5dac3c118ccc8" id="r_abd4260bbc0930a89c7f5dac3c118ccc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> openvdb::ax::ast::Tree::ConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd4260bbc0930a89c7f5dac3c118ccc8">parse</a> (const char *code, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">ax::Logger</a> &amp;logger)</td></tr>
<tr class="memdesc:abd4260bbc0930a89c7f5dac3c118ccc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an abstract syntax tree from a code snippet.  <br /></td></tr>
<tr class="memitem:a69f0a0e8f611a2cbbef0169bd8d6637e" id="r_a69f0a0e8f611a2cbbef0169bd8d6637e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> openvdb::ax::ast::Tree::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69f0a0e8f611a2cbbef0169bd8d6637e">parse</a> (const char *code)</td></tr>
<tr class="memdesc:a69f0a0e8f611a2cbbef0169bd8d6637e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an abstract syntax tree from a code snippet.  <br /></td></tr>
<tr class="memitem:a69c73a78e8b9750eb5813baaea02f24d" id="r_a69c73a78e8b9750eb5813baaea02f24d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69c73a78e8b9750eb5813baaea02f24d">print</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, const bool numberStatements=true, std::ostream &amp;os=std::cout, const char *indent=&quot;    &quot;)</td></tr>
<tr class="memdesc:a69c73a78e8b9750eb5813baaea02f24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a descriptive printout of a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">Node</a> hierarchy into a target stream.  <br /></td></tr>
<tr class="memitem:aa5bf97e104f5a6dcd9d4c96f3aa1f5e9" id="r_aa5bf97e104f5a6dcd9d4c96f3aa1f5e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5bf97e104f5a6dcd9d4c96f3aa1f5e9">reprint</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, std::ostream &amp;os=std::cout, const char *indent=&quot;    &quot;)</td></tr>
<tr class="memdesc:aa5bf97e104f5a6dcd9d4c96f3aa1f5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the provided AST, print corresponding AX code which may have been used to create it.  <br /></td></tr>
<tr class="memitem:aba72d1b54c716e80fd02971b3f1df127" id="r_aba72d1b54c716e80fd02971b3f1df127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba72d1b54c716e80fd02971b3f1df127">usesAttribute</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, const std::string &amp;name, const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a> type=<a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7a6ce26a62afab55d7606ad4e92428b30c">tokens::UNKNOWN</a>)</td></tr>
<tr class="memdesc:aba72d1b54c716e80fd02971b3f1df127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not a given branch of an AST reads from or writes to a given attribute.  <br /></td></tr>
<tr class="memitem:a82d0632c608643b161c9f66ae60fb602" id="r_a82d0632c608643b161c9f66ae60fb602"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82d0632c608643b161c9f66ae60fb602">writesToAttribute</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, const std::string &amp;name, const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a> type=<a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7a6ce26a62afab55d7606ad4e92428b30c">tokens::UNKNOWN</a>)</td></tr>
<tr class="memdesc:a82d0632c608643b161c9f66ae60fb602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not a given branch of an AST writes to a given attribute.  <br /></td></tr>
<tr class="memitem:a2d71d733044f7ccc1d50865d34ba3d23" id="r_a2d71d733044f7ccc1d50865d34ba3d23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d71d733044f7ccc1d50865d34ba3d23">callsFunction</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, const std::string &amp;name)</td></tr>
<tr class="memdesc:a2d71d733044f7ccc1d50865d34ba3d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not a given branch of an AST calls a function.  <br /></td></tr>
<tr class="memitem:ac69fd1bbcaf02d3788badd4a99fa2d2e" id="r_ac69fd1bbcaf02d3788badd4a99fa2d2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac69fd1bbcaf02d3788badd4a99fa2d2e">catalogueVariables</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, std::vector&lt; const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> * &gt; *readOnly, std::vector&lt; const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> * &gt; *writeOnly, std::vector&lt; const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> * &gt; *readWrite, const bool locals=true, const bool attributes=true)</td></tr>
<tr class="memdesc:ac69fd1bbcaf02d3788badd4a99fa2d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">todo  <br /></td></tr>
<tr class="memitem:a31b6bb7849632571045389bf8476350f" id="r_a31b6bb7849632571045389bf8476350f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31b6bb7849632571045389bf8476350f">catalogueAttributeTokens</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, std::vector&lt; std::string &gt; *readOnly, std::vector&lt; std::string &gt; *writeOnly, std::vector&lt; std::string &gt; *readWrite)</td></tr>
<tr class="memdesc:a31b6bb7849632571045389bf8476350f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse all attributes into three unique vectors which represent how they are accessed within the syntax tree. Read only attributes are stored within the 'readOnly' container (for example.  <br /></td></tr>
<tr class="memitem:af33d0619c7fefcb888b4ac3b55ceaf34" id="r_af33d0619c7fefcb888b4ac3b55ceaf34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af33d0619c7fefcb888b4ac3b55ceaf34">attributeDependencyTokens</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html">ast::Tree</a> &amp;tree, const std::string &amp;name, const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a> type, std::vector&lt; std::string &gt; &amp;dependencies)</td></tr>
<tr class="memdesc:af33d0619c7fefcb888b4ac3b55ceaf34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a list of attribute names which the given attribute depends on.  <br /></td></tr>
<tr class="memitem:adc7a0b3fe55c85fa98c9dd7ae46d9daa" id="r_adc7a0b3fe55c85fa98c9dd7ae46d9daa"><td class="memTemplParams" colspan="2">template&lt;typename NodeT, typename OpT&gt; </td></tr>
<tr class="memitem:adc7a0b3fe55c85fa98c9dd7ae46d9daa template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc7a0b3fe55c85fa98c9dd7ae46d9daa">visitNodeType</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, const OpT &amp;op)</td></tr>
<tr class="memdesc:adc7a0b3fe55c85fa98c9dd7ae46d9daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an AST node of a given type, search for and call a custom const operator() which takes a const reference to every occurrence of the specified node type.  <br /></td></tr>
<tr class="memitem:a81d739eaf1e71ce7a3a309e383ffb50e" id="r_a81d739eaf1e71ce7a3a309e383ffb50e"><td class="memTemplParams" colspan="2">template&lt;typename NodeT, typename ContainerType = std::vector&lt;const NodeT*&gt;&gt; </td></tr>
<tr class="memitem:a81d739eaf1e71ce7a3a309e383ffb50e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81d739eaf1e71ce7a3a309e383ffb50e">collectNodeType</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, ContainerType &amp;array)</td></tr>
<tr class="memdesc:a81d739eaf1e71ce7a3a309e383ffb50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit all nodes of a given type and store pointers to them in a provided compatible container.  <br /></td></tr>
<tr class="memitem:a96254b78dcaaa4a219a450144bd64fe3" id="r_a96254b78dcaaa4a219a450144bd64fe3"><td class="memTemplParams" colspan="2">template&lt;typename NodeTypeList, typename ContainerType = std::vector&lt;const Node*&gt;&gt; </td></tr>
<tr class="memitem:a96254b78dcaaa4a219a450144bd64fe3 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96254b78dcaaa4a219a450144bd64fe3">collectNodeTypes</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, ContainerType &amp;array)</td></tr>
<tr class="memdesc:a96254b78dcaaa4a219a450144bd64fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit all nodes of the given types and store pointers to them in a container of base <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">ast::Node</a> pointers.  <br /></td></tr>
<tr class="memitem:aeacd36563ba90e71d9b0cb9487810cb8" id="r_aeacd36563ba90e71d9b0cb9487810cb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeacd36563ba90e71d9b0cb9487810cb8">linearize</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, std::vector&lt; const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> * &gt; &amp;list)</td></tr>
<tr class="memdesc:aeacd36563ba90e71d9b0cb9487810cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten the provided AST branch into a linear list using post order traversal.  <br /></td></tr>
<tr class="memitem:a2c9ef6bf34f712ad5ed29eb15f2a0c35" id="r_a2c9ef6bf34f712ad5ed29eb15f2a0c35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c9ef6bf34f712ad5ed29eb15f2a0c35">firstUse</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, const std::string &amp;token)</td></tr>
<tr class="memitem:ab46bf7387382f5954f2478a21d3b6be9" id="r_ab46bf7387382f5954f2478a21d3b6be9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab46bf7387382f5954f2478a21d3b6be9">lastUse</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, const std::string &amp;token)</td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="af33d0619c7fefcb888b4ac3b55ceaf34" name="af33d0619c7fefcb888b4ac3b55ceaf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33d0619c7fefcb888b4ac3b55ceaf34">&#9670;&#160;</a></span>attributeDependencyTokens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void attributeDependencyTokens </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html">ast::Tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dependencies</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate a list of attribute names which the given attribute depends on. </p>

</div>
</div>
<a id="a2d71d733044f7ccc1d50865d34ba3d23" name="a2d71d733044f7ccc1d50865d34ba3d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d71d733044f7ccc1d50865d34ba3d23">&#9670;&#160;</a></span>callsFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> bool callsFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not a given branch of an AST calls a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The AST to analyze </td></tr>
    <tr><td class="paramname">name</td><td>the name of the function to search for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31b6bb7849632571045389bf8476350f" name="a31b6bb7849632571045389bf8476350f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b6bb7849632571045389bf8476350f">&#9670;&#160;</a></span>catalogueAttributeTokens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void catalogueAttributeTokens </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *</td>          <td class="paramname"><span class="paramname"><em>readOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *</td>          <td class="paramname"><span class="paramname"><em>writeOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *</td>          <td class="paramname"><span class="paramname"><em>readWrite</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse all attributes into three unique vectors which represent how they are accessed within the syntax tree. Read only attributes are stored within the 'readOnly' container (for example. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> a=@a; </div>
</div><!-- fragment --><p>), write only attributes in the 'writeOnly' container </p><div class="fragment"><div class="line">@a=1; </div>
</div><!-- fragment --><p> and readWrite attributes in the 'readWrite' container </p><div class="fragment"><div class="line">@a+=1; </div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Note that the code generator is able to do this far more efficiently, however this provides simple front-end support for detecting these types of operations</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The AST to analyze </td></tr>
    <tr><td class="paramname">readOnly</td><td>The unique list of attributes which are only read from </td></tr>
    <tr><td class="paramname">writeOnly</td><td>The unique list of attributes which are only written too </td></tr>
    <tr><td class="paramname">readWrite</td><td>The unique list of attributes which both read from and written too </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac69fd1bbcaf02d3788badd4a99fa2d2e" name="ac69fd1bbcaf02d3788badd4a99fa2d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69fd1bbcaf02d3788badd4a99fa2d2e">&#9670;&#160;</a></span>catalogueVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void catalogueVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>readOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>writeOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>readWrite</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>locals</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>attributes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>todo </p>

</div>
</div>
<a id="a81d739eaf1e71ce7a3a309e383ffb50e" name="a81d739eaf1e71ce7a3a309e383ffb50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d739eaf1e71ce7a3a309e383ffb50e">&#9670;&#160;</a></span>collectNodeType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeT, typename ContainerType = std::vector&lt;const NodeT*&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void collectNodeType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Visit all nodes of a given type and store pointers to them in a provided compatible container. </p>

</div>
</div>
<a id="a96254b78dcaaa4a219a450144bd64fe3" name="a96254b78dcaaa4a219a450144bd64fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96254b78dcaaa4a219a450144bd64fe3">&#9670;&#160;</a></span>collectNodeTypes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeTypeList, typename ContainerType = std::vector&lt;const Node*&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void collectNodeTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Visit all nodes of the given types and store pointers to them in a container of base <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">ast::Node</a> pointers. </p>
<dl class="section note"><dt>Note</dt><dd>NodeTypeList is expected to be a an <a class="el" href="structopenvdb_1_1v13__0_1_1TypeList.html" title="A list of types (not necessarily unique)">openvdb::TypeList</a> object with a list of node types. For example, to collect all <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html" title="Attributes represent any access to a primitive value, typically associated with the &#39;@&#39; symbol syntax...">Attribute</a> and External <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html" title="Variables are a base type for Locals, Attributes and ExternalVariables. Unlike other abstract types,...">Variable</a> ast Nodes:</dd></dl>
<p>using ListT = <a class="el" href="structopenvdb_1_1v13__0_1_1TypeList.html" title="A list of types (not necessarily unique)">openvdb::TypeList&lt;ast::Attribute, ast::ExternalVariable&gt;</a>; std::vector&lt;const ast::Node*&gt; nodes; ast::collectNodeTypes&lt;ListT&gt;(tree, nodes); </p>

</div>
</div>
<a id="a2c9ef6bf34f712ad5ed29eb15f2a0c35" name="a2c9ef6bf34f712ad5ed29eb15f2a0c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9ef6bf34f712ad5ed29eb15f2a0c35">&#9670;&#160;</a></span>firstUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> * firstUse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab46bf7387382f5954f2478a21d3b6be9" name="ab46bf7387382f5954f2478a21d3b6be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46bf7387382f5954f2478a21d3b6be9">&#9670;&#160;</a></span>lastUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> * lastUse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeacd36563ba90e71d9b0cb9487810cb8" name="aeacd36563ba90e71d9b0cb9487810cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacd36563ba90e71d9b0cb9487810cb8">&#9670;&#160;</a></span>linearize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void linearize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten the provided AST branch into a linear list using post order traversal. </p>

</div>
</div>
<a id="a69f0a0e8f611a2cbbef0169bd8d6637e" name="a69f0a0e8f611a2cbbef0169bd8d6637e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f0a0e8f611a2cbbef0169bd8d6637e">&#9670;&#160;</a></span>parse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> openvdb::ax::ast::Tree::Ptr parse </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>code</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an abstract syntax tree from a code snippet. </p>
<p>A runtime exception will be thrown with the first syntax error.</p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a valid AST.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>The code to parse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd4260bbc0930a89c7f5dac3c118ccc8" name="abd4260bbc0930a89c7f5dac3c118ccc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4260bbc0930a89c7f5dac3c118ccc8">&#9670;&#160;</a></span>parse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> openvdb::ax::ast::Tree::ConstPtr parse </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">ax::Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an abstract syntax tree from a code snippet. </p>
<p>This method parses the provided null terminated code snippet and attempts to construct a complete abstract syntax tree (AST) which can be passed to the AX <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Compiler.html" title="The compiler class. This holds a set of compiler options and constructs executable objects (e....">Compiler</a>. If the code is not well formed (as defined by the AX grammar) a nullptr is returned and instances of any errors encoutered are stored to the provided logger. </p><dl class="section note"><dt>Note</dt><dd>The returned AST is const as the logger uses this to determine line and column numbers of errors/warnings in later stages. If you need to modify the tree, take a copy.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a valid const AST. Can be a nullptr on error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>The code to parse </td></tr>
    <tr><td class="paramname">logger</td><td>The logger to collect syntax errors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69c73a78e8b9750eb5813baaea02f24d" name="a69c73a78e8b9750eb5813baaea02f24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c73a78e8b9750eb5813baaea02f24d">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>numberStatements</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cout</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>indent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;&#160;&#160;&#160;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a descriptive printout of a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">Node</a> hierarchy into a target stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">Node</a> to print </td></tr>
    <tr><td class="paramname">numberStatements</td><td>Whether to number the line statements </td></tr>
    <tr><td class="paramname">os</td><td>Stream to write into </td></tr>
    <tr><td class="paramname">indent</td><td>The indent to print on each child traversal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5bf97e104f5a6dcd9d4c96f3aa1f5e9" name="aa5bf97e104f5a6dcd9d4c96f3aa1f5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5bf97e104f5a6dcd9d4c96f3aa1f5e9">&#9670;&#160;</a></span>reprint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void reprint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cout</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>indent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;&#160;&#160;&#160;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using the provided AST, print corresponding AX code which may have been used to create it. </p>
<dl class="section note"><dt>Note</dt><dd>The result is not guaranteed to be exactly equal to the code that was original parsed. A few potential key differences worth mentioning include whitespace matching, component indexing and inferred attribute types. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">Node</a> to print </td></tr>
    <tr><td class="paramname">os</td><td>Stream to write into </td></tr>
    <tr><td class="paramname">indent</td><td>The indent to print on each child traversal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba72d1b54c716e80fd02971b3f1df127" name="aba72d1b54c716e80fd02971b3f1df127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba72d1b54c716e80fd02971b3f1df127">&#9670;&#160;</a></span>usesAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> bool usesAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7a6ce26a62afab55d7606ad4e92428b30c">tokens::UNKNOWN</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not a given branch of an AST reads from or writes to a given attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The AST to analyze </td></tr>
    <tr><td class="paramname">name</td><td>the name of the attribute to search for </td></tr>
    <tr><td class="paramname">type</td><td>the type of the attribute to search for. If UNKNOWN, any attribute with the given name is checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc7a0b3fe55c85fa98c9dd7ae46d9daa" name="adc7a0b3fe55c85fa98c9dd7ae46d9daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7a0b3fe55c85fa98c9dd7ae46d9daa">&#9670;&#160;</a></span>visitNodeType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeT, typename OpT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visitNodeType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OpT &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For an AST node of a given type, search for and call a custom const operator() which takes a const reference to every occurrence of the specified node type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The AST to run over </td></tr>
    <tr><td class="paramname">op</td><td>The operator to call on every found AST node of type NodeT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82d0632c608643b161c9f66ae60fb602" name="a82d0632c608643b161c9f66ae60fb602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d0632c608643b161c9f66ae60fb602">&#9670;&#160;</a></span>writesToAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> bool writesToAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7a6ce26a62afab55d7606ad4e92428b30c">tokens::UNKNOWN</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not a given branch of an AST writes to a given attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The AST to analyze </td></tr>
    <tr><td class="paramname">name</td><td>the name of the attribute to search for </td></tr>
    <tr><td class="paramname">type</td><td>the type of the attribute to search for. If UNKNOWN, the first attribute encountered with the given name is checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax.html">ax</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast.html">ast</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
