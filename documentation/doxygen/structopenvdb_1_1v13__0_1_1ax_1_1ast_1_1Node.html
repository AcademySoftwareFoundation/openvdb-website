<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: Node Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html','','structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Node Struct Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The base abstract node which determines the interface and required methods for all derived concrete nodes which comprise a valid AST.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AST_8h_source.html">openvdb_ax/ast/AST.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acac9cbaeea226ed297804c012dc12b16" id="r_acac9cbaeea226ed297804c012dc12b16"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acac9cbaeea226ed297804c012dc12b16">NodeType</a> { <br />
&#160;&#160;<a class="el" href="#acac9cbaeea226ed297804c012dc12b16a6e3c9853eac7f791316173112a4c920d">TreeNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16a48e5c1876288bf22cd46f986e38adf02">StatementListNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16a43780fadfdb2235144acada7dbe105c7">BlockNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16a4aab5c0f2459150efa56479af2eb819f">ConditionalStatementNode</a>
, <br />
&#160;&#160;<a class="el" href="#acac9cbaeea226ed297804c012dc12b16a9c67b92cc82860adc32a7bf2c3bdc31a">CommaOperatorNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16a211255852991e0aa4bc65fc0efb5308d">LoopNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16abdc96277641e4564f49f05fd3332a3d4">KeywordNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16aeda94965a49b65abcb13ab789c6f0ed4">AssignExpressionNode</a>
, <br />
&#160;&#160;<a class="el" href="#acac9cbaeea226ed297804c012dc12b16ae9a53f544375844ca76604ae5f2ca791">CrementNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16a5eb95c2e659ce03204e6c0b0b0c87740">UnaryOperatorNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16a1c1bb5e6682d57a60288fb496aeff4cf">BinaryOperatorNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16a050af244605ad1322fc8e7b5a0179f1b">TernaryOperatorNode</a>
, <br />
&#160;&#160;<a class="el" href="#acac9cbaeea226ed297804c012dc12b16af9a5d82c6573803b099c3adfc4b9b20c">CastNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16a7b3e1e1d3d5d99fc9af0ba930f3db50d">AttributeNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16a5eb065001855bf5fee13c8f1c40348ed">FunctionCallNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16a9501cd3ee5528bcca1e51ac8f0966994">ExternalVariableNode</a>
, <br />
&#160;&#160;<a class="el" href="#acac9cbaeea226ed297804c012dc12b16ac8a7cf9d5914e72e1b0d1d6b1209ab24">DeclareLocalNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16a641de2f20e7205326940bae22fed24d3">ArrayPackNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16aa4c2677554db379f707701e1e033b766">ArrayUnpackNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16a58e08f3e77b3e58192caac0a9a4c3465">LocalNode</a>
, <br />
&#160;&#160;<a class="el" href="#acac9cbaeea226ed297804c012dc12b16ad367abc3c089565a6428ca827885f831">ValueBoolNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16a86ec9f75634eb04e475dba4ee93933fb">ValueInt16Node</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16a764ee55f09a4bb6aac2eac083df73323">ValueInt32Node</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16aee71e3911c1b181f2d37f99668f44fc5">ValueInt64Node</a>
, <br />
&#160;&#160;<a class="el" href="#acac9cbaeea226ed297804c012dc12b16ada29dd0c7c5827571517da57d290f7ca">ValueFloatNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16ad42b26e9f262c9059e38424d71a38d60">ValueDoubleNode</a>
, <a class="el" href="#acac9cbaeea226ed297804c012dc12b16aa76996244034142252ec475e159c26bb">ValueStrNode</a>
<br />
 }</td></tr>
<tr class="memdesc:acac9cbaeea226ed297804c012dc12b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumerated list of node types for all concrete node types. These can be used for faster evaluation of a given concrete node using the virtual function table via <a class="el" href="#aff05a5224dcc24c6b53540c2578fd757" title="Virtual method for accessing node type information.">Node::nodetype()</a> rather than performing a dynamic_cast/calling <a class="el" href="#a4801cfec6882635913d378743433a560" title="Query whether or not this node is of a specific (derived) type. This method should be used to check i...">Node::isType</a>.  <a href="#acac9cbaeea226ed297804c012dc12b16">More...</a><br /></td></tr>
<tr class="memitem:abf2fb63266a358aa04393a2bb62c9478" id="r_abf2fb63266a358aa04393a2bb62c9478"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf2fb63266a358aa04393a2bb62c9478">Ptr</a> = std::shared_ptr&lt;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a>&gt;</td></tr>
<tr class="memitem:a2535f66344e41d5f3601465976377213" id="r_a2535f66344e41d5f3601465976377213"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2535f66344e41d5f3601465976377213">UniquePtr</a> = std::unique_ptr&lt;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a>&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a325a48b29994b2c5b17655fd7d7e369e" id="r_a325a48b29994b2c5b17655fd7d7e369e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a325a48b29994b2c5b17655fd7d7e369e">Node</a> ()=default</td></tr>
<tr class="memitem:aa39dab4d8faf3f7245f678b6899cd2d2" id="r_aa39dab4d8faf3f7245f678b6899cd2d2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa39dab4d8faf3f7245f678b6899cd2d2">~Node</a> ()=default</td></tr>
<tr class="memitem:a9729de7a5ee9e46534f79c2f3c5cbff7" id="r_a9729de7a5ee9e46534f79c2f3c5cbff7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9729de7a5ee9e46534f79c2f3c5cbff7">copy</a> () const =0</td></tr>
<tr class="memdesc:a9729de7a5ee9e46534f79c2f3c5cbff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The deep copy method for a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">Node</a>.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Name/Type</div></td></tr>
<tr class="memitem:aff05a5224dcc24c6b53540c2578fd757" id="r_aff05a5224dcc24c6b53540c2578fd757"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#acac9cbaeea226ed297804c012dc12b16">NodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff05a5224dcc24c6b53540c2578fd757">nodetype</a> () const =0</td></tr>
<tr class="memdesc:aff05a5224dcc24c6b53540c2578fd757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method for accessing node type information.  <br /></td></tr>
<tr class="memitem:a9cb821a029b533b95773379f9b68ba71" id="r_a9cb821a029b533b95773379f9b68ba71"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cb821a029b533b95773379f9b68ba71">nodename</a> () const =0</td></tr>
<tr class="memdesc:a9cb821a029b533b95773379f9b68ba71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method for accessing node name information.  <br /></td></tr>
<tr class="memitem:a9ca593c388e3e1fb286fd2b18acc2862" id="r_a9ca593c388e3e1fb286fd2b18acc2862"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ca593c388e3e1fb286fd2b18acc2862">subname</a> () const =0</td></tr>
<tr class="memdesc:a9ca593c388e3e1fb286fd2b18acc2862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method for accessing node name information.  <br /></td></tr>
<tr class="memitem:ae7a9ca73639fc90df1a5c5ad3e024f94" id="r_ae7a9ca73639fc90df1a5c5ad3e024f94"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7a9ca73639fc90df1a5c5ad3e024f94">basetype</a> () const</td></tr>
<tr class="memdesc:ae7a9ca73639fc90df1a5c5ad3e024f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method for accessing a node's base class. Note that if this is called explicitly on an instance of <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">ast::Node</a> (the top most base class) a nullptr is returned. This is primarily used by the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Visitor.html" title="The Visitor class uses the Curiously Recursive Template Pattern (CRTP) to provide a customizable inte...">Visitor</a> to support hierarchical visits.  <br /></td></tr>
<tr class="memitem:a4801cfec6882635913d378743433a560" id="r_a4801cfec6882635913d378743433a560"><td class="memTemplParams" colspan="2">template&lt;typename NodeT&gt; </td></tr>
<tr class="memitem:a4801cfec6882635913d378743433a560 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4801cfec6882635913d378743433a560">isType</a> () const</td></tr>
<tr class="memdesc:a4801cfec6882635913d378743433a560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether or not this node is of a specific (derived) type. This method should be used to check if a node is of a particular abstract type. When checking concrete types, it's generally more efficient to check the return value of <a class="el" href="#aff05a5224dcc24c6b53540c2578fd757" title="Virtual method for accessing node type information.">Node::nodetype()</a>  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Child Queries</div></td></tr>
<tr class="memitem:a3f2d1d94b348dcc8971f328b4bd41eb0" id="r_a3f2d1d94b348dcc8971f328b4bd41eb0"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f2d1d94b348dcc8971f328b4bd41eb0">children</a> () const =0</td></tr>
<tr class="memdesc:a3f2d1d94b348dcc8971f328b4bd41eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method for accessing child information. Returns the number of children a given AST node owns.  <br /></td></tr>
<tr class="memitem:a5dd2335d2b5967df299e049c89477bc1" id="r_a5dd2335d2b5967df299e049c89477bc1"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dd2335d2b5967df299e049c89477bc1">child</a> (const size_t index) const =0</td></tr>
<tr class="memdesc:a5dd2335d2b5967df299e049c89477bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method for accessing child information. Returns a const pointer to a child node at the given index. If the index is out of range, a nullptr is returned.  <br /></td></tr>
<tr class="memitem:a818561f63c248e8c2b3a329ad1cbd894" id="r_a818561f63c248e8c2b3a329ad1cbd894"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a818561f63c248e8c2b3a329ad1cbd894">childidx</a> () const</td></tr>
<tr class="memdesc:a818561f63c248e8c2b3a329ad1cbd894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the child index of this node in relation to its parent, or -1 if no valid index is found (usually representing the top most node (i.e. <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy....">Tree</a>)  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Replacement</div></td></tr>
<tr class="memitem:a0919d7b8b04ebb9fadd7eb3c99db5929" id="r_a0919d7b8b04ebb9fadd7eb3c99db5929"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0919d7b8b04ebb9fadd7eb3c99db5929">replace</a> (<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a0919d7b8b04ebb9fadd7eb3c99db5929"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place replacement. Attempts to replace this node at its specific location within its Abstract Syntax <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy....">Tree</a>. On a successful replacement, this node is destroyed, the provided node is inserted in its place and ownership is transferred to the parent node. No further calls to this node can be made on successful replacements.  <br /></td></tr>
<tr class="memitem:a39adc7dd66d859ef6f4ad0f7d1455692" id="r_a39adc7dd66d859ef6f4ad0f7d1455692"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39adc7dd66d859ef6f4ad0f7d1455692">replacechild</a> (const size_t index, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a39adc7dd66d859ef6f4ad0f7d1455692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method that attempted to replace a child at a given index with a provided node type.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Parent</h2></td></tr>
<tr class="memitem:af2e952097b8ed5eb6a7f598462c7a630" id="r_af2e952097b8ed5eb6a7f598462c7a630"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2e952097b8ed5eb6a7f598462c7a630">parent</a> () const</td></tr>
<tr class="memdesc:af2e952097b8ed5eb6a7f598462c7a630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a const pointer to this nodes parent.  <br /></td></tr>
<tr class="memitem:ade468b936d43438b4fd722bea1243b5d" id="r_ade468b936d43438b4fd722bea1243b5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade468b936d43438b4fd722bea1243b5d">setParent</a> (<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> *<a class="el" href="#af2e952097b8ed5eb6a7f598462c7a630">parent</a>)</td></tr>
<tr class="memdesc:ade468b936d43438b4fd722bea1243b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this node's parent. This is used during construction of an AST and should not be used.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The base abstract node which determines the interface and required methods for all derived concrete nodes which comprise a valid AST. </p>
<p>A reference list of all abstract and concrete AST nodes in hierarchical order (non-linear) Abstract nodes:</p><ul>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">Node</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Statement.html" title="Abstract (pure-virtual) AST nodes.">Statement</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Expression.html" title="Expressions are comprised of full or potentially partial parts of a full statement that may not neces...">Expression</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html" title="Variables are a base type for Locals, Attributes and ExternalVariables. Unlike other abstract types,...">Variable</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ValueBase.html" title="ValueBases are a base class for anything that holds a value (literal). Derived classes store the actu...">ValueBase</a></li>
</ul>
<p>Concrete nodes:</p><ul>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy....">Tree</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1StatementList.html" title="Concrete AST nodes.">StatementList</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html" title="A Block node represents a scoped list of statements. It may comprise of 0 or more statements,...">Block</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Loop.html" title="Loops represent for, while and do-while loop constructs. These all consist of a condition - evaluated...">Loop</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Keyword.html" title="Keywords represent keyword statements defining changes in execution. These include those that define ...">Keyword</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html" title="ConditionalStatements represents all combinations of &#39;if&#39;, &#39;else&#39; and &#39;else if&#39; syntax and semantics....">ConditionalStatement</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1CommaOperator.html">CommaOperator</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html" title="A BinaryOperator represents a single binary operation between a left hand side (LHS) and right hand s...">BinaryOperator</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html" title="A TernaryOperator represents a ternary (conditional) expression &#39;a ? b : c&#39; which evaluates to &#39;b&#39; if...">TernaryOperator</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1AssignExpression.html" title="AssignExpressions represents a similar object construction to a BinaryOperator. AssignExpressions can...">AssignExpression</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html" title="A Crement node represents a single increment &#39;++&#39; and decrement &#39;â€“&#39; operation. As well as it&#39;s cremen...">Crement</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html" title="A UnaryOperator represents a single unary operation on an expression. The operation type is stored as...">UnaryOperator</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html" title="Cast nodes represent the conversion of an underlying expression to a target type. Cast nodes are typi...">Cast</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1FunctionCall.html" title="FunctionCalls represent a single call to a function and any provided arguments. The argument list can...">FunctionCall</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html" title="ArrayUnpack represent indexing operations into AX container types, primarily vectors and matrices ind...">ArrayUnpack</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayPack.html" title="ArrayPacks represent temporary container creations of arbitrary sizes, typically generated through th...">ArrayPack</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html" title="Attributes represent any access to a primitive value, typically associated with the &#39;@&#39; symbol syntax...">Attribute</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html" title="DeclareLocal AST nodes symbolize a single type declaration of a local variable. These store the local...">DeclareLocal</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Local.html" title="Local AST nodes represent a single accesses to a local variable. The only store the name of the varia...">Local</a></li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value.html" title="A Value (literal) AST node holds either literal text or absolute value information on all numerical,...">Value</a>&lt;double/float/int32_t/int16_t/int64_t/bool&gt;</li>
<li><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value_3_01std_1_1string_01_4.html" title="Specialization of Values for strings.">Value&lt;std::string&gt;</a> <dl class="section note"><dt>Note</dt><dd>All AST nodes share a few common characteristics. All constructors typically take pointers to the abstract (pure-virtual) node types and assume ownership of this data on successful construction. Deep copy methods propagate down through all children of a given AST node but have the unique behavior of ensuring parent data is updated to the newly created parent nodes. Due to this behavior and the fact that most nodes store unique pointers to other nodes, we've omitted comparison and equality operators. </dd></dl>
</li>
</ul>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="abf2fb63266a358aa04393a2bb62c9478" name="abf2fb63266a358aa04393a2bb62c9478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2fb63266a358aa04393a2bb62c9478">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abf2fb63266a358aa04393a2bb62c9478">Ptr</a> = std::shared_ptr&lt;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2535f66344e41d5f3601465976377213" name="a2535f66344e41d5f3601465976377213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2535f66344e41d5f3601465976377213">&#9670;&#160;</a></span>UniquePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2535f66344e41d5f3601465976377213">UniquePtr</a> = std::unique_ptr&lt;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="acac9cbaeea226ed297804c012dc12b16" name="acac9cbaeea226ed297804c012dc12b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac9cbaeea226ed297804c012dc12b16">&#9670;&#160;</a></span>NodeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#acac9cbaeea226ed297804c012dc12b16">NodeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An enumerated list of node types for all concrete node types. These can be used for faster evaluation of a given concrete node using the virtual function table via <a class="el" href="#aff05a5224dcc24c6b53540c2578fd757" title="Virtual method for accessing node type information.">Node::nodetype()</a> rather than performing a dynamic_cast/calling <a class="el" href="#a4801cfec6882635913d378743433a560" title="Query whether or not this node is of a specific (derived) type. This method should be used to check i...">Node::isType</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This is sometimes referred to as "manual RTTI". We use this technique combine with single dispatch due to opting for CRTP on the main visitor and no templated virtual method support in C++. i.e. no way to double dispatch: visit&lt;template T&gt;(Visitor&lt;T&gt;*) </dd>
<dd>
Abstract (pure-virtual) nodes are not listed here. <a class="el" href="#a4801cfec6882635913d378743433a560" title="Query whether or not this node is of a specific (derived) type. This method should be used to check i...">Node::isType</a> should be used to determine if a node is of a given abstract type. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a6e3c9853eac7f791316173112a4c920d" name="acac9cbaeea226ed297804c012dc12b16a6e3c9853eac7f791316173112a4c920d"></a>TreeNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a48e5c1876288bf22cd46f986e38adf02" name="acac9cbaeea226ed297804c012dc12b16a48e5c1876288bf22cd46f986e38adf02"></a>StatementListNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a43780fadfdb2235144acada7dbe105c7" name="acac9cbaeea226ed297804c012dc12b16a43780fadfdb2235144acada7dbe105c7"></a>BlockNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a4aab5c0f2459150efa56479af2eb819f" name="acac9cbaeea226ed297804c012dc12b16a4aab5c0f2459150efa56479af2eb819f"></a>ConditionalStatementNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a9c67b92cc82860adc32a7bf2c3bdc31a" name="acac9cbaeea226ed297804c012dc12b16a9c67b92cc82860adc32a7bf2c3bdc31a"></a>CommaOperatorNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a211255852991e0aa4bc65fc0efb5308d" name="acac9cbaeea226ed297804c012dc12b16a211255852991e0aa4bc65fc0efb5308d"></a>LoopNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16abdc96277641e4564f49f05fd3332a3d4" name="acac9cbaeea226ed297804c012dc12b16abdc96277641e4564f49f05fd3332a3d4"></a>KeywordNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16aeda94965a49b65abcb13ab789c6f0ed4" name="acac9cbaeea226ed297804c012dc12b16aeda94965a49b65abcb13ab789c6f0ed4"></a>AssignExpressionNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16ae9a53f544375844ca76604ae5f2ca791" name="acac9cbaeea226ed297804c012dc12b16ae9a53f544375844ca76604ae5f2ca791"></a>CrementNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a5eb95c2e659ce03204e6c0b0b0c87740" name="acac9cbaeea226ed297804c012dc12b16a5eb95c2e659ce03204e6c0b0b0c87740"></a>UnaryOperatorNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a1c1bb5e6682d57a60288fb496aeff4cf" name="acac9cbaeea226ed297804c012dc12b16a1c1bb5e6682d57a60288fb496aeff4cf"></a>BinaryOperatorNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a050af244605ad1322fc8e7b5a0179f1b" name="acac9cbaeea226ed297804c012dc12b16a050af244605ad1322fc8e7b5a0179f1b"></a>TernaryOperatorNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16af9a5d82c6573803b099c3adfc4b9b20c" name="acac9cbaeea226ed297804c012dc12b16af9a5d82c6573803b099c3adfc4b9b20c"></a>CastNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a7b3e1e1d3d5d99fc9af0ba930f3db50d" name="acac9cbaeea226ed297804c012dc12b16a7b3e1e1d3d5d99fc9af0ba930f3db50d"></a>AttributeNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a5eb065001855bf5fee13c8f1c40348ed" name="acac9cbaeea226ed297804c012dc12b16a5eb065001855bf5fee13c8f1c40348ed"></a>FunctionCallNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a9501cd3ee5528bcca1e51ac8f0966994" name="acac9cbaeea226ed297804c012dc12b16a9501cd3ee5528bcca1e51ac8f0966994"></a>ExternalVariableNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16ac8a7cf9d5914e72e1b0d1d6b1209ab24" name="acac9cbaeea226ed297804c012dc12b16ac8a7cf9d5914e72e1b0d1d6b1209ab24"></a>DeclareLocalNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a641de2f20e7205326940bae22fed24d3" name="acac9cbaeea226ed297804c012dc12b16a641de2f20e7205326940bae22fed24d3"></a>ArrayPackNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16aa4c2677554db379f707701e1e033b766" name="acac9cbaeea226ed297804c012dc12b16aa4c2677554db379f707701e1e033b766"></a>ArrayUnpackNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a58e08f3e77b3e58192caac0a9a4c3465" name="acac9cbaeea226ed297804c012dc12b16a58e08f3e77b3e58192caac0a9a4c3465"></a>LocalNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16ad367abc3c089565a6428ca827885f831" name="acac9cbaeea226ed297804c012dc12b16ad367abc3c089565a6428ca827885f831"></a>ValueBoolNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a86ec9f75634eb04e475dba4ee93933fb" name="acac9cbaeea226ed297804c012dc12b16a86ec9f75634eb04e475dba4ee93933fb"></a>ValueInt16Node&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16a764ee55f09a4bb6aac2eac083df73323" name="acac9cbaeea226ed297804c012dc12b16a764ee55f09a4bb6aac2eac083df73323"></a>ValueInt32Node&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16aee71e3911c1b181f2d37f99668f44fc5" name="acac9cbaeea226ed297804c012dc12b16aee71e3911c1b181f2d37f99668f44fc5"></a>ValueInt64Node&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16ada29dd0c7c5827571517da57d290f7ca" name="acac9cbaeea226ed297804c012dc12b16ada29dd0c7c5827571517da57d290f7ca"></a>ValueFloatNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16ad42b26e9f262c9059e38424d71a38d60" name="acac9cbaeea226ed297804c012dc12b16ad42b26e9f262c9059e38424d71a38d60"></a>ValueDoubleNode&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acac9cbaeea226ed297804c012dc12b16aa76996244034142252ec475e159c26bb" name="acac9cbaeea226ed297804c012dc12b16aa76996244034142252ec475e159c26bb"></a>ValueStrNode&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a325a48b29994b2c5b17655fd7d7e369e" name="a325a48b29994b2c5b17655fd7d7e369e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325a48b29994b2c5b17655fd7d7e369e">&#9670;&#160;</a></span>Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa39dab4d8faf3f7245f678b6899cd2d2" name="aa39dab4d8faf3f7245f678b6899cd2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39dab4d8faf3f7245f678b6899cd2d2">&#9670;&#160;</a></span>~Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ae7a9ca73639fc90df1a5c5ad3e024f94" name="ae7a9ca73639fc90df1a5c5ad3e024f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a9ca73639fc90df1a5c5ad3e024f94">&#9670;&#160;</a></span>basetype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> * basetype </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method for accessing a node's base class. Note that if this is called explicitly on an instance of <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">ast::Node</a> (the top most base class) a nullptr is returned. This is primarily used by the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Visitor.html" title="The Visitor class uses the Curiously Recursive Template Pattern (CRTP) to provide a customizable inte...">Visitor</a> to support hierarchical visits. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current node as its base class type. </dd></dl>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayPack.html#a86dc27762670e13b020876d41933d1b0">ArrayPack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html#a86dc27762670e13b020876d41933d1b0">ArrayUnpack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1AssignExpression.html#a86dc27762670e13b020876d41933d1b0">AssignExpression</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html#a7b951be3c63297f75a386ce3366cffe4">Attribute</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html#a86dc27762670e13b020876d41933d1b0">BinaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html#a2d142a3e0977323d22ef495dd9d1faa2">Block</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html#a86dc27762670e13b020876d41933d1b0">Cast</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1CommaOperator.html#a86dc27762670e13b020876d41933d1b0">CommaOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html#a2d142a3e0977323d22ef495dd9d1faa2">ConditionalStatement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html#a86dc27762670e13b020876d41933d1b0">Crement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html#a2d142a3e0977323d22ef495dd9d1faa2">DeclareLocal</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Expression.html#a2d142a3e0977323d22ef495dd9d1faa2">Expression</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ExternalVariable.html#a7b951be3c63297f75a386ce3366cffe4">ExternalVariable</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1FunctionCall.html#a86dc27762670e13b020876d41933d1b0">FunctionCall</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Keyword.html#a2d142a3e0977323d22ef495dd9d1faa2">Keyword</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Local.html#a7b951be3c63297f75a386ce3366cffe4">Local</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Loop.html#a2d142a3e0977323d22ef495dd9d1faa2">Loop</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Statement.html#a5b0100a28088fb6a83b924a381851e02">Statement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1StatementList.html#a2d142a3e0977323d22ef495dd9d1faa2">StatementList</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html#a86dc27762670e13b020876d41933d1b0">TernaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html#a5b0100a28088fb6a83b924a381851e02">Tree</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html#a86dc27762670e13b020876d41933d1b0">UnaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value.html#a363670fa8d886925d0dd5d0c95c9f3a6">Value&lt; T &gt;</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value_3_01std_1_1string_01_4.html#a363670fa8d886925d0dd5d0c95c9f3a6">Value&lt; std::string &gt;</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ValueBase.html#a86dc27762670e13b020876d41933d1b0">ValueBase</a>, and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html#a86dc27762670e13b020876d41933d1b0">Variable</a>.</p>

</div>
</div>
<a id="a5dd2335d2b5967df299e049c89477bc1" name="a5dd2335d2b5967df299e049c89477bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd2335d2b5967df299e049c89477bc1">&#9670;&#160;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> * child </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method for accessing child information. Returns a const pointer to a child node at the given index. If the index is out of range, a nullptr is returned. </p>
<dl class="section note"><dt>Note</dt><dd>This may still return a nullptr even if the given index is valid if the child node has not been created. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The child index to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Pointer to the child node, or a nullptr if none exists. </dd></dl>

<p>Implemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayPack.html#a1a27eaf47cc30df4a4c30ec7dd95cfaf">ArrayPack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html#a312424787fd4827b709d9b85a6f21b19">ArrayUnpack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1AssignExpression.html#a1a27eaf47cc30df4a4c30ec7dd95cfaf">AssignExpression</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html#a1a27eaf47cc30df4a4c30ec7dd95cfaf">BinaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html#a312424787fd4827b709d9b85a6f21b19">Block</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html#a1a27eaf47cc30df4a4c30ec7dd95cfaf">Cast</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1CommaOperator.html#a1a27eaf47cc30df4a4c30ec7dd95cfaf">CommaOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html#a312424787fd4827b709d9b85a6f21b19">ConditionalStatement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html#a1a27eaf47cc30df4a4c30ec7dd95cfaf">Crement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html#a1a27eaf47cc30df4a4c30ec7dd95cfaf">DeclareLocal</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1FunctionCall.html#a1a27eaf47cc30df4a4c30ec7dd95cfaf">FunctionCall</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Keyword.html#abaa176ed7067d95e1292dbc702c8aa4c">Keyword</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Loop.html#a312424787fd4827b709d9b85a6f21b19">Loop</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1StatementList.html#a312424787fd4827b709d9b85a6f21b19">StatementList</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html#a1a27eaf47cc30df4a4c30ec7dd95cfaf">TernaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html#ad7936c578a42433bb090509654f46e60">Tree</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html#a1a27eaf47cc30df4a4c30ec7dd95cfaf">UnaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ValueBase.html#acaccc17508c7a2bca1eec66867b734f2">ValueBase</a>, and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html#acaccc17508c7a2bca1eec66867b734f2">Variable</a>.</p>

</div>
</div>
<a id="a818561f63c248e8c2b3a329ad1cbd894" name="a818561f63c248e8c2b3a329ad1cbd894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818561f63c248e8c2b3a329ad1cbd894">&#9670;&#160;</a></span>childidx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t childidx </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the child index of this node in relation to its parent, or -1 if no valid index is found (usually representing the top most node (i.e. <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy....">Tree</a>) </p>
<dl class="section return"><dt>Returns</dt><dd>The child index of this node </dd></dl>

</div>
</div>
<a id="a3f2d1d94b348dcc8971f328b4bd41eb0" name="a3f2d1d94b348dcc8971f328b4bd41eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2d1d94b348dcc8971f328b4bd41eb0">&#9670;&#160;</a></span>children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t children </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method for accessing child information. Returns the number of children a given AST node owns. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of children this node owns. </dd></dl>

<p>Implemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayPack.html#a254f3d183d1324e0b951c36f470c3476">ArrayPack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html#a254f3d183d1324e0b951c36f470c3476">ArrayUnpack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1AssignExpression.html#a254f3d183d1324e0b951c36f470c3476">AssignExpression</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html#a254f3d183d1324e0b951c36f470c3476">BinaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html#a254f3d183d1324e0b951c36f470c3476">Block</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html#a254f3d183d1324e0b951c36f470c3476">Cast</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1CommaOperator.html#a254f3d183d1324e0b951c36f470c3476">CommaOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html#a254f3d183d1324e0b951c36f470c3476">ConditionalStatement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html#a254f3d183d1324e0b951c36f470c3476">Crement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html#a254f3d183d1324e0b951c36f470c3476">DeclareLocal</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1FunctionCall.html#a254f3d183d1324e0b951c36f470c3476">FunctionCall</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Keyword.html#a254f3d183d1324e0b951c36f470c3476">Keyword</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Loop.html#a254f3d183d1324e0b951c36f470c3476">Loop</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1StatementList.html#a254f3d183d1324e0b951c36f470c3476">StatementList</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html#a254f3d183d1324e0b951c36f470c3476">TernaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html#a254f3d183d1324e0b951c36f470c3476">Tree</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html#a254f3d183d1324e0b951c36f470c3476">UnaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ValueBase.html#a188eac545914550f707f8ad7e2ba3dd0">ValueBase</a>, and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html#a188eac545914550f707f8ad7e2ba3dd0">Variable</a>.</p>

</div>
</div>
<a id="a9729de7a5ee9e46534f79c2f3c5cbff7" name="a9729de7a5ee9e46534f79c2f3c5cbff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9729de7a5ee9e46534f79c2f3c5cbff7">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> * copy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The deep copy method for a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">Node</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A deep copy of the current node and all its children </dd></dl>

<p>Implemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayPack.html#a3b931017fa38bae16a9018cdded72907">ArrayPack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html#a11f96805945c4875d786ba9bd3fa8b1f">ArrayUnpack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1AssignExpression.html#a1279ee70e3627521eb613319f6681e58">AssignExpression</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html#aae84f28bb0ac9923abb8ef4886511670">Attribute</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html#a6cf725406d76f29c72a3923f046661f3">BinaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html#aba4c1b4d2e0ccb51a3652622660b073c">Block</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html#a8dabe6e3ba8fdb549148eee45249205a">Cast</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1CommaOperator.html#adec5be8cc1db9e6d2b05b4a5d358c529">CommaOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html#a58b3e45189ab04aa933a2826311a637a">ConditionalStatement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html#a65ec5a6c59290ad5069e4a921e2b48a5">Crement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html#a2f8680830e4187b34cd4f8d6e7a77706">DeclareLocal</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Expression.html#a0db37ae8c886bc7077c313c0e542f004">Expression</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ExternalVariable.html#ae6526001d5eb1fa02303c4060c8cac86">ExternalVariable</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1FunctionCall.html#aa60b829ae6791e0f6298977a0a93b86a">FunctionCall</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Keyword.html#a42af6965da10d6ab37000456a36cc109">Keyword</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Local.html#adb9f930ab93a7d6fb3b5c8988d53ffc1">Local</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Loop.html#a4742cf492be72b05ec42256517129f0a">Loop</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Statement.html#acf6ddfe2cf87a2408b5d1cc4d31df92d">Statement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1StatementList.html#ae8f72e75d26678e44aa19c4868c4ba29">StatementList</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html#a429652ca72854564e3a89c53bff7bf49">TernaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html#a7291fb6a4d0947c11ff1e3a0320cad5f">Tree</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html#aea1075aa34880a2295703e56451e0b86">UnaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value.html#a25153a3b15b74ac737c7fc1895bc9e34">Value&lt; T &gt;</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value_3_01std_1_1string_01_4.html#a25153a3b15b74ac737c7fc1895bc9e34">Value&lt; std::string &gt;</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ValueBase.html#a0db37ae8c886bc7077c313c0e542f004">ValueBase</a>, and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html#a7ce8ea1af6f6bce6cc291c7d588f9282">Variable</a>.</p>

</div>
</div>
<a id="a4801cfec6882635913d378743433a560" name="a4801cfec6882635913d378743433a560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4801cfec6882635913d378743433a560">&#9670;&#160;</a></span>isType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether or not this node is of a specific (derived) type. This method should be used to check if a node is of a particular abstract type. When checking concrete types, it's generally more efficient to check the return value of <a class="el" href="#aff05a5224dcc24c6b53540c2578fd757" title="Virtual method for accessing node type information.">Node::nodetype()</a> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NodeT</td><td>The node type to query against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this node is of the given type, false otherwise. </dd></dl>

</div>
</div>
<a id="a9cb821a029b533b95773379f9b68ba71" name="a9cb821a029b533b95773379f9b68ba71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb821a029b533b95773379f9b68ba71">&#9670;&#160;</a></span>nodename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * nodename </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method for accessing node name information. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the node class name </dd></dl>

<p>Implemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayPack.html#a19b2063b92e15836b29c180eed462f9f">ArrayPack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html#a19b2063b92e15836b29c180eed462f9f">ArrayUnpack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1AssignExpression.html#a19b2063b92e15836b29c180eed462f9f">AssignExpression</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html#a19b2063b92e15836b29c180eed462f9f">Attribute</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html#a19b2063b92e15836b29c180eed462f9f">BinaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html#a19b2063b92e15836b29c180eed462f9f">Block</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html#a19b2063b92e15836b29c180eed462f9f">Cast</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1CommaOperator.html#a19b2063b92e15836b29c180eed462f9f">CommaOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html#a19b2063b92e15836b29c180eed462f9f">ConditionalStatement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html#a19b2063b92e15836b29c180eed462f9f">Crement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html#a19b2063b92e15836b29c180eed462f9f">DeclareLocal</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ExternalVariable.html#a19b2063b92e15836b29c180eed462f9f">ExternalVariable</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1FunctionCall.html#a19b2063b92e15836b29c180eed462f9f">FunctionCall</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Keyword.html#a19b2063b92e15836b29c180eed462f9f">Keyword</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Local.html#a19b2063b92e15836b29c180eed462f9f">Local</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Loop.html#a19b2063b92e15836b29c180eed462f9f">Loop</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1StatementList.html#a19b2063b92e15836b29c180eed462f9f">StatementList</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html#a19b2063b92e15836b29c180eed462f9f">TernaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html#a19b2063b92e15836b29c180eed462f9f">Tree</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html#a19b2063b92e15836b29c180eed462f9f">UnaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value.html#a19b2063b92e15836b29c180eed462f9f">Value&lt; T &gt;</a>, and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value_3_01std_1_1string_01_4.html#a19b2063b92e15836b29c180eed462f9f">Value&lt; std::string &gt;</a>.</p>

</div>
</div>
<a id="aff05a5224dcc24c6b53540c2578fd757" name="aff05a5224dcc24c6b53540c2578fd757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff05a5224dcc24c6b53540c2578fd757">&#9670;&#160;</a></span>nodetype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#acac9cbaeea226ed297804c012dc12b16">NodeType</a> nodetype </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method for accessing node type information. </p>
<dl class="section note"><dt>Note</dt><dd>This method should be used when querying a concrete nodes type. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the enumerated node type from the <a class="el" href="#acac9cbaeea226ed297804c012dc12b16" title="An enumerated list of node types for all concrete node types. These can be used for faster evaluation...">NodeType</a> list </dd></dl>

<p>Implemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayPack.html#a02380ba656f6431fa853aee00eeb42e8">ArrayPack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html#a02380ba656f6431fa853aee00eeb42e8">ArrayUnpack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1AssignExpression.html#a02380ba656f6431fa853aee00eeb42e8">AssignExpression</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html#a02380ba656f6431fa853aee00eeb42e8">Attribute</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html#a02380ba656f6431fa853aee00eeb42e8">BinaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html#a02380ba656f6431fa853aee00eeb42e8">Block</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html#a02380ba656f6431fa853aee00eeb42e8">Cast</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1CommaOperator.html#a02380ba656f6431fa853aee00eeb42e8">CommaOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html#a02380ba656f6431fa853aee00eeb42e8">ConditionalStatement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html#a02380ba656f6431fa853aee00eeb42e8">Crement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html#a02380ba656f6431fa853aee00eeb42e8">DeclareLocal</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ExternalVariable.html#a02380ba656f6431fa853aee00eeb42e8">ExternalVariable</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1FunctionCall.html#a02380ba656f6431fa853aee00eeb42e8">FunctionCall</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Keyword.html#a02380ba656f6431fa853aee00eeb42e8">Keyword</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Local.html#a02380ba656f6431fa853aee00eeb42e8">Local</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Loop.html#a02380ba656f6431fa853aee00eeb42e8">Loop</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1StatementList.html#a02380ba656f6431fa853aee00eeb42e8">StatementList</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html#a02380ba656f6431fa853aee00eeb42e8">TernaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html#a02380ba656f6431fa853aee00eeb42e8">Tree</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html#a02380ba656f6431fa853aee00eeb42e8">UnaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value.html#a02380ba656f6431fa853aee00eeb42e8">Value&lt; T &gt;</a>, and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value_3_01std_1_1string_01_4.html#a02380ba656f6431fa853aee00eeb42e8">Value&lt; std::string &gt;</a>.</p>

</div>
</div>
<a id="af2e952097b8ed5eb6a7f598462c7a630" name="af2e952097b8ed5eb6a7f598462c7a630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e952097b8ed5eb6a7f598462c7a630">&#9670;&#160;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> * parent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a const pointer to this nodes parent. </p>
<dl class="section note"><dt>Note</dt><dd>Can be a nullptr if this is the top most node in an AST (usually a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy....">Tree</a>) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to this node's parent node </dd></dl>

</div>
</div>
<a id="a0919d7b8b04ebb9fadd7eb3c99db5929" name="a0919d7b8b04ebb9fadd7eb3c99db5929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0919d7b8b04ebb9fadd7eb3c99db5929">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In place replacement. Attempts to replace this node at its specific location within its Abstract Syntax <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy....">Tree</a>. On a successful replacement, this node is destroyed, the provided node is inserted in its place and ownership is transferred to the parent node. No further calls to this node can be made on successful replacements. </p>
<dl class="section note"><dt>Note</dt><dd>A replacement will fail if this node is the top most node within an AST hierarchy or if the provided node type is not a compatible type for the required abstract storage. For example, if this node is an <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html" title="Attributes represent any access to a primitive value, typically associated with the &#39;@&#39; symbol syntax...">Attribute</a> being held on a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html" title="A BinaryOperator represents a single binary operation between a left hand side (LHS) and right hand s...">BinaryOperator</a>, only concrete nodes derived from an <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Expression.html" title="Expressions are comprised of full or potentially partial parts of a full statement that may not neces...">Expression</a> can be used as a replacement. </dd>
<dd>
This method will dynamic_cast the provided node to check to see if it's a compatible type. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to insert on a successful replacement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the replacement was successful, resulting in destruction of this class and ownership transferal of the provided node. False otherwise, where this and the provided node are unchanged. </dd></dl>

</div>
</div>
<a id="a39adc7dd66d859ef6f4ad0f7d1455692" name="a39adc7dd66d859ef6f4ad0f7d1455692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39adc7dd66d859ef6f4ad0f7d1455692">&#9670;&#160;</a></span>replacechild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool replacechild </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method that attempted to replace a child at a given index with a provided node type. </p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="#a0919d7b8b04ebb9fadd7eb3c99db5929" title="In place replacement. Attempts to replace this node at its specific location within its Abstract Synt...">Node::replace</a> for a more detailed description </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The child index where a replacement should be attempted </td></tr>
    <tr><td class="paramname">node</td><td>The node to insert on a successful replacement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the replacement was successful, false otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayPack.html#a87ac5af79c8c0df3592f36a6caaad473">ArrayPack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html#a87ac5af79c8c0df3592f36a6caaad473">ArrayUnpack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1AssignExpression.html#a87ac5af79c8c0df3592f36a6caaad473">AssignExpression</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html#a87ac5af79c8c0df3592f36a6caaad473">BinaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html#a87ac5af79c8c0df3592f36a6caaad473">Block</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html#a87ac5af79c8c0df3592f36a6caaad473">Cast</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1CommaOperator.html#a87ac5af79c8c0df3592f36a6caaad473">CommaOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html#a87ac5af79c8c0df3592f36a6caaad473">ConditionalStatement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html#a87ac5af79c8c0df3592f36a6caaad473">Crement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html#a87ac5af79c8c0df3592f36a6caaad473">DeclareLocal</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1FunctionCall.html#a87ac5af79c8c0df3592f36a6caaad473">FunctionCall</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Loop.html#a87ac5af79c8c0df3592f36a6caaad473">Loop</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1StatementList.html#a87ac5af79c8c0df3592f36a6caaad473">StatementList</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html#a87ac5af79c8c0df3592f36a6caaad473">TernaryOperator</a>, and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html#a87ac5af79c8c0df3592f36a6caaad473">UnaryOperator</a>.</p>

</div>
</div>
<a id="ade468b936d43438b4fd722bea1243b5d" name="ade468b936d43438b4fd722bea1243b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade468b936d43438b4fd722bea1243b5d">&#9670;&#160;</a></span>setParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>parent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this node's parent. This is used during construction of an AST and should not be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ca593c388e3e1fb286fd2b18acc2862" name="a9ca593c388e3e1fb286fd2b18acc2862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca593c388e3e1fb286fd2b18acc2862">&#9670;&#160;</a></span>subname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * subname </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method for accessing node name information. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the short node class name </dd></dl>

<p>Implemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayPack.html#ada28fb03ff59d5c3268f2b06e1d7f809">ArrayPack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html#ada28fb03ff59d5c3268f2b06e1d7f809">ArrayUnpack</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1AssignExpression.html#ada28fb03ff59d5c3268f2b06e1d7f809">AssignExpression</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html#ada28fb03ff59d5c3268f2b06e1d7f809">Attribute</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html#ada28fb03ff59d5c3268f2b06e1d7f809">BinaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html#ada28fb03ff59d5c3268f2b06e1d7f809">Block</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html#ada28fb03ff59d5c3268f2b06e1d7f809">Cast</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1CommaOperator.html#ada28fb03ff59d5c3268f2b06e1d7f809">CommaOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html#ada28fb03ff59d5c3268f2b06e1d7f809">ConditionalStatement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html#ada28fb03ff59d5c3268f2b06e1d7f809">Crement</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html#ada28fb03ff59d5c3268f2b06e1d7f809">DeclareLocal</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ExternalVariable.html#ada28fb03ff59d5c3268f2b06e1d7f809">ExternalVariable</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1FunctionCall.html#ada28fb03ff59d5c3268f2b06e1d7f809">FunctionCall</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Keyword.html#ada28fb03ff59d5c3268f2b06e1d7f809">Keyword</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Local.html#ada28fb03ff59d5c3268f2b06e1d7f809">Local</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Loop.html#ada28fb03ff59d5c3268f2b06e1d7f809">Loop</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1StatementList.html#ada28fb03ff59d5c3268f2b06e1d7f809">StatementList</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html#ada28fb03ff59d5c3268f2b06e1d7f809">TernaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html#ada28fb03ff59d5c3268f2b06e1d7f809">Tree</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html#ada28fb03ff59d5c3268f2b06e1d7f809">UnaryOperator</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value.html#ada28fb03ff59d5c3268f2b06e1d7f809">Value&lt; T &gt;</a>, and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value_3_01std_1_1string_01_4.html#ada28fb03ff59d5c3268f2b06e1d7f809">Value&lt; std::string &gt;</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax.html">ax</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast.html">ast</a></li><li class="navelem"><a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
