<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: IRFunction&lt; SignatureT &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunction.html','','structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunction-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">IRFunction&lt; SignatureT &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents a concrete IR function.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="FunctionTypes_8h_source.html">openvdb_ax/codegen/FunctionTypes.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2846ade648824cd69bd0fdc3d2cee4ca" id="r_a2846ade648824cd69bd0fdc3d2cee4ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2846ade648824cd69bd0fdc3d2cee4ca">Traits</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionTraits.html">FunctionTraits</a>&lt;SignatureT&gt;</td></tr>
<tr class="memitem:afcea31012bfb06b6c9a619df966c7f50" id="r_afcea31012bfb06b6c9a619df966c7f50"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcea31012bfb06b6c9a619df966c7f50">Ptr</a> = std::shared_ptr&lt;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunction.html">IRFunction</a>&gt;</td></tr>
<tr class="memitem:ac60d5949e5e9feb0d8925fddff6180aa" id="r_ac60d5949e5e9feb0d8925fddff6180aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#ac60d5949e5e9feb0d8925fddff6180aa">GeneratorNativeCb</a></td></tr>
<tr class="memdesc:ac60d5949e5e9feb0d8925fddff6180aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IR callback function which will write the LLVM IR for this function's body.  <br /></td></tr>
<tr class="memitem:ad02fa87041104eb2d97c66ac8441d77b" id="r_ad02fa87041104eb2d97c66ac8441d77b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#ad02fa87041104eb2d97c66ac8441d77b">GeneratorArgumentsCb</a></td></tr>
<tr class="memitem:a7683850ca58f8a884279701b7f95b84f" id="r_a7683850ca58f8a884279701b7f95b84f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a7683850ca58f8a884279701b7f95b84f">GeneratorCb</a></td></tr>
<tr class="memdesc:a7683850ca58f8a884279701b7f95b84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy callback, will eventually be deprecated in favour of using the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#ad02fa87041104eb2d97c66ac8441d77b">GeneratorArgumentsCb</a>.  <br /></td></tr>
<tr class="memitem:aee8c90b86fef2410c5903bcdd9df708c" id="r_aee8c90b86fef2410c5903bcdd9df708c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">SignatureMatch</a> { <br />
&#160;&#160;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708cac9d3e887722f2bc482bcca9d41c512af">None</a> = 0
, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708caff9abf2b1a689f70a77a18da50c01d9f">Size</a>
, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708ca81a198911eba60d4033c233d3ec90ea1">Implicit</a>
, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708ca8b6aaae09cff57a6af002d994ec5c647">Ambiguous</a>
, <br />
&#160;&#160;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708cad2dd6ed7eca9210b09941bee2c62735f">Explicit</a>
<br />
 }</td></tr>
<tr class="memdesc:aee8c90b86fef2410c5903bcdd9df708c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result type from calls to <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a00c794a174f7525be4a6cd0f2b0a1ee5" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6d69acba8d35814a4fbe0cb088dd5880" id="r_a6d69acba8d35814a4fbe0cb088dd5880"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d69acba8d35814a4fbe0cb088dd5880">IRFunction</a> (const std::string &amp;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a9f1ee89638a2fc436f51679d1a855bdf">symbol</a>, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a7683850ca58f8a884279701b7f95b84f">GeneratorCb</a> &amp;gen)</td></tr>
<tr class="memitem:af632a6f79ebc3d382c7a7c0072e1bbb4" id="r_af632a6f79ebc3d382c7a7c0072e1bbb4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af632a6f79ebc3d382c7a7c0072e1bbb4">IRFunction</a> (const std::string &amp;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a9f1ee89638a2fc436f51679d1a855bdf">symbol</a>, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#ac60d5949e5e9feb0d8925fddff6180aa">GeneratorNativeCb</a> &amp;gen)</td></tr>
<tr class="memitem:a14b6814883089fc0696572aefe53c2c8" id="r_a14b6814883089fc0696572aefe53c2c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14b6814883089fc0696572aefe53c2c8">IRFunction</a> (const std::string &amp;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a9f1ee89638a2fc436f51679d1a855bdf">symbol</a>, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#ad02fa87041104eb2d97c66ac8441d77b">GeneratorArgumentsCb</a> &amp;gen)</td></tr>
<tr class="memitem:a552e640f9d0305206696ddffc619e862" id="r_a552e640f9d0305206696ddffc619e862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html">ArgInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a552e640f9d0305206696ddffc619e862">types</a> (<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;types, llvm::LLVMContext &amp;C) const override</td></tr>
<tr class="memdesc:a552e640f9d0305206696ddffc619e862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a vector of ArgInfos which describe this function signature. This method is used by <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a31fe6ce9883ce66d9a748003b68afefb" title="Converts and creates this AX function into a llvm Function.">Function::create</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a122389addb0b884bb5f7f5b45a3b24a5" title="Print this function&#39;s signature to the provided ostream.">Function::print</a> and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a00c794a174f7525be4a6cd0f2b0a1ee5" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>.  <br /></td></tr>
<tr class="memitem:a498bb66ac13b5ba4fb6e66494dc482db" id="r_a498bb66ac13b5ba4fb6e66494dc482db"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a498bb66ac13b5ba4fb6e66494dc482db">types</a> (std::vector&lt; llvm::Type * &gt; &amp;types, llvm::LLVMContext &amp;C) const override</td></tr>
<tr class="memitem:a362ecd72d1dfb66426eb7658c5147849" id="r_a362ecd72d1dfb66426eb7658c5147849"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a362ecd72d1dfb66426eb7658c5147849">setEmbedIR</a> (bool on)</td></tr>
<tr class="memdesc:a362ecd72d1dfb66426eb7658c5147849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the embedding of IR. Embedded IR is currently required for function which use parent function parameters.  <br /></td></tr>
<tr class="memitem:a31dc765576d7dcd7776ab55da704fe1b" id="r_a31dc765576d7dcd7776ab55da704fe1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a31dc765576d7dcd7776ab55da704fe1b">hasEmbedIR</a> () const</td></tr>
<tr class="memitem:a5f7069870299fb4b0dccd996457e1a1e" id="r_a5f7069870299fb4b0dccd996457e1a1e"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a5f7069870299fb4b0dccd996457e1a1e">create</a> (llvm::LLVMContext &amp;C, llvm::Module *M) const override</td></tr>
<tr class="memdesc:a5f7069870299fb4b0dccd996457e1a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override for the creation of an IR function. This ensures that the body and prototype of the function are generated if a Module is provided.  <br /></td></tr>
<tr class="memitem:a5cc224e4e9d775d247167137509856a5" id="r_a5cc224e4e9d775d247167137509856a5"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a5cc224e4e9d775d247167137509856a5">create</a> (llvm::Module &amp;M) const</td></tr>
<tr class="memdesc:a5cc224e4e9d775d247167137509856a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method which always uses the provided module to find the function or insert it if necessary.  <br /></td></tr>
<tr class="memitem:aae8daf0986a2751029d10dc5a318465e" id="r_aae8daf0986a2751029d10dc5a318465e"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#aae8daf0986a2751029d10dc5a318465e">call</a> (const std::vector&lt; llvm::Value * &gt; &amp;args, llvm::IRBuilder&lt;&gt; &amp;B) const override</td></tr>
<tr class="memdesc:aae8daf0986a2751029d10dc5a318465e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override for call, which is only necessary if mEmbedIR is true, as the IR generation for embedded functions is delayed until the function is called. If mEmbedIR is false, this simply calls <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a8260c8666f1cbbb10279dd0f7b44e643" title="Uses the IRBuilder to create a call to this function with the given arguments, creating the function ...">Function::call</a>.  <br /></td></tr>
<tr class="memitem:a9d0b15d1776023f9c02d35458a24b334" id="r_a9d0b15d1776023f9c02d35458a24b334"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a9d0b15d1776023f9c02d35458a24b334">call</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html">Arguments</a> &amp;args, llvm::IRBuilder&lt;&gt; &amp;) const override</td></tr>
<tr class="memitem:a3eb5e0f696f0d8de2c9ce35ef725272f" id="r_a3eb5e0f696f0d8de2c9ce35ef725272f"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a3eb5e0f696f0d8de2c9ce35ef725272f">call</a> (const std::vector&lt; llvm::Value * &gt; &amp;args, llvm::IRBuilder&lt;&gt; &amp;B, const bool <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a3c7bbe5ddababca6b3a2da7a23a25fc1">cast</a>) const override</td></tr>
<tr class="memdesc:a3eb5e0f696f0d8de2c9ce35ef725272f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the IRBuilder to create a call to this function with the given arguments, creating the function and inserting it into the IRBuilder's Module if necessary (through <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a31fe6ce9883ce66d9a748003b68afefb" title="Converts and creates this AX function into a llvm Function.">Function::create</a>). Returns the result of the function call which can be a nullptr if the function is a non-sret void call.  <br /></td></tr>
<tr class="memitem:a0d777657b5c1605fa4792b479f49a448" id="r_a0d777657b5c1605fa4792b479f49a448"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a0d777657b5c1605fa4792b479f49a448">call</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html">NativeArguments</a> &amp;args, llvm::IRBuilder&lt;&gt; &amp;B) const</td></tr>
<tr class="memitem:ad7bf85f468767251d9039133646ec788" id="r_ad7bf85f468767251d9039133646ec788"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#ad7bf85f468767251d9039133646ec788">get</a> (const llvm::Module &amp;M) const</td></tr>
<tr class="memdesc:ad7bf85f468767251d9039133646ec788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for calling M.getFunction(symbol). Returns a nullptr if the function has not yet been created or if it is embedded IR.  <br /></td></tr>
<tr class="memitem:a00c794a174f7525be4a6cd0f2b0a1ee5" id="r_a00c794a174f7525be4a6cd0f2b0a1ee5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">SignatureMatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a00c794a174f7525be4a6cd0f2b0a1ee5">match</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;inputs, llvm::LLVMContext &amp;C) const</td></tr>
<tr class="memdesc:a00c794a174f7525be4a6cd0f2b0a1ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base implementation for determining how a vector of llvm arguments translates to this functions signature. Returns an enum which represents the available mapping.  <br /></td></tr>
<tr class="memitem:a8bc9b930270e06477d777256c1e060d9" id="r_a8bc9b930270e06477d777256c1e060d9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">SignatureMatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a8bc9b930270e06477d777256c1e060d9">match</a> (const std::vector&lt; llvm::Type * &gt; &amp;inputs, llvm::LLVMContext &amp;C) const</td></tr>
<tr class="memitem:a259cb5a711406a8c3e5d937eb9350cca" id="r_a259cb5a711406a8c3e5d937eb9350cca"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a259cb5a711406a8c3e5d937eb9350cca">size</a> () const</td></tr>
<tr class="memdesc:a259cb5a711406a8c3e5d937eb9350cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of arguments that this function has.  <br /></td></tr>
<tr class="memitem:a9f1ee89638a2fc436f51679d1a855bdf" id="r_a9f1ee89638a2fc436f51679d1a855bdf"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a9f1ee89638a2fc436f51679d1a855bdf">symbol</a> () const</td></tr>
<tr class="memdesc:a9f1ee89638a2fc436f51679d1a855bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function symbol name.  <br /></td></tr>
<tr class="memitem:a0ee4ae56bf532dc17117c17206c9bbba" id="r_a0ee4ae56bf532dc17117c17206c9bbba"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a0ee4ae56bf532dc17117c17206c9bbba">argName</a> (const size_t idx) const</td></tr>
<tr class="memdesc:a0ee4ae56bf532dc17117c17206c9bbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the descriptive name of the given argument index.  <br /></td></tr>
<tr class="memitem:a122389addb0b884bb5f7f5b45a3b24a5" id="r_a122389addb0b884bb5f7f5b45a3b24a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a122389addb0b884bb5f7f5b45a3b24a5">print</a> (llvm::LLVMContext &amp;C, std::ostream &amp;os, const char *name=nullptr, const bool axTypes=true) const</td></tr>
<tr class="memdesc:a122389addb0b884bb5f7f5b45a3b24a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print this function's signature to the provided ostream.  <br /></td></tr>
<tr class="memitem:a592052ecd54b2fed6431ca2fb31cecce" id="r_a592052ecd54b2fed6431ca2fb31cecce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#acc2e13670241c2002b01d5c4daeeaa51">SmallArgumentVector</a>&lt; const char * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a592052ecd54b2fed6431ca2fb31cecce">dependencies</a> () const</td></tr>
<tr class="memitem:a851def4e79a8080add2df87bdf87a32a" id="r_a851def4e79a8080add2df87bdf87a32a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a851def4e79a8080add2df87bdf87a32a">hasParamAttribute</a> (const size_t i, const llvm::Attribute::AttrKind &amp;kind) const</td></tr>
<tr class="memdesc:a851def4e79a8080add2df87bdf87a32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated builder methods, no longer public.  <br /></td></tr>
<tr class="memitem:af6187793e0d3c6b1098b1d037e5b9530" id="r_af6187793e0d3c6b1098b1d037e5b9530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#af6187793e0d3c6b1098b1d037e5b9530">setArgumentNames</a> (std::vector&lt; const char * &gt; names)</td></tr>
<tr class="memitem:a130dc8b5cf81200428494e2d63384483" id="r_a130dc8b5cf81200428494e2d63384483"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a130dc8b5cf81200428494e2d63384483">setDependencies</a> (std::vector&lt; const char * &gt; deps)</td></tr>
<tr class="memitem:a6fb0a8f2ddba1d3d98741894a5db5f03" id="r_a6fb0a8f2ddba1d3d98741894a5db5f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a6fb0a8f2ddba1d3d98741894a5db5f03">setFnAttributes</a> (const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;in)</td></tr>
<tr class="memitem:a51952659e55f5546f5e3d8f6a4e56eb3" id="r_a51952659e55f5546f5e3d8f6a4e56eb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a51952659e55f5546f5e3d8f6a4e56eb3">setRetAttributes</a> (const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;in)</td></tr>
<tr class="memitem:a359ce980d9f1de2430296ca2f3e42409" id="r_a359ce980d9f1de2430296ca2f3e42409"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a359ce980d9f1de2430296ca2f3e42409">setParamAttributes</a> (const size_t i, const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;in)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab8ec780861efc5bbb24ac1cd3a0309fd" id="r_ab8ec780861efc5bbb24ac1cd3a0309fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#ab8ec780861efc5bbb24ac1cd3a0309fd">verifyResultType</a> (const llvm::Type *result, const llvm::Type *expected) const</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-static-methods" class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a3c7bbe5ddababca6b3a2da7a23a25fc1" id="r_a3c7bbe5ddababca6b3a2da7a23a25fc1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a3c7bbe5ddababca6b3a2da7a23a25fc1">cast</a> (std::vector&lt; llvm::Value * &gt; &amp;args, const std::vector&lt; llvm::Type * &gt; &amp;<a class="el" href="#a552e640f9d0305206696ddffc619e862">types</a>, llvm::IRBuilder&lt;&gt; &amp;B)</td></tr>
<tr class="memdesc:a3c7bbe5ddababca6b3a2da7a23a25fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the provided arguments to the given type as supported by implicit casting of function types. If the types already match OR if a cast cannot be performed, nothing is done to the argument.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4b6bc6c176432f9527ccb58e0e53d74a" id="r_a4b6bc6c176432f9527ccb58e0e53d74a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#ad02fa87041104eb2d97c66ac8441d77b">GeneratorArgumentsCb</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a4b6bc6c176432f9527ccb58e0e53d74a">mGen</a></td></tr>
<tr class="memitem:a9f06f4cf7b3192fa886efa709090daeb" id="r_a9f06f4cf7b3192fa886efa709090daeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a9f06f4cf7b3192fa886efa709090daeb">mEmbedIR</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename SignatureT&gt;<br />
struct openvdb::v13_0::ax::codegen::IRFunction&lt; SignatureT &gt;</div><p>Represents a concrete IR function. </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="ad02fa87041104eb2d97c66ac8441d77b" name="ad02fa87041104eb2d97c66ac8441d77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02fa87041104eb2d97c66ac8441d77b">&#9670;&#160;</a></span>GeneratorArgumentsCb</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#ad02fa87041104eb2d97c66ac8441d77b">GeneratorArgumentsCb</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;<a class="code hl_class" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></div>
<div class="line">        (<span class="keyword">const</span> <a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html">Arguments</a>&amp;, llvm::IRBuilder&lt;&gt;&amp;)&gt;</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value_html"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">openvdb::v13_0::ax::codegen::Value</a></div><div class="ttdoc">Intermediate representation wrapper for supported value types in AX as immutable instances.</div><div class="ttdef"><b>Definition</b> Value.h:63</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments_html"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html">openvdb::v13_0::ax::codegen::Arguments</a></div><div class="ttdoc">Arbitrary, potentially &quot;non-native&quot; arguments. This wrapper struct can be used when generating functi...</div><div class="ttdef"><b>Definition</b> FunctionTypes.h:382</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7683850ca58f8a884279701b7f95b84f" name="a7683850ca58f8a884279701b7f95b84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7683850ca58f8a884279701b7f95b84f">&#9670;&#160;</a></span>GeneratorCb</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a7683850ca58f8a884279701b7f95b84f">GeneratorCb</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;llvm::Value*</div>
<div class="line">        (<span class="keyword">const</span> std::vector&lt;llvm::Value*&gt;&amp;,</div>
<div class="line">         llvm::IRBuilder&lt;&gt;&amp;)&gt;</div>
</div><!-- fragment -->
<p>Legacy callback, will eventually be deprecated in favour of using the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#ad02fa87041104eb2d97c66ac8441d77b">GeneratorArgumentsCb</a>. </p>

</div>
</div>
<a id="ac60d5949e5e9feb0d8925fddff6180aa" name="ac60d5949e5e9feb0d8925fddff6180aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60d5949e5e9feb0d8925fddff6180aa">&#9670;&#160;</a></span>GeneratorNativeCb</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#ac60d5949e5e9feb0d8925fddff6180aa">GeneratorNativeCb</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::function&lt;<a class="code hl_class" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></div>
<div class="line">        (<span class="keyword">const</span> <a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html">NativeArguments</a>&amp;, llvm::IRBuilder&lt;&gt;&amp;)&gt;</div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments_html"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html">openvdb::v13_0::ax::codegen::NativeArguments</a></div><div class="ttdoc">Wrapper struct to represent &quot;native&quot; function arguments; that is, the set of Value type that the AX g...</div><div class="ttdef"><b>Definition</b> FunctionTypes.h:349</div></div>
</div><!-- fragment -->
<p>The IR callback function which will write the LLVM IR for this function's body. </p>
<p>The first argument is the vector of functional arguments. i.e. a representation of the value that the callback has been invoked with. The last argument is the IR builder which should be used to generate the function body IR. </p><dl class="section note"><dt>Note</dt><dd>You can return a ret void instruction, an actual value or <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> which will cause the function framework to insert a ret void if necessary. </dd></dl>

</div>
</div>
<a id="afcea31012bfb06b6c9a619df966c7f50" name="afcea31012bfb06b6c9a619df966c7f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcea31012bfb06b6c9a619df966c7f50">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afcea31012bfb06b6c9a619df966c7f50">Ptr</a> = std::shared_ptr&lt;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunction.html">IRFunction</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2846ade648824cd69bd0fdc3d2cee4ca" name="a2846ade648824cd69bd0fdc3d2cee4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2846ade648824cd69bd0fdc3d2cee4ca">&#9670;&#160;</a></span>Traits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2846ade648824cd69bd0fdc3d2cee4ca">Traits</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionTraits.html">FunctionTraits</a>&lt;SignatureT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="aee8c90b86fef2410c5903bcdd9df708c" name="aee8c90b86fef2410c5903bcdd9df708c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8c90b86fef2410c5903bcdd9df708c">&#9670;&#160;</a></span>SignatureMatch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">SignatureMatch</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The result type from calls to <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a00c794a174f7525be4a6cd0f2b0a1ee5" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a00c794a174f7525be4a6cd0f2b0a1ee5" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a> cannot return Ambiguous - this is only returned by the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html" title="A group of functions which all have the same name but different signatures. For example: float abs(fl...">FunctionGroup</a> API. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aee8c90b86fef2410c5903bcdd9df708cac9d3e887722f2bc482bcca9d41c512af" name="aee8c90b86fef2410c5903bcdd9df708cac9d3e887722f2bc482bcca9d41c512af"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee8c90b86fef2410c5903bcdd9df708caff9abf2b1a689f70a77a18da50c01d9f" name="aee8c90b86fef2410c5903bcdd9df708caff9abf2b1a689f70a77a18da50c01d9f"></a>Size&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee8c90b86fef2410c5903bcdd9df708ca81a198911eba60d4033c233d3ec90ea1" name="aee8c90b86fef2410c5903bcdd9df708ca81a198911eba60d4033c233d3ec90ea1"></a>Implicit&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee8c90b86fef2410c5903bcdd9df708ca8b6aaae09cff57a6af002d994ec5c647" name="aee8c90b86fef2410c5903bcdd9df708ca8b6aaae09cff57a6af002d994ec5c647"></a>Ambiguous&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee8c90b86fef2410c5903bcdd9df708cad2dd6ed7eca9210b09941bee2c62735f" name="aee8c90b86fef2410c5903bcdd9df708cad2dd6ed7eca9210b09941bee2c62735f"></a>Explicit&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6d69acba8d35814a4fbe0cb088dd5880" name="a6d69acba8d35814a4fbe0cb088dd5880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d69acba8d35814a4fbe0cb088dd5880">&#9670;&#160;</a></span>IRFunction() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunction.html">IRFunction</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a7683850ca58f8a884279701b7f95b84f">GeneratorCb</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af632a6f79ebc3d382c7a7c0072e1bbb4" name="af632a6f79ebc3d382c7a7c0072e1bbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af632a6f79ebc3d382c7a7c0072e1bbb4">&#9670;&#160;</a></span>IRFunction() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunction.html">IRFunction</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#ac60d5949e5e9feb0d8925fddff6180aa">GeneratorNativeCb</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14b6814883089fc0696572aefe53c2c8" name="a14b6814883089fc0696572aefe53c2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b6814883089fc0696572aefe53c2c8">&#9670;&#160;</a></span>IRFunction() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunction.html">IRFunction</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#ad02fa87041104eb2d97c66ac8441d77b">GeneratorArgumentsCb</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a0ee4ae56bf532dc17117c17206c9bbba" name="a0ee4ae56bf532dc17117c17206c9bbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee4ae56bf532dc17117c17206c9bbba">&#9670;&#160;</a></span>argName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * argName </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the descriptive name of the given argument index. </p>
<p>If the index is greater than the number of arguments, an empty string is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d777657b5c1605fa4792b479f49a448" name="a0d777657b5c1605fa4792b479f49a448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d777657b5c1605fa4792b479f49a448">&#9670;&#160;</a></span>call() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> call </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html">NativeArguments</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d0b15d1776023f9c02d35458a24b334" name="a9d0b15d1776023f9c02d35458a24b334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0b15d1776023f9c02d35458a24b334">&#9670;&#160;</a></span>call() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> call </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html">Arguments</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#af7bcc97dfb22797e3f0ff274415dc222">Function</a>.</p>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a160d941a6104d6c46c3da98584a8a265">SRetFunction&lt; SignatureT, IRFunction&lt; SignatureT &gt; &gt;</a>.</p>

</div>
</div>
<a id="aae8daf0986a2751029d10dc5a318465e" name="aae8daf0986a2751029d10dc5a318465e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8daf0986a2751029d10dc5a318465e">&#9670;&#160;</a></span>call() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * call </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override for call, which is only necessary if mEmbedIR is true, as the IR generation for embedded functions is delayed until the function is called. If mEmbedIR is false, this simply calls <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a8260c8666f1cbbb10279dd0f7b44e643" title="Uses the IRBuilder to create a call to this function with the given arguments, creating the function ...">Function::call</a>. </p>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a3f3e86b1fdff3bf0b914203cdce239be">Function</a>.</p>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#aae8daf0986a2751029d10dc5a318465e">SRetFunction&lt; SignatureT, IRFunction&lt; SignatureT &gt; &gt;</a>.</p>

</div>
</div>
<a id="a3eb5e0f696f0d8de2c9ce35ef725272f" name="a3eb5e0f696f0d8de2c9ce35ef725272f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb5e0f696f0d8de2c9ce35ef725272f">&#9670;&#160;</a></span>call() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * call </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>cast</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses the IRBuilder to create a call to this function with the given arguments, creating the function and inserting it into the IRBuilder's Module if necessary (through <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a31fe6ce9883ce66d9a748003b68afefb" title="Converts and creates this AX function into a llvm Function.">Function::create</a>). Returns the result of the function call which can be a nullptr if the function is a non-sret void call. </p>
<dl class="section note"><dt>Note</dt><dd>The IRBuilder must have a valid llvm Module/Function/Block attached </dd>
<dd>
If the number of provided arguments do not match the size of the current function, invalid IR will be generated. </dd>
<dd>
If the provided argument types do not match the current function and cast is false, invalid IR will be generated. Additionally, invalid IR will be generated if cast is true but no valid cast exists for a given argument. </dd>
<dd>
When casting arguments, the readonly flags of the function are not checked (unlike <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a00c794a174f7525be4a6cd0f2b0a1ee5" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>). Casting an argument will cause a new copy of the argument to be created and passed to the function. These new values do not propagate back any changes to the original argument. Separate functions for all writable argument types must be created.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The llvm <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> arguments to call this function with </td></tr>
    <tr><td class="paramname">B</td><td>The llvm IRBuilder </td></tr>
    <tr><td class="paramname">cast</td><td>Whether to allow implicit casting of arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated</a></b></dt><dd>"Function::call which takes llvm::Value's and " "supports casting is incompatible with LLVM 16+ and will be removed." <br  />
 </dd></dl>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a8260c8666f1cbbb10279dd0f7b44e643">Function</a>.</p>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a3eb5e0f696f0d8de2c9ce35ef725272f">SRetFunction&lt; SignatureT, IRFunction&lt; SignatureT &gt; &gt;</a>.</p>

</div>
</div>
<a id="a3c7bbe5ddababca6b3a2da7a23a25fc1" name="a3c7bbe5ddababca6b3a2da7a23a25fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7bbe5ddababca6b3a2da7a23a25fc1">&#9670;&#160;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cast </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; llvm::Type * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast the provided arguments to the given type as supported by implicit casting of function types. If the types already match OR if a cast cannot be performed, nothing is done to the argument. </p>

</div>
</div>
<a id="a5cc224e4e9d775d247167137509856a5" name="a5cc224e4e9d775d247167137509856a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc224e4e9d775d247167137509856a5">&#9670;&#160;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function * create </td>
          <td>(</td>
          <td class="paramtype">llvm::Module &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method which always uses the provided module to find the function or insert it if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The llvm::Module to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f7069870299fb4b0dccd996457e1a1e" name="a5f7069870299fb4b0dccd996457e1a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7069870299fb4b0dccd996457e1a1e">&#9670;&#160;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function * create </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Module *</td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override for the creation of an IR function. This ensures that the body and prototype of the function are generated if a Module is provided. </p>
<dl class="section note"><dt>Note</dt><dd>A nullptr is returned if mEmbedIR is true and no action is performed. </dd>
<dd>
Throws if this function has been initialized with a nullptr generator callback. In this case, the function prototype will be created, but not the function body. </dd>
<dd>
Throws if the return type of the generator callback does not match the function prototype. In this case, both the prototype and the function body will be created and inserted, but the IR will be invalid. </dd></dl>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a31fe6ce9883ce66d9a748003b68afefb">Function</a>.</p>

</div>
</div>
<a id="a592052ecd54b2fed6431ca2fb31cecce" name="a592052ecd54b2fed6431ca2fb31cecce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592052ecd54b2fed6431ca2fb31cecce">&#9670;&#160;</a></span>dependencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#acc2e13670241c2002b01d5c4daeeaa51">SmallArgumentVector</a>&lt; const char * &gt; &amp; dependencies </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7bf85f468767251d9039133646ec788" name="ad7bf85f468767251d9039133646ec788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bf85f468767251d9039133646ec788">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function * get </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method for calling M.getFunction(symbol). Returns a nullptr if the function has not yet been created or if it is embedded IR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The llvm::Module to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31dc765576d7dcd7776ab55da704fe1b" name="a31dc765576d7dcd7776ab55da704fe1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31dc765576d7dcd7776ab55da704fe1b">&#9670;&#160;</a></span>hasEmbedIR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasEmbedIR </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a851def4e79a8080add2df87bdf87a32a" name="a851def4e79a8080add2df87bdf87a32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851def4e79a8080add2df87bdf87a32a">&#9670;&#160;</a></span>hasParamAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasParamAttribute </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Attribute::AttrKind &amp;</td>          <td class="paramname"><span class="paramname"><em>kind</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated builder methods, no longer public. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated</a></b></dt><dd>"This method incorrectly returns the attributes " "of the function set by the FunctionBuilder, not by the codegen. To " "inspect function attributes, retrieve the created function from the " "llvm::Module." <br  />
 </dd></dl>

</div>
</div>
<a id="a00c794a174f7525be4a6cd0f2b0a1ee5" name="a00c794a174f7525be4a6cd0f2b0a1ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c794a174f7525be4a6cd0f2b0a1ee5">&#9670;&#160;</a></span>match() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">SignatureMatch</a> match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The base implementation for determining how a vector of llvm arguments translates to this functions signature. Returns an enum which represents the available mapping. </p>
<p>This method calls <a class="el" href="#a552e640f9d0305206696ddffc619e862" title="Populate a vector of ArgInfos which describe this function signature. This method is used by Function...">types()</a> to figure out the function signature, then compares each argument type to the type in the input vector. If the types match exactly, an Explicit match is found. If the sizes of the inputs and signature differ, no match is found and None is returned. If however, the sizes match and there exists a valid implicit cast from the input type to the signature type for every input, an Implicit match is returned. Finally, if the sizes match but there is no implicit cast mapping, Size is returned. i8 -&gt; i32 : Implicit i32 -&gt; i32 : Explicit str -&gt; i32 : Size (i32,i32) -&gt; i32 : None Never returns Ambiguous (this state is used by <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html" title="A group of functions which all have the same name but different signatures. For example: float abs(fl...">FunctionGroup</a>) </p><dl class="section note"><dt>Note</dt><dd>Due to the way <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionSRet.html" title="Represents a concrete C function binding with the first argument as its return type.">CFunctionSRet</a> is implemented, the LLVM Context must be provided in case we have a zero arg function signature with a SRET. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>The input types </td></tr>
    <tr><td class="paramname">C</td><td>The LLVM Context </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a431456d47fdcb019ab9db247b9989a38">SRetFunction&lt; SignatureT, CFunction&lt; SignatureT &gt; &gt;</a>, and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a431456d47fdcb019ab9db247b9989a38">SRetFunction&lt; SignatureT, IRFunction&lt; SignatureT &gt; &gt;</a>.</p>

</div>
</div>
<a id="a8bc9b930270e06477d777256c1e060d9" name="a8bc9b930270e06477d777256c1e060d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc9b930270e06477d777256c1e060d9">&#9670;&#160;</a></span>match() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">SignatureMatch</a> match </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Type * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated</a></b></dt><dd>"Switch to AX's internal ArgInfo types for LLVM 16 onwards" <br  />
 </dd></dl>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a9527ef3e0f61abd8b26dba4d2648ad21">SRetFunction&lt; SignatureT, CFunction&lt; SignatureT &gt; &gt;</a>, and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a9527ef3e0f61abd8b26dba4d2648ad21">SRetFunction&lt; SignatureT, IRFunction&lt; SignatureT &gt; &gt;</a>.</p>

</div>
</div>
<a id="a122389addb0b884bb5f7f5b45a3b24a5" name="a122389addb0b884bb5f7f5b45a3b24a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122389addb0b884bb5f7f5b45a3b24a5">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void print </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>axTypes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print this function's signature to the provided ostream. </p>
<p>This is intended to return a descriptive front end user string rather than the function's IR representation. This function is virtual so that derived classes can customize how they present frontend information. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#aa1fdf8da42ec61c8bae2a73419879629" title="Print a function signature to the provided ostream.">printSignature</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The llvm context </td></tr>
    <tr><td class="paramname">os</td><td>The ostream to print to </td></tr>
    <tr><td class="paramname">name</td><td>The name to insert into the description. </td></tr>
    <tr><td class="paramname">axTypes</td><td>Whether to print llvm IR or AX Types. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a02be931d9569d33334a4032a421d9c52">SRetFunction&lt; SignatureT, CFunction&lt; SignatureT &gt; &gt;</a>, and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a02be931d9569d33334a4032a421d9c52">SRetFunction&lt; SignatureT, IRFunction&lt; SignatureT &gt; &gt;</a>.</p>

</div>
</div>
<a id="af6187793e0d3c6b1098b1d037e5b9530" name="af6187793e0d3c6b1098b1d037e5b9530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6187793e0d3c6b1098b1d037e5b9530">&#9670;&#160;</a></span>setArgumentNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setArgumentNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const char * &gt;</td>          <td class="paramname"><span class="paramname"><em>names</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated</a></b></dt><dd>"Use the FunctionBuilder to construct Functions" <br  />
 </dd></dl>

</div>
</div>
<a id="a130dc8b5cf81200428494e2d63384483" name="a130dc8b5cf81200428494e2d63384483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130dc8b5cf81200428494e2d63384483">&#9670;&#160;</a></span>setDependencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setDependencies </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const char * &gt;</td>          <td class="paramname"><span class="paramname"><em>deps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated</a></b></dt><dd>"Use the FunctionBuilder to construct Functions" <br  />
 </dd></dl>

</div>
</div>
<a id="a362ecd72d1dfb66426eb7658c5147849" name="a362ecd72d1dfb66426eb7658c5147849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362ecd72d1dfb66426eb7658c5147849">&#9670;&#160;</a></span>setEmbedIR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setEmbedIR </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>on</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable the embedding of IR. Embedded IR is currently required for function which use parent function parameters. </p>

</div>
</div>
<a id="a6fb0a8f2ddba1d3d98741894a5db5f03" name="a6fb0a8f2ddba1d3d98741894a5db5f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb0a8f2ddba1d3d98741894a5db5f03">&#9670;&#160;</a></span>setFnAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setFnAttributes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated</a></b></dt><dd>"Use the FunctionBuilder to construct Functions" <br  />
 </dd></dl>

</div>
</div>
<a id="a359ce980d9f1de2430296ca2f3e42409" name="a359ce980d9f1de2430296ca2f3e42409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359ce980d9f1de2430296ca2f3e42409">&#9670;&#160;</a></span>setParamAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setParamAttributes </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated</a></b></dt><dd>"Use the FunctionBuilder to construct Functions" <br  />
 </dd></dl>

</div>
</div>
<a id="a51952659e55f5546f5e3d8f6a4e56eb3" name="a51952659e55f5546f5e3d8f6a4e56eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51952659e55f5546f5e3d8f6a4e56eb3">&#9670;&#160;</a></span>setRetAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setRetAttributes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated</a></b></dt><dd>"Use the FunctionBuilder to construct Functions" <br  />
 </dd></dl>

</div>
</div>
<a id="a259cb5a711406a8c3e5d937eb9350cca" name="a259cb5a711406a8c3e5d937eb9350cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259cb5a711406a8c3e5d937eb9350cca">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of arguments that this function has. </p>

</div>
</div>
<a id="a9f1ee89638a2fc436f51679d1a855bdf" name="a9f1ee89638a2fc436f51679d1a855bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1ee89638a2fc436f51679d1a855bdf">&#9670;&#160;</a></span>symbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * symbol </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function symbol name. </p>
<p>This will be used as its identifier in IR and must be unique. </p>

</div>
</div>
<a id="a552e640f9d0305206696ddffc619e862" name="a552e640f9d0305206696ddffc619e862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552e640f9d0305206696ddffc619e862">&#9670;&#160;</a></span>types() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html">ArgInfo</a> types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a vector of ArgInfos which describe this function signature. This method is used by <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a31fe6ce9883ce66d9a748003b68afefb" title="Converts and creates this AX function into a llvm Function.">Function::create</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a122389addb0b884bb5f7f5b45a3b24a5" title="Print this function&#39;s signature to the provided ostream.">Function::print</a> and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a00c794a174f7525be4a6cd0f2b0a1ee5" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The variant that takes a vector of ArgInfos is optional with LLVM 15 for compatibility but must be implemented with newer versions. </dd></dl>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aa7be69eba606cab147a0162591c13e6f">Function</a>.</p>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#aeeedef433759fed9cd7d72a6e1e56c9f">SRetFunction&lt; SignatureT, IRFunction&lt; SignatureT &gt; &gt;</a>.</p>

</div>
</div>
<a id="a498bb66ac13b5ba4fb6e66494dc482db" name="a498bb66ac13b5ba4fb6e66494dc482db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498bb66ac13b5ba4fb6e66494dc482db">&#9670;&#160;</a></span>types() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * types </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Type * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated</a></b></dt><dd>"Switch to AX's internal ArgInfo types for LLVM 16 onwards" <br  />
 </dd></dl>

<p>Implements <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#ab2b6bacd57c3ab5d930fc96e1319977d">Function</a>.</p>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#aeb7c9936016e2c09aab2e6f8e039a16a">SRetFunction&lt; SignatureT, IRFunction&lt; SignatureT &gt; &gt;</a>.</p>

</div>
</div>
<a id="ab8ec780861efc5bbb24ac1cd3a0309fd" name="ab8ec780861efc5bbb24ac1cd3a0309fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ec780861efc5bbb24ac1cd3a0309fd">&#9670;&#160;</a></span>verifyResultType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void verifyResultType </td>
          <td>(</td>
          <td class="paramtype">const llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>expected</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a9f06f4cf7b3192fa886efa709090daeb" name="a9f06f4cf7b3192fa886efa709090daeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f06f4cf7b3192fa886efa709090daeb">&#9670;&#160;</a></span>mEmbedIR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mEmbedIR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b6bc6c176432f9527ccb58e0e53d74a" name="a4b6bc6c176432f9527ccb58e0e53d74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6bc6c176432f9527ccb58e0e53d74a">&#9670;&#160;</a></span>mGen</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#ad02fa87041104eb2d97c66ac8441d77b">GeneratorArgumentsCb</a> mGen</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax.html">ax</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html">codegen</a></li><li class="navelem"><a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunction.html">IRFunction</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
