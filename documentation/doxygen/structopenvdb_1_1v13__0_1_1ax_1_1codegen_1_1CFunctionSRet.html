<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: CFunctionSRet&lt; SignatureT &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionSRet.html','','structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionSRet-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">CFunctionSRet&lt; SignatureT &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents a concrete C function binding with the first argument as its return type.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="FunctionTypes_8h_source.html">openvdb_ax/codegen/FunctionTypes.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a441bc7ccfcf686435f4d8c4a534fe5b6" id="r_a441bc7ccfcf686435f4d8c4a534fe5b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a441bc7ccfcf686435f4d8c4a534fe5b6">BaseT</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html">SRetFunction</a>&lt;SignatureT, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html">CFunction</a>&lt;SignatureT&gt;&gt;</td></tr>
<tr class="memitem:a1f0369aa802ea699423de0552c44a42b" id="r_a1f0369aa802ea699423de0552c44a42b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a1f0369aa802ea699423de0552c44a42b">Ptr</a></td></tr>
<tr class="memitem:a2846ade648824cd69bd0fdc3d2cee4ca" id="r_a2846ade648824cd69bd0fdc3d2cee4ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a2846ade648824cd69bd0fdc3d2cee4ca">Traits</a></td></tr>
<tr class="memitem:afbaff2c38456dbe53e25a87898fa0c4a" id="r_afbaff2c38456dbe53e25a87898fa0c4a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html#afbaff2c38456dbe53e25a87898fa0c4a">CFunctionT</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html">CFunction</a>&lt;SignatureT&gt;</td></tr>
<tr class="memitem:aee8c90b86fef2410c5903bcdd9df708c" id="r_aee8c90b86fef2410c5903bcdd9df708c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">SignatureMatch</a> { <br />
&#160;&#160;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708cac9d3e887722f2bc482bcca9d41c512af">None</a> = 0
, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708caff9abf2b1a689f70a77a18da50c01d9f">Size</a>
, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708ca81a198911eba60d4033c233d3ec90ea1">Implicit</a>
, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708ca8b6aaae09cff57a6af002d994ec5c647">Ambiguous</a>
, <br />
&#160;&#160;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708cad2dd6ed7eca9210b09941bee2c62735f">Explicit</a>
<br />
 }</td></tr>
<tr class="memdesc:aee8c90b86fef2410c5903bcdd9df708c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result type from calls to <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a00c794a174f7525be4a6cd0f2b0a1ee5" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2ae187a4647173c1a9fb982dea60bcdf" id="r_a2ae187a4647173c1a9fb982dea60bcdf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ae187a4647173c1a9fb982dea60bcdf">CFunctionSRet</a> (const std::string &amp;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a9f1ee89638a2fc436f51679d1a855bdf">symbol</a>, const SignatureT function)</td></tr>
<tr class="memitem:ac2aa6a4231668330c0f2d6fb1cf6edb0" id="r_ac2aa6a4231668330c0f2d6fb1cf6edb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2aa6a4231668330c0f2d6fb1cf6edb0">~CFunctionSRet</a> () override=default</td></tr>
<tr class="memitem:aeeedef433759fed9cd7d72a6e1e56c9f" id="r_aeeedef433759fed9cd7d72a6e1e56c9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html">ArgInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#aeeedef433759fed9cd7d72a6e1e56c9f">types</a> (<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;args, llvm::LLVMContext &amp;C) const override</td></tr>
<tr class="memdesc:aeeedef433759fed9cd7d72a6e1e56c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overide the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html" title="Metadata associated with a function argument or return value.">ArgInfo</a> type method. This does NOT change the arg order, it simply marks the first argument as a return argument. Note that the void ret type is also left as a return type.  <br /></td></tr>
<tr class="memitem:aeb7c9936016e2c09aab2e6f8e039a16a" id="r_aeb7c9936016e2c09aab2e6f8e039a16a"><td class="memItemLeft" align="right" valign="top">virtual llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#aeb7c9936016e2c09aab2e6f8e039a16a">types</a> (std::vector&lt; llvm::Type * &gt; &amp;, llvm::LLVMContext &amp;) const =0</td></tr>
<tr class="memitem:a431456d47fdcb019ab9db247b9989a38" id="r_a431456d47fdcb019ab9db247b9989a38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">Function::SignatureMatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a431456d47fdcb019ab9db247b9989a38">match</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;args, llvm::LLVMContext &amp;C) const override</td></tr>
<tr class="memdesc:a431456d47fdcb019ab9db247b9989a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of match which inserts the SRET type such that the base class methods ignore it.  <br /></td></tr>
<tr class="memitem:a9527ef3e0f61abd8b26dba4d2648ad21" id="r_a9527ef3e0f61abd8b26dba4d2648ad21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">Function::SignatureMatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a9527ef3e0f61abd8b26dba4d2648ad21">match</a> (const std::vector&lt; llvm::Type * &gt; &amp;args, llvm::LLVMContext &amp;C) const override</td></tr>
<tr class="memitem:aae8daf0986a2751029d10dc5a318465e" id="r_aae8daf0986a2751029d10dc5a318465e"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#aae8daf0986a2751029d10dc5a318465e">call</a> (const std::vector&lt; llvm::Value * &gt; &amp;args, llvm::IRBuilder&lt;&gt; &amp;B) const override</td></tr>
<tr class="memdesc:aae8daf0986a2751029d10dc5a318465e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of call which allocates the required SRET llvm::Value for this function.  <br /></td></tr>
<tr class="memitem:a160d941a6104d6c46c3da98584a8a265" id="r_a160d941a6104d6c46c3da98584a8a265"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a160d941a6104d6c46c3da98584a8a265">call</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html">Arguments</a> &amp;args, llvm::IRBuilder&lt;&gt; &amp;B) const override</td></tr>
<tr class="memitem:a3eb5e0f696f0d8de2c9ce35ef725272f" id="r_a3eb5e0f696f0d8de2c9ce35ef725272f"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a3eb5e0f696f0d8de2c9ce35ef725272f">call</a> (const std::vector&lt; llvm::Value * &gt; &amp;args, llvm::IRBuilder&lt;&gt; &amp;B, const bool <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a3c7bbe5ddababca6b3a2da7a23a25fc1">cast</a>) const override</td></tr>
<tr class="memitem:a0d777657b5c1605fa4792b479f49a448" id="r_a0d777657b5c1605fa4792b479f49a448"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a0d777657b5c1605fa4792b479f49a448">call</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html">NativeArguments</a> &amp;args, llvm::IRBuilder&lt;&gt; &amp;B) const</td></tr>
<tr class="memitem:a02be931d9569d33334a4032a421d9c52" id="r_a02be931d9569d33334a4032a421d9c52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a02be931d9569d33334a4032a421d9c52">print</a> (llvm::LLVMContext &amp;C, std::ostream &amp;os, const char *name=nullptr, const bool axTypes=true) const override</td></tr>
<tr class="memdesc:a02be931d9569d33334a4032a421d9c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of print to avoid printing out the SRET type.  <br /></td></tr>
<tr class="memitem:a172f6d0829640e5012919c726d7b0bcd" id="r_a172f6d0829640e5012919c726d7b0bcd"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html#a172f6d0829640e5012919c726d7b0bcd">address</a> () const override final</td></tr>
<tr class="memdesc:a172f6d0829640e5012919c726d7b0bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global address of this function.  <br /></td></tr>
<tr class="memitem:ad3dd86f31cfbcdfff6a7039302c71b29" id="r_ad3dd86f31cfbcdfff6a7039302c71b29"><td class="memItemLeft" align="right" valign="top">llvm::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html#ad3dd86f31cfbcdfff6a7039302c71b29">fold</a> (const std::vector&lt; llvm::Value * &gt; &amp;args, llvm::LLVMContext &amp;C) const override final</td></tr>
<tr class="memitem:a31e5847bbc4d67cfaf0be3c2e3c48184" id="r_a31e5847bbc4d67cfaf0be3c2e3c48184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionBase.html#a31e5847bbc4d67cfaf0be3c2e3c48184">setConstantFold</a> (bool on)</td></tr>
<tr class="memitem:a0d2b2de459de09d6f663fe41ab54a460" id="r_a0d2b2de459de09d6f663fe41ab54a460"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionBase.html#a0d2b2de459de09d6f663fe41ab54a460">hasConstantFold</a> () const</td></tr>
<tr class="memitem:a31fe6ce9883ce66d9a748003b68afefb" id="r_a31fe6ce9883ce66d9a748003b68afefb"><td class="memItemLeft" align="right" valign="top">virtual llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a31fe6ce9883ce66d9a748003b68afefb">create</a> (llvm::LLVMContext &amp;C, llvm::Module *M=nullptr) const</td></tr>
<tr class="memdesc:a31fe6ce9883ce66d9a748003b68afefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts and creates this AX function into a llvm <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a>.  <br /></td></tr>
<tr class="memitem:a5cc224e4e9d775d247167137509856a5" id="r_a5cc224e4e9d775d247167137509856a5"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a5cc224e4e9d775d247167137509856a5">create</a> (llvm::Module &amp;M) const</td></tr>
<tr class="memdesc:a5cc224e4e9d775d247167137509856a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method which always uses the provided module to find the function or insert it if necessary.  <br /></td></tr>
<tr class="memitem:ad7bf85f468767251d9039133646ec788" id="r_ad7bf85f468767251d9039133646ec788"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#ad7bf85f468767251d9039133646ec788">get</a> (const llvm::Module &amp;M) const</td></tr>
<tr class="memdesc:ad7bf85f468767251d9039133646ec788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for calling M.getFunction(symbol). Returns a nullptr if the function has not yet been created or if it is embedded IR.  <br /></td></tr>
<tr class="memitem:a259cb5a711406a8c3e5d937eb9350cca" id="r_a259cb5a711406a8c3e5d937eb9350cca"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a259cb5a711406a8c3e5d937eb9350cca">size</a> () const</td></tr>
<tr class="memdesc:a259cb5a711406a8c3e5d937eb9350cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of arguments that this function has.  <br /></td></tr>
<tr class="memitem:a9f1ee89638a2fc436f51679d1a855bdf" id="r_a9f1ee89638a2fc436f51679d1a855bdf"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a9f1ee89638a2fc436f51679d1a855bdf">symbol</a> () const</td></tr>
<tr class="memdesc:a9f1ee89638a2fc436f51679d1a855bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function symbol name.  <br /></td></tr>
<tr class="memitem:a0ee4ae56bf532dc17117c17206c9bbba" id="r_a0ee4ae56bf532dc17117c17206c9bbba"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a0ee4ae56bf532dc17117c17206c9bbba">argName</a> (const size_t idx) const</td></tr>
<tr class="memdesc:a0ee4ae56bf532dc17117c17206c9bbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the descriptive name of the given argument index.  <br /></td></tr>
<tr class="memitem:a592052ecd54b2fed6431ca2fb31cecce" id="r_a592052ecd54b2fed6431ca2fb31cecce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#acc2e13670241c2002b01d5c4daeeaa51">SmallArgumentVector</a>&lt; const char * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a592052ecd54b2fed6431ca2fb31cecce">dependencies</a> () const</td></tr>
<tr class="memitem:a851def4e79a8080add2df87bdf87a32a" id="r_a851def4e79a8080add2df87bdf87a32a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a851def4e79a8080add2df87bdf87a32a">hasParamAttribute</a> (const size_t i, const llvm::Attribute::AttrKind &amp;kind) const</td></tr>
<tr class="memdesc:a851def4e79a8080add2df87bdf87a32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated builder methods, no longer public.  <br /></td></tr>
<tr class="memitem:af6187793e0d3c6b1098b1d037e5b9530" id="r_af6187793e0d3c6b1098b1d037e5b9530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#af6187793e0d3c6b1098b1d037e5b9530">setArgumentNames</a> (std::vector&lt; const char * &gt; names)</td></tr>
<tr class="memitem:a130dc8b5cf81200428494e2d63384483" id="r_a130dc8b5cf81200428494e2d63384483"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a130dc8b5cf81200428494e2d63384483">setDependencies</a> (std::vector&lt; const char * &gt; deps)</td></tr>
<tr class="memitem:a6fb0a8f2ddba1d3d98741894a5db5f03" id="r_a6fb0a8f2ddba1d3d98741894a5db5f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a6fb0a8f2ddba1d3d98741894a5db5f03">setFnAttributes</a> (const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;in)</td></tr>
<tr class="memitem:a51952659e55f5546f5e3d8f6a4e56eb3" id="r_a51952659e55f5546f5e3d8f6a4e56eb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a51952659e55f5546f5e3d8f6a4e56eb3">setRetAttributes</a> (const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;in)</td></tr>
<tr class="memitem:a359ce980d9f1de2430296ca2f3e42409" id="r_a359ce980d9f1de2430296ca2f3e42409"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a359ce980d9f1de2430296ca2f3e42409">setParamAttributes</a> (const size_t i, const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;in)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-static-methods" class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a3c7bbe5ddababca6b3a2da7a23a25fc1" id="r_a3c7bbe5ddababca6b3a2da7a23a25fc1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a3c7bbe5ddababca6b3a2da7a23a25fc1">cast</a> (std::vector&lt; llvm::Value * &gt; &amp;args, const std::vector&lt; llvm::Type * &gt; &amp;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#aeeedef433759fed9cd7d72a6e1e56c9f">types</a>, llvm::IRBuilder&lt;&gt; &amp;B)</td></tr>
<tr class="memdesc:a3c7bbe5ddababca6b3a2da7a23a25fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the provided arguments to the given type as supported by implicit casting of function types. If the types already match OR if a cast cannot be performed, nothing is done to the argument.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename SignatureT&gt;<br />
struct openvdb::v13_0::ax::codegen::CFunctionSRet&lt; SignatureT &gt;</div><p>Represents a concrete C function binding with the first argument as its return type. </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a441bc7ccfcf686435f4d8c4a534fe5b6" name="a441bc7ccfcf686435f4d8c4a534fe5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441bc7ccfcf686435f4d8c4a534fe5b6">&#9670;&#160;</a></span>BaseT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a441bc7ccfcf686435f4d8c4a534fe5b6">BaseT</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html">SRetFunction</a>&lt;SignatureT, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html">CFunction</a>&lt;SignatureT&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbaff2c38456dbe53e25a87898fa0c4a" name="afbaff2c38456dbe53e25a87898fa0c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbaff2c38456dbe53e25a87898fa0c4a">&#9670;&#160;</a></span>CFunctionT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html#afbaff2c38456dbe53e25a87898fa0c4a">CFunctionT</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html">CFunction</a>&lt;SignatureT&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f0369aa802ea699423de0552c44a42b" name="a1f0369aa802ea699423de0552c44a42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0369aa802ea699423de0552c44a42b">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a1f0369aa802ea699423de0552c44a42b">Ptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2846ade648824cd69bd0fdc3d2cee4ca" name="a2846ade648824cd69bd0fdc3d2cee4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2846ade648824cd69bd0fdc3d2cee4ca">&#9670;&#160;</a></span>Traits</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#a2846ade648824cd69bd0fdc3d2cee4ca">Traits</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="aee8c90b86fef2410c5903bcdd9df708c" name="aee8c90b86fef2410c5903bcdd9df708c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8c90b86fef2410c5903bcdd9df708c">&#9670;&#160;</a></span>SignatureMatch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">SignatureMatch</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The result type from calls to <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a00c794a174f7525be4a6cd0f2b0a1ee5" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a00c794a174f7525be4a6cd0f2b0a1ee5" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a> cannot return Ambiguous - this is only returned by the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html" title="A group of functions which all have the same name but different signatures. For example: float abs(fl...">FunctionGroup</a> API. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aee8c90b86fef2410c5903bcdd9df708cac9d3e887722f2bc482bcca9d41c512af" name="aee8c90b86fef2410c5903bcdd9df708cac9d3e887722f2bc482bcca9d41c512af"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee8c90b86fef2410c5903bcdd9df708caff9abf2b1a689f70a77a18da50c01d9f" name="aee8c90b86fef2410c5903bcdd9df708caff9abf2b1a689f70a77a18da50c01d9f"></a>Size&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee8c90b86fef2410c5903bcdd9df708ca81a198911eba60d4033c233d3ec90ea1" name="aee8c90b86fef2410c5903bcdd9df708ca81a198911eba60d4033c233d3ec90ea1"></a>Implicit&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee8c90b86fef2410c5903bcdd9df708ca8b6aaae09cff57a6af002d994ec5c647" name="aee8c90b86fef2410c5903bcdd9df708ca8b6aaae09cff57a6af002d994ec5c647"></a>Ambiguous&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aee8c90b86fef2410c5903bcdd9df708cad2dd6ed7eca9210b09941bee2c62735f" name="aee8c90b86fef2410c5903bcdd9df708cad2dd6ed7eca9210b09941bee2c62735f"></a>Explicit&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2ae187a4647173c1a9fb982dea60bcdf" name="a2ae187a4647173c1a9fb982dea60bcdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae187a4647173c1a9fb982dea60bcdf">&#9670;&#160;</a></span>CFunctionSRet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionSRet.html">CFunctionSRet</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>symbol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SignatureT</td>          <td class="paramname"><span class="paramname"><em>function</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2aa6a4231668330c0f2d6fb1cf6edb0" name="ac2aa6a4231668330c0f2d6fb1cf6edb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2aa6a4231668330c0f2d6fb1cf6edb0">&#9670;&#160;</a></span>~CFunctionSRet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionSRet.html">CFunctionSRet</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a172f6d0829640e5012919c726d7b0bcd" name="a172f6d0829640e5012919c726d7b0bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172f6d0829640e5012919c726d7b0bcd">&#9670;&#160;</a></span>address()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t address </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel final">final</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the global address of this function. </p>
<dl class="section note"><dt>Note</dt><dd>This is only required for C bindings. </dd></dl>

<p>Implements <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionBase.html#ab297a4267d686e973ef81ecfe05563bc">CFunctionBase</a>.</p>

</div>
</div>
<a id="a0ee4ae56bf532dc17117c17206c9bbba" name="a0ee4ae56bf532dc17117c17206c9bbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee4ae56bf532dc17117c17206c9bbba">&#9670;&#160;</a></span>argName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * argName </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the descriptive name of the given argument index. </p>
<p>If the index is greater than the number of arguments, an empty string is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d777657b5c1605fa4792b479f49a448" name="a0d777657b5c1605fa4792b479f49a448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d777657b5c1605fa4792b479f49a448">&#9670;&#160;</a></span>call() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> call </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html">NativeArguments</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a160d941a6104d6c46c3da98584a8a265" name="a160d941a6104d6c46c3da98584a8a265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160d941a6104d6c46c3da98584a8a265">&#9670;&#160;</a></span>call() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> call </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html">Arguments</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html#a160d941a6104d6c46c3da98584a8a265">CFunction&lt; SignatureT &gt;</a>.</p>

</div>
</div>
<a id="aae8daf0986a2751029d10dc5a318465e" name="aae8daf0986a2751029d10dc5a318465e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8daf0986a2751029d10dc5a318465e">&#9670;&#160;</a></span>call() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * call </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override of call which allocates the required SRET llvm::Value for this function. </p>
<dl class="section note"><dt>Note</dt><dd>Unlike other function where the returned llvm::Value* is a llvm::CallInst (which also represents the return value), SRET functions return the allocated 1st argument i.e. not a llvm::CallInst </dd></dl>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html#aae8daf0986a2751029d10dc5a318465e">CFunction&lt; SignatureT &gt;</a>.</p>

</div>
</div>
<a id="a3eb5e0f696f0d8de2c9ce35ef725272f" name="a3eb5e0f696f0d8de2c9ce35ef725272f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb5e0f696f0d8de2c9ce35ef725272f">&#9670;&#160;</a></span>call() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * call </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>cast</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is deprecated! Omitting the warning as it invokes the parent function which is also deprecated. Use <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html" title="Wrapper struct to represent &quot;native&quot; function arguments; that is, the set of Value type that the AX g...">NativeArguments</a> to perform argument casting </dd></dl>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html#a3eb5e0f696f0d8de2c9ce35ef725272f">CFunction&lt; SignatureT &gt;</a>.</p>

</div>
</div>
<a id="a3c7bbe5ddababca6b3a2da7a23a25fc1" name="a3c7bbe5ddababca6b3a2da7a23a25fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7bbe5ddababca6b3a2da7a23a25fc1">&#9670;&#160;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cast </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; llvm::Type * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast the provided arguments to the given type as supported by implicit casting of function types. If the types already match OR if a cast cannot be performed, nothing is done to the argument. </p>

</div>
</div>
<a id="a31fe6ce9883ce66d9a748003b68afefb" name="a31fe6ce9883ce66d9a748003b68afefb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fe6ce9883ce66d9a748003b68afefb">&#9670;&#160;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Function * create </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Module *</td>          <td class="paramname"><span class="paramname"><em>M</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts and creates this AX function into a llvm <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a>. </p>
<p>This method uses the result from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aa7be69eba606cab147a0162591c13e6f" title="Populate a vector of ArgInfos which describe this function signature. This method is used by Function...">Function::types()</a> to construct a llvm::FunctionType and a subsequent a llvm::Function. Any parameter, return or function attributes are also added to the function. If a module is provided, the module if first checked to see if the function already exists. If it does, it is immediately returned. If the function doesn't exist in the module, its prototype is created and also inserted into the end of the modules function list. If no module is provided, the function is left detached and must be added to a valid Module to be callable. </p><dl class="section warning"><dt>Warning</dt><dd>If a module is not provided, the caller takes ownership of the returned function and is responsible for deallocating it. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The body of the function is left to derived classes to implement. As you need a Module to generate the prototype/body, this function serves two purposes. The first is to return the detached function signature if only a context is provided. The second is to ensure the function prototype and body (if required) is inserted into the module prior to returning. </dd>
<dd>
It is possible to end up with function symbol collisions if you do not have unique function symbols in your module</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The LLVM Context </td></tr>
    <tr><td class="paramname">M</td><td>The Module to write the function to </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a5f7069870299fb4b0dccd996457e1a1e">IRFunctionBase</a>.</p>

</div>
</div>
<a id="a5cc224e4e9d775d247167137509856a5" name="a5cc224e4e9d775d247167137509856a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc224e4e9d775d247167137509856a5">&#9670;&#160;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function * create </td>
          <td>(</td>
          <td class="paramtype">llvm::Module &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method which always uses the provided module to find the function or insert it if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The llvm::Module to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a592052ecd54b2fed6431ca2fb31cecce" name="a592052ecd54b2fed6431ca2fb31cecce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592052ecd54b2fed6431ca2fb31cecce">&#9670;&#160;</a></span>dependencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#acc2e13670241c2002b01d5c4daeeaa51">SmallArgumentVector</a>&lt; const char * &gt; &amp; dependencies </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3dd86f31cfbcdfff6a7039302c71b29" name="ad3dd86f31cfbcdfff6a7039302c71b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3dd86f31cfbcdfff6a7039302c71b29">&#9670;&#160;</a></span>fold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignatureT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Constant * fold </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel final">final</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated</a></b></dt><dd></dd></dl>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionBase.html#a63efe3f44116e72bed2c9c6f7b916fe9">CFunctionBase</a>.</p>

</div>
</div>
<a id="ad7bf85f468767251d9039133646ec788" name="ad7bf85f468767251d9039133646ec788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bf85f468767251d9039133646ec788">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function * get </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method for calling M.getFunction(symbol). Returns a nullptr if the function has not yet been created or if it is embedded IR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The llvm::Module to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d2b2de459de09d6f663fe41ab54a460" name="a0d2b2de459de09d6f663fe41ab54a460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2b2de459de09d6f663fe41ab54a460">&#9670;&#160;</a></span>hasConstantFold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasConstantFold </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a851def4e79a8080add2df87bdf87a32a" name="a851def4e79a8080add2df87bdf87a32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851def4e79a8080add2df87bdf87a32a">&#9670;&#160;</a></span>hasParamAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasParamAttribute </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Attribute::AttrKind &amp;</td>          <td class="paramname"><span class="paramname"><em>kind</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated builder methods, no longer public. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated</a></b></dt><dd>"This method incorrectly returns the attributes " "of the function set by the FunctionBuilder, not by the codegen. To " "inspect function attributes, retrieve the created function from the " "llvm::Module." <br  />
 </dd></dl>

</div>
</div>
<a id="a431456d47fdcb019ab9db247b9989a38" name="a431456d47fdcb019ab9db247b9989a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431456d47fdcb019ab9db247b9989a38">&#9670;&#160;</a></span>match() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">Function::SignatureMatch</a> match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override of match which inserts the SRET type such that the base class methods ignore it. </p>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a00c794a174f7525be4a6cd0f2b0a1ee5">Function</a>.</p>

</div>
</div>
<a id="a9527ef3e0f61abd8b26dba4d2648ad21" name="a9527ef3e0f61abd8b26dba4d2648ad21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9527ef3e0f61abd8b26dba4d2648ad21">&#9670;&#160;</a></span>match() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">Function::SignatureMatch</a> match </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Type * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is deprecated! Omitting the warning as it invokes the parent function which is also deprecated. Use <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html" title="Wrapper struct to represent &quot;native&quot; function arguments; that is, the set of Value type that the AX g...">NativeArguments</a> to perform argument casting </dd></dl>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a8bc9b930270e06477d777256c1e060d9">Function</a>.</p>

</div>
</div>
<a id="a02be931d9569d33334a4032a421d9c52" name="a02be931d9569d33334a4032a421d9c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02be931d9569d33334a4032a421d9c52">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void print </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>axTypes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override of print to avoid printing out the SRET type. </p>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a122389addb0b884bb5f7f5b45a3b24a5">Function</a>.</p>

</div>
</div>
<a id="af6187793e0d3c6b1098b1d037e5b9530" name="af6187793e0d3c6b1098b1d037e5b9530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6187793e0d3c6b1098b1d037e5b9530">&#9670;&#160;</a></span>setArgumentNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setArgumentNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const char * &gt;</td>          <td class="paramname"><span class="paramname"><em>names</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated</a></b></dt><dd>"Use the FunctionBuilder to construct Functions" <br  />
 </dd></dl>

</div>
</div>
<a id="a31e5847bbc4d67cfaf0be3c2e3c48184" name="a31e5847bbc4d67cfaf0be3c2e3c48184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e5847bbc4d67cfaf0be3c2e3c48184">&#9670;&#160;</a></span>setConstantFold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setConstantFold </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>on</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a130dc8b5cf81200428494e2d63384483" name="a130dc8b5cf81200428494e2d63384483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130dc8b5cf81200428494e2d63384483">&#9670;&#160;</a></span>setDependencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setDependencies </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const char * &gt;</td>          <td class="paramname"><span class="paramname"><em>deps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated</a></b></dt><dd>"Use the FunctionBuilder to construct Functions" <br  />
 </dd></dl>

</div>
</div>
<a id="a6fb0a8f2ddba1d3d98741894a5db5f03" name="a6fb0a8f2ddba1d3d98741894a5db5f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb0a8f2ddba1d3d98741894a5db5f03">&#9670;&#160;</a></span>setFnAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setFnAttributes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated</a></b></dt><dd>"Use the FunctionBuilder to construct Functions" <br  />
 </dd></dl>

</div>
</div>
<a id="a359ce980d9f1de2430296ca2f3e42409" name="a359ce980d9f1de2430296ca2f3e42409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359ce980d9f1de2430296ca2f3e42409">&#9670;&#160;</a></span>setParamAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setParamAttributes </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated</a></b></dt><dd>"Use the FunctionBuilder to construct Functions" <br  />
 </dd></dl>

</div>
</div>
<a id="a51952659e55f5546f5e3d8f6a4e56eb3" name="a51952659e55f5546f5e3d8f6a4e56eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51952659e55f5546f5e3d8f6a4e56eb3">&#9670;&#160;</a></span>setRetAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setRetAttributes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated</a></b></dt><dd>"Use the FunctionBuilder to construct Functions" <br  />
 </dd></dl>

</div>
</div>
<a id="a259cb5a711406a8c3e5d937eb9350cca" name="a259cb5a711406a8c3e5d937eb9350cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259cb5a711406a8c3e5d937eb9350cca">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of arguments that this function has. </p>

</div>
</div>
<a id="a9f1ee89638a2fc436f51679d1a855bdf" name="a9f1ee89638a2fc436f51679d1a855bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1ee89638a2fc436f51679d1a855bdf">&#9670;&#160;</a></span>symbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * symbol </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function symbol name. </p>
<p>This will be used as its identifier in IR and must be unique. </p>

</div>
</div>
<a id="aeeedef433759fed9cd7d72a6e1e56c9f" name="aeeedef433759fed9cd7d72a6e1e56c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeedef433759fed9cd7d72a6e1e56c9f">&#9670;&#160;</a></span>types() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html">ArgInfo</a> types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overide the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html" title="Metadata associated with a function argument or return value.">ArgInfo</a> type method. This does NOT change the arg order, it simply marks the first argument as a return argument. Note that the void ret type is also left as a return type. </p>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html#a552e640f9d0305206696ddffc619e862">CFunction&lt; SignatureT &gt;</a>.</p>

</div>
</div>
<a id="aeb7c9936016e2c09aab2e6f8e039a16a" name="aeb7c9936016e2c09aab2e6f8e039a16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7c9936016e2c09aab2e6f8e039a16a">&#9670;&#160;</a></span>types() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Type * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Bring in deprecated type methods </dd></dl>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html#a498bb66ac13b5ba4fb6e66494dc482db">CFunction&lt; SignatureT &gt;</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax.html">ax</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html">codegen</a></li><li class="navelem"><a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionSRet.html">CFunctionSRet</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
