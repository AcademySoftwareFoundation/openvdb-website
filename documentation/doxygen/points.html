<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: OpenVDB Points</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">9.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenVDB</a></li><li class="navelem"><a class="el" href="changes.html">Release Notes</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">OpenVDB Points </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="secPtContents"></a>
Contents</h1>
<ul>
<li><a class="el" href="points.html#secPtOverview">Introduction</a></li>
<li><a class="el" href="points.html#secPtCompression">Compression</a></li>
<li><a class="el" href="points.html#secPtLocality">Locality</a></li>
<li><a class="el" href="points.html#secPtAttributes">Attributes</a><ul>
<li><a class="el" href="points.html#secPtTypedAttributeArray">TypedAttributeArray</a></li>
<li><a class="el" href="points.html#secPtAttributeHandle">AttributeHandle</a></li>
<li><a class="el" href="points.html#secPtAttributePerformance">TypedAttributeArray vs AttributeHandle</a></li>
<li><a class="el" href="points.html#secPtAttributeSet">AttributeSet and Descriptor</a></li>
</ul>
</li>
<li><a class="el" href="points.html#secPtPointTree">The Point Tree</a><ul>
<li><a class="el" href="points.html#secPtPointIndexTree">Point Index Tree</a></li>
<li><a class="el" href="points.html#secPtPointDataTree">Point Data Tree</a></li>
</ul>
</li>
<li><a class="el" href="points.html#secPtSparsity">Voxel Values</a><ul>
<li><a class="el" href="points.html#secPtBackground">Background and Tile Values</a></li>
<li><a class="el" href="points.html#secPtActiveValues">Active Values</a></li>
<li><a class="el" href="points.html#secPtIndexIterators">Index Iterators</a></li>
<li><a class="el" href="points.html#secPtIndexFilters">Index Filters</a></li>
</ul>
</li>
<li><a class="el" href="points.html#secPtSpaceAndTrans">Voxel Space, Index Space, World Space</a></li>
</ul>
<h1><a class="anchor" id="secPtOverview"></a>
Introduction</h1>
<p><a class="anchor" id="openvdbPointsOverview"></a> The <b>OpenVDB</b> library can store point data within an OpenVDB hierarchy in two different ways. A <b>PointIndexGrid</b> stores index offsets that reference data stored in an external linear point array, a <b>PointDataGrid</b> stores the points with attributes directly in the VDB Grid. This document focuses mainly on the localised style of storage used by <b>PointDataGrids</b>. Using this storage mechanism, points are spatially-organised into VDB voxels to provide faster access and a greater opportunity for data compression compared with linear point arrays.</p>
<p>See the <a class="el" href="codeExamples.html#openvdbPointsHelloWorld">Cookbook</a> for code examples to get started using <b>OpenVDB</b> <b>Points</b>.</p>
<h1><a class="anchor" id="secPtCompression"></a>
Compression</h1>
<p>A key motivation behind the library is to increase data compression and thus reduce the memory and disk space requirements of the point set.</p>
<p>There are three types of compression used in this library to store point attribute data - (1) <b>value</b> <b>compression</b> where the codec is selected specifically based on the intent of the data, (2) <b>uniform</b> <b>compression</b> where arrays of identical values can be collapsed down into a single value, (3) <b>stream</b> <b>compression</b> where the Blosc stream compressor can be used to pack and unpack streams of data using a fast, lossless compression codec.</p>
<p>Uniform and stream compression are offered in other applications, notably Houdini, but with the case of stream compression, used only for disk storage.</p>
<p>Value compression is provided based on the principal that a good general-purpose compression scheme will usually not be superior to one that is specifically tuned to the range and intention of how the data will be used. The most commonly used style of value compression in OpenVDB Points is quantization for point position data. Floating-point world-space positions will typically use a much higher accuracy than desired around the origin and a much lower accuracy than desired far from the origin, which is as a result of the dynamic range used in floating-point that makes it usable at different orders of magnitude. More tailored position compression is introduced by splitting positions into an integer offset provided by the VDB voxels and grid transform and a reduced precision fixed-point offset from the center of the voxel.</p>
<p>In addition, other attributes such as velocity can benefit from value compression. For example, a unit vector scheme can compress a 3 x float vector (12 bytes) into just 2 bytes.</p>
<h1><a class="anchor" id="secPtLocality"></a>
Locality</h1>
<p>Data compression isn't the only area to benefit from a spatially organised data set. Due to the effects of L1 and L2 caching in modern CPUs, improved cache locality through storing point data close in memory to their neighbors can bring about a big improvement in performance.</p>
<p>A number of point rasterization gather-style tests that compared spatially organised data with randomly organised linear data when dereferenced using a spatial acceleration structure consistently resulted in a performance improvement of between 2x and 3x.</p>
<h1><a class="anchor" id="secPtAttributes"></a>
Attributes</h1>
<p>Attribute storage is provided as an independent toolset within the library to allow for use outside of OpenVDB grids.</p>
<h2><a class="anchor" id="secPtTypedAttributeArray"></a>
TypedAttributeArray</h2>
<p>The TypedAttributeArray stores array data with a specified value type and compression codec, which form the template signature.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType, <span class="keyword">typename</span> Codec&gt;</div><div class="line"><span class="keyword">class </span>TypedAttributeArray: <span class="keyword">public</span> <a class="code" href="namespacenanovdb.html#a88f2aa0b172a229831be2b4e1c70e757ac9f80f42ad87935afb0e58d931cac637">AttributeArray</a></div></div><!-- fragment --><p>The base AttributeArray class from which the TypedAttributeArray derives is not templated and can be used for all non-typed operations such as serialization.</p>
<p>Here is an example of floating-point scalar attribute storage using a truncation codec to reduce the footprint from 32-bit to 16-bit:</p>
<div class="fragment"><div class="line">openvdb::points::TypedAttributeArray&lt;float, openvdb::points::TruncateCodec&gt;</div></div><!-- fragment --><h2><a class="anchor" id="secPtAttributeHandle"></a>
AttributeHandle</h2>
<p>AttributeHandle and AttributeWriteHandle classes provide access to the array data without requiring knowledge of the codec. This is important as it can allow users to add their own attribute compression schemes without requiring any modification to existing code.</p>
<p>AttributeHandles provide benefits to memory usage in allowing data to be packed and unpacked efficiently when using stream compression. When compressed with a stream compression scheme, the AttributeHandle unpacks attribute data into a local (uncompressed) buffer on access and discards this temporary data once the AttributeHandle is destroyed. This has the benefit of retaining the stream compression during access which lowers the peak memory substantially.</p>
<p>This is how to create a float AttributeHandle bound to a specific attribute in a leaf:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> handle = AttributeHandle&lt;float&gt;::create(leaf-&gt;constAttributeArray(<span class="stringliteral">&quot;attribute_name&quot;</span>));</div></div><!-- fragment --><p>Note that ensuring const access to the attribute array will prevent redundant copying when using a read-only handle.</p>
<h2><a class="anchor" id="secPtAttributePerformance"></a>
TypedAttributeArray vs AttributeHandle</h2>
<p>One key benefit of AttributeHandles is that they ensure the data being accessed has been uncompressed and is in-core on creation of the handle to avoid the need to perform these checks when the data is being accessed and modified for improved performance. An AttributeHandle may also be provided a specific codec if known to eliminate the indirection cost.</p>
<h2><a class="anchor" id="secPtAttributeSet"></a>
AttributeSet and Descriptor</h2>
<p>The AttributeSet stores a collection of attribute arrays along with a Descriptor that tracks the type of each of the attribute arrays.</p>
<p>In typical use cases, the Descriptor is shared amongst leaf nodes with many of the algorithms making this assumption for performance reasons. However, it is still possible to configure the data so that leaf nodes in the same grid can use different Descriptors with different numbers and types of attributes. A typical use-case for this might be to reduce precision of an attribute further from a camera where accuracy is deemed less important and can be traded for a reduced memory or disk footprint.</p>
<h1><a class="anchor" id="secPtPointTree"></a>
The Point Tree</h1>
<h2><a class="anchor" id="secPtPointIndexTree"></a>
Point Index Tree</h2>
<p>As mentioned in the introduction, the PointIndexTree is a structure in OpenVDB that stores an array of offset indices to a linear point array in the leaf nodes. In constrast, the PointDataTree stores the actual data localised in the leaf nodes.</p>
<p>The PointIndexTree has this tree configuration:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> tree::Tree4&lt;PointIdx32, 5, 4, 3&gt;::Type <a class="code" href="namespaceopenvdb_1_1v9__0_1_1tools.html#af59b06fbf7e8c0f817695e92b0a86db1">PointIndexTree</a>;</div></div><!-- fragment --><h2><a class="anchor" id="secPtPointDataTree"></a>
Point Data Tree</h2>
<p>The PointDataTree has this tree configuration:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> tree::Tree4&lt;PointDataIdx32, 5, 4, 3&gt;::Type <a class="code" href="namespaceopenvdb_1_1v9__0_1_1points.html#a7fec47b2a3d864d85c53f69c3655fdbf">PointDataTree</a>;</div></div><!-- fragment --><p>Note that with both the PointIndexTree and the PointDataTree, the data type is actually a 32-bit unsigned integer, but it is provided in this form to distinguish it from other LeafNodes that store the same data type. None of the other components within the Tree or Grid hierarchy change. It is for this reason that many of the existing features of OpenVDB such as serialization work without requiring additional functionality in OpenVDB.</p>
<h1><a class="anchor" id="secPtSparsity"></a>
Voxel Values</h1>
<p>For the PointDataTree, the voxel values represent the end position in the linear attribute arrays attached to each LeafNode. Using the value of the previous voxel (zero for the first voxel), the offset for the start position can be deduced.</p>
<h2><a class="anchor" id="secPtBackground"></a>
Background and Tile Values</h2>
<p>There are three distinct ways of storing data in an OpenVDB tree: <b>voxel values</b>, <b>tile values</b>, and a <b>background value</b>. Unfortunately the background value and tile values make little sense for point data. While technically it would be valid to use a non-zero background value and tile value, this would simply mean that only the first voxel in the LeafNode contains points which is neither an efficient storage mechanism nor particularly common. For this reason, the LeafNode constructor may take a background value but it is internally overriden to be zero on construction.</p>
<h2><a class="anchor" id="secPtActiveValues"></a>
Active Values</h2>
<p>Any voxel or tile can be classified as either <b>active</b> or <b>inactive</b>. The interpretation of this state is application-specific, however there are some conventions, such as using the active state to denote the narrow band in a levelset. For points, the most intuitive use of the active state is to mark a voxel as active if it contains points and inactive otherwise. This allows iteration over the points in a LeafNode to be accelerated to only iterate over voxels that contain points.</p>
<h2><a class="anchor" id="secPtIndexIterators"></a>
Index Iterators</h2>
<p><a class="anchor" id="openvdbPointsIterators"></a> An index iterator contains a value iterator and an index filter, however the most common usage is provided by the convenience methods on the leaf node:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> iterAll = leaf.beginIndexAll();</div><div class="line"><span class="keyword">auto</span> iterOn = leaf.beginIndexOn();</div><div class="line"><span class="keyword">auto</span> iterOff = leaf.beginIndexOff();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; iterOn; ++iterOn) {</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v9__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> index = *iterOn;</div><div class="line">}</div></div><!-- fragment --><p>These are analagous to the value iterators in the LeafNode and are creating an index iterator that wraps the value iterator together with a null filter.</p>
<p>It is also possible to iterate over indices within a specific voxel by using the beginIndexVoxel convenience method on the leaf:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> iterVoxel = leaf.beginIndexVoxel(ijk);</div></div><!-- fragment --><p>For performance and simplicity, it is recommended to use the all/on/off index iterators where possible, as these hide the explicit voxel iteration from the user meaning it is only necessary to iterate over the indices within the leaf. It is also possible to retrieve the voxel coordinate from the index iterator directly.</p>
<h2><a class="anchor" id="secPtIndexFilters"></a>
Index Filters</h2>
<p>Index filters provide an easy way of only iterating over indices that match a set criteria. One such index filter provided by the library is to iterate over the points within a group:</p>
<div class="fragment"><div class="line">openvdb::points::GroupFilter filter(<span class="stringliteral">&quot;test_point_group&quot;</span>);</div><div class="line"><span class="keyword">auto</span> iter = leaf.beginIndexOn(filter);</div></div><!-- fragment --><p>As the index iterator is templated on the filter, it's possible to construct filters that do relatively complicated operations provided they meet the basic interface requirements of an IndexFilter.</p>
<h1><a class="anchor" id="secPtSpaceAndTrans"></a>
Voxel Space, Index Space, World Space</h1>
<p>Points are stored in <b>voxel</b> <b>space</b>, meaning all point positions lie between (-0.5, -0.5, -0.5) and (0.5, 0.5, 0.5) with the center of the voxel being (0.0, 0.0, 0.0). The position of the point can be extracted in <b>index</b> <b>space</b> by adding the voxel space position to the ijk value of the voxel. The position of the point can be extracted in <b>world</b> <b>space</b> by using the grid transform to do an indexToWorld conversion.</p>
<p>See the <a class="el" href="codeExamples.html#openvdbPointsHelloWorld">Cookbook</a> for code examples to get started using <b>OpenVDB</b> <b>Points</b>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
