<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: Houdini Cookbook</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">9.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenVDB</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Houdini Cookbook </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This cookbook provides code snippets that illustrate the use of some new tools that simplify the construction of operators in Houdini. It also shows how to write operators that use OpenVDB.</p>
<h1><a class="anchor" id="sHoudiniContents"></a>
Contents</h1>
<ul>
<li><a class="el" href="houdini.html#sUIConstruction">General operator construction</a><ul>
<li><a class="el" href="houdini.html#sParmFactory">ParmFactory and ParmList</a></li>
<li><a class="el" href="houdini.html#sOpFactory">OpFactory</a></li>
<li><a class="el" href="houdini.html#sScopedInputLock">ScopedInputLock</a></li>
</ul>
</li>
<li><a class="el" href="houdini.html#sOpenVDBOperators">OpenVDB SOP construction</a><ul>
<li><a class="el" href="houdini.html#sListOfIncomingGrids">Selecting grids</a></li>
<li><a class="el" href="houdini.html#sIteratingOverGrids">Iterating over grids</a></li>
<li><a class="el" href="houdini.html#sProcessingTypedGrids">Processing grids of different types</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="sUIConstruction"></a>
General operator construction</h1>
<p>This section gives usage examples for some general helper classes that aid in the construction of Houdini operators. These helper classes are independent of OpenVDB and can be used in the implementation of any type of operator.</p>
<h2><a class="anchor" id="sParmFactory"></a>
ParmFactory and ParmList</h2>
<p>The <a class="el" href="classhoudini__utils_1_1ParmFactory.html">ParmFactory</a> provides a simplified interface to define the parameters of an operator. Invoking the <a class="el" href="classhoudini__utils_1_1ParmFactory.html#a7810cba012e9493faf3f7b009796e711">get</a> method on a <b>ParmFactory</b> produces a new <b>PRM_Template</b> describing a single parameter. For example,</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;houdini_utils/ParmFactory.h&gt;</span></div><div class="line">...</div><div class="line"></div><div class="line">PRM_Template groupParm =</div><div class="line">    <a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_STRING, <span class="stringliteral">&quot;group&quot;</span>, <span class="stringliteral">&quot;Group&quot;</span>)</div><div class="line">    .<a class="code" href="classhoudini__utils_1_1ParmFactory.html#a651e290633757baf60583024c1d42657">setTooltip</a>(<span class="stringliteral">&quot;Specify a subset of the input VDB grids to be processed.&quot;</span>)</div><div class="line">    .<a class="code" href="classhoudini__utils_1_1ParmFactory.html#a85f4fa3826d90f375abcd8fdc49457b5">setDocumentation</a>(</div><div class="line">        <span class="stringliteral">&quot;The subset of VDB grids to be processed&quot;</span></div><div class="line">        <span class="stringliteral">&quot; (see [specifying volumes|/model/volumes#group] for details&quot;</span></div><div class="line">        <span class="stringliteral">&quot; on selecting grids)&quot;</span>)</div><div class="line">    .<a class="code" href="classhoudini__utils_1_1ParmFactory.html#aab2d7b405605f636c28e78a84c413a5e">setChoiceList</a>(&amp;<a class="code" href="namespacehoudini__utils.html#afefd9db59dd2c1bc68e438920f3339ba">houdini_utils::PrimGroupMenu</a>)</div><div class="line">    .<a class="code" href="classhoudini__utils_1_1ParmFactory.html#a7810cba012e9493faf3f7b009796e711">get</a>();</div><div class="line"></div><div class="line">PRM_Template toleranceParm =</div><div class="line">    <a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_FLT_J, <span class="stringliteral">&quot;tolerance&quot;</span>, <span class="stringliteral">&quot;Pruning Tolerance&quot;</span>)</div><div class="line">    .<a class="code" href="classhoudini__utils_1_1ParmFactory.html#ad5bd8c39149c203e002ba5b18a92d8c9">setDefault</a>(0.01)</div><div class="line">    .<a class="code" href="classhoudini__utils_1_1ParmFactory.html#a7ca684924e0fbe45013ff42cccbd0da1">setRange</a>(PRM_RANGE_RESTRICTED, 0, PRM_RANGE_UI, 1)</div><div class="line">    .<a class="code" href="classhoudini__utils_1_1ParmFactory.html#a7810cba012e9493faf3f7b009796e711">get</a>();</div></div><!-- fragment --><p>Note that, using a <b>ParmFactory</b>, one need only specify those attributes of a parameter (<b>setDefaults</b>, <b>setTooltip</b>, etc.) that have non-default values.</p>
<p>By default, a parameter&rsquo;s tooltip is used to describe the parameter on the Help page for its operator. More detailed documentation in Houdini&rsquo;s <a href="http://www.sidefx.com/docs/houdini/help/format">wiki markup</a> format can be added with <a class="el" href="classhoudini__utils_1_1ParmFactory.html#a85f4fa3826d90f375abcd8fdc49457b5">setDocumentation</a>, as in the example above. Call <b>setDocumentation</b> with a null pointer or with an empty string to exclude a parameter from the Help page.</p>
<p><b>ParmFactory</b> objects may be added directly to a <a class="el" href="classhoudini__utils_1_1ParmList.html">ParmList</a>, which among other things ensures that the list of templates is properly null-terminated. Typically, the <b>ParmList</b> is populated at the time the operator is registered, as in the following example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;houdini_utils/ParmFactory.h&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">newSopOperator(OP_OperatorTable* table)</div><div class="line">{</div><div class="line">    <a class="code" href="classhoudini__utils_1_1ParmList.html">houdini_utils::ParmList</a> parms;</div><div class="line"></div><div class="line">    <span class="comment">// Define a string-valued group name pattern parameter and add it to the list.</span></div><div class="line">    parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#adc43bec96556f6ab7277dad2e0af262a">add</a>(<a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_STRING, <span class="stringliteral">&quot;group&quot;</span>, <span class="stringliteral">&quot;Group&quot;</span>)</div><div class="line">        .setTooltip(<span class="stringliteral">&quot;Specify a subset of the input VDB grids to be processed.&quot;</span>)</div><div class="line">        .setChoiceList(&amp;<a class="code" href="namespacehoudini__utils.html#afefd9db59dd2c1bc68e438920f3339ba">houdini_utils::PrimGroupMenu</a>));</div><div class="line"></div><div class="line">    <span class="comment">// Define a menu of verbosity levels.</span></div><div class="line">    parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#adc43bec96556f6ab7277dad2e0af262a">add</a>(<a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_ORD, <span class="stringliteral">&quot;verbose&quot;</span>, <span class="stringliteral">&quot;Verbosity&quot;</span>)</div><div class="line">        .setDefault(PRMoneDefaults)</div><div class="line">        .setChoiceListItems(PRM_CHOICELIST_SINGLE, {</div><div class="line">            <span class="stringliteral">&quot;quiet&quot;</span>,    <span class="stringliteral">&quot;Quiet&quot;</span>, <span class="comment">// token, label</span></div><div class="line">            <span class="stringliteral">&quot;verbose&quot;</span>,  <span class="stringliteral">&quot;Verbose&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;verbose2&quot;</span>, <span class="stringliteral">&quot;More Verbose&quot;</span>,</div><div class="line">        }));</div><div class="line"></div><div class="line">    <span class="comment">// Define a menu from a dynamically-constructed list of items.</span></div><div class="line">    {</div><div class="line">        std::vector&lt;std::string&gt; items;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceopenvdb_1_1v9__0.html#a06fc87d81c62e9abb8790b6e5713c55bad920626883d514328c461b4d2496e3b6">openvdb::NUM_GRID_CLASSES</a>; ++i) {</div><div class="line">            <a class="code" href="namespaceopenvdb_1_1v9__0.html#a511a7f5bd868162ec06bcc20b98e160e">openvdb::GridClass</a> cls = <a class="code" href="namespaceopenvdb_1_1v9__0.html#a511a7f5bd868162ec06bcc20b98e160e">openvdb::GridClass</a>(i);</div><div class="line">            items.push_back(<a class="code" href="classopenvdb_1_1v9__0_1_1GridBase.html#ac5ba27730c606524a3f91ad68081cfcf">openvdb::GridBase::gridClassToString</a>(cls));   <span class="comment">// token</span></div><div class="line">            items.push_back(<a class="code" href="classopenvdb_1_1v9__0_1_1GridBase.html#a235f104d43761fdf4a92425ba82c1e1d">openvdb::GridBase::gridClassToMenuName</a>(cls)); <span class="comment">// label</span></div><div class="line">        }</div><div class="line"></div><div class="line">        parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#adc43bec96556f6ab7277dad2e0af262a">add</a>(<a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_ORD, <span class="stringliteral">&quot;gridclass&quot;</span>, <span class="stringliteral">&quot;Grid Class&quot;</span>)</div><div class="line">            .setDefault(PRMzeroDefaults)</div><div class="line">            .setChoiceListItems(PRM_CHOICELIST_SINGLE, items));</div><div class="line">    }</div><div class="line"></div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Switchers"></a>
Switchers</h2>
<p>The <b>ParmList</b> provides a convenient way of defining switchers (tab menus):</p>
<div class="fragment"><div class="line">parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#a56a15afebeb279b85bccc7de15a5406c">beginSwitcher</a>(<span class="stringliteral">&quot;switcher&quot;</span>);</div><div class="line"></div><div class="line">parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#abccd3f4d77b68e1ead1232042c7b8985">addFolder</a>(<span class="stringliteral">&quot;Tree Topology&quot;</span>);</div><div class="line"></div><div class="line">parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#adc43bec96556f6ab7277dad2e0af262a">add</a>(<a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_HEADING, <span class="stringliteral">&quot;nodes&quot;</span>, <span class="stringliteral">&quot;Nodes&quot;</span>));</div><div class="line">parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#adc43bec96556f6ab7277dad2e0af262a">add</a>(<a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_TOGGLE, <span class="stringliteral">&quot;viewnodes&quot;</span>, <span class="stringliteral">&quot;View&quot;</span>));</div><div class="line">...</div><div class="line"></div><div class="line">parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#abccd3f4d77b68e1ead1232042c7b8985">addFolder</a>(<span class="stringliteral">&quot;Isosurface&quot;</span>);</div><div class="line"></div><div class="line">parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#adc43bec96556f6ab7277dad2e0af262a">add</a>(<a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_HEADING, <span class="stringliteral">&quot;surfacing&quot;</span>, <span class="stringliteral">&quot;Surfacing&quot;</span>));</div><div class="line">parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#adc43bec96556f6ab7277dad2e0af262a">add</a>(<a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_TOGGLE, <span class="stringliteral">&quot;extractmesh&quot;</span>, <span class="stringliteral">&quot;Extract Mesh&quot;</span>));</div><div class="line">...</div><div class="line"></div><div class="line">parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#af1e0a29d616435dd3e8e561f365d7c85">endSwitcher</a>();</div></div><!-- fragment --><p>The above generates the following UI:</p>
<div class="image">
<img src="tabmenu.png" alt="tabmenu.png"/>
</div>
<p>Switchers can also be nested:</p>
<div class="fragment"><div class="line">parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#a56a15afebeb279b85bccc7de15a5406c">beginSwitcher</a>(<span class="stringliteral">&quot;switcher&quot;</span>);</div><div class="line">    parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#abccd3f4d77b68e1ead1232042c7b8985">addFolder</a>(<span class="stringliteral">&quot;A&quot;</span>);</div><div class="line">        parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#a56a15afebeb279b85bccc7de15a5406c">beginSwitcher</a>(<span class="stringliteral">&quot;nested_switcher&quot;</span>);</div><div class="line">            parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#abccd3f4d77b68e1ead1232042c7b8985">addFolder</a>(<span class="stringliteral">&quot;1&quot;</span>);</div><div class="line">            parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#abccd3f4d77b68e1ead1232042c7b8985">addFolder</a>(<span class="stringliteral">&quot;2&quot;</span>);</div><div class="line">            parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#abccd3f4d77b68e1ead1232042c7b8985">addFolder</a>(<span class="stringliteral">&quot;3&quot;</span>);</div><div class="line">        parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#af1e0a29d616435dd3e8e561f365d7c85">endSwitcher</a>();</div><div class="line">    parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#abccd3f4d77b68e1ead1232042c7b8985">addFolder</a>(<span class="stringliteral">&quot;B&quot;</span>);</div><div class="line">    ...</div><div class="line">parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#af1e0a29d616435dd3e8e561f365d7c85">endSwitcher</a>();</div></div><!-- fragment --><h2><a class="anchor" id="Multi-Parms"></a>
Multi-Parms</h2>
<p>Multi-parms are dynamically-sized parameters that consist of a variable number of child instances. Each child instance is defined by a second <b>ParmList</b> that itself consists of multiple parameters. These parameters&rsquo; tokens must include a <code>#</code> character, which is typically placed at the end of the token.</p>
<div class="fragment"><div class="line"><a class="code" href="classhoudini__utils_1_1ParmList.html">houdini_utils::ParmList</a> parms;</div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// Build the multi-parm&#39;s parameter list.</span></div><div class="line">houdini_utils::ParmList multiParms;</div><div class="line">multiParms.<a class="code" href="classhoudini__utils_1_1ParmList.html#adc43bec96556f6ab7277dad2e0af262a">add</a>(<a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_STRING, <span class="stringliteral">&quot;gridname#&quot;</span>, <span class="stringliteral">&quot;Grid name&quot;</span>)</div><div class="line">    .setTooltip(<span class="stringliteral">&quot;Specify a name for this grid.&quot;</span>));</div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// Create the multi-parm itself.</span></div><div class="line">parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#adc43bec96556f6ab7277dad2e0af262a">add</a>(<a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_MULTITYPE_LIST, <span class="stringliteral">&quot;gridlist&quot;</span>, <span class="stringliteral">&quot;Grids&quot;</span>)</div><div class="line">    .setMultiparms(multiParms)</div><div class="line">    .setDefault(PRMoneDefaults));</div><div class="line">...</div></div><!-- fragment --><p>The above generates the following UI: </p><div class="image">
<img src="multiparm.png" alt="multiparm.png"/>
</div>
<p>A multi-parm&rsquo;s parameters are accessed by iterating through each child instance:</p>
<div class="fragment"><div class="line">UT_String gridNameStr;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1, N = evalInt(<span class="stringliteral">&quot;gridlist&quot;</span>, 0, 0); i &lt;= N; ++i) {</div><div class="line">    evalStringInst(<span class="stringliteral">&quot;gridname#&quot;</span>, &amp;i, gridNameStr, 0, time);</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>Note that evaluating the multi-parm gives the number of child instances, and that the instances are numbered starting from one.</p>
<h2><a class="anchor" id="sOpFactory"></a>
OpFactory</h2>
<p>The <a class="el" href="classhoudini__utils_1_1OpFactory.html">OpFactory</a> is used in conjunction with a <a class="el" href="classhoudini__utils_1_1ParmList.html">ParmList</a> to register a new operator by adding it to the <b>OP_OperatorTable</b>. Among other things, the <b>OpFactory</b> ensures that the operator&rsquo;s type name follows a consistent naming scheme, that its Help URL is set correctly and that its inputs are labeled. Continuing with the earlier <b>newSopOperator</b> example,</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;houdini_utils/ParmFactory.h&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">newSopOperator(OP_OperatorTable* table)</div><div class="line">{</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// Register this operator.</span></div><div class="line">    <a class="code" href="classhoudini__utils_1_1OpFactory.html">houdini_utils::OpFactory</a>(<a class="code" href="classhoudini__utils_1_1OpPolicy.html">houdini_utils::OpPolicy</a>(), <span class="stringliteral">&quot;My SOP&quot;</span>,</div><div class="line">            MySOP::factory, parms, *table)</div><div class="line">        .<a class="code" href="classhoudini__utils_1_1OpFactory.html#ac5b716d0e148196a1da3d0e7556052da">addInput</a>(<span class="stringliteral">&quot;VDB grids to process&quot;</span>)        <span class="comment">// input 0</span></div><div class="line">        .<a class="code" href="classhoudini__utils_1_1OpFactory.html#afb1eb43dec0439c4cc5bb7b102b3d3f6">addOptionalInput</a>(<span class="stringliteral">&quot;Reference geometry&quot;</span>); <span class="comment">// input 1</span></div><div class="line">}</div></div><!-- fragment --><p>The first argument to the <b>OpFactory</b> constructor is an instance of the <a class="el" href="classhoudini__utils_1_1OpPolicy.html">OpPolicy</a> class (or a subclass thereof). <b>OpPolicy</b> objects allow for customization of certain behaviors of the <b>OpFactory</b>. The base class specifies a policy for converting an English operator name like <code>"My SOP"</code>, which appears in menus and other UI elements, into an operator type name. The default policy is simply to call <b>UT_String::forceValidVariableName</b> on the English name.</p>
<p>If the policy does not specify the URL of a Help page, or if the <b>OpFactory</b> is constructed without an <b>OpPolicy</b>, then documentation for the operator in Houdini&rsquo;s <a href="http://www.sidefx.com/docs/houdini/help/format">wiki markup</a> format can be provided with <a class="el" href="classhoudini__utils_1_1OpFactory.html#ab5c090b692d8ffba6ca7e8ab49fd8105">setDocumentation</a>. By default, documentation for the operator&rsquo;s parameters is generated automatically and appended to the text provided with <b>setDocumentation</b>.</p>
<p>When a particular <b>OpPolicy</b> is to be used to register multiple operators, it might be convenient to subclass <b>OpFactory</b> itself and provide a constructor that automatically initializes the base class with the desired policy.</p>
<p>If an operator ever needs to be renamed, call <a class="el" href="classhoudini__utils_1_1OpFactory.html#ac8b1a3c06d506d6c2948e8c1544a54a5">OpFactory::addAlias</a> with the old name. This will help to ensure that scene files in which the operator was saved with the old name can still be read:</p>
<div class="fragment"><div class="line"><a class="code" href="classhoudini__utils_1_1OpFactory.html">houdini_utils::OpFactory</a>(<span class="stringliteral">&quot;My Renamed SOP&quot;</span>, MySOP::factory, parms, *table)</div><div class="line">    .<a class="code" href="classhoudini__utils_1_1OpFactory.html#ac5b716d0e148196a1da3d0e7556052da">addInput</a>(<span class="stringliteral">&quot;VDB grids to process&quot;</span>)</div><div class="line">    .<a class="code" href="classhoudini__utils_1_1OpFactory.html#ac8b1a3c06d506d6c2948e8c1544a54a5">addAlias</a>(<span class="stringliteral">&quot;My SOP&quot;</span>); <span class="comment">// old name</span></div></div><!-- fragment --><p>If the operator name changed as a result of an <b>OpPolicy</b> change, supply the old operator type name directly, with <a class="el" href="classhoudini__utils_1_1OpFactory.html#aa9c45689db75d699768fe773697577b3">addAliasVerbatim</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classhoudini__utils_1_1OpFactory.html">houdini_utils::OpFactory</a>(houdini_utils::MyNewOpPolicy(), <span class="stringliteral">&quot;My SOP&quot;</span>,</div><div class="line">        MySOP::factory, parms, *table)</div><div class="line">    .<a class="code" href="classhoudini__utils_1_1OpFactory.html#aa9c45689db75d699768fe773697577b3">addAliasVerbatim</a>(<span class="stringliteral">&quot;My_Old_SOP_Type&quot;</span>); <span class="comment">// old operator type name</span></div></div><!-- fragment --><p>Among other <b>OpFactory</b> features, <a class="el" href="classhoudini__utils_1_1OpFactory.html#af9bd64bd829f378b0342714367a49cad">OpFactory::setObsoleteParms</a> accepts an additional <b>ParmList</b> of parameters that are no longer in use but that might still exist in older scene files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;houdini_utils/ParmFactory.h&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">newSopOperator(OP_OperatorTable* table)</div><div class="line">{</div><div class="line">    <span class="comment">// This boolean &quot;draw&quot; parameter has been replaced with a multi-state</span></div><div class="line">    <span class="comment">// &quot;drawmode&quot; parameter.</span></div><div class="line">    <a class="code" href="classhoudini__utils_1_1ParmList.html">houdini_utils::ParmList</a> obsoleteParms;</div><div class="line">    obsoleteParms.<a class="code" href="classhoudini__utils_1_1ParmList.html#adc43bec96556f6ab7277dad2e0af262a">add</a>(<a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_TOGGLE, <span class="stringliteral">&quot;draw&quot;</span>, <span class="stringliteral">&quot;Draw&quot;</span>));</div><div class="line"></div><div class="line">    <a class="code" href="classhoudini__utils_1_1ParmList.html">houdini_utils::ParmList</a> parms;</div><div class="line"></div><div class="line">    parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#adc43bec96556f6ab7277dad2e0af262a">add</a>(<a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_ORD, <span class="stringliteral">&quot;drawmode&quot;</span>, <span class="stringliteral">&quot;Draw&quot;</span>)</div><div class="line">        .setChoiceListItems(PRM_CHOICELIST_SINGLE, {</div><div class="line">            <span class="stringliteral">&quot;none&quot;</span>,      <span class="stringliteral">&quot;Don&#39;t Draw&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;wireframe&quot;</span>, <span class="stringliteral">&quot;Draw Wireframe&quot;</span>,</div><div class="line">            <span class="stringliteral">&quot;shaded&quot;</span>,    <span class="stringliteral">&quot;Draw Shaded&quot;</span>,</div><div class="line">        }));</div><div class="line"></div><div class="line">    <span class="comment">// Register this operator.</span></div><div class="line">    <a class="code" href="classhoudini__utils_1_1OpFactory.html">houdini_utils::OpFactory</a>(<span class="stringliteral">&quot;My SOP&quot;</span>, MySOP::factory, parms, *table)</div><div class="line">        .<a class="code" href="classhoudini__utils_1_1OpFactory.html#ac5b716d0e148196a1da3d0e7556052da">addInput</a>(<span class="stringliteral">&quot;Input geometry&quot;</span>)</div><div class="line">        .<a class="code" href="classhoudini__utils_1_1OpFactory.html#af9bd64bd829f378b0342714367a49cad">setObsoleteParms</a>(obsoleteParms);</div><div class="line">}</div></div><!-- fragment --><p>Override <b>OP_Node::resolveObsoleteParms</b> to convert the values of obsolete parameters into values of current parameters where appropriate.</p>
<h2><a class="anchor" id="sScopedInputLock"></a>
ScopedInputLock</h2>
<p>A <a class="el" href="classhoudini__utils_1_1ScopedInputLock.html">ScopedInputLock</a> locks the inputs to an operator and then automatically unlocks them when it (the lock object) goes out of scope, even if an exception is thrown.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;houdini_utils/ParmFactory.h&gt;</span></div><div class="line"></div><div class="line">OP_ERROR</div><div class="line">MySOP::cookMySop(OP_Context&amp; context)</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <a class="code" href="classhoudini__utils_1_1ScopedInputLock.html">houdini_utils::ScopedInputLock</a> lock(*<span class="keyword">this</span>, context);</div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="comment">//  do cook work</span></div><div class="line">        <span class="comment">//</span></div><div class="line">    } <span class="keywordflow">catch</span> (std::exception&amp; e) {</div><div class="line">        addError(SOP_MESSAGE, e.what());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> error();</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="sOpenVDBOperators"></a>
OpenVDB SOP construction</h1>
<p>OpenVDB SOPs are derived from the <a class="el" href="classopenvdb__houdini_1_1SOP__NodeVDB.html">SOP_NodeVDB</a> base class which, among other things, adds guide geometry and node-specific info text.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;houdini_utils/ParmFactory.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb__houdini_2openvdb__houdini_2Utils_8h.html">openvdb_houdini/Utils.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="SOP__NodeVDB_8h.html">openvdb_houdini/SOP_NodeVDB.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;UT/UT_Interrupt.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>SOP_DW_OpenVDBTemplate: <span class="keyword">public</span> <a class="code" href="classopenvdb__houdini_1_1SOP__NodeVDB.html">openvdb_houdini::SOP_NodeVDB</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    SOP_DW_OpenVDBTemplate(OP_Network*, <span class="keyword">const</span> <span class="keywordtype">char</span>* name, OP_Operator*);</div><div class="line">    ~SOP_DW_OpenVDBTemplate()<span class="keyword"> override </span>{};</div><div class="line"></div><div class="line">    <span class="keyword">static</span> OP_Node* factory(OP_Network*, <span class="keyword">const</span> <span class="keywordtype">char</span>* name, OP_Operator*);</div><div class="line"></div><div class="line">    <span class="comment">// Return true for a given input if the connector to the input</span></div><div class="line">    <span class="comment">// should be drawn dashed rather than solid.</span></div><div class="line">    <span class="keywordtype">int</span> isRefInput(<span class="keywordtype">unsigned</span> idx)<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> (idx == 1); }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    OP_ERROR <a class="code" href="classopenvdb__houdini_1_1SOP__NodeVDB.html#a8b4f1f0d89a410d26977462356c978ef">cookVDBSop</a>(OP_Context&amp;) <span class="keyword">override</span>;</div><div class="line">    <span class="keywordtype">bool</span> updateParmsFlags() <span class="keyword">override</span>;</div><div class="line">};</div></div><!-- fragment --><h2><a class="anchor" id="sListOfIncomingGrids"></a>
Selecting grids</h2>
<p>A typical SOP will have at least one group name parameter for each of its inputs. These parameters should be defined as follows (note the use of spare data to specify the input):</p>
<div class="fragment"><div class="line"><a class="code" href="classhoudini__utils_1_1ParmList.html">houdini_utils::ParmList</a> parms;</div><div class="line"></div><div class="line"><span class="comment">// Define a string-valued group name pattern parameter.</span></div><div class="line">parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#adc43bec96556f6ab7277dad2e0af262a">add</a>(<a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_STRING, <span class="stringliteral">&quot;group&quot;</span>, <span class="stringliteral">&quot;Group&quot;</span>)</div><div class="line">    .setTooltip(<span class="stringliteral">&quot;Specify a subset of the input VDB grids to be processed.&quot;</span>)</div><div class="line">    .setChoiceList(&amp;<a class="code" href="namespacehoudini__utils.html#afefd9db59dd2c1bc68e438920f3339ba">houdini_utils::PrimGroupMenu</a>));</div><div class="line"></div><div class="line"><span class="comment">// Define a group name parameter associated with this operator&#39;s second input.</span></div><div class="line">parms.<a class="code" href="classhoudini__utils_1_1ParmList.html#adc43bec96556f6ab7277dad2e0af262a">add</a>(<a class="code" href="classhoudini__utils_1_1ParmFactory.html">houdini_utils::ParmFactory</a>(PRM_STRING, <span class="stringliteral">&quot;group&quot;</span>, <span class="stringliteral">&quot;Group&quot;</span>)</div><div class="line">    .setTooltip(<span class="stringliteral">&quot;Specify a subset of the input VDB grids to be processed.&quot;</span>)</div><div class="line">    .setChoiceList(&amp;<a class="code" href="namespacehoudini__utils.html#afefd9db59dd2c1bc68e438920f3339ba">houdini_utils::PrimGroupMenu</a>)</div><div class="line">    .setSpareData(&amp;SOP_Node::theSecondInput));</div></div><!-- fragment --><p>Associated with each parameter is a menu of primitive group names. Users can select one or more groups from the menu, or create new groups on the fly using Houdini&rsquo;s <code>@<em>attr</em>=<em>value</em></code> syntax. For example, entering <code>@name="density*"</code> as the group name creates a new group comprising all input primitives whose name begins with <code>density</code>. Entering <code>@vdb_value_type=float</code> creates a new group of input grid primitives whose data type is <code>float</code>. Users may enter multiple space-separated group names or grouping expressions.</p>
<h2><a class="anchor" id="sIteratingOverGrids"></a>
Iterating over grids</h2>
<p>In <b>cookMySOP</b>, the string value of a group parameter is used to construct a <b>GA_PrimitiveGroup</b>. (SOP_NodeVDB provides a convenience method, <a class="el" href="classopenvdb__houdini_1_1SOP__NodeVDB.html#aba064bb1ec530ed62374fe2cc1ac2e05">SOP_NodeVDB::matchGroup</a>, to simplify this step and to handle errors in a standard way.) The <b>GA_PrimitiveGroup</b> so constructed may be iterated over using either a <a class="el" href="classopenvdb__houdini_1_1VdbPrimCIterator.html">VdbPrimCIterator</a>, for read-only access, or a <a class="el" href="classopenvdb__houdini_1_1VdbPrimIterator.html">VdbPrimIterator</a>, for read/write access:</p>
<div class="fragment"><div class="line">OP_ERROR</div><div class="line">MySOP::cookVDBSOP(OP_Context&amp; context)</div><div class="line">{</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        <a class="code" href="classhoudini__utils_1_1ScopedInputLock.html">houdini_utils::ScopedInputLock</a> lock(*<span class="keyword">this</span>, context);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> fpreal time = context.getTime();</div><div class="line"></div><div class="line">        <span class="comment">// This does a deep copy of native Houdini primitives</span></div><div class="line">        <span class="comment">// but only a shallow copy of VDB grids.</span></div><div class="line">        duplicateSource(0, context);</div><div class="line"></div><div class="line">        <span class="comment">// Get the group of grids to process.</span></div><div class="line">        UT_String groupStr;</div><div class="line">        evalString(groupStr, <span class="stringliteral">&quot;group&quot;</span>, 0, time);</div><div class="line">        <span class="keyword">const</span> GA_PrimitiveGroup* group = matchGroup(*gdp, groupStr.toStdString());</div><div class="line"></div><div class="line">        <span class="comment">// Get other UI parameters.</span></div><div class="line">        <span class="keywordtype">int</span> verbose = evalInt(<span class="stringliteral">&quot;verbose&quot;</span>, 0, time);</div><div class="line"></div><div class="line">        UT_AutoInterrupt progress(<span class="stringliteral">&quot;Processing VDB grids&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">// For each VDB primitive in the selected group...</span></div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="classopenvdb__houdini_1_1VdbPrimIterator.html">openvdb_houdini::VdbPrimIterator</a> it(gdp, group); it; ++it) {</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (progress.wasInterrupted()) {</div><div class="line">                <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;processing was interrupted&quot;</span>);</div><div class="line">            }</div><div class="line"></div><div class="line">            GU_PrimVDB* vdbPrim = *it;</div><div class="line"></div><div class="line">            <span class="comment">// Optionally get the primitive&#39;s name (or, if the name is empty,</span></div><div class="line">            <span class="comment">// the primitive&#39;s index).</span></div><div class="line">            <span class="keyword">const</span> UT_String gridName = it.getPrimitiveNameOrIndex();</div><div class="line"></div><div class="line">            <span class="comment">// If this primitive&#39;s grid is shared with other primitives, make</span></div><div class="line">            <span class="comment">// a deep copy of it.  If the grid is not going to be modified</span></div><div class="line">            <span class="comment">// in place (or when using GEOvdbProcessTypedGrid()--see below),</span></div><div class="line">            <span class="comment">// skip this step.</span></div><div class="line">            vdbPrim-&gt;makeGridUnique();</div><div class="line"></div><div class="line">            <a class="code" href="classopenvdb_1_1v9__0_1_1GridBase.html">openvdb_houdini::Grid</a>&amp; grid = vdbPrim-&gt;getGrid();</div><div class="line"></div><div class="line">            <span class="comment">// Process the grid.</span></div><div class="line">            <span class="comment">// (Your code goes here.)</span></div><div class="line"></div><div class="line">            <span class="comment">// In cases where it is not possible to process the primitive&#39;s</span></div><div class="line">            <span class="comment">// grid in place, replace the grid with a new grid:</span></div><div class="line">            <span class="comment">// openvdb_houdini::GridPtr outputGrid = ...;</span></div><div class="line">            <span class="comment">// vdbPrim-&gt;setGrid(*outputGrid);</span></div><div class="line">        }</div><div class="line">    } <span class="keywordflow">catch</span> (std::exception&amp; e) {</div><div class="line">        addError(SOP_MESSAGE, e.what());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> error();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="sProcessingTypedGrids"></a>
Processing grids of different types</h2>
<p>Recall that a <b>Grid</b> is a container for a transform, metadata and a <b>Tree</b>, and that the <b>Tree</b> holds voxel data of a specific type (<code>bool</code>, <code>float</code>, <code>vec3s</code>, etc.). Whenever possible, try to write generic grid processing code. That is, write code that can handle grids of more than one type (<code>int</code>, <code>float</code> and <code>double</code>, say, instead of just <code>float</code>) or, ideally, grids of arbitrary type.</p>
<p>Writing generic code can be tricky, but convenience functions exist to make the job easier. Use <b>GEOvdbProcessTypedGrid</b> to call a method or methods on a primitive&rsquo;s grid, regardless of its type:</p>
<div class="fragment"><div class="line">MyGridProcessor proc;  <span class="comment">// functor (see explanation below)</span></div><div class="line"><span class="comment">// Call a method on the primitive&#39;s grid, regardless of the grid&#39;s type.</span></div><div class="line"><span class="comment">// Note that by default, GEOvdbProcessTypedGrid() calls makeGridUnique()</span></div><div class="line"><span class="comment">// on the primitive if it is non-const.</span></div><div class="line">GEOvdbProcessTypedGrid(*vdbPrim, proc);</div></div><!-- fragment --><p><b>GEOvdbProcessTypedGrid</b> accepts a primitive and a functor (an object for which the call operator, <code>operator()()</code>, is defined). The functor&rsquo;s call operator must be templated on a single type (the grid type) and must accept a single argument (a reference to a grid of the template type). The operator&rsquo;s return value is ignored, so it&rsquo;s best to declare it <code>void</code>. The following is a simple example of a functor that satisfies these conditions:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PruneOp</div><div class="line">{</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Gr<span class="keywordtype">id</span>T&gt;</div><div class="line">    <span class="keywordtype">void</span> operator()(GridT&amp; grid)<span class="keyword"> const </span>{ grid.prune(); }</div><div class="line">};</div></div><!-- fragment --><p><b>PruneOp</b> can call the <b>prune</b> method on a grid of any type, but it&rsquo;s necessary to know the specific type, because <b>prune</b> takes an optional tolerance argument whose type is the type of the grid&rsquo;s voxel values. (Note that grids also have a <b>pruneGrid</b> method that doesn&rsquo;t require knowledge of the voxel value type.)</p>
<p>Because a functor is an object, it can have member variables. This makes it possible for the functor to process more than one grid at a time, even though it gets called with only one grid. This example shows how one might compute the CSG union of two level set grids, <em>A</em> and <em>B</em>, of the same type:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Composite_8h.html">openvdb/tools/Composite.h</a>&gt;</span> <span class="comment">// for csgUnion()</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>CSGUnionOp</div><div class="line">{</div><div class="line">    <span class="comment">// Pointer to the B grid</span></div><div class="line">    <span class="comment">// (non-const, because CSG operations modify both the A and B grids)</span></div><div class="line">    <a class="code" href="classopenvdb_1_1v9__0_1_1GridBase.html">openvdb_houdini::Grid</a>* bGridBase;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Gr<span class="keywordtype">id</span>T&gt;</div><div class="line">    <span class="keywordtype">void</span> operator()(GridT&amp; aGrid)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="comment">// Cast the generic B grid pointer to point to a grid of</span></div><div class="line">        <span class="comment">// the same type as the A grid.</span></div><div class="line">        <span class="keywordflow">if</span> (GridT* bGrid = UTvdbGridCast&lt;GridT&gt;(bGridBase)) {</div><div class="line">            <span class="comment">// Compute the union, storing the result in the A grid</span></div><div class="line">            <span class="comment">// and emptying the B grid.</span></div><div class="line">            <a class="code" href="namespaceopenvdb_1_1v9__0_1_1tools.html#a003db10da0696d7e120eff0477bc782c">openvdb::tools::csgUnion</a>(aGrid, *bGrid);</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">OP_ERROR</div><div class="line">MySOP::cookVDBSop(OP_Context&amp; context)</div><div class="line">{</div><div class="line">    ...</div><div class="line">    <span class="comment">// Retrieve the A and B grids from primitives on the input detail(s)</span></div><div class="line">    <span class="comment">// (non-const, because CSG operations modify both the A and B grids).</span></div><div class="line">    <a class="code" href="classopenvdb_1_1v9__0_1_1GridBase.html">openvdb_houdini::Grid</a></div><div class="line">        &amp;aGrid = aPrim-&gt;getGrid(),</div><div class="line">        &amp;bGrid = bPrim-&gt;getGrid();</div><div class="line"></div><div class="line">    <span class="comment">// CSG operations require the A and B grids to have the same type.</span></div><div class="line">    <span class="keywordflow">if</span> (aGrid.<a class="code" href="classopenvdb_1_1v9__0_1_1GridBase.html#a1e793b87a734c3559214c0246e3dfce7">type</a>() != bGrid.type()) {</div><div class="line">        addError(SOP_MESSAGE, <span class="stringliteral">&quot;grids have different types&quot;</span>);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        CSGUnionOp proc;</div><div class="line"></div><div class="line">        <span class="comment">// Hand the functor a generic pointer to the B grid</span></div><div class="line">        <span class="comment">// (whose concrete type we don&#39;t know yet).</span></div><div class="line">        proc.bGridBase = &amp;bGrid;</div><div class="line"></div><div class="line">        <span class="comment">// Apply the CSG operation, overwriting grid A (and emptying grid B).</span></div><div class="line">        <span class="keywordflow">if</span> (!GEOvdbProcessTypedGrid(*aPrim, proc)) {</div><div class="line">            addError(SOP_MESSAGE, <span class="stringliteral">&quot;failed to compute CSG union&quot;</span>);</div><div class="line">        }</div><div class="line">        ...</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Certain operations might make sense only for grids with scalar or with vector voxel values. Variants of <b>GEOvdbProcessTypedGrid</b> exist to handle those cases. For example, <b>GEOvdbProcessTypedGridScalar</b> and <b>GEOvdbProcessTypedGridVec3</b> invoke a functor only on grids of scalar or 3-vector types, respectively, and they return <code>false</code> for and ignore grids of all other types. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
