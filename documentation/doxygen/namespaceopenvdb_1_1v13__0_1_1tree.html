<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: openvdb::v13_0::tree Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespaceopenvdb_1_1v13__0_1_1tree.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">openvdb::v13_0::tree Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:iter" id="r_iter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree_1_1iter.html">iter</a></td></tr>
<tr class="memitem:leafmgr" id="r_leafmgr"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree_1_1leafmgr.html">leafmgr</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:CombineOpAdapter" id="r_CombineOpAdapter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1CombineOpAdapter.html">CombineOpAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to adapt a three-argument (a, b, result) CombineOp functor into a single-argument functor that accepts a <a class="el" href="classopenvdb_1_1v13__0_1_1CombineArgs.html" title="This struct collects both input and output arguments to &quot;grid combiner&quot; functors used with the tree::...">CombineArgs</a> struct.  <a href="structopenvdb_1_1v13__0_1_1tree_1_1CombineOpAdapter.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseIteratorBase" id="r_DenseIteratorBase"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1DenseIteratorBase.html">DenseIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dense iterators over internal and leaf nodes.  <a href="structopenvdb_1_1v13__0_1_1tree_1_1DenseIteratorBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:DynamicNodeManager" id="r_DynamicNodeManager"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1DynamicNodeManager.html">DynamicNodeManager</a></td></tr>
<tr class="memitem:DynamicNodeManagerLink" id="r_DynamicNodeManagerLink"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1DynamicNodeManagerLink.html">DynamicNodeManagerLink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a link in a chain that each caches tree nodes of a specific type in a linear array.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1DynamicNodeManagerLink.html#details">More...</a><br /></td></tr>
<tr class="memitem:ForeachFilterOp" id="r_ForeachFilterOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1ForeachFilterOp.html">ForeachFilterOp</a></td></tr>
<tr class="memitem:InternalNode" id="r_InternalNode"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>InternalNode</b></td></tr>
<tr class="memitem:IteratorBase" id="r_IteratorBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1IteratorBase.html">IteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for iterators over internal and leaf nodes.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1IteratorBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:IteratorRange" id="r_IteratorRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1IteratorRange.html">IteratorRange</a></td></tr>
<tr class="memitem:IterListItem" id="r_IterListItem"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1IterListItem.html">IterListItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1IterListItem.html" title="An IterListItem is an element of a compile-time linked list of iterators to nodes of different types.">IterListItem</a> is an element of a compile-time linked list of iterators to nodes of different types.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1IterListItem.html#details">More...</a><br /></td></tr>
<tr class="memitem:IterListItem_3C_20PrevItemT_2C_20NodeVecT_2C_201_2C_20_5FLevel_20_3E" id="r_IterListItem_3C_20PrevItemT_2C_20NodeVecT_2C_201_2C_20_5FLevel_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1IterListItem_3_01PrevItemT_00_01NodeVecT_00_011_00_01__Level_01_4.html">IterListItem&lt; PrevItemT, NodeVecT, 1, _Level &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final element of a compile-time linked list of iterators to nodes of different types.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1IterListItem_3_01PrevItemT_00_01NodeVecT_00_011_00_01__Level_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:IterListItem_3C_20PrevItemT_2C_20NodeVecT_2C_20VecSize_2C_200U_20_3E" id="r_IterListItem_3C_20PrevItemT_2C_20NodeVecT_2C_20VecSize_2C_200U_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1IterListItem_3_01PrevItemT_00_01NodeVecT_00_01VecSize_00_010U_01_4.html">IterListItem&lt; PrevItemT, NodeVecT, VecSize, 0U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial element of a compile-time linked list of iterators to nodes of different types.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1IterListItem_3_01PrevItemT_00_01NodeVecT_00_01VecSize_00_010U_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:IterTraits" id="r_IterTraits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1IterTraits.html">IterTraits</a></td></tr>
<tr class="memitem:IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AChildAllCIter_20_3E" id="r_IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AChildAllCIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ChildAllCIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ChildAllCIter &gt;</a></td></tr>
<tr class="memitem:IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AChildAllIter_20_3E" id="r_IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AChildAllIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ChildAllIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ChildAllIter &gt;</a></td></tr>
<tr class="memitem:IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AChildOffCIter_20_3E" id="r_IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AChildOffCIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ChildOffCIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ChildOffCIter &gt;</a></td></tr>
<tr class="memitem:IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AChildOffIter_20_3E" id="r_IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AChildOffIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ChildOffIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ChildOffIter &gt;</a></td></tr>
<tr class="memitem:IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AChildOnCIter_20_3E" id="r_IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AChildOnCIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ChildOnCIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ChildOnCIter &gt;</a></td></tr>
<tr class="memitem:IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AChildOnIter_20_3E" id="r_IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AChildOnIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ChildOnIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ChildOnIter &gt;</a></td></tr>
<tr class="memitem:IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AValueAllCIter_20_3E" id="r_IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AValueAllCIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ValueAllCIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ValueAllCIter &gt;</a></td></tr>
<tr class="memitem:IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AValueAllIter_20_3E" id="r_IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AValueAllIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ValueAllIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ValueAllIter &gt;</a></td></tr>
<tr class="memitem:IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AValueOffCIter_20_3E" id="r_IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AValueOffCIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ValueOffCIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ValueOffCIter &gt;</a></td></tr>
<tr class="memitem:IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AValueOffIter_20_3E" id="r_IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AValueOffIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ValueOffIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ValueOffIter &gt;</a></td></tr>
<tr class="memitem:IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AValueOnCIter_20_3E" id="r_IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AValueOnCIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ValueOnCIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ValueOnCIter &gt;</a></td></tr>
<tr class="memitem:IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AValueOnIter_20_3E" id="r_IterTraits_3C_20NodeT_2C_20typename_20NodeT_3A_3AValueOnIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ValueOnIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ValueOnIter &gt;</a></td></tr>
<tr class="memitem:LeafBuffer" id="r_LeafBuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafBuffer.html">LeafBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of fixed size 2<sup>3<em>Log2Dim</em></sup> that stores the voxel values of a <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim....">LeafNode</a>.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1LeafBuffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:LeafBuffer_3C_20bool_2C_20Log2Dim_20_3E" id="r_LeafBuffer_3C_20bool_2C_20Log2Dim_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafBuffer_3_01bool_00_01Log2Dim_01_4.html">LeafBuffer&lt; bool, Log2Dim &gt;</a></td></tr>
<tr class="memitem:LeafIteratorBase" id="r_LeafIteratorBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafIteratorBase.html">LeafIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for tree-traversal iterators over all leaf nodes (but not leaf voxels)  <a href="classopenvdb_1_1v13__0_1_1tree_1_1LeafIteratorBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:LeafManager" id="r_LeafManager"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager.html">LeafManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class manages a linear array of pointers to a given tree's leaf nodes, as well as optional auxiliary buffers (one or more per leaf) that can be swapped with the leaf nodes' voxel data buffers.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager.html#details">More...</a><br /></td></tr>
<tr class="memitem:LeafManagerImpl" id="r_LeafManagerImpl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1LeafManagerImpl.html">LeafManagerImpl</a></td></tr>
<tr class="memitem:LeafManagerImpl_3C_20LeafManager_3C_20const_20TreeT_20_3E_20_3E" id="r_LeafManagerImpl_3C_20LeafManager_3C_20const_20TreeT_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1LeafManagerImpl_3_01LeafManager_3_01const_01TreeT_01_4_01_4.html">LeafManagerImpl&lt; LeafManager&lt; const TreeT &gt; &gt;</a></td></tr>
<tr class="memitem:LeafNode" id="r_LeafNode"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html">LeafNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated block class to hold specific data types and a fixed number of values determined by Log2Dim. The actual coordinate dimension of the block is 2^Log2Dim, i.e. Log2Dim=3 corresponds to a <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim....">LeafNode</a> that spans a 8^3 block.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html#details">More...</a><br /></td></tr>
<tr class="memitem:LeafNode_3C_20bool_2C_20Log2Dim_20_3E" id="r_LeafNode_3C_20bool_2C_20Log2Dim_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>LeafNode&lt; bool, Log2Dim &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim....">LeafNode</a> specialization for values of type bool that stores both the active states and the values of (2^Log2Dim)^3 voxels as bit masks. <br /></td></tr>
<tr class="memitem:LeafNode_3C_20ValueMask_2C_20Log2Dim_20_3E" id="r_LeafNode_3C_20ValueMask_2C_20Log2Dim_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>LeafNode&lt; ValueMask, Log2Dim &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim....">LeafNode</a> specialization for values of type <a class="el" href="classopenvdb_1_1v13__0_1_1ValueMask.html">ValueMask</a> that encodes both the active states and the boolean values of (2^Log2Dim)^3 voxels in a single bit mask, i.e. voxel values and states are indistinguishable! <br /></td></tr>
<tr class="memitem:NodeChain" id="r_NodeChain"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1NodeChain.html">NodeChain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1NodeChain.html#ab3773598ec5a6b9d42e3de221960e9e3">NodeChain&lt;RootNodeType, RootNodeType::LEVEL&gt;::Type</a> is a <a class="el" href="structopenvdb_1_1v13__0_1_1TypeList.html" title="A list of types (not necessarily unique)">openvdb::TypeList</a> that lists the types of the nodes of the tree rooted at RootNodeType in reverse order, from <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim....">LeafNode</a> to <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>.  <a href="structopenvdb_1_1v13__0_1_1tree_1_1NodeChain.html#details">More...</a><br /></td></tr>
<tr class="memitem:NodeChain_3C_20HeadT_2C_201_20_3E" id="r_NodeChain_3C_20HeadT_2C_201_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1NodeChain_3_01HeadT_00_011_01_4.html">NodeChain&lt; HeadT, 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to terminate <a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1NodeChain.html" title="NodeChain&lt;RootNodeType, RootNodeType::LEVEL&gt;::Type is a openvdb::TypeList that lists the types of the...">NodeChain</a>.  <a href="structopenvdb_1_1v13__0_1_1tree_1_1NodeChain_3_01HeadT_00_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:NodeFilter" id="r_NodeFilter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1NodeFilter.html">NodeFilter</a></td></tr>
<tr class="memitem:NodeIteratorBase" id="r_NodeIteratorBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1NodeIteratorBase.html">NodeIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for tree-traversal iterators over all nodes.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1NodeIteratorBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:NodeList" id="r_NodeList"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1NodeList.html">NodeList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class caches tree nodes of a specific type in a linear array.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1NodeList.html#details">More...</a><br /></td></tr>
<tr class="memitem:NodeManager" id="r_NodeManager"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1NodeManager.html">NodeManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">To facilitate threading over the nodes of a tree, cache node pointers in linear arrays, one for each level of the tree.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1NodeManager.html#details">More...</a><br /></td></tr>
<tr class="memitem:NodeManagerLink" id="r_NodeManagerLink"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1NodeManagerLink.html">NodeManagerLink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a link in a chain that each caches tree nodes of a specific type in a linear array.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1NodeManagerLink.html#details">More...</a><br /></td></tr>
<tr class="memitem:NodeUnion" id="r_NodeUnion"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1NodeUnion.html">NodeUnion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of a <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1NodeUnion.html" title="Default implementation of a NodeUnion that stores the child pointer and the value separately (i....">NodeUnion</a> that stores the child pointer and the value separately (i.e., not in a union). Types which select this specialization usually do not conform to the requirements of a union member, that is that the type ValueT is not trivially copyable. This implementation is thus NOT used for POD, math::Vec, <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Mat.html">math::Mat</a>, <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Quat.html">math::Quat</a> or <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html" title="Signed (x, y, z) 32-bit integer coordinates.">math::Coord</a> types, but is used (for example) with std::string.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1NodeUnion.html#details">More...</a><br /></td></tr>
<tr class="memitem:NodeUnion_3C_20ValueT_2C_20ChildT_2C_20typename_20std_3A_3Aenable_5Fif_3C_20std_3A_3Ais_5Ftrivially_5Fcopyable_3C_20ValueT_20_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E" id="r_NodeUnion_3C_20ValueT_2C_20ChildT_2C_20typename_20std_3A_3Aenable_5Fif_3C_20std_3A_3Ais_5Ftrivially_5Fcopyable_3C_20ValueT_20_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1NodeUnion_3_01ValueT_00_01ChildT_00_01typename_01std_1_1enable3541fe84f788dddfea7adcd5921edaac.html">NodeUnion&lt; ValueT, ChildT, typename std::enable_if&lt; std::is_trivially_copyable&lt; ValueT &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of a <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1NodeUnion.html" title="Default implementation of a NodeUnion that stores the child pointer and the value separately (i....">NodeUnion</a> that stores the child pointer and the value together (int, float, pointer, etc.)  <a href="classopenvdb_1_1v13__0_1_1tree_1_1NodeUnion_3_01ValueT_00_01ChildT_00_01typename_01std_1_1enable3541fe84f788dddfea7adcd5921edaac.html#details">More...</a><br /></td></tr>
<tr class="memitem:ReduceFilterOp" id="r_ReduceFilterOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1ReduceFilterOp.html">ReduceFilterOp</a></td></tr>
<tr class="memitem:RootNode" id="r_RootNode"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a></td></tr>
<tr class="memitem:RootNodeCombineHelper" id="r_RootNodeCombineHelper"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1RootNodeCombineHelper.html">RootNodeCombineHelper</a></td></tr>
<tr class="memitem:RootNodeCombineHelper_3C_20CombineOp_2C_20RootT_2C_20OtherRootT_2C_20true_20_3E" id="r_RootNodeCombineHelper_3C_20CombineOp_2C_20RootT_2C_20OtherRootT_2C_20true_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1RootNodeCombineHelper_3_01CombineOp_00_01RootT_00_01OtherRootT_00_01true_01_4.html">RootNodeCombineHelper&lt; CombineOp, RootT, OtherRootT, true &gt;</a></td></tr>
<tr class="memitem:RootNodeCopyHelper" id="r_RootNodeCopyHelper"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1RootNodeCopyHelper.html">RootNodeCopyHelper</a></td></tr>
<tr class="memitem:RootNodeCopyHelper_3C_20RootT_2C_20OtherRootT_2C_20true_20_3E" id="r_RootNodeCopyHelper_3C_20RootT_2C_20OtherRootT_2C_20true_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1RootNodeCopyHelper_3_01RootT_00_01OtherRootT_00_01true_01_4.html">RootNodeCopyHelper&lt; RootT, OtherRootT, true &gt;</a></td></tr>
<tr class="memitem:SameInternalConfig" id="r_SameInternalConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>SameInternalConfig</b></td></tr>
<tr class="memitem:SameInternalConfig_3C_20ChildT1_2C_20Dim1_2C_20InternalNode_3C_20ChildT2_2C_20Dim1_20_3E_20_3E" id="r_SameInternalConfig_3C_20ChildT1_2C_20Dim1_2C_20InternalNode_3C_20ChildT2_2C_20Dim1_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>SameInternalConfig&lt; ChildT1, Dim1, InternalNode&lt; ChildT2, Dim1 &gt; &gt;</b></td></tr>
<tr class="memitem:SameLeafConfig" id="r_SameLeafConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1SameLeafConfig.html">SameLeafConfig</a></td></tr>
<tr class="memitem:SameLeafConfig_3C_20Dim1_2C_20LeafNode_3C_20T2_2C_20Dim1_20_3E_20_3E" id="r_SameLeafConfig_3C_20Dim1_2C_20LeafNode_3C_20T2_2C_20Dim1_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1SameLeafConfig_3_01Dim1_00_01LeafNode_3_01T2_00_01Dim1_01_4_01_4.html">SameLeafConfig&lt; Dim1, LeafNode&lt; T2, Dim1 &gt; &gt;</a></td></tr>
<tr class="memitem:SameLeafConfig_3C_20Dim1_2C_20openvdb_3A_3Atools_3A_3APointIndexLeafNode_3C_20T2_2C_20Dim1_20_3E_20_3E" id="r_SameLeafConfig_3C_20Dim1_2C_20openvdb_3A_3Atools_3A_3APointIndexLeafNode_3C_20T2_2C_20Dim1_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1SameLeafConfig_3_01Dim1_00_01openvdb_1_1tools_1_1PointIndexLe41cd311c80d4680c95c6356200b891f8.html">SameLeafConfig&lt; Dim1, openvdb::tools::PointIndexLeafNode&lt; T2, Dim1 &gt; &gt;</a></td></tr>
<tr class="memitem:SameLeafConfig_3C_20Dim1_2C_20points_3A_3APointDataLeafNode_3C_20T2_2C_20Dim1_20_3E_20_3E" id="r_SameLeafConfig_3C_20Dim1_2C_20points_3A_3APointDataLeafNode_3C_20T2_2C_20Dim1_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1SameLeafConfig_3_01Dim1_00_01points_1_1PointDataLeafNode_3_01T2_00_01Dim1_01_4_01_4.html">SameLeafConfig&lt; Dim1, points::PointDataLeafNode&lt; T2, Dim1 &gt; &gt;</a></td></tr>
<tr class="memitem:SameRootConfig" id="r_SameRootConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1SameRootConfig.html">SameRootConfig</a></td></tr>
<tr class="memitem:SameRootConfig_3C_20ChildT1_2C_20RootNode_3C_20ChildT2_20_3E_20_3E" id="r_SameRootConfig_3C_20ChildT1_2C_20RootNode_3C_20ChildT2_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1SameRootConfig_3_01ChildT1_00_01RootNode_3_01ChildT2_01_4_01_4.html">SameRootConfig&lt; ChildT1, RootNode&lt; ChildT2 &gt; &gt;</a></td></tr>
<tr class="memitem:SparseIteratorBase" id="r_SparseIteratorBase"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1SparseIteratorBase.html">SparseIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sparse iterators over internal and leaf nodes.  <a href="structopenvdb_1_1v13__0_1_1tree_1_1SparseIteratorBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:Tree" id="r_Tree"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1Tree.html">Tree</a></td></tr>
<tr class="memitem:Tree3" id="r_Tree3"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1Tree3.html">Tree3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1Tree3.html#a74e796a0dad5f76b408fdc4b6e249c93">Tree3&lt;T, N1, N2&gt;::Type</a> is the type of a three-level tree (Root, Internal, Leaf) with value type T and internal and leaf node log dimensions N1 and N2, respectively.  <a href="structopenvdb_1_1v13__0_1_1tree_1_1Tree3.html#details">More...</a><br /></td></tr>
<tr class="memitem:Tree4" id="r_Tree4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1Tree4.html">Tree4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1Tree4.html#a662d25f72b925dce0073c06f65283489">Tree4&lt;T, N1, N2, N3&gt;::Type</a> is the type of a four-level tree (Root, Internal, Internal, Leaf) with value type T and internal and leaf node log dimensions N1, N2 and N3, respectively.  <a href="structopenvdb_1_1v13__0_1_1tree_1_1Tree4.html#details">More...</a><br /></td></tr>
<tr class="memitem:Tree5" id="r_Tree5"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1Tree5.html">Tree5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1Tree5.html#a92b63ccd38526375f496cd47dbe54224">Tree5&lt;T, N1, N2, N3, N4&gt;::Type</a> is the type of a five-level tree (Root, Internal, Internal, Internal, Leaf) with value type T and internal and leaf node log dimensions N1, N2, N3 and N4, respectively.  <a href="structopenvdb_1_1v13__0_1_1tree_1_1Tree5.html#details">More...</a><br /></td></tr>
<tr class="memitem:TreeBase" id="r_TreeBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1TreeBase.html">TreeBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for typed trees.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1TreeBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:TreeIterTraits" id="r_TreeIterTraits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits.html">TreeIterTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits.html" title="TreeIterTraits provides, for all tree iterators, a begin(tree) function that returns an iterator over...">TreeIterTraits</a> provides, for all tree iterators, a begin(tree) function that returns an iterator over a tree of arbitrary type.  <a href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits.html#details">More...</a><br /></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ALeafCIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ALeafCIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1LeafCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::LeafCIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ALeafIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ALeafIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1LeafIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::LeafIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ANodeCIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ANodeCIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1NodeCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::NodeCIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ANodeIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ANodeIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1NodeIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::NodeIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ARootNodeType_3A_3AChildAllCIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ARootNodeType_3A_3AChildAllCIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1RootNodeType_1_1ChildAllCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::RootNodeType::ChildAllCIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ARootNodeType_3A_3AChildAllIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ARootNodeType_3A_3AChildAllIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1RootNodeType_1_1ChildAllIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::RootNodeType::ChildAllIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ARootNodeType_3A_3AChildOffCIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ARootNodeType_3A_3AChildOffCIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1RootNodeType_1_1ChildOffCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::RootNodeType::ChildOffCIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ARootNodeType_3A_3AChildOffIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ARootNodeType_3A_3AChildOffIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1RootNodeType_1_1ChildOffIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::RootNodeType::ChildOffIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ARootNodeType_3A_3AChildOnCIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ARootNodeType_3A_3AChildOnCIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1RootNodeType_1_1ChildOnCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::RootNodeType::ChildOnCIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ARootNodeType_3A_3AChildOnIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3ARootNodeType_3A_3AChildOnIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1RootNodeType_1_1ChildOnIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::RootNodeType::ChildOnIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3AValueAllCIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3AValueAllCIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1ValueAllCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::ValueAllCIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3AValueAllIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3AValueAllIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1ValueAllIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::ValueAllIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3AValueOffCIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3AValueOffCIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1ValueOffCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::ValueOffCIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3AValueOffIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3AValueOffIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1ValueOffIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::ValueOffIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3AValueOnCIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3AValueOnCIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1ValueOnCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::ValueOnCIter &gt;</a></td></tr>
<tr class="memitem:TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3AValueOnIter_20_3E" id="r_TreeIterTraits_3C_20TreeT_2C_20typename_20TreeT_3A_3AValueOnIter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1ValueOnIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::ValueOnIter &gt;</a></td></tr>
<tr class="memitem:TreeValueIteratorBase" id="r_TreeValueIteratorBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for tree-traversal iterators over tile and voxel values.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1TreeValueIteratorBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueAccessorBase" id="r_ValueAccessorBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class for ValueAccessors manages registration of an accessor with a tree so that the tree can automatically clear the accessor whenever one of its nodes is deleted.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueAccessorImpl" id="r_ValueAccessorImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Value Accessor Implementation and API methods. The majoirty of the API matches the API of a compatible OpenVDB <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1Tree.html">Tree</a> Node.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorImpl.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueAccessorLeafBuffer" id="r_ValueAccessorLeafBuffer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorLeafBuffer.html">ValueAccessorLeafBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small class that contains a cached pointer to a <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim....">LeafNode</a> data buffer which is derived from by the internal Value Accessor Implementation. This allows for the empty base class optimization to be performed in the case where a <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim....">LeafNode</a> does not store a contiguous index-able buffer. From C++20 we can instead switch to [[no_unique_address]].  <a href="structopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorLeafBuffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueAccessorLeafBuffer_3C_20TreeTypeT_2C_20IntegerSequence_2C_20typename_20std_3A_3Aenable_5Fif_3C_20_21value_5Faccessor_5Finternal_3A_3AEnableLeafBuffer_3C_20TreeTypeT_2C_20IntegerSequence_20_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E" id="r_ValueAccessorLeafBuffer_3C_20TreeTypeT_2C_20IntegerSequence_2C_20typename_20std_3A_3Aenable_5Fif_3C_20_21value_5Faccessor_5Finternal_3A_3AEnableLeafBuffer_3C_20TreeTypeT_2C_20IntegerSequence_20_3E_3A_3Avalue_20_3E_3A_3Atype_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>ValueAccessorLeafBuffer&lt; TreeTypeT, IntegerSequence, typename std::enable_if&lt; !value_accessor_internal::EnableLeafBuffer&lt; TreeTypeT, IntegerSequence &gt;::value &gt;::type &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the case where a Leaf Buffer cannot be cached. <br /></td></tr>
<tr class="memitem:ValueAccessorLock" id="r_ValueAccessorLock"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorLock.html">ValueAccessorLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small class that contains a Mutex which is derived from by the internal Value Accessor Implementation. This allows for the empty base class optimization to be performed in the case where a Mutex/Lock is not in use. From C++20 we can instead switch to [[no_unique_address]].  <a href="structopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorLock.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueAccessorLock_3C_20void_20_3E" id="r_ValueAccessorLock_3C_20void_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorLock_3_01void_01_4.html">ValueAccessorLock&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the case where no Mutex is in use. See above.  <a href="structopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorLock_3_01void_01_4.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a09d15a8ce9e84448003ae4bb40326488" id="r_a09d15a8ce9e84448003ae4bb40326488"><td class="memTemplParams" colspan="2">template&lt;typename TreeType, bool IsSafe = true, size_t CacheLevels = std::max(Index(1),TreeType::DEPTH)-1, typename MutexType = void&gt; </td></tr>
<tr class="memitem:a09d15a8ce9e84448003ae4bb40326488 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09d15a8ce9e84448003ae4bb40326488">ValueAccessor</a></td></tr>
<tr class="memdesc:a09d15a8ce9e84448003ae4bb40326488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default alias for a <a class="el" href="#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>. This is simply a helper alias for the generic definition but takes a single <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> specifying the number of nodes to cache. This is expanded into an index sequence (required for backward compatibility).  <br /></td></tr>
<tr class="memitem:a71c89514a00864f659030a7d88272bb7" id="r_a71c89514a00864f659030a7d88272bb7"><td class="memTemplParams" colspan="2">template&lt;typename TreeType, bool IsSafe&gt; </td></tr>
<tr class="memitem:a71c89514a00864f659030a7d88272bb7 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71c89514a00864f659030a7d88272bb7">ValueAccessor0</a></td></tr>
<tr class="memdesc:a71c89514a00864f659030a7d88272bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a <a class="el" href="#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a> which doesn't cache any Internal or Leaf nodes.  <br /></td></tr>
<tr class="memitem:ab2453161a80247daa47ab68fdbbf7303" id="r_ab2453161a80247daa47ab68fdbbf7303"><td class="memTemplParams" colspan="2">template&lt;typename TreeType, bool IsSafe, size_t L0 = 0&gt; </td></tr>
<tr class="memitem:ab2453161a80247daa47ab68fdbbf7303 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2453161a80247daa47ab68fdbbf7303">ValueAccessor1</a></td></tr>
<tr class="memdesc:ab2453161a80247daa47ab68fdbbf7303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a <a class="el" href="#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a> which caches a single node level. By default, the node level is 0, which corresponds to the lowest node level, typically LeafNodes.  <br /></td></tr>
<tr class="memitem:a592c66f93fb0e930ce01a393884f35d6" id="r_a592c66f93fb0e930ce01a393884f35d6"><td class="memTemplParams" colspan="2">template&lt;typename TreeType, bool IsSafe, size_t L0 = 0, size_t L1 = 1&gt; </td></tr>
<tr class="memitem:a592c66f93fb0e930ce01a393884f35d6 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a592c66f93fb0e930ce01a393884f35d6">ValueAccessor2</a></td></tr>
<tr class="memdesc:a592c66f93fb0e930ce01a393884f35d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a <a class="el" href="#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a> which caches two node levels. By default the two lowest node levels are selected (0, 1) which typically correspond to an InternalNode and its child LeafNodes. This instantiation will only be valid for <a class="el" href="namespaceopenvdb_1_1v13__0.html#a3a90960207f67b6eef0b2bd45c820e94">TreeTypes</a> which have at least two levels of nodes (excluding the Root node).  <br /></td></tr>
<tr class="memitem:a682224f88f42583ec31fc43552b962b8" id="r_a682224f88f42583ec31fc43552b962b8"><td class="memTemplParams" colspan="2">template&lt;typename TreeType, bool IsSafe, size_t L0 = 0, size_t L1 = 1, size_t L2 = 2&gt; </td></tr>
<tr class="memitem:a682224f88f42583ec31fc43552b962b8 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a682224f88f42583ec31fc43552b962b8">ValueAccessor3</a></td></tr>
<tr class="memdesc:a682224f88f42583ec31fc43552b962b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a <a class="el" href="#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a> which caches three node levels. By default the three lowest node levels are selected (0, 1, 2) which typically correspond to two InternalNodes followed by the bottom LeafNodes. This instantiation will only be valid for <a class="el" href="namespaceopenvdb_1_1v13__0.html#a3a90960207f67b6eef0b2bd45c820e94">TreeTypes</a> which have at least three levels of nodes (excluding the Root node).  <br /></td></tr>
<tr class="memitem:a2be6027a90f96de5f0afc733ef61967b" id="r_a2be6027a90f96de5f0afc733ef61967b"><td class="memTemplParams" colspan="2">template&lt;typename TreeType, bool IsSafe = true, size_t CacheLevels = std::max(Index(1),TreeType::DEPTH)-1&gt; </td></tr>
<tr class="memitem:a2be6027a90f96de5f0afc733ef61967b template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2be6027a90f96de5f0afc733ef61967b">ValueAccessorRW</a></td></tr>
<tr class="memdesc:a2be6027a90f96de5f0afc733ef61967b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a ValueAccesor which spin locks every API call.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a849ce014596bde83a80e781e1edad788" id="r_a849ce014596bde83a80e781e1edad788"><td class="memTemplParams" colspan="2">template&lt;typename T, <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> Log2Dim&gt; </td></tr>
<tr class="memitem:a849ce014596bde83a80e781e1edad788 template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a849ce014596bde83a80e781e1edad788">operator&lt;&lt;</a> (std::ostream &amp;os, const typename <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html">LeafNode</a>&lt; T, Log2Dim &gt;::Buffer &amp;buf)</td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a09d15a8ce9e84448003ae4bb40326488" name="a09d15a8ce9e84448003ae4bb40326488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d15a8ce9e84448003ae4bb40326488">&#9670;&#160;</a></span>ValueAccessor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeType, bool IsSafe = true, size_t CacheLevels = std::max(Index(1),TreeType::DEPTH)-1, typename MutexType = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a09d15a8ce9e84448003ae4bb40326488">ValueAccessor</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a>&lt;TreeType, IsSafe, MutexType,</div>
<div class="line">        <a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0.html#a5f5cd8b98731c428a508de30f945a9af">openvdb::make_index_sequence&lt;CacheLevels&gt;</a>&gt;</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorImpl_html"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorImpl.html">openvdb::v13_0::tree::ValueAccessorImpl</a></div><div class="ttdoc">The Value Accessor Implementation and API methods. The majoirty of the API matches the API of a compa...</div><div class="ttdef"><b>Definition</b> ValueAccessor.h:367</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_html_a5f5cd8b98731c428a508de30f945a9af"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0.html#a5f5cd8b98731c428a508de30f945a9af">openvdb::v13_0::make_index_sequence</a></div><div class="ttdeci">std::decay_t&lt; decltype(make_index_sequence_impl&lt; N &gt;())&gt; make_index_sequence</div><div class="ttdef"><b>Definition</b> Types.h:285</div></div>
</div><!-- fragment -->
<p>Default alias for a <a class="el" href="#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>. This is simply a helper alias for the generic definition but takes a single <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> specifying the number of nodes to cache. This is expanded into an index sequence (required for backward compatibility). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TreeType</td><td>The tree type </td></tr>
    <tr><td class="paramname">IsSafe</td><td>Whether this accessor registers itself to the tree. See the base class definition for more information on this parameter. </td></tr>
    <tr><td class="paramname">CacheLevels</td><td>The number of node levels to cache <em>excluding</em> the Root node. The Root node is implicitly always included, even if this value is zero. </td></tr>
    <tr><td class="paramname">MutexType</td><td>An optional std compatible mutex to use which ensures every call to the <a class="el" href="#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a> API is thread safe. If void (the default) no locking takes place. In general it's not advised to mutex lock <a class="el" href="#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a> methods (instead consider creating a accessor per thread). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71c89514a00864f659030a7d88272bb7" name="a71c89514a00864f659030a7d88272bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c89514a00864f659030a7d88272bb7">&#9670;&#160;</a></span>ValueAccessor0</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeType, bool IsSafe&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a71c89514a00864f659030a7d88272bb7">ValueAccessor0</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl&lt;TreeType, IsSafe, void, openvdb::index_sequence&lt;&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>Helper alias for a <a class="el" href="#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a> which doesn't cache any Internal or Leaf nodes. </p>

</div>
</div>
<a id="ab2453161a80247daa47ab68fdbbf7303" name="ab2453161a80247daa47ab68fdbbf7303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2453161a80247daa47ab68fdbbf7303">&#9670;&#160;</a></span>ValueAccessor1</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeType, bool IsSafe, size_t L0 = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab2453161a80247daa47ab68fdbbf7303">ValueAccessor1</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl&lt;TreeType, IsSafe, void, openvdb::index_sequence&lt;L0&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>Helper alias for a <a class="el" href="#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a> which caches a single node level. By default, the node level is 0, which corresponds to the lowest node level, typically LeafNodes. </p>

</div>
</div>
<a id="a592c66f93fb0e930ce01a393884f35d6" name="a592c66f93fb0e930ce01a393884f35d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592c66f93fb0e930ce01a393884f35d6">&#9670;&#160;</a></span>ValueAccessor2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeType, bool IsSafe, size_t L0 = 0, size_t L1 = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a592c66f93fb0e930ce01a393884f35d6">ValueAccessor2</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl&lt;TreeType, IsSafe, void, openvdb::index_sequence&lt;L0, L1&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>Helper alias for a <a class="el" href="#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a> which caches two node levels. By default the two lowest node levels are selected (0, 1) which typically correspond to an InternalNode and its child LeafNodes. This instantiation will only be valid for <a class="el" href="namespaceopenvdb_1_1v13__0.html#a3a90960207f67b6eef0b2bd45c820e94">TreeTypes</a> which have at least two levels of nodes (excluding the Root node). </p>

</div>
</div>
<a id="a682224f88f42583ec31fc43552b962b8" name="a682224f88f42583ec31fc43552b962b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682224f88f42583ec31fc43552b962b8">&#9670;&#160;</a></span>ValueAccessor3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeType, bool IsSafe, size_t L0 = 0, size_t L1 = 1, size_t L2 = 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a682224f88f42583ec31fc43552b962b8">ValueAccessor3</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl&lt;TreeType, IsSafe, void, openvdb::index_sequence&lt;L0, L1, L2&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>Helper alias for a <a class="el" href="#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a> which caches three node levels. By default the three lowest node levels are selected (0, 1, 2) which typically correspond to two InternalNodes followed by the bottom LeafNodes. This instantiation will only be valid for <a class="el" href="namespaceopenvdb_1_1v13__0.html#a3a90960207f67b6eef0b2bd45c820e94">TreeTypes</a> which have at least three levels of nodes (excluding the Root node). </p>

</div>
</div>
<a id="a2be6027a90f96de5f0afc733ef61967b" name="a2be6027a90f96de5f0afc733ef61967b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be6027a90f96de5f0afc733ef61967b">&#9670;&#160;</a></span>ValueAccessorRW</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeType, bool IsSafe = true, size_t CacheLevels = std::max(Index(1),TreeType::DEPTH)-1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2be6027a90f96de5f0afc733ef61967b">ValueAccessorRW</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a>&lt;TreeType, IsSafe, tbb::spin_mutex,</div>
<div class="line">        <a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0.html#a5f5cd8b98731c428a508de30f945a9af">openvdb::make_index_sequence&lt;CacheLevels&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>Helper alias for a ValueAccesor which spin locks every API call. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a849ce014596bde83a80e781e1edad788" name="a849ce014596bde83a80e781e1edad788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849ce014596bde83a80e781e1edad788">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> Log2Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html">LeafNode</a>&lt; T, Log2Dim &gt;::Buffer &amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1tree.html">tree</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
