<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: openvdb::v10_1::tree Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">10.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v10__1.html">v10_1</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree.html">tree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">openvdb::v10_1::tree Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceopenvdb_1_1v10__1_1_1tree_1_1iter"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree_1_1iter.html">iter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v10__1_1_1tree_1_1leafmgr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree_1_1leafmgr.html">leafmgr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1CombineOpAdapter.html">CombineOpAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to adapt a three-argument (a, b, result) CombineOp functor into a single-argument functor that accepts a <a class="el" href="classopenvdb_1_1v10__1_1_1CombineArgs.html" title="This struct collects both input and output arguments to &quot;grid combiner&quot; functors used with the tree::...">CombineArgs</a> struct.  <a href="structopenvdb_1_1v10__1_1_1tree_1_1CombineOpAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1DenseIteratorBase.html">DenseIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dense iterators over internal and leaf nodes.  <a href="structopenvdb_1_1v10__1_1_1tree_1_1DenseIteratorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1DynamicNodeManager.html">DynamicNodeManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1DynamicNodeManagerLink.html">DynamicNodeManagerLink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a link in a chain that each caches tree nodes of a specific type in a linear array.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1DynamicNodeManagerLink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1ForeachFilterOp.html">ForeachFilterOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1InternalNode.html">InternalNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1IteratorBase.html">IteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for iterators over internal and leaf nodes.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1IteratorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1IteratorRange.html">IteratorRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1IterListItem.html">IterListItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1IterListItem.html" title="An IterListItem is an element of a compile-time linked list of iterators to nodes of different types...">IterListItem</a> is an element of a compile-time linked list of iterators to nodes of different types.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1IterListItem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1IterListItem_3_01PrevItemT_00_01NodeVecT_00_011_00_01__Level_01_4.html">IterListItem&lt; PrevItemT, NodeVecT, 1, _Level &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final element of a compile-time linked list of iterators to nodes of different types.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1IterListItem_3_01PrevItemT_00_01NodeVecT_00_011_00_01__Level_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1IterListItem_3_01PrevItemT_00_01NodeVecT_00_01VecSize_00_010U_01_4.html">IterListItem&lt; PrevItemT, NodeVecT, VecSize, 0U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial element of a compile-time linked list of iterators to nodes of different types.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1IterListItem_3_01PrevItemT_00_01NodeVecT_00_01VecSize_00_010U_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1IterTraits.html">IterTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ChildAllCIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ChildAllCIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ChildAllIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ChildAllIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ChildOffCIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ChildOffCIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ChildOffIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ChildOffIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ChildOnCIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ChildOnCIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ChildOnIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ChildOnIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ValueAllCIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ValueAllCIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ValueAllIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ValueAllIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ValueOffCIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ValueOffCIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ValueOffIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ValueOffIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ValueOnCIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ValueOnCIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1IterTraits_3_01NodeT_00_01typename_01NodeT_1_1ValueOnIter_01_4.html">IterTraits&lt; NodeT, typename NodeT::ValueOnIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafBuffer.html">LeafBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of fixed size 2<sup>3<em>Log2Dim</em></sup> that stores the voxel values of a <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim...">LeafNode</a>.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1LeafBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafBuffer_3_01bool_00_01Log2Dim_01_4.html">LeafBuffer&lt; bool, Log2Dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafIteratorBase.html">LeafIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for tree-traversal iterators over all leaf nodes (but not leaf voxels)  <a href="classopenvdb_1_1v10__1_1_1tree_1_1LeafIteratorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafManager.html">LeafManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class manages a linear array of pointers to a given tree's leaf nodes, as well as optional auxiliary buffers (one or more per leaf) that can be swapped with the leaf nodes' voxel data buffers.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1LeafManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1LeafManagerImpl.html">LeafManagerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1LeafManagerImpl_3_01LeafManager_3_01const_01TreeT_01_4_01_4.html">LeafManagerImpl&lt; LeafManager&lt; const TreeT &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode.html">LeafNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated block class to hold specific data types and a fixed number of values determined by Log2Dim. The actual coordinate dimension of the block is 2^Log2Dim, i.e. Log2Dim=3 corresponds to a <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim...">LeafNode</a> that spans a 8^3 block.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode_3_01bool_00_01Log2Dim_01_4.html">LeafNode&lt; bool, Log2Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim...">LeafNode</a> specialization for values of type bool that stores both the active states and the values of (2^Log2Dim)^3 voxels as bit masks.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode_3_01bool_00_01Log2Dim_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode_3_01ValueMask_00_01Log2Dim_01_4.html">LeafNode&lt; ValueMask, Log2Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim...">LeafNode</a> specialization for values of type <a class="el" href="classopenvdb_1_1v10__1_1_1ValueMask.html">ValueMask</a> that encodes both the active states and the boolean values of (2^Log2Dim)^3 voxels in a single bit mask, i.e. voxel values and states are indistinguishable!  <a href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode_3_01ValueMask_00_01Log2Dim_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1NodeChain.html">NodeChain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1NodeChain.html#ab3773598ec5a6b9d42e3de221960e9e3">NodeChain&lt;RootNodeType, RootNodeType::LEVEL&gt;::Type</a> is a openvdb::TypeList that lists the types of the nodes of the tree rooted at RootNodeType in reverse order, from <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim...">LeafNode</a> to <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1RootNode.html">RootNode</a>.  <a href="structopenvdb_1_1v10__1_1_1tree_1_1NodeChain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1NodeChain_3_01HeadT_00_011_01_4.html">NodeChain&lt; HeadT, 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to terminate <a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1NodeChain.html" title="NodeChain&lt;RootNodeType, RootNodeType::LEVEL&gt;::Type is a openvdb::TypeList that lists the types of the...">NodeChain</a>.  <a href="structopenvdb_1_1v10__1_1_1tree_1_1NodeChain_3_01HeadT_00_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1NodeFilter.html">NodeFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1NodeIteratorBase.html">NodeIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for tree-traversal iterators over all nodes.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1NodeIteratorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1NodeList.html">NodeList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class caches tree nodes of a specific type in a linear array.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1NodeList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1NodeManager.html">NodeManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">To facilitate threading over the nodes of a tree, cache node pointers in linear arrays, one for each level of the tree.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1NodeManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1NodeManagerLink.html">NodeManagerLink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a link in a chain that each caches tree nodes of a specific type in a linear array.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1NodeManagerLink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1NodeUnion.html">NodeUnion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of a <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1NodeUnion.html" title="Default implementation of a NodeUnion that stores the child pointer and the value separately (i...">NodeUnion</a> that stores the child pointer and the value separately (i.e., not in a union). Types which select this specialization usually do not conform to the requirements of a union member, that is that the type ValueT is not trivially copyable. This implementation is thus NOT used for POD, math::Vec, <a class="el" href="classopenvdb_1_1v10__1_1_1math_1_1Mat.html">math::Mat</a>, <a class="el" href="classopenvdb_1_1v10__1_1_1math_1_1Quat.html">math::Quat</a> or <a class="el" href="classopenvdb_1_1v10__1_1_1math_1_1Coord.html" title="Signed (x, y, z) 32-bit integer coordinates. ">math::Coord</a> types, but is used (for example) with std::string.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1NodeUnion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1NodeUnion_3_01ValueT_00_01ChildT_00_01_01_01_01_01_01_01_01_01c20d86b9b124c9c388ff1d7590abaa30.html">NodeUnion&lt; ValueT, ChildT,           typename std::enable_if&lt; std::is_trivially_copyable&lt; ValueT &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of a <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1NodeUnion.html" title="Default implementation of a NodeUnion that stores the child pointer and the value separately (i...">NodeUnion</a> that stores the child pointer and the value together (int, float, pointer, etc.)  <a href="classopenvdb_1_1v10__1_1_1tree_1_1NodeUnion_3_01ValueT_00_01ChildT_00_01_01_01_01_01_01_01_01_01c20d86b9b124c9c388ff1d7590abaa30.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1ReduceFilterOp.html">ReduceFilterOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1RootNode.html">RootNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1RootNodeCombineHelper.html">RootNodeCombineHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1RootNodeCombineHelper_3_01CombineOp_00_01RootT_00_01OtherRootT_00_01true_01_4.html">RootNodeCombineHelper&lt; CombineOp, RootT, OtherRootT, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1RootNodeCopyHelper.html">RootNodeCopyHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1RootNodeCopyHelper_3_01RootT_00_01OtherRootT_00_01true_01_4.html">RootNodeCopyHelper&lt; RootT, OtherRootT, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1SameInternalConfig.html">SameInternalConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1SameInternalConfig_3_01ChildT1_00_01Dim1_00_01InternalNode_3_01ChildT2_00_01Dim1_01_4_01_4.html">SameInternalConfig&lt; ChildT1, Dim1, InternalNode&lt; ChildT2, Dim1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1SameLeafConfig.html">SameLeafConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1SameLeafConfig_3_01Dim1_00_01LeafNode_3_01T2_00_01Dim1_01_4_01_4.html">SameLeafConfig&lt; Dim1, LeafNode&lt; T2, Dim1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1SameLeafConfig_3_01Dim1_00_01openvdb_1_1tools_1_1PointIndexLea49f5c3906972b968d4cc7f85373bdad.html">SameLeafConfig&lt; Dim1, openvdb::tools::PointIndexLeafNode&lt; T2, Dim1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1SameLeafConfig_3_01Dim1_00_01points_1_1PointDataLeafNode_3_01T2_00_01Dim1_01_4_01_4.html">SameLeafConfig&lt; Dim1, points::PointDataLeafNode&lt; T2, Dim1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1SameRootConfig.html">SameRootConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1SameRootConfig_3_01ChildT1_00_01RootNode_3_01ChildT2_01_4_01_4.html">SameRootConfig&lt; ChildT1, RootNode&lt; ChildT2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1SparseIteratorBase.html">SparseIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for sparse iterators over internal and leaf nodes.  <a href="structopenvdb_1_1v10__1_1_1tree_1_1SparseIteratorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1Tree.html">Tree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1Tree3.html">Tree3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1Tree3.html#a74e796a0dad5f76b408fdc4b6e249c93">Tree3&lt;T, N1, N2&gt;::Type</a> is the type of a three-level tree (Root, Internal, Leaf) with value type T and internal and leaf node log dimensions N1 and N2, respectively.  <a href="structopenvdb_1_1v10__1_1_1tree_1_1Tree3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1Tree4.html">Tree4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1Tree4.html#a662d25f72b925dce0073c06f65283489">Tree4&lt;T, N1, N2, N3&gt;::Type</a> is the type of a four-level tree (Root, Internal, Internal, Leaf) with value type T and internal and leaf node log dimensions N1, N2 and N3, respectively.  <a href="structopenvdb_1_1v10__1_1_1tree_1_1Tree4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1Tree5.html">Tree5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1Tree5.html#a72e4b1e2718526bdebd7d90798430c6f">Tree5&lt;T, N1, N2, N3, N4&gt;::Type</a> is the type of a five-level tree (Root, Internal, Internal, Internal, Leaf) with value type T and internal and leaf node log dimensions N1, N2, N3 and N4, respectively.  <a href="structopenvdb_1_1v10__1_1_1tree_1_1Tree5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1TreeBase.html">TreeBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for typed trees.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1TreeBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits.html">TreeIterTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits.html" title="TreeIterTraits provides, for all tree iterators, a begin(tree) function that returns an iterator over...">TreeIterTraits</a> provides, for all tree iterators, a begin(tree) function that returns an iterator over a tree of arbitrary type.  <a href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1LeafCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::LeafCIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1LeafIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::LeafIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1NodeCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::NodeCIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1NodeIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::NodeIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1RootNodeType_1_1ChildAllCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::RootNodeType::ChildAllCIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1RootNodeType_1_1ChildAllIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::RootNodeType::ChildAllIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1RootNodeType_1_1ChildOffCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::RootNodeType::ChildOffCIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1RootNodeType_1_1ChildOffIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::RootNodeType::ChildOffIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1RootNodeType_1_1ChildOnCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::RootNodeType::ChildOnCIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1RootNodeType_1_1ChildOnIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::RootNodeType::ChildOnIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1ValueAllCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::ValueAllCIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1ValueAllIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::ValueAllIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1ValueOffCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::ValueOffCIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1ValueOffIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::ValueOffIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1ValueOnCIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::ValueOnCIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1TreeIterTraits_3_01TreeT_00_01typename_01TreeT_1_1ValueOnIter_01_4.html">TreeIterTraits&lt; TreeT, typename TreeT::ValueOnIter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for tree-traversal iterators over tile and voxel values.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1TreeValueIteratorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class for ValueAccessors manages registration of an accessor with a tree so that the tree can automatically clear the accessor whenever one of its nodes is deleted.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Value Accessor Implementation and API methods. The majoirty of the API matches the API of a compatible OpenVDB <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1Tree.html">Tree</a> Node.  <a href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorLeafBuffer.html">ValueAccessorLeafBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small class that contains a cached pointer to a <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim...">LeafNode</a> data buffer which is derived from by the internal Value Accessor Implementation. This allows for the empty base class optimization to be performed in the case where a <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim...">LeafNode</a> does not store a contiguous index-able buffer. From C++20 we can instead switch to [[no_unique_address]].  <a href="structopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorLeafBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorLeafBuffer_3_01TreeTypeT_00_01IntegerSequence_00952255788e849e94e3c06632d5331885.html">ValueAccessorLeafBuffer&lt; TreeTypeT, IntegerSequence,           typename std::enable_if&lt;                                                  !value_accessor_internal::EnableLeafBuffer&lt; TreeTypeT, IntegerSequence &gt;::value           &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the case where a Leaf Buffer cannot be cached.  <a href="structopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorLeafBuffer_3_01TreeTypeT_00_01IntegerSequence_00952255788e849e94e3c06632d5331885.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorLock.html">ValueAccessorLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small class that contains a Mutex which is derived from by the internal Value Accessor Implementation. This allows for the empty base class optimization to be performed in the case where a Mutex/Lock is not in use. From C++20 we can instead switch to [[no_unique_address]].  <a href="structopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorLock_3_01void_01_4.html">ValueAccessorLock&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the case where no Mutex is in use. See above.  <a href="structopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorLock_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9bffaa36c0bfe91d3ac486db84d76410"><td class="memTemplParams" colspan="2">template&lt;typename TreeType , bool IsSafe = true, size_t CacheLevels = std::max(Index(1),TreeType::DEPTH)-1, typename MutexType  = void&gt; </td></tr>
<tr class="memitem:a9bffaa36c0bfe91d3ac486db84d76410"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree.html#a9bffaa36c0bfe91d3ac486db84d76410">ValueAccessor</a> = <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a>&lt; TreeType, IsSafe, MutexType, <a class="el" href="namespaceopenvdb_1_1v10__1.html#a64bb796a5880d027cddd2f6a2f43224c">openvdb::make_index_sequence</a>&lt; CacheLevels &gt;&gt;</td></tr>
<tr class="memdesc:a9bffaa36c0bfe91d3ac486db84d76410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes a single Index specifying the number of nodes to cache. This is expanded into an index sequence (required for backward compatibility).  <a href="#a9bffaa36c0bfe91d3ac486db84d76410">More...</a><br /></td></tr>
<tr class="separator:a9bffaa36c0bfe91d3ac486db84d76410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91391009e65d76543e7e542bc18b395f"><td class="memTemplParams" colspan="2">template&lt;typename TreeType , bool IsSafe&gt; </td></tr>
<tr class="memitem:a91391009e65d76543e7e542bc18b395f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree.html#a91391009e65d76543e7e542bc18b395f">ValueAccessor0</a> = <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a>&lt; TreeType, IsSafe, void, <a class="el" href="structopenvdb_1_1v10__1_1_1index__sequence.html">openvdb::index_sequence</a>&lt;&gt;&gt;</td></tr>
<tr class="memdesc:a91391009e65d76543e7e542bc18b395f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a ValueAccessor which doesn't cache any Internal or Leaf nodes.  <a href="#a91391009e65d76543e7e542bc18b395f">More...</a><br /></td></tr>
<tr class="separator:a91391009e65d76543e7e542bc18b395f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc6cb02d8dbeef5695e7e10b98768ec"><td class="memTemplParams" colspan="2">template&lt;typename TreeType , bool IsSafe, size_t L0 = 0&gt; </td></tr>
<tr class="memitem:acfc6cb02d8dbeef5695e7e10b98768ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree.html#acfc6cb02d8dbeef5695e7e10b98768ec">ValueAccessor1</a> = <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a>&lt; TreeType, IsSafe, void, <a class="el" href="structopenvdb_1_1v10__1_1_1index__sequence.html">openvdb::index_sequence</a>&lt; L0 &gt;&gt;</td></tr>
<tr class="memdesc:acfc6cb02d8dbeef5695e7e10b98768ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a ValueAccessor which caches a single node level. By default, the node level is 0, which corresponds to the lowest node level, typically LeafNodes.  <a href="#acfc6cb02d8dbeef5695e7e10b98768ec">More...</a><br /></td></tr>
<tr class="separator:acfc6cb02d8dbeef5695e7e10b98768ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d86ca6794e2fa6a7a71a358ca8eeda0"><td class="memTemplParams" colspan="2">template&lt;typename TreeType , bool IsSafe, size_t L0 = 0, size_t L1 = 1&gt; </td></tr>
<tr class="memitem:a1d86ca6794e2fa6a7a71a358ca8eeda0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree.html#a1d86ca6794e2fa6a7a71a358ca8eeda0">ValueAccessor2</a> = <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a>&lt; TreeType, IsSafe, void, <a class="el" href="structopenvdb_1_1v10__1_1_1index__sequence.html">openvdb::index_sequence</a>&lt; L0, L1 &gt;&gt;</td></tr>
<tr class="memdesc:a1d86ca6794e2fa6a7a71a358ca8eeda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a ValueAccessor which caches two node levels. By default the two lowest node levels are selected (0, 1) which typically correspond to an <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1InternalNode.html">InternalNode</a> and its child LeafNodes. This instantiation will only be valid for TreeTypes which have at least two levels of nodes (excluding the Root node).  <a href="#a1d86ca6794e2fa6a7a71a358ca8eeda0">More...</a><br /></td></tr>
<tr class="separator:a1d86ca6794e2fa6a7a71a358ca8eeda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1d265463c2153d920dcefb872ed705"><td class="memTemplParams" colspan="2">template&lt;typename TreeType , bool IsSafe, size_t L0 = 0, size_t L1 = 1, size_t L2 = 2&gt; </td></tr>
<tr class="memitem:afc1d265463c2153d920dcefb872ed705"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree.html#afc1d265463c2153d920dcefb872ed705">ValueAccessor3</a> = <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a>&lt; TreeType, IsSafe, void, <a class="el" href="structopenvdb_1_1v10__1_1_1index__sequence.html">openvdb::index_sequence</a>&lt; L0, L1, L2 &gt;&gt;</td></tr>
<tr class="memdesc:afc1d265463c2153d920dcefb872ed705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a ValueAccessor which caches three node levels. By default the three lowest node levels are selected (0, 1, 2) which typically correspond to two InternalNodes followed by the bottom LeafNodes. This instantiation will only be valid for TreeTypes which have at least three levels of nodes (excluding the Root node).  <a href="#afc1d265463c2153d920dcefb872ed705">More...</a><br /></td></tr>
<tr class="separator:afc1d265463c2153d920dcefb872ed705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac968581579c1f235f8f0a22a68d7fe9b"><td class="memTemplParams" colspan="2">template&lt;typename TreeType , bool IsSafe = true, size_t CacheLevels = std::max(Index(1),TreeType::DEPTH)-1&gt; </td></tr>
<tr class="memitem:ac968581579c1f235f8f0a22a68d7fe9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree.html#ac968581579c1f235f8f0a22a68d7fe9b">ValueAccessorRW</a> = <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a>&lt; TreeType, IsSafe, tbb::spin_mutex, <a class="el" href="namespaceopenvdb_1_1v10__1.html#a64bb796a5880d027cddd2f6a2f43224c">openvdb::make_index_sequence</a>&lt; CacheLevels &gt;&gt;</td></tr>
<tr class="memdesc:ac968581579c1f235f8f0a22a68d7fe9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a ValueAccesor which spin locks every API call.  <a href="#ac968581579c1f235f8f0a22a68d7fe9b">More...</a><br /></td></tr>
<tr class="separator:ac968581579c1f235f8f0a22a68d7fe9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9cdb9d00f4c5f9820eaaaa472b326fb9"><td class="memTemplParams" colspan="2">template&lt;typename T , Index Log2Dim&gt; </td></tr>
<tr class="memitem:a9cdb9d00f4c5f9820eaaaa472b326fb9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree.html#a9cdb9d00f4c5f9820eaaaa472b326fb9">operator&lt;&lt;</a> (std::ostream &amp;os, const typename <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode.html">LeafNode</a>&lt; T, Log2Dim &gt;::Buffer &amp;buf)</td></tr>
<tr class="separator:a9cdb9d00f4c5f9820eaaaa472b326fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a9bffaa36c0bfe91d3ac486db84d76410"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree.html#a9bffaa36c0bfe91d3ac486db84d76410">ValueAccessor</a> =  <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a>&lt;TreeType, IsSafe, MutexType, <a class="el" href="namespaceopenvdb_1_1v10__1.html#a64bb796a5880d027cddd2f6a2f43224c">openvdb::make_index_sequence</a>&lt;CacheLevels&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes a single Index specifying the number of nodes to cache. This is expanded into an index sequence (required for backward compatibility). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TreeType</td><td>The tree type </td></tr>
    <tr><td class="paramname">IsSafe</td><td>Whether this accessor registers itself to the tree. See the base class definition for more information on this parameter. </td></tr>
    <tr><td class="paramname">CacheLevels</td><td>The number of node levels to cache <em>excluding</em> the Root node. The Root node is implicitly always included, even if this value is zero. </td></tr>
    <tr><td class="paramname">MutexType</td><td>An optional std compatible mutex to use which ensures every call to the ValueAccessor API is thread safe. If void (the default) no locking takes place. In general it's not advised to mutex lock ValueAccessor methods (instead consider creating a accessor per thread). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91391009e65d76543e7e542bc18b395f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree.html#a91391009e65d76543e7e542bc18b395f">ValueAccessor0</a> =  <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a>&lt;TreeType, IsSafe, void, <a class="el" href="structopenvdb_1_1v10__1_1_1index__sequence.html">openvdb::index_sequence</a>&lt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper alias for a ValueAccessor which doesn't cache any Internal or Leaf nodes. </p>

</div>
</div>
<a class="anchor" id="acfc6cb02d8dbeef5695e7e10b98768ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree.html#acfc6cb02d8dbeef5695e7e10b98768ec">ValueAccessor1</a> =  <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a>&lt;TreeType, IsSafe, void, <a class="el" href="structopenvdb_1_1v10__1_1_1index__sequence.html">openvdb::index_sequence</a>&lt;L0&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper alias for a ValueAccessor which caches a single node level. By default, the node level is 0, which corresponds to the lowest node level, typically LeafNodes. </p>

</div>
</div>
<a class="anchor" id="a1d86ca6794e2fa6a7a71a358ca8eeda0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree.html#a1d86ca6794e2fa6a7a71a358ca8eeda0">ValueAccessor2</a> =  <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a>&lt;TreeType, IsSafe, void, <a class="el" href="structopenvdb_1_1v10__1_1_1index__sequence.html">openvdb::index_sequence</a>&lt;L0, L1&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper alias for a ValueAccessor which caches two node levels. By default the two lowest node levels are selected (0, 1) which typically correspond to an <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1InternalNode.html">InternalNode</a> and its child LeafNodes. This instantiation will only be valid for TreeTypes which have at least two levels of nodes (excluding the Root node). </p>

</div>
</div>
<a class="anchor" id="afc1d265463c2153d920dcefb872ed705"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree.html#afc1d265463c2153d920dcefb872ed705">ValueAccessor3</a> =  <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a>&lt;TreeType, IsSafe, void, <a class="el" href="structopenvdb_1_1v10__1_1_1index__sequence.html">openvdb::index_sequence</a>&lt;L0, L1, L2&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper alias for a ValueAccessor which caches three node levels. By default the three lowest node levels are selected (0, 1, 2) which typically correspond to two InternalNodes followed by the bottom LeafNodes. This instantiation will only be valid for TreeTypes which have at least three levels of nodes (excluding the Root node). </p>

</div>
</div>
<a class="anchor" id="ac968581579c1f235f8f0a22a68d7fe9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v10__1_1_1tree.html#ac968581579c1f235f8f0a22a68d7fe9b">ValueAccessorRW</a> =  <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl</a>&lt;TreeType, IsSafe, tbb::spin_mutex, <a class="el" href="namespaceopenvdb_1_1v10__1.html#a64bb796a5880d027cddd2f6a2f43224c">openvdb::make_index_sequence</a>&lt;CacheLevels&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper alias for a ValueAccesor which spin locks every API call. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9cdb9d00f4c5f9820eaaaa472b326fb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; openvdb::v10_1::tree::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classopenvdb_1_1v10__1_1_1tree_1_1LeafNode.html">LeafNode</a>&lt; T, Log2Dim &gt;::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
