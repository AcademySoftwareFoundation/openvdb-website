<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: PagedArray&lt; ValueT, Log2PageSize &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html','','classopenvdb_1_1v13__0_1_1util_1_1PagedArray-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">PagedArray&lt; ValueT, Log2PageSize &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compliant iterators. It is primarily intended for applications that concurrently insert (a possibly unkown number of) elements into a dynamically growing linear array, and fast random access to said elements.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PagedArray_8h_source.html">openvdb/util/PagedArray.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:ConstIterator" id="r_ConstIterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a></td></tr>
<tr class="memitem:Iterator" id="r_Iterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a></td></tr>
<tr class="memitem:Page" id="r_Page"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1Page.html">Page</a></td></tr>
<tr class="memitem:ValueBuffer" id="r_ValueBuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a72ced3f4f821016da17c4ecd262e8b03" id="r_a72ced3f4f821016da17c4ecd262e8b03"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> = ValueT</td></tr>
<tr class="memitem:ac662067233f2ff94261b81bafac2b1e6" id="r_ac662067233f2ff94261b81bafac2b1e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac662067233f2ff94261b81bafac2b1e6">Ptr</a> = <a class="el" href="namespaceopenvdb_1_1v13__0.html#ad71c1f3b8d46b57fd328d48cee283c1f">SharedPtr</a>&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html">PagedArray</a>&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a53d94f3afe55677c30f923898e0c85e3" id="r_a53d94f3afe55677c30f923898e0c85e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53d94f3afe55677c30f923898e0c85e3">PagedArray</a> ()</td></tr>
<tr class="memdesc:a53d94f3afe55677c30f923898e0c85e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="memitem:aa6d53e13fd82dcd47d234226100469da" id="r_aa6d53e13fd82dcd47d234226100469da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6d53e13fd82dcd47d234226100469da">~PagedArray</a> ()</td></tr>
<tr class="memdesc:aa6d53e13fd82dcd47d234226100469da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor removed all allocated pages.  <br /></td></tr>
<tr class="memitem:a266b3984ff84343231b5c7aad18a9d70" id="r_a266b3984ff84343231b5c7aad18a9d70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a266b3984ff84343231b5c7aad18a9d70">PagedArray</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html">PagedArray</a> &amp;)=delete</td></tr>
<tr class="memitem:a8ee734512d3274a92f9698823a2ff703" id="r_a8ee734512d3274a92f9698823a2ff703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html">PagedArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ee734512d3274a92f9698823a2ff703">operator=</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html">PagedArray</a> &amp;)=delete</td></tr>
<tr class="memitem:abbeaccec9a5f8378f9db700990773afb" id="r_abbeaccec9a5f8378f9db700990773afb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbeaccec9a5f8378f9db700990773afb">getBuffer</a> ()</td></tr>
<tr class="memitem:a2db49bee5258957acd0317c8d4342fb3" id="r_a2db49bee5258957acd0317c8d4342fb3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2db49bee5258957acd0317c8d4342fb3">push_back_unsafe</a> (const <a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;value)</td></tr>
<tr class="memitem:a5f16304f80b6fb253c7b0ead3e16dd18" id="r_a5f16304f80b6fb253c7b0ead3e16dd18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f16304f80b6fb253c7b0ead3e16dd18">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a5f16304f80b6fb253c7b0ead3e16dd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the page table to fix the current size.  <br /></td></tr>
<tr class="memitem:a928bc95e1ad8f6d08f84b69fdf6961f4" id="r_a928bc95e1ad8f6d08f84b69fdf6961f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a928bc95e1ad8f6d08f84b69fdf6961f4">operator[]</a> (size_t i)</td></tr>
<tr class="memdesc:a928bc95e1ad8f6d08f84b69fdf6961f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value at the specified offset.  <br /></td></tr>
<tr class="memitem:acf8da78b4ea31847d210d19911fa8533" id="r_acf8da78b4ea31847d210d19911fa8533"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf8da78b4ea31847d210d19911fa8533">operator[]</a> (size_t i) const</td></tr>
<tr class="memdesc:acf8da78b4ea31847d210d19911fa8533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const-reference to the value at the specified offset.  <br /></td></tr>
<tr class="memitem:a6adf5091670b306e0669292ecfece5b8" id="r_a6adf5091670b306e0669292ecfece5b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6adf5091670b306e0669292ecfece5b8">fill</a> (const <a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;v)</td></tr>
<tr class="memdesc:a6adf5091670b306e0669292ecfece5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all elements in the page table to the specified value.  <br /></td></tr>
<tr class="memitem:ab7480dfb0409914fda2134576f62d88b" id="r_ab7480dfb0409914fda2134576f62d88b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7480dfb0409914fda2134576f62d88b">copy</a> (<a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> *p, size_t count) const</td></tr>
<tr class="memdesc:ab7480dfb0409914fda2134576f62d88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the first <em class="arg">count</em> values in this PageArray into a raw c-style array, assuming it to be at least <em class="arg">count</em> elements long.  <br /></td></tr>
<tr class="memitem:a2eae0a8edb46251d6f54095daee665ec" id="r_a2eae0a8edb46251d6f54095daee665ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eae0a8edb46251d6f54095daee665ec">copy</a> (<a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> *p) const</td></tr>
<tr class="memitem:a514affe27cc623fc5dccf1bf4648eb2a" id="r_a514affe27cc623fc5dccf1bf4648eb2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a514affe27cc623fc5dccf1bf4648eb2a">resize</a> (size_t <a class="el" href="#a259cb5a711406a8c3e5d937eb9350cca">size</a>)</td></tr>
<tr class="memdesc:a514affe27cc623fc5dccf1bf4648eb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize this array to the specified size.  <br /></td></tr>
<tr class="memitem:a9027f383daa2bb7bc9078f5f98858d47" id="r_a9027f383daa2bb7bc9078f5f98858d47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9027f383daa2bb7bc9078f5f98858d47">resize</a> (size_t <a class="el" href="#a259cb5a711406a8c3e5d937eb9350cca">size</a>, const <a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;v)</td></tr>
<tr class="memdesc:a9027f383daa2bb7bc9078f5f98858d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize this array to the specified size and initialize all values to <em class="arg">v</em>.  <br /></td></tr>
<tr class="memitem:a259cb5a711406a8c3e5d937eb9350cca" id="r_a259cb5a711406a8c3e5d937eb9350cca"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a259cb5a711406a8c3e5d937eb9350cca">size</a> () const</td></tr>
<tr class="memdesc:a259cb5a711406a8c3e5d937eb9350cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in this array.  <br /></td></tr>
<tr class="memitem:a7223528283cd4e5872e0cc716bf9bd9d" id="r_a7223528283cd4e5872e0cc716bf9bd9d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7223528283cd4e5872e0cc716bf9bd9d">capacity</a> () const</td></tr>
<tr class="memdesc:a7223528283cd4e5872e0cc716bf9bd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of elements that this array can contain without allocating more memory pages.  <br /></td></tr>
<tr class="memitem:a6cde563443a9855088851862612451f9" id="r_a6cde563443a9855088851862612451f9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cde563443a9855088851862612451f9">freeCount</a> () const</td></tr>
<tr class="memdesc:a6cde563443a9855088851862612451f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of additional elements that can be added to this array without allocating more memory pages.  <br /></td></tr>
<tr class="memitem:a491448507f009e86efb97e3188583e37" id="r_a491448507f009e86efb97e3188583e37"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a491448507f009e86efb97e3188583e37">pageCount</a> () const</td></tr>
<tr class="memdesc:a491448507f009e86efb97e3188583e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of allocated memory pages.  <br /></td></tr>
<tr class="memitem:a11fad25577340b7b31df24025314a844" id="r_a11fad25577340b7b31df24025314a844"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11fad25577340b7b31df24025314a844">memUsage</a> () const</td></tr>
<tr class="memdesc:a11fad25577340b7b31df24025314a844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the memory footprint of this array in bytes.  <br /></td></tr>
<tr class="memitem:acf82f9b2937375c7b1cf3dccb3df3312" id="r_acf82f9b2937375c7b1cf3dccb3df3312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf82f9b2937375c7b1cf3dccb3df3312">isEmpty</a> () const</td></tr>
<tr class="memdesc:acf82f9b2937375c7b1cf3dccb3df3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the container contains no elements.  <br /></td></tr>
<tr class="memitem:a723fd7d55551ebb23154d15baeedbcf3" id="r_a723fd7d55551ebb23154d15baeedbcf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a723fd7d55551ebb23154d15baeedbcf3">isPartiallyFull</a> () const</td></tr>
<tr class="memdesc:a723fd7d55551ebb23154d15baeedbcf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the page table is partially full, i.e. the last non-empty page contains less than <a class="el" href="#afa3a6d6e461b89bd214b04bb6ed883a6" title="Return the number of elements per memory page.">pageSize()</a> elements.  <br /></td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204" id="r_ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr class="memdesc:ac8bb3912a3ce86b15842e79d0b421204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the array and delete all pages.  <br /></td></tr>
<tr class="memitem:a2387033802383edbdc95f9bbb12a707e" id="r_a2387033802383edbdc95f9bbb12a707e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2387033802383edbdc95f9bbb12a707e">begin</a> ()</td></tr>
<tr class="memdesc:a2387033802383edbdc95f9bbb12a707e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a non-const iterator pointing to the first element.  <br /></td></tr>
<tr class="memitem:ab45dae688fc5d8983727abffa4389003" id="r_ab45dae688fc5d8983727abffa4389003"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab45dae688fc5d8983727abffa4389003">end</a> ()</td></tr>
<tr class="memdesc:ab45dae688fc5d8983727abffa4389003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a non-const iterator pointing to the past-the-last element.  <br /></td></tr>
<tr class="memitem:a98b1109a9006f8cc7d4566146a3bd737" id="r_a98b1109a9006f8cc7d4566146a3bd737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98b1109a9006f8cc7d4566146a3bd737">cbegin</a> () const</td></tr>
<tr class="memdesc:a98b1109a9006f8cc7d4566146a3bd737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator pointing to the first element.  <br /></td></tr>
<tr class="memitem:ad5fee900c7aee90671038c79225bf8ec" id="r_ad5fee900c7aee90671038c79225bf8ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5fee900c7aee90671038c79225bf8ec">begin</a> () const</td></tr>
<tr class="memitem:a02fd29b6dc3e21fbe4484362d85893bc" id="r_a02fd29b6dc3e21fbe4484362d85893bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02fd29b6dc3e21fbe4484362d85893bc">cend</a> () const</td></tr>
<tr class="memdesc:a02fd29b6dc3e21fbe4484362d85893bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator pointing to the past-the-last element.  <br /></td></tr>
<tr class="memitem:a69b6e2a03c835ca5d658a1f16acbaa9c" id="r_a69b6e2a03c835ca5d658a1f16acbaa9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69b6e2a03c835ca5d658a1f16acbaa9c">end</a> () const</td></tr>
<tr class="memitem:a47fdc9eea42b6975cdc835bb2e08810e" id="r_a47fdc9eea42b6975cdc835bb2e08810e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47fdc9eea42b6975cdc835bb2e08810e">sort</a> ()</td></tr>
<tr class="memdesc:a47fdc9eea42b6975cdc835bb2e08810e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel sort of all the elements in ascending order.  <br /></td></tr>
<tr class="memitem:a562fe73ea409de2947247a52a685a5ef" id="r_a562fe73ea409de2947247a52a685a5ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a562fe73ea409de2947247a52a685a5ef">invSort</a> ()</td></tr>
<tr class="memdesc:a562fe73ea409de2947247a52a685a5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel sort of all the elements in descending order.  <br /></td></tr>
<tr class="memitem:a532f53d8ad34787bf9734b63665a9ef9" id="r_a532f53d8ad34787bf9734b63665a9ef9"><td class="memTemplParams" colspan="2">template&lt;typename Functor&gt; </td></tr>
<tr class="memitem:a532f53d8ad34787bf9734b63665a9ef9 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a532f53d8ad34787bf9734b63665a9ef9">sort</a> (Functor func)</td></tr>
<tr class="memdesc:a532f53d8ad34787bf9734b63665a9ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel sort of all the elements based on a custom functor with the api:  <br /></td></tr>
<tr class="memitem:ac07534f9ba83f95d11ce49c4ef4d5ce4" id="r_ac07534f9ba83f95d11ce49c4ef4d5ce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac07534f9ba83f95d11ce49c4ef4d5ce4">merge</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html">PagedArray</a> &amp;other)</td></tr>
<tr class="memdesc:ac07534f9ba83f95d11ce49c4ef4d5ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer all the elements (and pages) from the other array to this array.  <br /></td></tr>
<tr class="memitem:ae76e7240cdf93cfe932eb4ebee0711e7" id="r_ae76e7240cdf93cfe932eb4ebee0711e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae76e7240cdf93cfe932eb4ebee0711e7">print</a> (std::ostream &amp;os=std::cout) const</td></tr>
<tr class="memdesc:ae76e7240cdf93cfe932eb4ebee0711e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print information for debugging.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad9ed7a677da4265c8ec80a525783c7f0" id="r_ad9ed7a677da4265c8ec80a525783c7f0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ac662067233f2ff94261b81bafac2b1e6">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9ed7a677da4265c8ec80a525783c7f0">create</a> ()</td></tr>
<tr class="memdesc:ad9ed7a677da4265c8ec80a525783c7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a shared pointer to a new instance of this class.  <br /></td></tr>
<tr class="memitem:afa3a6d6e461b89bd214b04bb6ed883a6" id="r_afa3a6d6e461b89bd214b04bb6ed883a6"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa3a6d6e461b89bd214b04bb6ed883a6">pageSize</a> ()</td></tr>
<tr class="memdesc:afa3a6d6e461b89bd214b04bb6ed883a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements per memory page.  <br /></td></tr>
<tr class="memitem:a20079d9af0877028f05572c5eda297a4" id="r_a20079d9af0877028f05572c5eda297a4"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20079d9af0877028f05572c5eda297a4">log2PageSize</a> ()</td></tr>
<tr class="memdesc:a20079d9af0877028f05572c5eda297a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return log2 of the number of elements per memory page.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:afc867e0705ff7ee57a5a4be9bb466aa8" id="r_afc867e0705ff7ee57a5a4be9bb466aa8"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc867e0705ff7ee57a5a4be9bb466aa8">ValueBuffer</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt;<br />
class openvdb::v13_0::util::PagedArray&lt; ValueT, Log2PageSize &gt;</div><p>Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compliant iterators. It is primarily intended for applications that concurrently insert (a possibly unkown number of) elements into a dynamically growing linear array, and fast random access to said elements. </p>
<dl class="section note"><dt>Note</dt><dd>Multiple threads can grow the page-table and push_back new elements concurrently. A <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a> provides accelerated and threadsafe push_back at the cost of potentially re-ordering elements (when multiple instances are used).</dd></dl>
<p>This data structure employes contiguous pages of elements (a std::deque) which avoids moving data when the capacity is out-grown and new pages are allocated. The size of the pages can be controlled with the Log2PageSize template parameter (defaults to 1024 elements of type ValueT).</p>
<p>There are three fundamentally different ways to insert elements to this container - each with different advanteges and disadvanteges.</p>
<p>The simplest way to insert elements is to use <a class="el" href="#a2db49bee5258957acd0317c8d4342fb3">PagedArray::push_back_unsafe</a> which is <em class="arg">not</em> thread-safe: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a53d94f3afe55677c30f923898e0c85e3">PagedArray&lt;size_t&gt;</a> array;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;100000; ++i) array.<a class="code hl_function" href="#a2db49bee5258957acd0317c8d4342fb3">push_back_unsafe</a>(i);</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1util_1_1PagedArray_html_a2db49bee5258957acd0317c8d4342fb3"><div class="ttname"><a href="#a2db49bee5258957acd0317c8d4342fb3">openvdb::v13_0::util::PagedArray::push_back_unsafe</a></div><div class="ttdeci">size_t push_back_unsafe(const ValueType &amp;value)</div><div class="ttdef"><b>Definition</b> PagedArray.h:193</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1util_1_1PagedArray_html_a53d94f3afe55677c30f923898e0c85e3"><div class="ttname"><a href="#a53d94f3afe55677c30f923898e0c85e3">openvdb::v13_0::util::PagedArray::PagedArray</a></div><div class="ttdeci">PagedArray()</div><div class="ttdoc">Default constructor.</div><div class="ttdef"><b>Definition</b> PagedArray.h:157</div></div>
</div><!-- fragment --><p>The fastest way (by far) to insert elements is by means of a <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ValueBuffer.html">PagedArray::ValueBuffer</a>: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a53d94f3afe55677c30f923898e0c85e3">PagedArray&lt;size_t&gt;</a> array;</div>
<div class="line"><span class="keyword">auto</span> buffer = array.<a class="code hl_function" href="#abbeaccec9a5f8378f9db700990773afb">getBuffer</a>();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;100000; ++i) buffer.push_back(i);</div>
<div class="line">buffer.flush();</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1util_1_1PagedArray_html_abbeaccec9a5f8378f9db700990773afb"><div class="ttname"><a href="#abbeaccec9a5f8378f9db700990773afb">openvdb::v13_0::util::PagedArray::getBuffer</a></div><div class="ttdeci">ValueBuffer getBuffer()</div><div class="ttdef"><b>Definition</b> PagedArray.h:180</div></div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a53d94f3afe55677c30f923898e0c85e3">PagedArray&lt;size_t&gt;</a> array;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//local scope of a single thread</span></div>
<div class="line">    <span class="keyword">auto</span> buffer = array.<a class="code hl_function" href="#abbeaccec9a5f8378f9db700990773afb">getBuffer</a>();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;100000; ++i) buffer.push_back(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p> or with TBB task-based multi-threading: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a53d94f3afe55677c30f923898e0c85e3">PagedArray&lt;size_t&gt;</a> array;</div>
<div class="line">tbb::parallel_for(</div>
<div class="line">    tbb::blocked_range&lt;size_t&gt;(0, 10000, array.<a class="code hl_function" href="#afa3a6d6e461b89bd214b04bb6ed883a6">pageSize</a>()),</div>
<div class="line">    [&amp;array](<span class="keyword">const</span> tbb::blocked_range&lt;size_t&gt;&amp; range) {</div>
<div class="line">        auto buffer = array.getBuffer();</div>
<div class="line">        for (size_t i=range.begin(); i!=range.end(); ++i) buffer.push_back(i);</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1util_1_1PagedArray_html_afa3a6d6e461b89bd214b04bb6ed883a6"><div class="ttname"><a href="#afa3a6d6e461b89bd214b04bb6ed883a6">openvdb::v13_0::util::PagedArray::pageSize</a></div><div class="ttdeci">static size_t pageSize()</div><div class="ttdoc">Return the number of elements per memory page.</div><div class="ttdef"><b>Definition</b> PagedArray.h:334</div></div>
</div><!-- fragment --><p> or with TBB thread-local storage for even better performance (due to fewer concurrent instantiations of partially full ValueBuffers) </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a53d94f3afe55677c30f923898e0c85e3">PagedArray&lt;size_t&gt;</a> array;</div>
<div class="line"><span class="keyword">auto</span> exemplar = array.<a class="code hl_function" href="#abbeaccec9a5f8378f9db700990773afb">getBuffer</a>();<span class="comment">//dummy used for initialization</span></div>
<div class="line">tbb::enumerable_thread_specific&lt;PagedArray&lt;size_t&gt;::ValueBuffer&gt;</div>
<div class="line">    pool(exemplar);<span class="comment">//thread local storage pool of ValueBuffers</span></div>
<div class="line">tbb::parallel_for(</div>
<div class="line">    tbb::blocked_range&lt;size_t&gt;(0, 10000, array.<a class="code hl_function" href="#afa3a6d6e461b89bd214b04bb6ed883a6">pageSize</a>()),</div>
<div class="line">    [&amp;pool](<span class="keyword">const</span> tbb::blocked_range&lt;size_t&gt;&amp; range) {</div>
<div class="line">        auto &amp;buffer = pool.local();</div>
<div class="line">        for (size_t i=range.begin(); i!=range.end(); ++i) buffer.push_back(i);</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i=pool.begin(); i!=pool.end(); ++i) i-&gt;flush();</div>
</div><!-- fragment --><p> This technique generally outperforms <a class="el" href="#a2db49bee5258957acd0317c8d4342fb3">PagedArray::push_back_unsafe</a>, std::vector::push_back, std::deque::push_back and even tbb::concurrent_vector::push_back. Additionally it is thread-safe as long as each thread has it's own instance of a <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ValueBuffer.html">PagedArray::ValueBuffer</a>. The only disadvantage is the ordering of the elements is undefined if multiple instance of a <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ValueBuffer.html">PagedArray::ValueBuffer</a> are employed. This is typically the case in the context of multi-threading, where the ordering of inserts are undefined anyway. Note that a local scope can be used to guarentee that the <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a> has inserted all its elements by the time the scope ends. Alternatively the <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a> can be explicitly flushed by calling ValueBuffer::flush.</p>
<p>The third way to insert elements is to resize the container and use random access, e.g. </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a53d94f3afe55677c30f923898e0c85e3">PagedArray&lt;int&gt;</a> array;</div>
<div class="line">array.<a class="code hl_function" href="#a514affe27cc623fc5dccf1bf4648eb2a">resize</a>(100000);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;100000; ++i) array[i] = i;</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1util_1_1PagedArray_html_a514affe27cc623fc5dccf1bf4648eb2a"><div class="ttname"><a href="#a514affe27cc623fc5dccf1bf4648eb2a">openvdb::v13_0::util::PagedArray::resize</a></div><div class="ttdeci">void resize(size_t size)</div><div class="ttdoc">Resize this array to the specified size.</div><div class="ttdef"><b>Definition</b> PagedArray.h:288</div></div>
</div><!-- fragment --><p> or in terms of the random access iterator </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a53d94f3afe55677c30f923898e0c85e3">PagedArray&lt;int&gt;</a> array;</div>
<div class="line">array.<a class="code hl_function" href="#a514affe27cc623fc5dccf1bf4648eb2a">resize</a>(100000);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i=array.<a class="code hl_function" href="#a2387033802383edbdc95f9bbb12a707e">begin</a>(); i!=array.<a class="code hl_function" href="#ab45dae688fc5d8983727abffa4389003">end</a>(); ++i) *i = i.pos();</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1util_1_1PagedArray_html_a2387033802383edbdc95f9bbb12a707e"><div class="ttname"><a href="#a2387033802383edbdc95f9bbb12a707e">openvdb::v13_0::util::PagedArray::begin</a></div><div class="ttdeci">Iterator begin()</div><div class="ttdoc">Return a non-const iterator pointing to the first element.</div><div class="ttdef"><b>Definition</b> PagedArray.h:368</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1util_1_1PagedArray_html_ab45dae688fc5d8983727abffa4389003"><div class="ttname"><a href="#ab45dae688fc5d8983727abffa4389003">openvdb::v13_0::util::PagedArray::end</a></div><div class="ttdeci">Iterator end()</div><div class="ttdoc">Return a non-const iterator pointing to the past-the-last element.</div><div class="ttdef"><b>Definition</b> PagedArray.h:375</div></div>
</div><!-- fragment --><p> While this approach is both fast and thread-safe it suffers from the major disadvantage that the problem size, i.e. number of elements, needs to be known in advance. If that's the case you might as well consider using std::vector or a raw c-style array! In other words the <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html" title="Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compl...">PagedArray</a> is most useful in the context of applications that involve multi-threading of dynamically growing linear arrays that require fast random access. </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="ac662067233f2ff94261b81bafac2b1e6" name="ac662067233f2ff94261b81bafac2b1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac662067233f2ff94261b81bafac2b1e6">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac662067233f2ff94261b81bafac2b1e6">Ptr</a> = <a class="el" href="namespaceopenvdb_1_1v13__0.html#ad71c1f3b8d46b57fd328d48cee283c1f">SharedPtr</a>&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html">PagedArray</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72ced3f4f821016da17c4ecd262e8b03" name="a72ced3f4f821016da17c4ecd262e8b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ced3f4f821016da17c4ecd262e8b03">&#9670;&#160;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> = ValueT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a53d94f3afe55677c30f923898e0c85e3" name="a53d94f3afe55677c30f923898e0c85e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d94f3afe55677c30f923898e0c85e3">&#9670;&#160;</a></span>PagedArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html">PagedArray</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="aa6d53e13fd82dcd47d234226100469da" name="aa6d53e13fd82dcd47d234226100469da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d53e13fd82dcd47d234226100469da">&#9670;&#160;</a></span>~PagedArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html">PagedArray</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor removed all allocated pages. </p>

</div>
</div>
<a id="a266b3984ff84343231b5c7aad18a9d70" name="a266b3984ff84343231b5c7aad18a9d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266b3984ff84343231b5c7aad18a9d70">&#9670;&#160;</a></span>PagedArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html">PagedArray</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html">PagedArray</a>&lt; ValueT, Log2PageSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a2387033802383edbdc95f9bbb12a707e" name="a2387033802383edbdc95f9bbb12a707e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2387033802383edbdc95f9bbb12a707e">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a> begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a non-const iterator pointing to the first element. </p>

</div>
</div>
<a id="ad5fee900c7aee90671038c79225bf8ec" name="ad5fee900c7aee90671038c79225bf8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fee900c7aee90671038c79225bf8ec">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a> begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7223528283cd4e5872e0cc716bf9bd9d" name="a7223528283cd4e5872e0cc716bf9bd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7223528283cd4e5872e0cc716bf9bd9d">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum number of elements that this array can contain without allocating more memory pages. </p>

</div>
</div>
<a id="a98b1109a9006f8cc7d4566146a3bd737" name="a98b1109a9006f8cc7d4566146a3bd737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b1109a9006f8cc7d4566146a3bd737">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a> cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator pointing to the first element. </p>

</div>
</div>
<a id="a02fd29b6dc3e21fbe4484362d85893bc" name="a02fd29b6dc3e21fbe4484362d85893bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fd29b6dc3e21fbe4484362d85893bc">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a> cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator pointing to the past-the-last element. </p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a> does not point to a valid element and should not be dereferenced! </dd></dl>

</div>
</div>
<a id="ac8bb3912a3ce86b15842e79d0b421204" name="ac8bb3912a3ce86b15842e79d0b421204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bb3912a3ce86b15842e79d0b421204">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from the array and delete all pages. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe! </dd></dl>

</div>
</div>
<a id="a2eae0a8edb46251d6f54095daee665ec" name="a2eae0a8edb46251d6f54095daee665ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eae0a8edb46251d6f54095daee665ec">&#9670;&#160;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> *</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7480dfb0409914fda2134576f62d88b" name="ab7480dfb0409914fda2134576f62d88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7480dfb0409914fda2134576f62d88b">&#9670;&#160;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the first <em class="arg">count</em> values in this PageArray into a raw c-style array, assuming it to be at least <em class="arg">count</em> elements long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pointer to an array that will used as the destination of the copy. </td></tr>
    <tr><td class="paramname">count</td><td>number of elements to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9ed7a677da4265c8ec80a525783c7f0" name="ad9ed7a677da4265c8ec80a525783c7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ed7a677da4265c8ec80a525783c7f0">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac662067233f2ff94261b81bafac2b1e6">Ptr</a> create </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a shared pointer to a new instance of this class. </p>

</div>
</div>
<a id="ab45dae688fc5d8983727abffa4389003" name="ab45dae688fc5d8983727abffa4389003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45dae688fc5d8983727abffa4389003">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a> end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a non-const iterator pointing to the past-the-last element. </p>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1Iterator.html">Iterator</a> does not point to a valid element and should not be dereferenced! </dd></dl>

</div>
</div>
<a id="a69b6e2a03c835ca5d658a1f16acbaa9c" name="a69b6e2a03c835ca5d658a1f16acbaa9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b6e2a03c835ca5d658a1f16acbaa9c">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ConstIterator.html">ConstIterator</a> end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6adf5091670b306e0669292ecfece5b8" name="a6adf5091670b306e0669292ecfece5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6adf5091670b306e0669292ecfece5b8">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all elements in the page table to the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>value to be filled in all the existing pages of this <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html" title="Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compl...">PagedArray</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Multi-threaded </dd></dl>

</div>
</div>
<a id="a6cde563443a9855088851862612451f9" name="a6cde563443a9855088851862612451f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cde563443a9855088851862612451f9">&#9670;&#160;</a></span>freeCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t freeCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of additional elements that can be added to this array without allocating more memory pages. </p>

</div>
</div>
<a id="abbeaccec9a5f8378f9db700990773afb" name="abbeaccec9a5f8378f9db700990773afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbeaccec9a5f8378f9db700990773afb">&#9670;&#160;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a> getBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a new instance of a <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a> which supports thread-safe push_back! </dd></dl>

</div>
</div>
<a id="a562fe73ea409de2947247a52a685a5ef" name="a562fe73ea409de2947247a52a685a5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562fe73ea409de2947247a52a685a5ef">&#9670;&#160;</a></span>invSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void invSort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel sort of all the elements in descending order. </p>

</div>
</div>
<a id="acf82f9b2937375c7b1cf3dccb3df3312" name="acf82f9b2937375c7b1cf3dccb3df3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf82f9b2937375c7b1cf3dccb3df3312">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the container contains no elements. </p>

</div>
</div>
<a id="a723fd7d55551ebb23154d15baeedbcf3" name="a723fd7d55551ebb23154d15baeedbcf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723fd7d55551ebb23154d15baeedbcf3">&#9670;&#160;</a></span>isPartiallyFull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isPartiallyFull </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the page table is partially full, i.e. the last non-empty page contains less than <a class="el" href="#afa3a6d6e461b89bd214b04bb6ed883a6" title="Return the number of elements per memory page.">pageSize()</a> elements. </p>
<p>When the page table is partially full calling <a class="el" href="#ac07534f9ba83f95d11ce49c4ef4d5ce4" title="Transfer all the elements (and pages) from the other array to this array.">merge()</a> or using a <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a> will rearrange the ordering of existing elements. </p>

</div>
</div>
<a id="a20079d9af0877028f05572c5eda297a4" name="a20079d9af0877028f05572c5eda297a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20079d9af0877028f05572c5eda297a4">&#9670;&#160;</a></span>log2PageSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t log2PageSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return log2 of the number of elements per memory page. </p>

</div>
</div>
<a id="a11fad25577340b7b31df24025314a844" name="a11fad25577340b7b31df24025314a844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fad25577340b7b31df24025314a844">&#9670;&#160;</a></span>memUsage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t memUsage </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the memory footprint of this array in bytes. </p>

</div>
</div>
<a id="ac07534f9ba83f95d11ce49c4ef4d5ce4" name="ac07534f9ba83f95d11ce49c4ef4d5ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07534f9ba83f95d11ce49c4ef4d5ce4">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html">PagedArray</a>&lt; ValueT, Log2PageSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer all the elements (and pages) from the other array to this array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>non-const reference to the <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html" title="Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compl...">PagedArray</a> that will be merged into this <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html" title="Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compl...">PagedArray</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The other <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html" title="Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compl...">PagedArray</a> is empty on return.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The ordering of elements is undefined if this page table is partially full! </dd></dl>

</div>
</div>
<a id="a8ee734512d3274a92f9698823a2ff703" name="a8ee734512d3274a92f9698823a2ff703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee734512d3274a92f9698823a2ff703">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html">PagedArray</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html">PagedArray</a>&lt; ValueT, Log2PageSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a928bc95e1ad8f6d08f84b69fdf6961f4" name="a928bc95e1ad8f6d08f84b69fdf6961f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928bc95e1ad8f6d08f84b69fdf6961f4">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the value at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>linear offset of the value to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This random access has constant time complexity.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is assumed that the i'th element is already allocated! </dd></dl>

</div>
</div>
<a id="acf8da78b4ea31847d210d19911fa8533" name="acf8da78b4ea31847d210d19911fa8533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8da78b4ea31847d210d19911fa8533">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const-reference to the value at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>linear offset of the value to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This random access has constant time complexity.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is assumed that the i'th element is already allocated! </dd></dl>

</div>
</div>
<a id="a491448507f009e86efb97e3188583e37" name="a491448507f009e86efb97e3188583e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491448507f009e86efb97e3188583e37">&#9670;&#160;</a></span>pageCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t pageCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of allocated memory pages. </p>

</div>
</div>
<a id="afa3a6d6e461b89bd214b04bb6ed883a6" name="afa3a6d6e461b89bd214b04bb6ed883a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3a6d6e461b89bd214b04bb6ed883a6">&#9670;&#160;</a></span>pageSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t pageSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements per memory page. </p>

</div>
</div>
<a id="ae76e7240cdf93cfe932eb4ebee0711e7" name="ae76e7240cdf93cfe932eb4ebee0711e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76e7240cdf93cfe932eb4ebee0711e7">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::cout</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print information for debugging. </p>

</div>
</div>
<a id="a2db49bee5258957acd0317c8d4342fb3" name="a2db49bee5258957acd0317c8d4342fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db49bee5258957acd0317c8d4342fb3">&#9670;&#160;</a></span>push_back_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t push_back_unsafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to be added to this <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html" title="Concurrent, page-based, dynamically-sized linear data structure with O(1) random access and STL-compl...">PagedArray</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For best performance consider using the ValueBuffer!</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe and mostly intended for debugging! </dd></dl>

</div>
</div>
<a id="a514affe27cc623fc5dccf1bf4648eb2a" name="a514affe27cc623fc5dccf1bf4648eb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514affe27cc623fc5dccf1bf4648eb2a">&#9670;&#160;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resize </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize this array to the specified size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>number of elements that this PageArray will contain.</td></tr>
  </table>
  </dd>
</dl>
<p>Will grow or shrink the page table to contain the specified number of elements. It will affect the <a class="el" href="#a259cb5a711406a8c3e5d937eb9350cca" title="Return the number of elements in this array.">size()</a>, iteration will go over all those elements, push_back will insert after them and operator[] can be used directly access them.</p>
<dl class="section note"><dt>Note</dt><dd>No reserve method is implemented due to efficiency concerns (especially for the <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a>) from having to deal with empty pages.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe! </dd></dl>

</div>
</div>
<a id="a9027f383daa2bb7bc9078f5f98858d47" name="a9027f383daa2bb7bc9078f5f98858d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9027f383daa2bb7bc9078f5f98858d47">&#9670;&#160;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resize </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a72ced3f4f821016da17c4ecd262e8b03">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize this array to the specified size and initialize all values to <em class="arg">v</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>number of elements that this PageArray will contain. </td></tr>
    <tr><td class="paramname">v</td><td>value of all the <em class="arg">size</em> values.</td></tr>
  </table>
  </dd>
</dl>
<p>Will grow or shrink the page table to contain the specified number of elements. It will affect the <a class="el" href="#a259cb5a711406a8c3e5d937eb9350cca" title="Return the number of elements in this array.">size()</a>, iteration will go over all those elements, push_back will insert after them and operator[] can be used directly access them.</p>
<dl class="section note"><dt>Note</dt><dd>No reserve method is implemented due to efficiency concerns (especially for the <a class="el" href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray_1_1ValueBuffer.html">ValueBuffer</a>) from having to deal with empty pages.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe! </dd></dl>

</div>
</div>
<a id="a5f16304f80b6fb253c7b0ead3e16dd18" name="a5f16304f80b6fb253c7b0ead3e16dd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f16304f80b6fb253c7b0ead3e16dd18">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce the page table to fix the current size. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not thread-safe! </dd></dl>

</div>
</div>
<a id="a259cb5a711406a8c3e5d937eb9350cca" name="a259cb5a711406a8c3e5d937eb9350cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259cb5a711406a8c3e5d937eb9350cca">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements in this array. </p>

</div>
</div>
<a id="a47fdc9eea42b6975cdc835bb2e08810e" name="a47fdc9eea42b6975cdc835bb2e08810e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fdc9eea42b6975cdc835bb2e08810e">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sort </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel sort of all the elements in ascending order. </p>

</div>
</div>
<a id="a532f53d8ad34787bf9734b63665a9ef9" name="a532f53d8ad34787bf9734b63665a9ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532f53d8ad34787bf9734b63665a9ef9">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<div class="memtemplate">
template&lt;typename Functor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sort </td>
          <td>(</td>
          <td class="paramtype">Functor</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallel sort of all the elements based on a custom functor with the api: </p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> ValueT&amp; a, <span class="keyword">const</span> ValueT&amp; b) </div>
</div><!-- fragment --><p> which returns true if a comes before b. </p>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="afc867e0705ff7ee57a5a4be9bb466aa8" name="afc867e0705ff7ee57a5a4be9bb466aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc867e0705ff7ee57a5a4be9bb466aa8">&#9670;&#160;</a></span>ValueBuffer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, size_t Log2PageSize = 10UL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ValueBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1util.html">util</a></li><li class="navelem"><a href="classopenvdb_1_1v13__0_1_1util_1_1PagedArray.html">PagedArray</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
