<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: openvdb_ax/codegen/FunctionTypes.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('FunctionTypes_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">FunctionTypes.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Contains frameworks for creating custom AX functions which can be registered within the FunctionRegistry and used during code generation. The intended and safest way to build a function is to use the FunctionBuilder struct with its addSignature methods. Note that the derived Function classes provided can also be subclassed for more granular control, however may be subject to more substantial API changes.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="ax_2openvdb__ax_2codegen_2Types_8h_source.html">Types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Value_8h_source.html">Value.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="openvdb__ax_2openvdb__ax_2codegen_2Utils_8h_source.html">Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ConstantFolding_8h_source.html">ConstantFolding.h</a>&quot;</code><br />
<code>#include &lt;openvdb/version.h&gt;</code><br />
<code>#include &lt;<a class="el" href="Assert_8h_source.html">openvdb/util/Assert.h</a>&gt;</code><br />
<code>#include &lt;llvm/ADT/SmallVector.h&gt;</code><br />
<code>#include &lt;llvm/IR/Constants.h&gt;</code><br />
<code>#include &lt;llvm/IR/IRBuilder.h&gt;</code><br />
<code>#include &lt;llvm/IR/Module.h&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;stack&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="FunctionTypes_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:ArgType_3C_20T_2C_20_5FSIZE_20_3E" id="r_ArgType_3C_20T_2C_20_5FSIZE_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType&lt; T, _SIZE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object to array conversion methods to allow functions to return vector types. These containers provided an interface for automatic conversion of C++ objects to LLVM types as array types.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html#details">More...</a><br /></td></tr>
<tr class="memitem:LLVMType_3C_20ArgType_3C_20T_2C_20S_20_3E_20_3E" id="r_LLVMType_3C_20ArgType_3C_20T_2C_20S_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1LLVMType_3_01ArgType_3_01T_00_01S_01_4_01_4.html">LLVMType&lt; ArgType&lt; T, S &gt; &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20T_20_3E" id="r_TypeToSymbol_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol.html">TypeToSymbol&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to symbol conversions - these characters are used to build each functions unique signature. They differ from standard AX or LLVM syntax to be as short as possible i.e. vec4d, [4 x double] = d4.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeToSymbol_3C_20void_20_3E" id="r_TypeToSymbol_3C_20void_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01void_01_4.html">TypeToSymbol&lt; void &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20char_20_3E" id="r_TypeToSymbol_3C_20char_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01char_01_4.html">TypeToSymbol&lt; char &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20uint8_5Ft_20_3E" id="r_TypeToSymbol_3C_20uint8_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01uint8__t_01_4.html">TypeToSymbol&lt; uint8_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20uint16_5Ft_20_3E" id="r_TypeToSymbol_3C_20uint16_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01uint16__t_01_4.html">TypeToSymbol&lt; uint16_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20uint32_5Ft_20_3E" id="r_TypeToSymbol_3C_20uint32_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01uint32__t_01_4.html">TypeToSymbol&lt; uint32_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20uint64_5Ft_20_3E" id="r_TypeToSymbol_3C_20uint64_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01uint64__t_01_4.html">TypeToSymbol&lt; uint64_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20int8_5Ft_20_3E" id="r_TypeToSymbol_3C_20int8_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01int8__t_01_4.html">TypeToSymbol&lt; int8_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20int16_5Ft_20_3E" id="r_TypeToSymbol_3C_20int16_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01int16__t_01_4.html">TypeToSymbol&lt; int16_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20int32_5Ft_20_3E" id="r_TypeToSymbol_3C_20int32_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01int32__t_01_4.html">TypeToSymbol&lt; int32_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20int64_5Ft_20_3E" id="r_TypeToSymbol_3C_20int64_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01int64__t_01_4.html">TypeToSymbol&lt; int64_t &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20float_20_3E" id="r_TypeToSymbol_3C_20float_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01float_01_4.html">TypeToSymbol&lt; float &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20double_20_3E" id="r_TypeToSymbol_3C_20double_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01double_01_4.html">TypeToSymbol&lt; double &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20codegen_3A_3AString_20_3E" id="r_TypeToSymbol_3C_20codegen_3A_3AString_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01codegen_1_1String_01_4.html">TypeToSymbol&lt; codegen::String &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20T_20_2A_20_3E" id="r_TypeToSymbol_3C_20T_20_2A_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01T_01_5_01_4.html">TypeToSymbol&lt; T * &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20T_5BS_5D_3E" id="r_TypeToSymbol_3C_20T_5BS_5D_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01T_0fS_0e_4.html">TypeToSymbol&lt; T[S]&gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20ArgType_3C_20T_2C_20S_20_3E_20_3E" id="r_TypeToSymbol_3C_20ArgType_3C_20T_2C_20S_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01ArgType_3_01T_00_01S_01_4_01_4.html">TypeToSymbol&lt; ArgType&lt; T, S &gt; &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20math_3A_3AVec2_3C_20T_20_3E_20_3E" id="r_TypeToSymbol_3C_20math_3A_3AVec2_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Vec2_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Vec2&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20math_3A_3AVec3_3C_20T_20_3E_20_3E" id="r_TypeToSymbol_3C_20math_3A_3AVec3_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Vec3_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Vec3&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20math_3A_3AVec4_3C_20T_20_3E_20_3E" id="r_TypeToSymbol_3C_20math_3A_3AVec4_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Vec4_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Vec4&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20math_3A_3AMat3_3C_20T_20_3E_20_3E" id="r_TypeToSymbol_3C_20math_3A_3AMat3_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Mat3_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Mat3&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20math_3A_3AMat4_3C_20T_20_3E_20_3E" id="r_TypeToSymbol_3C_20math_3A_3AMat4_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Mat4_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Mat4&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20const_20T_20_3E" id="r_TypeToSymbol_3C_20const_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01const_01T_01_4.html">TypeToSymbol&lt; const T &gt;</a></td></tr>
<tr class="memitem:TypeToSymbol_3C_20const_20T_20_2A_20_3E" id="r_TypeToSymbol_3C_20const_20T_20_2A_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1TypeToSymbol_3_01const_01T_01_5_01_4.html">TypeToSymbol&lt; const T * &gt;</a></td></tr>
<tr class="memitem:ArgumentIterator_3C_20SignatureT_2C_20I_20_3E" id="r_ArgumentIterator_3C_20SignatureT_2C_20I_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgumentIterator.html">ArgumentIterator&lt; SignatureT, I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated argument iterator which implements various small functions per argument type, resolved at compile time.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgumentIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArgumentIterator_3C_20SignatureT_2C_200_20_3E" id="r_ArgumentIterator_3C_20SignatureT_2C_200_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgumentIterator_3_01SignatureT_00_010_01_4.html">ArgumentIterator&lt; SignatureT, 0 &gt;</a></td></tr>
<tr class="memitem:ArgInfo" id="r_ArgInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html">ArgInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classopenvdb_1_1v13__0_1_1Metadata.html" title="Base class for storing metadata information in a grid.">Metadata</a> associated with a function argument or return value.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArgInfoVector" id="r_ArgInfoVector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of ArgInfos. This class makes up part of the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a> API for querying signature information.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html#details">More...</a><br /></td></tr>
<tr class="memitem:NativeArguments" id="r_NativeArguments"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html">NativeArguments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper struct to represent "native" function arguments; that is, the set of <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> type that the AX grammar supports. <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html" title="Wrapper struct to represent &quot;native&quot; function arguments; that is, the set of Value type that the AX g...">NativeArguments</a> have two benefits; they support casting and implicit function matching through FunctionGroups and can be used directly in IR generators (to leverage the AX <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> API). Functions can still be generated and called with "non-native" arguments, but in these cases <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html#a559782c89d155504fd859c39530bfd15" title="Given a set of Arguments, find an EXPLICIT signature match, generate and execute the function body....">FunctionGroup::execute</a> must result in an explicit signature match.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html#details">More...</a><br /></td></tr>
<tr class="memitem:Arguments" id="r_Arguments"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html">Arguments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitrary, potentially "non-native" arguments. This wrapper struct can be used when generating function which cannot be called from AX itself (e.g. VDB accessor functions or Volume/Point kernels etc). They do not support implicit function signature matching or casting.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html#details">More...</a><br /></td></tr>
<tr class="memitem:Function" id="r_Function"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base/abstract representation of an AX function. Derived classes must implement the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aa7be69eba606cab147a0162591c13e6f" title="Populate a vector of ArgInfos which describe this function signature. This method is used by Function...">Function::types</a> call to describe their signature.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#details">More...</a><br /></td></tr>
<tr class="memitem:SRetFunction_3C_20SignatureT_2C_20DerivedFunction_20_3E" id="r_SRetFunction_3C_20SignatureT_2C_20DerivedFunction_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html">SRetFunction&lt; SignatureT, DerivedFunction &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated interface class for SRET functions. This struct provides the interface for functions that wish to return arrays (vectors or matrices) by internally remapping the first argument for the user. As far as LLVM and any bindings are concerned, the function signature remains unchanged - however the first argument becomes "invisible" to the user and is instead allocated by LLVM before the function is executed. Importantly, the argument has no impact on the user facing AX signature and doesn't affect declaration selection.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1SRetFunction.html#details">More...</a><br /></td></tr>
<tr class="memitem:CFunctionBase" id="r_CFunctionBase"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionBase.html">CFunctionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all C bindings.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:CFunction_3C_20SignatureT_20_3E" id="r_CFunction_3C_20SignatureT_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html">CFunction&lt; SignatureT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a concrete C function binding.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunction.html#details">More...</a><br /></td></tr>
<tr class="memitem:IRFunctionBase" id="r_IRFunctionBase"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html">IRFunctionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base/abstract definition for an IR function.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:IRFunction_3C_20SignatureT_20_3E" id="r_IRFunction_3C_20SignatureT_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunction.html">IRFunction&lt; SignatureT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a concrete IR function.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunction.html#details">More...</a><br /></td></tr>
<tr class="memitem:CFunctionSRet_3C_20SignatureT_20_3E" id="r_CFunctionSRet_3C_20SignatureT_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionSRet.html">CFunctionSRet&lt; SignatureT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a concrete C function binding with the first argument as its return type.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1CFunctionSRet.html#details">More...</a><br /></td></tr>
<tr class="memitem:IRFunctionSRet_3C_20SignatureT_20_3E" id="r_IRFunctionSRet_3C_20SignatureT_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionSRet.html">IRFunctionSRet&lt; SignatureT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a concrete IR function with the first argument as its return type.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1IRFunctionSRet.html#details">More...</a><br /></td></tr>
<tr class="memitem:FunctionGroup" id="r_FunctionGroup"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html">FunctionGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A group of functions which all have the same name but different signatures. For example: float abs(float) double abs(double) As well as serving as a way of grouping common functions, this class provides an API for selecting the best possible function signature, should a match exist, against a provided set of argument types.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html#details">More...</a><br /></td></tr>
<tr class="memitem:FunctionBuilder" id="r_FunctionBuilder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionBuilder.html">FunctionBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionBuilder.html" title="The FunctionBuilder class provides a builder pattern framework to allow easy and valid construction o...">FunctionBuilder</a> class provides a builder pattern framework to allow easy and valid construction of AX functions. There are a number of complex tasks which may need to be performed during construction of C or IR function which are delegated to this builder, whilst ensuring that the constructed functions are guaranteed to be valid.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionBuilder.html#details">More...</a><br /></td></tr>
<tr class="memitem:FunctionBuilder_3A_3ASettings" id="r_FunctionBuilder_3A_3ASettings"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionBuilder_1_1Settings.html">FunctionBuilder::Settings</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:openvdb" id="r_openvdb"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb.html">openvdb</a></td></tr>
<tr class="memitem:openvdb_3A_3Av13_5F0" id="r_openvdb_3A_3Av13_5F0"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0.html">openvdb::v13_0</a></td></tr>
<tr class="memitem:openvdb_3A_3Av13_5F0_3A_3Aax" id="r_openvdb_3A_3Av13_5F0_3A_3Aax"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax.html">openvdb::v13_0::ax</a></td></tr>
<tr class="memitem:openvdb_3A_3Av13_5F0_3A_3Aax_3A_3Acodegen" id="r_openvdb_3A_3Av13_5F0_3A_3Aax_3A_3Acodegen"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html">openvdb::v13_0::ax::codegen</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acc2e13670241c2002b01d5c4daeeaa51" id="r_acc2e13670241c2002b01d5c4daeeaa51"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:acc2e13670241c2002b01d5c4daeeaa51 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#acc2e13670241c2002b01d5c4daeeaa51">SmallArgumentVector</a> = llvm::SmallVector&lt;T, 3&gt;</td></tr>
<tr class="memdesc:acc2e13670241c2002b01d5c4daeeaa51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef a stack allocated array with malloc grow support for anything which is relatively small and bases its container size on the number of function arguments.  <br /></td></tr>
<tr class="memitem:a19491c62dae10fc5b97850b29231b0ef" id="r_a19491c62dae10fc5b97850b29231b0ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#a19491c62dae10fc5b97850b29231b0ef">V2D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 2&gt;</td></tr>
<tr class="memitem:adf19fc2ebfc31df1b136083c7051c524" id="r_adf19fc2ebfc31df1b136083c7051c524"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#adf19fc2ebfc31df1b136083c7051c524">V2F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 2&gt;</td></tr>
<tr class="memitem:ac39e79e84de78fa6188c1b812ef7c9c0" id="r_ac39e79e84de78fa6188c1b812ef7c9c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#ac39e79e84de78fa6188c1b812ef7c9c0">V2I</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;int32_t, 2&gt;</td></tr>
<tr class="memitem:afe076b1a292d8635a2e144ecb285be2c" id="r_afe076b1a292d8635a2e144ecb285be2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#afe076b1a292d8635a2e144ecb285be2c">V3D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 3&gt;</td></tr>
<tr class="memitem:a3a93313e37930c7ec565dc4f3eb36fd6" id="r_a3a93313e37930c7ec565dc4f3eb36fd6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#a3a93313e37930c7ec565dc4f3eb36fd6">V3F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 3&gt;</td></tr>
<tr class="memitem:a7b46918e9d7dca7ca333e39d3a80f525" id="r_a7b46918e9d7dca7ca333e39d3a80f525"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#a7b46918e9d7dca7ca333e39d3a80f525">V3I</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;int32_t, 3&gt;</td></tr>
<tr class="memitem:a96a5962a96d7ca3f39ad565d8fffd335" id="r_a96a5962a96d7ca3f39ad565d8fffd335"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#a96a5962a96d7ca3f39ad565d8fffd335">V4D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 4&gt;</td></tr>
<tr class="memitem:a5289743e2fa6d363751795a25ec6dd19" id="r_a5289743e2fa6d363751795a25ec6dd19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#a5289743e2fa6d363751795a25ec6dd19">V4F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 4&gt;</td></tr>
<tr class="memitem:a1da87a694970da5888f4db38a93c2ffb" id="r_a1da87a694970da5888f4db38a93c2ffb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#a1da87a694970da5888f4db38a93c2ffb">V4I</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;int32_t, 4&gt;</td></tr>
<tr class="memitem:a4b2463f1262305b6a40aface8a10d5ff" id="r_a4b2463f1262305b6a40aface8a10d5ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#a4b2463f1262305b6a40aface8a10d5ff">M3D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 9&gt;</td></tr>
<tr class="memitem:aa54db21251983c9e341b3da7635e9766" id="r_aa54db21251983c9e341b3da7635e9766"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#aa54db21251983c9e341b3da7635e9766">M3F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 9&gt;</td></tr>
<tr class="memitem:a50d45a6bbe207f32a91d91d9a3f545bb" id="r_a50d45a6bbe207f32a91d91d9a3f545bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#a50d45a6bbe207f32a91d91d9a3f545bb">M4D</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 16&gt;</td></tr>
<tr class="memitem:a013d7b6412643a11b959eb75b974ef6c" id="r_a013d7b6412643a11b959eb75b974ef6c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#a013d7b6412643a11b959eb75b974ef6c">M4F</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 16&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a105446c95a7ce98ce3f73dfde0206226" id="r_a105446c95a7ce98ce3f73dfde0206226"><td class="memTemplParams" colspan="2">template&lt;typename SignatureT&gt; </td></tr>
<tr class="memitem:a105446c95a7ce98ce3f73dfde0206226 template"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#a105446c95a7ce98ce3f73dfde0206226">llvmTypesFromSignature</a> (llvm::LLVMContext &amp;C, std::vector&lt; llvm::Type * &gt; *types=nullptr)</td></tr>
<tr class="memdesc:a105446c95a7ce98ce3f73dfde0206226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a vector of llvm types from a function signature declaration.  <br /></td></tr>
<tr class="memitem:a1eeceafcca5526a3fae05aa99c8580db" id="r_a1eeceafcca5526a3fae05aa99c8580db"><td class="memTemplParams" colspan="2">template&lt;typename SignatureT&gt; </td></tr>
<tr class="memitem:a1eeceafcca5526a3fae05aa99c8580db template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html">ArgInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#a1eeceafcca5526a3fae05aa99c8580db">llvmArgTypesFromSignature</a> (llvm::LLVMContext &amp;C, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> *types=nullptr)</td></tr>
<tr class="memdesc:a1eeceafcca5526a3fae05aa99c8580db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a vector of ArgInfos from a function signature declaration.  <br /></td></tr>
<tr class="memitem:a9542678f89fe09c6cc12b93d2ed61208" id="r_a9542678f89fe09c6cc12b93d2ed61208"><td class="memTemplParams" colspan="2">template&lt;typename SignatureT&gt; </td></tr>
<tr class="memitem:a9542678f89fe09c6cc12b93d2ed61208 template"><td class="memItemLeft" align="right" valign="top">llvm::FunctionType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#a9542678f89fe09c6cc12b93d2ed61208">llvmFunctionTypeFromSignature</a> (llvm::LLVMContext &amp;C)</td></tr>
<tr class="memdesc:a9542678f89fe09c6cc12b93d2ed61208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an LLVM FunctionType from a function signature.  <br /></td></tr>
<tr class="memitem:aa1fdf8da42ec61c8bae2a73419879629" id="r_aa1fdf8da42ec61c8bae2a73419879629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#aa1fdf8da42ec61c8bae2a73419879629">printSignature</a> (std::ostream &amp;os, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;types, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfo.html">ArgInfo</a> &amp;returnType, const char *name=nullptr, const llvm::ArrayRef&lt; const char * &gt; &amp;names={}, const bool axTypes=false)</td></tr>
<tr class="memdesc:aa1fdf8da42ec61c8bae2a73419879629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a function signature to the provided ostream.  <br /></td></tr>
<tr class="memitem:a4ddb10635251f8f3b8988a1d9f9886bd" id="r_a4ddb10635251f8f3b8988a1d9f9886bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a4054a06b412a2c4f17ad97328fccd2cd">OPENVDB_AX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html#a4ddb10635251f8f3b8988a1d9f9886bd">printSignature</a> (std::ostream &amp;os, const std::vector&lt; llvm::Type * &gt; &amp;types, const llvm::Type *returnType, const char *name=nullptr, const std::vector&lt; const char * &gt; &amp;names={}, const bool axTypes=false)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains frameworks for creating custom AX functions which can be registered within the FunctionRegistry and used during code generation. The intended and safest way to build a function is to use the FunctionBuilder struct with its addSignature methods. Note that the derived Function classes provided can also be subclassed for more granular control, however may be subject to more substantial API changes. </p>
<dl class="section author"><dt>Authors</dt><dd>Nick Avramoussis</dd></dl>
<p>There are a variety of different ways to build a function which are tailored towards different function types. The two currently supported function implementations are C Bindings and IR generation. Additionally, depending on the return type of the function, you may need to declare your function an SRET (structural return) function.</p>
<p>C Bindings: As the name suggests, the CFunction class infrastructure provides the quickest and easiest way to bind to methods in your host application. The most important thing to consider when choosing this approach is performance. LLVM will have no knowledge of the function body during optimization passes. Depending on the implementation of your method and the user's usage from AX, C bindings may be subject to limited optimizations in comparison to IR functions. For example, a static function which is called from within a loop cannot be unrolled. See the CFunction templated class.</p>
<p>IR Functions: IR Functions expect implementations to generate the body of the function directly into IR during code generation. This ensures optimal performance during optimization passes however can be trickier to design. Note that, in the future, AX functions will be internally supported to provide a better solution for IR generated functions. See the IRFunction templated class.</p>
<p>SRET Functions: Both C Bindings and IR Functions can be marked as SRET methods. SRET methods, in AX, are any function which returns a value which is not a scalar (e.g. vectors, matrices). This follows the same optimization logic as clang which will rebuild function signatures with their return type as the first argument if the return type is greater than a given size. You should never attempt to return alloca's directly from functions (unless malloced).</p>
<p>Some other things to consider:</p><ul>
<li>Ensure C Binding dependencies have been correctly mapped.</li>
<li>Avoid calling B.CreateAlloca inside of IR functions - instead rely on the utility method insertStaticAlloca() where possible.</li>
<li>Ensure both floating point and integer argument signatures are provided if you wish to avoid floats truncating.</li>
<li>Array arguments (vectors/matrices) are always passed by pointer. Scalar arguments are always passed by copy.</li>
<li>Ensure array arguments which will not be modified are marked as readonly. Currently, only array arguments can be passed by "reference".</li>
<li>Ensure function bodies, return types and parameters and marked with desirable llvm attributes. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_cae5b229f742550e00edd472eaaf99f1.html">openvdb_ax</a></li><li class="navelem"><a href="dir_de747e3eb4c4c2c23b38546883fd0233.html">codegen</a></li><li class="navelem"><a href="FunctionTypes_8h.html">FunctionTypes.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
