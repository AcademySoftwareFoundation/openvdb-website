<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: LeafManager&lt; TreeT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classopenvdb_1_1v13__0_1_1tree_1_1LeafManager.html','','classopenvdb_1_1v13__0_1_1tree_1_1LeafManager-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">LeafManager&lt; TreeT &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class manages a linear array of pointers to a given tree's leaf nodes, as well as optional auxiliary buffers (one or more per leaf) that can be swapped with the leaf nodes' voxel data buffers.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LeafManager_8h_source.html">openvdb/tree/LeafManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:LeafRange" id="r_LeafRange"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager_1_1LeafRange.html">LeafRange</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af07a8c75c48174ee79d06fbfe43dd821" id="r_af07a8c75c48174ee79d06fbfe43dd821"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> = TreeT</td></tr>
<tr class="memitem:a19fb67be7bc6aa858ee34277782a2209" id="r_a19fb67be7bc6aa858ee34277782a2209"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19fb67be7bc6aa858ee34277782a2209">ValueType</a> = typename TreeT::ValueType</td></tr>
<tr class="memitem:a63b17471dabe2990c3ad67e10d7f1973" id="r_a63b17471dabe2990c3ad67e10d7f1973"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63b17471dabe2990c3ad67e10d7f1973">RootNodeType</a> = typename TreeT::RootNodeType</td></tr>
<tr class="memitem:a7947e6bf0b6e87b54dcce9c9f0ca68df" id="r_a7947e6bf0b6e87b54dcce9c9f0ca68df"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7947e6bf0b6e87b54dcce9c9f0ca68df">NonConstLeafType</a> = typename TreeType::LeafNodeType</td></tr>
<tr class="memitem:af311c60c070ae3bf132cc752e08d424a" id="r_af311c60c070ae3bf132cc752e08d424a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af311c60c070ae3bf132cc752e08d424a">LeafType</a> = typename <a class="el" href="structopenvdb_1_1v13__0_1_1CopyConstness.html">CopyConstness</a>&lt;<a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a>, <a class="el" href="#a7947e6bf0b6e87b54dcce9c9f0ca68df">NonConstLeafType</a>&gt;::Type</td></tr>
<tr class="memitem:aff34a091cd54db8860dbea7885fe7888" id="r_aff34a091cd54db8860dbea7885fe7888"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff34a091cd54db8860dbea7885fe7888">LeafNodeType</a> = <a class="el" href="#af311c60c070ae3bf132cc752e08d424a">LeafType</a></td></tr>
<tr class="memitem:a1f4485ee3a5799073a49bd3cb4c374a8" id="r_a1f4485ee3a5799073a49bd3cb4c374a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f4485ee3a5799073a49bd3cb4c374a8">LeafIterType</a> = typename <a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1leafmgr_1_1TreeTraits.html">leafmgr::TreeTraits</a>&lt;TreeT&gt;::LeafIterType</td></tr>
<tr class="memitem:ad8f9836a2f27a60d6b6a3e3801c11f47" id="r_ad8f9836a2f27a60d6b6a3e3801c11f47"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8f9836a2f27a60d6b6a3e3801c11f47">NonConstBufferType</a> = typename LeafType::Buffer</td></tr>
<tr class="memitem:a15837204fc4fd8dc657b1de732ed5fa2" id="r_a15837204fc4fd8dc657b1de732ed5fa2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15837204fc4fd8dc657b1de732ed5fa2">BufferType</a> = typename <a class="el" href="structopenvdb_1_1v13__0_1_1CopyConstness.html">CopyConstness</a>&lt;<a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a>, <a class="el" href="#ad8f9836a2f27a60d6b6a3e3801c11f47">NonConstBufferType</a>&gt;::Type</td></tr>
<tr class="memitem:aa108a6bf58f9df0ca024104843d33d75" id="r_aa108a6bf58f9df0ca024104843d33d75"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa108a6bf58f9df0ca024104843d33d75">RangeType</a> = tbb::blocked_range&lt;size_t&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6bad6c4b86a2ec52ce35cbd5519cfa45" id="r_a6bad6c4b86a2ec52ce35cbd5519cfa45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bad6c4b86a2ec52ce35cbd5519cfa45">LeafManager</a> (<a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;<a class="el" href="#a00f0f1bad5545bbba684da07dba34eb5">tree</a>, size_t <a class="el" href="#a769d75fadd0b2282892a0b7a69fa2576">auxBuffersPerLeaf</a>=0, bool serial=false)</td></tr>
<tr class="memdesc:a6bad6c4b86a2ec52ce35cbd5519cfa45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a tree reference and an auxiliary buffer count.  <br /></td></tr>
<tr class="memitem:a80195dcd80d3614f522176fb87464046" id="r_a80195dcd80d3614f522176fb87464046"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80195dcd80d3614f522176fb87464046">LeafManager</a> (<a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;<a class="el" href="#a00f0f1bad5545bbba684da07dba34eb5">tree</a>, <a class="el" href="#af311c60c070ae3bf132cc752e08d424a">LeafType</a> **begin, <a class="el" href="#af311c60c070ae3bf132cc752e08d424a">LeafType</a> **end, size_t <a class="el" href="#a769d75fadd0b2282892a0b7a69fa2576">auxBuffersPerLeaf</a>=0, bool serial=false)</td></tr>
<tr class="memdesc:a80195dcd80d3614f522176fb87464046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct directly from an existing array of leafnodes.  <br /></td></tr>
<tr class="memitem:a4564928988bed112c6e4a9db516ef2dd" id="r_a4564928988bed112c6e4a9db516ef2dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4564928988bed112c6e4a9db516ef2dd">LeafManager</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager.html">LeafManager</a> &amp;other)</td></tr>
<tr class="memitem:a27df2921c5308dcf3b8814d90d9ab5e1" id="r_a27df2921c5308dcf3b8814d90d9ab5e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27df2921c5308dcf3b8814d90d9ab5e1">rebuild</a> (bool serial=false)</td></tr>
<tr class="memdesc:a27df2921c5308dcf3b8814d90d9ab5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Re)initialize by resizing (if necessary) and repopulating the leaf array and by deleting existing auxiliary buffers and allocating new ones.  <br /></td></tr>
<tr class="memitem:abc9678b87fd0a3c643c20b733989bfa7" id="r_abc9678b87fd0a3c643c20b733989bfa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc9678b87fd0a3c643c20b733989bfa7">rebuild</a> (size_t <a class="el" href="#a769d75fadd0b2282892a0b7a69fa2576">auxBuffersPerLeaf</a>, bool serial=false)</td></tr>
<tr class="memdesc:abc9678b87fd0a3c643c20b733989bfa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repopulate the leaf array and delete and reallocate auxiliary buffers.  <br /></td></tr>
<tr class="memitem:a2512a475143e9bf424983e31b14b6d90" id="r_a2512a475143e9bf424983e31b14b6d90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2512a475143e9bf424983e31b14b6d90">rebuild</a> (<a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;<a class="el" href="#a00f0f1bad5545bbba684da07dba34eb5">tree</a>, bool serial=false)</td></tr>
<tr class="memitem:a96b9faebed83c665e89d7dcd1ea73c5c" id="r_a96b9faebed83c665e89d7dcd1ea73c5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96b9faebed83c665e89d7dcd1ea73c5c">rebuild</a> (<a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;<a class="el" href="#a00f0f1bad5545bbba684da07dba34eb5">tree</a>, size_t <a class="el" href="#a769d75fadd0b2282892a0b7a69fa2576">auxBuffersPerLeaf</a>, bool serial=false)</td></tr>
<tr class="memitem:aa8b77a7173180a24da3a10a28c0fe987" id="r_aa8b77a7173180a24da3a10a28c0fe987"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8b77a7173180a24da3a10a28c0fe987">rebuildAuxBuffers</a> (size_t <a class="el" href="#a769d75fadd0b2282892a0b7a69fa2576">auxBuffersPerLeaf</a>, bool serial=false)</td></tr>
<tr class="memdesc:aa8b77a7173180a24da3a10a28c0fe987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the number of auxiliary buffers.  <br /></td></tr>
<tr class="memitem:affa2e44cef7e0e027e7fcc5a404ad58a" id="r_affa2e44cef7e0e027e7fcc5a404ad58a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affa2e44cef7e0e027e7fcc5a404ad58a">removeAuxBuffers</a> ()</td></tr>
<tr class="memdesc:affa2e44cef7e0e027e7fcc5a404ad58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the auxiliary buffers, but don't rebuild the leaf array.  <br /></td></tr>
<tr class="memitem:a8b7eb7df4fd22eed01ec5883a2c6a829" id="r_a8b7eb7df4fd22eed01ec5883a2c6a829"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b7eb7df4fd22eed01ec5883a2c6a829">rebuildLeafArray</a> (bool serial=false)</td></tr>
<tr class="memdesc:a8b7eb7df4fd22eed01ec5883a2c6a829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the auxiliary buffers and rebuild the leaf array.  <br /></td></tr>
<tr class="memitem:a12abb1622ff22f38860f844b987d5ef7" id="r_a12abb1622ff22f38860f844b987d5ef7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12abb1622ff22f38860f844b987d5ef7">auxBufferCount</a> () const</td></tr>
<tr class="memdesc:a12abb1622ff22f38860f844b987d5ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of allocated auxiliary buffers.  <br /></td></tr>
<tr class="memitem:a769d75fadd0b2282892a0b7a69fa2576" id="r_a769d75fadd0b2282892a0b7a69fa2576"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a769d75fadd0b2282892a0b7a69fa2576">auxBuffersPerLeaf</a> () const</td></tr>
<tr class="memdesc:a769d75fadd0b2282892a0b7a69fa2576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of auxiliary buffers per leaf node.  <br /></td></tr>
<tr class="memitem:a90c12d687db3681030ad5774215542ba" id="r_a90c12d687db3681030ad5774215542ba"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90c12d687db3681030ad5774215542ba">leafCount</a> () const</td></tr>
<tr class="memdesc:a90c12d687db3681030ad5774215542ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of leaf nodes.  <br /></td></tr>
<tr class="memitem:afef1d5fc6dc50276e8cdf5ff75faeb97" id="r_afef1d5fc6dc50276e8cdf5ff75faeb97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afef1d5fc6dc50276e8cdf5ff75faeb97">activeLeafVoxelCount</a> () const</td></tr>
<tr class="memdesc:afef1d5fc6dc50276e8cdf5ff75faeb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of active voxels in the leaf nodes.  <br /></td></tr>
<tr class="memitem:a00f0f1bad5545bbba684da07dba34eb5" id="r_a00f0f1bad5545bbba684da07dba34eb5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00f0f1bad5545bbba684da07dba34eb5">tree</a> () const</td></tr>
<tr class="memdesc:a00f0f1bad5545bbba684da07dba34eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to tree associated with this manager.  <br /></td></tr>
<tr class="memitem:a17b80f47bec1787373e4a546909379a3" id="r_a17b80f47bec1787373e4a546909379a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17b80f47bec1787373e4a546909379a3">tree</a> ()</td></tr>
<tr class="memdesc:a17b80f47bec1787373e4a546909379a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the tree associated with this manager.  <br /></td></tr>
<tr class="memitem:af2f19b30b303f9bcbd46b125e34173ac" id="r_af2f19b30b303f9bcbd46b125e34173ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a63b17471dabe2990c3ad67e10d7f1973">RootNodeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2f19b30b303f9bcbd46b125e34173ac">root</a> () const</td></tr>
<tr class="memdesc:af2f19b30b303f9bcbd46b125e34173ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to root node associated with this manager.  <br /></td></tr>
<tr class="memitem:a1597a4ee7b0ac005eeafb868ab3c97c7" id="r_a1597a4ee7b0ac005eeafb868ab3c97c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a63b17471dabe2990c3ad67e10d7f1973">RootNodeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1597a4ee7b0ac005eeafb868ab3c97c7">root</a> ()</td></tr>
<tr class="memdesc:a1597a4ee7b0ac005eeafb868ab3c97c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the root node associated with this manager.  <br /></td></tr>
<tr class="memitem:a5b29b5b9a617df3ecddeca09b1fea0c3" id="r_a5b29b5b9a617df3ecddeca09b1fea0c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b29b5b9a617df3ecddeca09b1fea0c3">isConstTree</a> () const</td></tr>
<tr class="memdesc:a5b29b5b9a617df3ecddeca09b1fea0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the tree associated with this manager is immutable.  <br /></td></tr>
<tr class="memitem:a07511f0828438a050edd0ad48d2c63a5" id="r_a07511f0828438a050edd0ad48d2c63a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af311c60c070ae3bf132cc752e08d424a">LeafType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07511f0828438a050edd0ad48d2c63a5">leaf</a> (size_t leafIdx) const</td></tr>
<tr class="memdesc:a07511f0828438a050edd0ad48d2c63a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node at index <em class="arg">leafIdx</em> in the array.  <br /></td></tr>
<tr class="memitem:a05c0ff55f5a1cef204664076e9e51142" id="r_a05c0ff55f5a1cef204664076e9e51142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a15837204fc4fd8dc657b1de732ed5fa2">BufferType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05c0ff55f5a1cef204664076e9e51142">getBuffer</a> (size_t leafIdx, size_t bufferIdx) const</td></tr>
<tr class="memdesc:a05c0ff55f5a1cef204664076e9e51142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the leaf or auxiliary buffer for the leaf node at index <em class="arg">leafIdx</em>. If <em class="arg">bufferIdx</em> is zero, return the leaf buffer, otherwise return the nth auxiliary buffer, where n = <em class="arg">bufferIdx</em> - 1.  <br /></td></tr>
<tr class="memitem:a2cd830d0f29e22833420b0c6e95f2b05" id="r_a2cd830d0f29e22833420b0c6e95f2b05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aa108a6bf58f9df0ca024104843d33d75">RangeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cd830d0f29e22833420b0c6e95f2b05">getRange</a> (size_t grainsize=1) const</td></tr>
<tr class="memdesc:a2cd830d0f29e22833420b0c6e95f2b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>tbb::blocked_range</code> of leaf array indices.  <br /></td></tr>
<tr class="memitem:ae69049a01bb981da50f7e3c43da64892" id="r_ae69049a01bb981da50f7e3c43da64892"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager_1_1LeafRange.html">LeafRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae69049a01bb981da50f7e3c43da64892">leafRange</a> (size_t grainsize=1) const</td></tr>
<tr class="memdesc:ae69049a01bb981da50f7e3c43da64892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a TBB-compatible <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager_1_1LeafRange.html">LeafRange</a>.  <br /></td></tr>
<tr class="memitem:a22ac33d0549b786059b9c691f0a534f7" id="r_a22ac33d0549b786059b9c691f0a534f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22ac33d0549b786059b9c691f0a534f7">swapLeafBuffer</a> (size_t bufferIdx, bool serial=false)</td></tr>
<tr class="memdesc:a22ac33d0549b786059b9c691f0a534f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap each leaf node's buffer with the nth corresponding auxiliary buffer, where n = <em class="arg">bufferIdx</em>.  <br /></td></tr>
<tr class="memitem:a288a8c0c3e8c6132e6284ab66cc591cd" id="r_a288a8c0c3e8c6132e6284ab66cc591cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a288a8c0c3e8c6132e6284ab66cc591cd">swapBuffer</a> (size_t bufferIdx1, size_t bufferIdx2, bool serial=false)</td></tr>
<tr class="memdesc:a288a8c0c3e8c6132e6284ab66cc591cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap any two buffers for each leaf node.  <br /></td></tr>
<tr class="memitem:a2f5bb8c75cfd73036df566fba4dd693e" id="r_a2f5bb8c75cfd73036df566fba4dd693e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f5bb8c75cfd73036df566fba4dd693e">syncAuxBuffer</a> (size_t bufferIdx, bool serial=false)</td></tr>
<tr class="memdesc:a2f5bb8c75cfd73036df566fba4dd693e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync up the specified auxiliary buffer with the corresponding leaf node buffer.  <br /></td></tr>
<tr class="memitem:a3bad152cbc97be4c39b46f852cf523b4" id="r_a3bad152cbc97be4c39b46f852cf523b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bad152cbc97be4c39b46f852cf523b4">syncAllBuffers</a> (bool serial=false)</td></tr>
<tr class="memdesc:a3bad152cbc97be4c39b46f852cf523b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync up all auxiliary buffers with their corresponding leaf node buffers.  <br /></td></tr>
<tr class="memitem:a449355fc31ee41387283def6d663f807" id="r_a449355fc31ee41387283def6d663f807"><td class="memTemplParams" colspan="2">template&lt;typename LeafOp&gt; </td></tr>
<tr class="memitem:a449355fc31ee41387283def6d663f807 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a449355fc31ee41387283def6d663f807">foreach</a> (const LeafOp &amp;op, bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:a449355fc31ee41387283def6d663f807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded method that applies a user-supplied functor to each leaf node in the <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager.html" title="This class manages a linear array of pointers to a given tree&#39;s leaf nodes, as well as optional auxil...">LeafManager</a>.  <br /></td></tr>
<tr class="memitem:a564f198735d281f486addac56f65751d" id="r_a564f198735d281f486addac56f65751d"><td class="memTemplParams" colspan="2">template&lt;typename LeafOp&gt; </td></tr>
<tr class="memitem:a564f198735d281f486addac56f65751d template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a564f198735d281f486addac56f65751d">reduce</a> (LeafOp &amp;op, bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:a564f198735d281f486addac56f65751d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded method that applies a user-supplied functor to each leaf node in the <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager.html" title="This class manages a linear array of pointers to a given tree&#39;s leaf nodes, as well as optional auxil...">LeafManager</a>. Unlike foreach (defined above) this method performs a reduction on all the leaf nodes.  <br /></td></tr>
<tr class="memitem:a06f465dfbb611dea7957ab44e2ce903f" id="r_a06f465dfbb611dea7957ab44e2ce903f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06f465dfbb611dea7957ab44e2ce903f">getPrefixSum</a> (size_t *&amp;offsets, size_t &amp;size, size_t grainSize=1) const</td></tr>
<tr class="memdesc:a06f465dfbb611dea7957ab44e2ce903f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a linear array of prefix sums of offsets into the active voxels in the leafs. So <em class="arg">offsets</em>[n]+m is the offset to the mth active voxel in the nth leaf node (useful for user-managed value buffers, e.g. in <a class="el" href="LevelSetAdvect_8h.html" title="Hyperbolic advection of narrow-band level sets.">tools/LevelSetAdvect.h</a>).  <br /></td></tr>
<tr class="memitem:a27688381045d0db7c8f9499b4562f777" id="r_a27688381045d0db7c8f9499b4562f777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27688381045d0db7c8f9499b4562f777">operator()</a> (const <a class="el" href="#aa108a6bf58f9df0ca024104843d33d75">RangeType</a> &amp;r) const</td></tr>
<tr class="memdesc:a27688381045d0db7c8f9499b4562f777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally by tbb::parallel_for() - never call it directly!  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a33812eef2746f526e18a7d13ad9d0eb3" id="r_a33812eef2746f526e18a7d13ad9d0eb3"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33812eef2746f526e18a7d13ad9d0eb3">DEPTH</a> = 2</td></tr>
<tr class="memitem:aed029134efd058169d0a0d3cae1c6f32" id="r_aed029134efd058169d0a0d3cae1c6f32"><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed029134efd058169d0a0d3cae1c6f32">IsConstTree</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1leafmgr_1_1TreeTraits.html">leafmgr::TreeTraits</a>&lt;TreeT&gt;::IsConstTree</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename TreeT&gt;<br />
class openvdb::v13_0::tree::LeafManager&lt; TreeT &gt;</div><p>This class manages a linear array of pointers to a given tree's leaf nodes, as well as optional auxiliary buffers (one or more per leaf) that can be swapped with the leaf nodes' voxel data buffers. </p>
<p>The leaf array is useful for multithreaded computations over leaf voxels in a tree with static topology but varying voxel values. The auxiliary buffers are convenient for temporal integration. Efficient methods are provided for multithreaded swapping and sync'ing (i.e., copying the contents) of these buffers.</p>
<dl class="section note"><dt>Note</dt><dd>Buffer index 0 denotes a leaf node's internal voxel data buffer. Any auxiliary buffers are indexed starting from one. </dd></dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a15837204fc4fd8dc657b1de732ed5fa2" name="a15837204fc4fd8dc657b1de732ed5fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15837204fc4fd8dc657b1de732ed5fa2">&#9670;&#160;</a></span>BufferType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a15837204fc4fd8dc657b1de732ed5fa2">BufferType</a> = typename <a class="el" href="structopenvdb_1_1v13__0_1_1CopyConstness.html">CopyConstness</a>&lt;<a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a>, <a class="el" href="#ad8f9836a2f27a60d6b6a3e3801c11f47">NonConstBufferType</a>&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f4485ee3a5799073a49bd3cb4c374a8" name="a1f4485ee3a5799073a49bd3cb4c374a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4485ee3a5799073a49bd3cb4c374a8">&#9670;&#160;</a></span>LeafIterType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1f4485ee3a5799073a49bd3cb4c374a8">LeafIterType</a> = typename <a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1leafmgr_1_1TreeTraits.html">leafmgr::TreeTraits</a>&lt;TreeT&gt;::LeafIterType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff34a091cd54db8860dbea7885fe7888" name="aff34a091cd54db8860dbea7885fe7888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff34a091cd54db8860dbea7885fe7888">&#9670;&#160;</a></span>LeafNodeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aff34a091cd54db8860dbea7885fe7888">LeafNodeType</a> = <a class="el" href="#af311c60c070ae3bf132cc752e08d424a">LeafType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af311c60c070ae3bf132cc752e08d424a" name="af311c60c070ae3bf132cc752e08d424a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af311c60c070ae3bf132cc752e08d424a">&#9670;&#160;</a></span>LeafType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af311c60c070ae3bf132cc752e08d424a">LeafType</a> = typename <a class="el" href="structopenvdb_1_1v13__0_1_1CopyConstness.html">CopyConstness</a>&lt;<a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a>, <a class="el" href="#a7947e6bf0b6e87b54dcce9c9f0ca68df">NonConstLeafType</a>&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8f9836a2f27a60d6b6a3e3801c11f47" name="ad8f9836a2f27a60d6b6a3e3801c11f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f9836a2f27a60d6b6a3e3801c11f47">&#9670;&#160;</a></span>NonConstBufferType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad8f9836a2f27a60d6b6a3e3801c11f47">NonConstBufferType</a> = typename LeafType::Buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7947e6bf0b6e87b54dcce9c9f0ca68df" name="a7947e6bf0b6e87b54dcce9c9f0ca68df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7947e6bf0b6e87b54dcce9c9f0ca68df">&#9670;&#160;</a></span>NonConstLeafType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7947e6bf0b6e87b54dcce9c9f0ca68df">NonConstLeafType</a> = typename TreeType::LeafNodeType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa108a6bf58f9df0ca024104843d33d75" name="aa108a6bf58f9df0ca024104843d33d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa108a6bf58f9df0ca024104843d33d75">&#9670;&#160;</a></span>RangeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa108a6bf58f9df0ca024104843d33d75">RangeType</a> = tbb::blocked_range&lt;size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63b17471dabe2990c3ad67e10d7f1973" name="a63b17471dabe2990c3ad67e10d7f1973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b17471dabe2990c3ad67e10d7f1973">&#9670;&#160;</a></span>RootNodeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a63b17471dabe2990c3ad67e10d7f1973">RootNodeType</a> = typename TreeT::RootNodeType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af07a8c75c48174ee79d06fbfe43dd821" name="af07a8c75c48174ee79d06fbfe43dd821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07a8c75c48174ee79d06fbfe43dd821">&#9670;&#160;</a></span>TreeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> = TreeT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19fb67be7bc6aa858ee34277782a2209" name="a19fb67be7bc6aa858ee34277782a2209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fb67be7bc6aa858ee34277782a2209">&#9670;&#160;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a19fb67be7bc6aa858ee34277782a2209">ValueType</a> = typename TreeT::ValueType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6bad6c4b86a2ec52ce35cbd5519cfa45" name="a6bad6c4b86a2ec52ce35cbd5519cfa45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bad6c4b86a2ec52ce35cbd5519cfa45">&#9670;&#160;</a></span>LeafManager() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager.html">LeafManager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>auxBuffersPerLeaf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>serial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a tree reference and an auxiliary buffer count. </p>
<dl class="section note"><dt>Note</dt><dd>The default is no auxiliary buffers </dd></dl>

</div>
</div>
<a id="a80195dcd80d3614f522176fb87464046" name="a80195dcd80d3614f522176fb87464046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80195dcd80d3614f522176fb87464046">&#9670;&#160;</a></span>LeafManager() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager.html">LeafManager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af311c60c070ae3bf132cc752e08d424a">LeafType</a> **</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af311c60c070ae3bf132cc752e08d424a">LeafType</a> **</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>auxBuffersPerLeaf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>serial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct directly from an existing array of leafnodes. </p>
<dl class="section warning"><dt>Warning</dt><dd>The leafnodes are implicitly assumed to exist in the input <em class="arg">tree</em>. </dd></dl>

</div>
</div>
<a id="a4564928988bed112c6e4a9db516ef2dd" name="a4564928988bed112c6e4a9db516ef2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4564928988bed112c6e4a9db516ef2dd">&#9670;&#160;</a></span>LeafManager() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager.html">LeafManager</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager.html">LeafManager</a>&lt; TreeT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shallow copy constructor called by tbb::parallel_for() threads</p>
<dl class="section note"><dt>Note</dt><dd>This should never get called directly </dd></dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="afef1d5fc6dc50276e8cdf5ff75faeb97" name="afef1d5fc6dc50276e8cdf5ff75faeb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef1d5fc6dc50276e8cdf5ff75faeb97">&#9670;&#160;</a></span>activeLeafVoxelCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> activeLeafVoxelCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of active voxels in the leaf nodes. </p>
<dl class="section note"><dt>Note</dt><dd>Multi-threaded for better performance than <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1Tree.html#a59650f93e1ae386d3e4d51c3ee11c447" title="Return the number of active voxels stored in leaf nodes.">Tree::activeLeafVoxelCount</a> </dd></dl>

</div>
</div>
<a id="a12abb1622ff22f38860f844b987d5ef7" name="a12abb1622ff22f38860f844b987d5ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12abb1622ff22f38860f844b987d5ef7">&#9670;&#160;</a></span>auxBufferCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t auxBufferCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number of allocated auxiliary buffers. </p>

</div>
</div>
<a id="a769d75fadd0b2282892a0b7a69fa2576" name="a769d75fadd0b2282892a0b7a69fa2576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769d75fadd0b2282892a0b7a69fa2576">&#9670;&#160;</a></span>auxBuffersPerLeaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t auxBuffersPerLeaf </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of auxiliary buffers per leaf node. </p>

</div>
</div>
<a id="a449355fc31ee41387283def6d663f807" name="a449355fc31ee41387283def6d663f807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449355fc31ee41387283def6d663f807">&#9670;&#160;</a></span>foreach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<div class="memtemplate">
template&lt;typename LeafOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void foreach </td>
          <td>(</td>
          <td class="paramtype">const LeafOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threaded method that applies a user-supplied functor to each leaf node in the <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager.html" title="This class manages a linear array of pointers to a given tree&#39;s leaf nodes, as well as optional auxil...">LeafManager</a>. </p>
<p>The user-supplied functor needs to define the methods required for tbb::parallel_for.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>user-supplied functor, see examples for interface details. </td></tr>
    <tr><td class="paramname">threaded</td><td>optional toggle to disable threading, on by default. </td></tr>
    <tr><td class="paramname">grainSize</td><td>optional parameter to specify the grainsize for threading, one by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The functor object is deep-copied to create TBB tasks. This allows the function to use non-thread-safe members like a <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="comment">// Functor to offset a tree&#39;s voxel values with values from another tree.</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TreeType&gt;</div>
<div class="line"><span class="keyword">struct </span>OffsetOp</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>Accessor = <a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488">tree::ValueAccessor&lt;const TreeType&gt;</a>;</div>
<div class="line"> </div>
<div class="line">    OffsetOp(<span class="keyword">const</span> <a class="code hl_typedef" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a>&amp; <a class="code hl_function" href="#a00f0f1bad5545bbba684da07dba34eb5">tree</a>): mRhsTreeAcc(<a class="code hl_function" href="#a00f0f1bad5545bbba684da07dba34eb5">tree</a>) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LeafNodeType&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(LeafNodeType &amp;lhsLeaf, <span class="keywordtype">size_t</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keyword">const</span> LeafNodeType *rhsLeaf = mRhsTreeAcc.probeConstLeaf(lhsLeaf.origin());</div>
<div class="line">        <span class="keywordflow">if</span> (rhsLeaf) {</div>
<div class="line">            <span class="keyword">typename</span> LeafNodeType::ValueOnIter <a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1tree_1_1iter.html">iter</a> = lhsLeaf.beginValueOn();</div>
<div class="line">            <span class="keywordflow">for</span> (; <a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1tree_1_1iter.html">iter</a>; ++<a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1tree_1_1iter.html">iter</a>) {</div>
<div class="line">                <a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1tree_1_1iter.html">iter</a>.setValue(<a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1tree_1_1iter.html">iter</a>.getValue() + rhsLeaf-&gt;getValue(<a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1tree_1_1iter.html">iter</a>.pos()));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    Accessor mRhsTreeAcc;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// usage:</span></div>
<div class="line">tree::LeafManager&lt;FloatTree&gt; leafNodes(lhsTree);</div>
<div class="line">leafNodes.foreach(OffsetOp&lt;FloatTree&gt;(rhsTree));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A functor that performs a min operation between different auxiliary buffers.</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LeafManagerType&gt;</div>
<div class="line"><span class="keyword">struct </span>MinOp</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>BufferType = <span class="keyword">typename</span> LeafManagerType::BufferType;</div>
<div class="line"> </div>
<div class="line">    MinOp(LeafManagerType&amp; leafNodes): mLeafs(leafNodes) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LeafNodeType&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(LeafNodeType &amp;leaf, <span class="keywordtype">size_t</span> leafIndex)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// get the first buffer</span></div>
<div class="line">        BufferType&amp; buffer = mLeafs.getBuffer(leafIndex, 1);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// min ...</span></div>
<div class="line">    }</div>
<div class="line">    LeafManagerType&amp; mLeafs;</div>
<div class="line">};</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1tree_1_1LeafManager_html_a00f0f1bad5545bbba684da07dba34eb5"><div class="ttname"><a href="#a00f0f1bad5545bbba684da07dba34eb5">openvdb::v13_0::tree::LeafManager::tree</a></div><div class="ttdeci">const TreeType &amp; tree() const</div><div class="ttdoc">Return a const reference to tree associated with this manager.</div><div class="ttdef"><b>Definition</b> LeafManager.h:303</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1tree_1_1LeafManager_html_af07a8c75c48174ee79d06fbfe43dd821"><div class="ttname"><a href="#af07a8c75c48174ee79d06fbfe43dd821">openvdb::v13_0::tree::LeafManager::TreeType</a></div><div class="ttdeci">TreeT TreeType</div><div class="ttdef"><b>Definition</b> LeafManager.h:88</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tree_1_1iter_html"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0_1_1tree_1_1iter.html">openvdb::v13_0::tree::iter</a></div><div class="ttdef"><b>Definition</b> TreeIterator.h:30</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tree_html_a09d15a8ce9e84448003ae4bb40326488"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488">openvdb::v13_0::tree::ValueAccessor</a></div><div class="ttdeci">ValueAccessorImpl&lt; TreeType, IsSafe, MutexType, openvdb::make_index_sequence&lt; CacheLevels &gt; &gt; ValueAccessor</div><div class="ttdoc">Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...</div><div class="ttdef"><b>Definition</b> ValueAccessor.h:86</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a05c0ff55f5a1cef204664076e9e51142" name="a05c0ff55f5a1cef204664076e9e51142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c0ff55f5a1cef204664076e9e51142">&#9670;&#160;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a15837204fc4fd8dc657b1de732ed5fa2">BufferType</a> &amp; getBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>leafIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufferIdx</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the leaf or auxiliary buffer for the leaf node at index <em class="arg">leafIdx</em>. If <em class="arg">bufferIdx</em> is zero, return the leaf buffer, otherwise return the nth auxiliary buffer, where n = <em class="arg">bufferIdx</em> - 1. </p>
<dl class="section note"><dt>Note</dt><dd>For performance reasons no range checks are performed on the inputs (other than assertions)! Since auxiliary buffers, unlike leaf buffers, might not exist, be especially careful when specifying the <em class="arg">bufferIdx</em>. </dd>
<dd>
For const trees, this method always returns a reference to a const buffer. It is safe to <code>const_cast</code> and modify any auxiliary buffer (<em class="arg">bufferIdx</em> &gt; 0), but it is not safe to modify the leaf buffer (<em class="arg">bufferIdx</em> = 0). </dd></dl>

</div>
</div>
<a id="a06f465dfbb611dea7957ab44e2ce903f" name="a06f465dfbb611dea7957ab44e2ce903f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f465dfbb611dea7957ab44e2ce903f">&#9670;&#160;</a></span>getPrefixSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getPrefixSum </td>
          <td>(</td>
          <td class="paramtype">size_t *&amp;</td>          <td class="paramname"><span class="paramname"><em>offsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a linear array of prefix sums of offsets into the active voxels in the leafs. So <em class="arg">offsets</em>[n]+m is the offset to the mth active voxel in the nth leaf node (useful for user-managed value buffers, e.g. in <a class="el" href="LevelSetAdvect_8h.html" title="Hyperbolic advection of narrow-band level sets.">tools/LevelSetAdvect.h</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of active values in the leaf nodes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>array of prefix sums of offsets to active voxels </td></tr>
    <tr><td class="paramname">size</td><td>on input, the size of <em class="arg">offsets</em>; on output, its new size </td></tr>
    <tr><td class="paramname">grainSize</td><td>optional grain size for threading</td></tr>
  </table>
  </dd>
</dl>
<p>If <em class="arg">offsets</em> is <code>nullptr</code> or <em class="arg">size</em> is smaller than the total number of active voxels (the return value) then <em class="arg">offsets</em> is reallocated and <em class="arg">size</em> equals the total number of active voxels. </p>

</div>
</div>
<a id="a2cd830d0f29e22833420b0c6e95f2b05" name="a2cd830d0f29e22833420b0c6e95f2b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd830d0f29e22833420b0c6e95f2b05">&#9670;&#160;</a></span>getRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa108a6bf58f9df0ca024104843d33d75">RangeType</a> getRange </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainsize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <code>tbb::blocked_range</code> of leaf array indices. </p>
<dl class="section note"><dt>Note</dt><dd>Consider using <a class="el" href="#ae69049a01bb981da50f7e3c43da64892" title="Return a TBB-compatible LeafRange.">leafRange()</a> instead, which provides access methods to leaf nodes and buffers. </dd></dl>

</div>
</div>
<a id="a5b29b5b9a617df3ecddeca09b1fea0c3" name="a5b29b5b9a617df3ecddeca09b1fea0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b29b5b9a617df3ecddeca09b1fea0c3">&#9670;&#160;</a></span>isConstTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isConstTree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the tree associated with this manager is immutable. </p>

</div>
</div>
<a id="a07511f0828438a050edd0ad48d2c63a5" name="a07511f0828438a050edd0ad48d2c63a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07511f0828438a050edd0ad48d2c63a5">&#9670;&#160;</a></span>leaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af311c60c070ae3bf132cc752e08d424a">LeafType</a> &amp; leaf </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>leafIdx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node at index <em class="arg">leafIdx</em> in the array. </p>
<dl class="section note"><dt>Note</dt><dd>For performance reasons no range check is performed (other than an assertion)! </dd></dl>

</div>
</div>
<a id="a90c12d687db3681030ad5774215542ba" name="a90c12d687db3681030ad5774215542ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c12d687db3681030ad5774215542ba">&#9670;&#160;</a></span>leafCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t leafCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of leaf nodes. </p>

</div>
</div>
<a id="ae69049a01bb981da50f7e3c43da64892" name="ae69049a01bb981da50f7e3c43da64892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69049a01bb981da50f7e3c43da64892">&#9670;&#160;</a></span>leafRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager_1_1LeafRange.html">LeafRange</a> leafRange </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainsize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a TBB-compatible <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager_1_1LeafRange.html">LeafRange</a>. </p>

</div>
</div>
<a id="a27688381045d0db7c8f9499b4562f777" name="a27688381045d0db7c8f9499b4562f777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27688381045d0db7c8f9499b4562f777">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aa108a6bf58f9df0ca024104843d33d75">RangeType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally by tbb::parallel_for() - never call it directly! </p>

</div>
</div>
<a id="a27df2921c5308dcf3b8814d90d9ab5e1" name="a27df2921c5308dcf3b8814d90d9ab5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27df2921c5308dcf3b8814d90d9ab5e1">&#9670;&#160;</a></span>rebuild() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebuild </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>serial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Re)initialize by resizing (if necessary) and repopulating the leaf array and by deleting existing auxiliary buffers and allocating new ones. </p>
<p>Call this method if the tree's topology, and therefore the number of leaf nodes, changes. New auxiliary buffers are initialized with copies of corresponding leaf node buffers. </p>

</div>
</div>
<a id="abc9678b87fd0a3c643c20b733989bfa7" name="abc9678b87fd0a3c643c20b733989bfa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9678b87fd0a3c643c20b733989bfa7">&#9670;&#160;</a></span>rebuild() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebuild </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>auxBuffersPerLeaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>serial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repopulate the leaf array and delete and reallocate auxiliary buffers. </p>

</div>
</div>
<a id="a2512a475143e9bf424983e31b14b6d90" name="a2512a475143e9bf424983e31b14b6d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2512a475143e9bf424983e31b14b6d90">&#9670;&#160;</a></span>rebuild() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebuild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>serial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96b9faebed83c665e89d7dcd1ea73c5c" name="a96b9faebed83c665e89d7dcd1ea73c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b9faebed83c665e89d7dcd1ea73c5c">&#9670;&#160;</a></span>rebuild() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebuild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>auxBuffersPerLeaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>serial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8b77a7173180a24da3a10a28c0fe987" name="aa8b77a7173180a24da3a10a28c0fe987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b77a7173180a24da3a10a28c0fe987">&#9670;&#160;</a></span>rebuildAuxBuffers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebuildAuxBuffers </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>auxBuffersPerLeaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>serial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the number of auxiliary buffers. </p>
<p>If auxBuffersPerLeaf is 0, all existing auxiliary buffers are deleted. New auxiliary buffers are initialized with copies of corresponding leaf node buffers. This method does not rebuild the leaf array. </p>

</div>
</div>
<a id="a8b7eb7df4fd22eed01ec5883a2c6a829" name="a8b7eb7df4fd22eed01ec5883a2c6a829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7eb7df4fd22eed01ec5883a2c6a829">&#9670;&#160;</a></span>rebuildLeafArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebuildLeafArray </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>serial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the auxiliary buffers and rebuild the leaf array. </p>

</div>
</div>
<a id="a564f198735d281f486addac56f65751d" name="a564f198735d281f486addac56f65751d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564f198735d281f486addac56f65751d">&#9670;&#160;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<div class="memtemplate">
template&lt;typename LeafOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reduce </td>
          <td>(</td>
          <td class="paramtype">LeafOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threaded method that applies a user-supplied functor to each leaf node in the <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager.html" title="This class manages a linear array of pointers to a given tree&#39;s leaf nodes, as well as optional auxil...">LeafManager</a>. Unlike foreach (defined above) this method performs a reduction on all the leaf nodes. </p>
<p>The user-supplied functor needs to define the methods required for tbb::parallel_reduce.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>user-supplied functor, see examples for interface details. </td></tr>
    <tr><td class="paramname">threaded</td><td>optional toggle to disable threading, on by default. </td></tr>
    <tr><td class="paramname">grainSize</td><td>optional parameter to specify the grainsize for threading, one by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The functor object is deep-copied to create TBB tasks. This allows the function to use non-thread-safe members like a <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="comment">// Functor to count the number of negative (active) leaf values</span></div>
<div class="line"><span class="keyword">struct </span>CountOp</div>
<div class="line">{</div>
<div class="line">    CountOp() : mCounter(0) {}</div>
<div class="line">    CountOp(<span class="keyword">const</span> CountOp &amp;other) : mCounter(other.mCounter) {}</div>
<div class="line">    CountOp(<span class="keyword">const</span> CountOp &amp;other, tbb::split) : mCounter(0) {}</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LeafNodeType&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(LeafNodeType &amp;leaf, <span class="keywordtype">size_t</span>)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">typename</span> LeafNodeType::ValueOnIter iter = leaf.beginValueOn();</div>
<div class="line">      <span class="keywordflow">for</span> (; iter; ++iter) <span class="keywordflow">if</span> (*iter &lt; 0.0f) ++mCounter;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> join(<span class="keyword">const</span> CountOp &amp;other) {mCounter += other.mCounter;}</div>
<div class="line">    <span class="keywordtype">size_t</span> mCounter;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// usage:</span></div>
<div class="line">tree::LeafManager&lt;FloatTree&gt; leafNodes(<a class="code hl_function" href="#a00f0f1bad5545bbba684da07dba34eb5">tree</a>);</div>
<div class="line">MinValueOp <a class="code hl_function" href="namespaceopenvdb_1_1v13__0_1_1tools_1_1composite.html#ad715de018c1beeec76eec91e8d4828c0">min</a>;</div>
<div class="line">leafNodes.reduce(min);</div>
<div class="line">std::cerr &lt;&lt; <span class="stringliteral">&quot;Number of negative active voxels = &quot;</span> &lt;&lt; <a class="code hl_function" href="namespaceopenvdb_1_1v13__0_1_1tools_1_1composite.html#ad715de018c1beeec76eec91e8d4828c0">min</a>.mCounter &lt;&lt; std::endl;</div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tools_1_1composite_html_ad715de018c1beeec76eec91e8d4828c0"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0_1_1tools_1_1composite.html#ad715de018c1beeec76eec91e8d4828c0">openvdb::v13_0::tools::composite::min</a></div><div class="ttdeci">const std::enable_if&lt;!VecTraits&lt; T &gt;::IsVec, T &gt;::type &amp; min(const T &amp;a, const T &amp;b)</div><div class="ttdef"><b>Definition</b> Composite.h:106</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="affa2e44cef7e0e027e7fcc5a404ad58a" name="affa2e44cef7e0e027e7fcc5a404ad58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa2e44cef7e0e027e7fcc5a404ad58a">&#9670;&#160;</a></span>removeAuxBuffers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void removeAuxBuffers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the auxiliary buffers, but don't rebuild the leaf array. </p>

</div>
</div>
<a id="a1597a4ee7b0ac005eeafb868ab3c97c7" name="a1597a4ee7b0ac005eeafb868ab3c97c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1597a4ee7b0ac005eeafb868ab3c97c7">&#9670;&#160;</a></span>root() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a63b17471dabe2990c3ad67e10d7f1973">RootNodeType</a> &amp; root </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the root node associated with this manager. </p>

</div>
</div>
<a id="af2f19b30b303f9bcbd46b125e34173ac" name="af2f19b30b303f9bcbd46b125e34173ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f19b30b303f9bcbd46b125e34173ac">&#9670;&#160;</a></span>root() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a63b17471dabe2990c3ad67e10d7f1973">RootNodeType</a> &amp; root </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to root node associated with this manager. </p>

</div>
</div>
<a id="a288a8c0c3e8c6132e6284ab66cc591cd" name="a288a8c0c3e8c6132e6284ab66cc591cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288a8c0c3e8c6132e6284ab66cc591cd">&#9670;&#160;</a></span>swapBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool swapBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufferIdx1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufferIdx2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>serial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap any two buffers for each leaf node. </p>
<dl class="section note"><dt>Note</dt><dd>Recall that the indexing of auxiliary buffers is 1-based, since buffer index 0 denotes the leaf node buffer. So buffer index 1 denotes the first auxiliary buffer. </dd></dl>

</div>
</div>
<a id="a22ac33d0549b786059b9c691f0a534f7" name="a22ac33d0549b786059b9c691f0a534f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ac33d0549b786059b9c691f0a534f7">&#9670;&#160;</a></span>swapLeafBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool swapLeafBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufferIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>serial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap each leaf node's buffer with the nth corresponding auxiliary buffer, where n = <em class="arg">bufferIdx</em>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the swap was successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferIdx</td><td>index of the buffer that will be swapped with the corresponding leaf node buffer </td></tr>
    <tr><td class="paramname">serial</td><td>if false, swap buffers in parallel using multiple threads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Recall that the indexing of auxiliary buffers is 1-based, since buffer index 0 denotes the leaf node buffer. So buffer index 1 denotes the first auxiliary buffer. </dd></dl>

</div>
</div>
<a id="a3bad152cbc97be4c39b46f852cf523b4" name="a3bad152cbc97be4c39b46f852cf523b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bad152cbc97be4c39b46f852cf523b4">&#9670;&#160;</a></span>syncAllBuffers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool syncAllBuffers </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>serial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sync up all auxiliary buffers with their corresponding leaf node buffers. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the sync was successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial</td><td>if false, sync buffers in parallel using multiple threads. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f5bb8c75cfd73036df566fba4dd693e" name="a2f5bb8c75cfd73036df566fba4dd693e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5bb8c75cfd73036df566fba4dd693e">&#9670;&#160;</a></span>syncAuxBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool syncAuxBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufferIdx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>serial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sync up the specified auxiliary buffer with the corresponding leaf node buffer. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the sync was successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferIdx</td><td>index of the buffer that will contain a copy of the corresponding leaf node buffer </td></tr>
    <tr><td class="paramname">serial</td><td>if false, sync buffers in parallel using multiple threads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Recall that the indexing of auxiliary buffers is 1-based, since buffer index 0 denotes the leaf node buffer. So buffer index 1 denotes the first auxiliary buffer. </dd></dl>

</div>
</div>
<a id="a17b80f47bec1787373e4a546909379a3" name="a17b80f47bec1787373e4a546909379a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b80f47bec1787373e4a546909379a3">&#9670;&#160;</a></span>tree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp; tree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the tree associated with this manager. </p>

</div>
</div>
<a id="a00f0f1bad5545bbba684da07dba34eb5" name="a00f0f1bad5545bbba684da07dba34eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f0f1bad5545bbba684da07dba34eb5">&#9670;&#160;</a></span>tree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp; tree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to tree associated with this manager. </p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a33812eef2746f526e18a7d13ad9d0eb3" name="a33812eef2746f526e18a7d13ad9d0eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33812eef2746f526e18a7d13ad9d0eb3">&#9670;&#160;</a></span>DEPTH</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> DEPTH = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed029134efd058169d0a0d3cae1c6f32" name="aed029134efd058169d0a0d3cae1c6f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed029134efd058169d0a0d3cae1c6f32">&#9670;&#160;</a></span>IsConstTree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool IsConstTree = <a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1leafmgr_1_1TreeTraits.html">leafmgr::TreeTraits</a>&lt;TreeT&gt;::IsConstTree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1tree.html">tree</a></li><li class="navelem"><a href="classopenvdb_1_1v13__0_1_1tree_1_1LeafManager.html">LeafManager</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
