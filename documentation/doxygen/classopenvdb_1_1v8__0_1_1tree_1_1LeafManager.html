<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: LeafManager&lt; TreeT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__0.html">v8_0</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tree.html">tree</a></li><li class="navelem"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html">LeafManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LeafManager&lt; TreeT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class manages a linear array of pointers to a given tree's leaf nodes, as well as optional auxiliary buffers (one or more per leaf) that can be swapped with the leaf nodes' voxel data buffers.  
 <a href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LeafManager_8h_source.html">LeafManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager_1_1LeafRange.html">LeafRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af07a8c75c48174ee79d06fbfe43dd821"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> = TreeT</td></tr>
<tr class="separator:af07a8c75c48174ee79d06fbfe43dd821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fb67be7bc6aa858ee34277782a2209"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a19fb67be7bc6aa858ee34277782a2209">ValueType</a> = typename TreeT::ValueType</td></tr>
<tr class="separator:a19fb67be7bc6aa858ee34277782a2209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b17471dabe2990c3ad67e10d7f1973"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a63b17471dabe2990c3ad67e10d7f1973">RootNodeType</a> = typename TreeT::RootNodeType</td></tr>
<tr class="separator:a63b17471dabe2990c3ad67e10d7f1973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7947e6bf0b6e87b54dcce9c9f0ca68df"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a7947e6bf0b6e87b54dcce9c9f0ca68df">NonConstLeafType</a> = typename TreeType::LeafNodeType</td></tr>
<tr class="separator:a7947e6bf0b6e87b54dcce9c9f0ca68df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af311c60c070ae3bf132cc752e08d424a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af311c60c070ae3bf132cc752e08d424a">LeafType</a> = typename <a class="el" href="structopenvdb_1_1v8__0_1_1CopyConstness.html">CopyConstness</a>&lt; <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a>, <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a7947e6bf0b6e87b54dcce9c9f0ca68df">NonConstLeafType</a> &gt;::Type</td></tr>
<tr class="separator:af311c60c070ae3bf132cc752e08d424a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff34a091cd54db8860dbea7885fe7888"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aff34a091cd54db8860dbea7885fe7888">LeafNodeType</a> = <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af311c60c070ae3bf132cc752e08d424a">LeafType</a></td></tr>
<tr class="separator:aff34a091cd54db8860dbea7885fe7888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4485ee3a5799073a49bd3cb4c374a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a1f4485ee3a5799073a49bd3cb4c374a8">LeafIterType</a> = typename <a class="el" href="structopenvdb_1_1v8__0_1_1tree_1_1leafmgr_1_1TreeTraits.html">leafmgr::TreeTraits</a>&lt; TreeT &gt;::<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a1f4485ee3a5799073a49bd3cb4c374a8">LeafIterType</a></td></tr>
<tr class="separator:a1f4485ee3a5799073a49bd3cb4c374a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f9836a2f27a60d6b6a3e3801c11f47"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#ad8f9836a2f27a60d6b6a3e3801c11f47">NonConstBufferType</a> = typename LeafType::Buffer</td></tr>
<tr class="separator:ad8f9836a2f27a60d6b6a3e3801c11f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15837204fc4fd8dc657b1de732ed5fa2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a15837204fc4fd8dc657b1de732ed5fa2">BufferType</a> = typename <a class="el" href="structopenvdb_1_1v8__0_1_1CopyConstness.html">CopyConstness</a>&lt; <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a>, <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#ad8f9836a2f27a60d6b6a3e3801c11f47">NonConstBufferType</a> &gt;::Type</td></tr>
<tr class="separator:a15837204fc4fd8dc657b1de732ed5fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa108a6bf58f9df0ca024104843d33d75"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aa108a6bf58f9df0ca024104843d33d75">RangeType</a> = tbb::blocked_range&lt; size_t &gt;</td></tr>
<tr class="separator:aa108a6bf58f9df0ca024104843d33d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6bad6c4b86a2ec52ce35cbd5519cfa45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a6bad6c4b86a2ec52ce35cbd5519cfa45">LeafManager</a> (<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a932dc28aa53e3961b2c4f8b3ff4c7242">tree</a>, size_t <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a331fa25148c35653896b22a29903cc46">auxBuffersPerLeaf</a>=0, bool serial=false)</td></tr>
<tr class="memdesc:a6bad6c4b86a2ec52ce35cbd5519cfa45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a tree reference and an auxiliary buffer count.  <a href="#a6bad6c4b86a2ec52ce35cbd5519cfa45">More...</a><br /></td></tr>
<tr class="separator:a6bad6c4b86a2ec52ce35cbd5519cfa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80195dcd80d3614f522176fb87464046"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a80195dcd80d3614f522176fb87464046">LeafManager</a> (<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a932dc28aa53e3961b2c4f8b3ff4c7242">tree</a>, <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af311c60c070ae3bf132cc752e08d424a">LeafType</a> **begin, <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af311c60c070ae3bf132cc752e08d424a">LeafType</a> **end, size_t <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a331fa25148c35653896b22a29903cc46">auxBuffersPerLeaf</a>=0, bool serial=false)</td></tr>
<tr class="memdesc:a80195dcd80d3614f522176fb87464046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct directly from an existing array of leafnodes.  <a href="#a80195dcd80d3614f522176fb87464046">More...</a><br /></td></tr>
<tr class="separator:a80195dcd80d3614f522176fb87464046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4564928988bed112c6e4a9db516ef2dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a4564928988bed112c6e4a9db516ef2dd">LeafManager</a> (const <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html">LeafManager</a> &amp;other)</td></tr>
<tr class="separator:a4564928988bed112c6e4a9db516ef2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27df2921c5308dcf3b8814d90d9ab5e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a27df2921c5308dcf3b8814d90d9ab5e1">rebuild</a> (bool serial=false)</td></tr>
<tr class="memdesc:a27df2921c5308dcf3b8814d90d9ab5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Re)initialize by resizing (if necessary) and repopulating the leaf array and by deleting existing auxiliary buffers and allocating new ones.  <a href="#a27df2921c5308dcf3b8814d90d9ab5e1">More...</a><br /></td></tr>
<tr class="separator:a27df2921c5308dcf3b8814d90d9ab5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b77a7173180a24da3a10a28c0fe987"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aa8b77a7173180a24da3a10a28c0fe987">rebuildAuxBuffers</a> (size_t <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a331fa25148c35653896b22a29903cc46">auxBuffersPerLeaf</a>, bool serial=false)</td></tr>
<tr class="memdesc:aa8b77a7173180a24da3a10a28c0fe987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the number of auxiliary buffers.  <a href="#aa8b77a7173180a24da3a10a28c0fe987">More...</a><br /></td></tr>
<tr class="separator:aa8b77a7173180a24da3a10a28c0fe987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa2e44cef7e0e027e7fcc5a404ad58a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#affa2e44cef7e0e027e7fcc5a404ad58a">removeAuxBuffers</a> ()</td></tr>
<tr class="memdesc:affa2e44cef7e0e027e7fcc5a404ad58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the auxiliary buffers, but don't rebuild the leaf array.  <a href="#affa2e44cef7e0e027e7fcc5a404ad58a">More...</a><br /></td></tr>
<tr class="separator:affa2e44cef7e0e027e7fcc5a404ad58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7eb7df4fd22eed01ec5883a2c6a829"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a8b7eb7df4fd22eed01ec5883a2c6a829">rebuildLeafArray</a> (bool serial=false)</td></tr>
<tr class="memdesc:a8b7eb7df4fd22eed01ec5883a2c6a829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the auxiliary buffers and rebuild the leaf array.  <a href="#a8b7eb7df4fd22eed01ec5883a2c6a829">More...</a><br /></td></tr>
<tr class="separator:a8b7eb7df4fd22eed01ec5883a2c6a829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ee4d892d3cebd2319506ce4069d1ab"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a96ee4d892d3cebd2319506ce4069d1ab">auxBufferCount</a> () const </td></tr>
<tr class="memdesc:a96ee4d892d3cebd2319506ce4069d1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of allocated auxiliary buffers.  <a href="#a96ee4d892d3cebd2319506ce4069d1ab">More...</a><br /></td></tr>
<tr class="separator:a96ee4d892d3cebd2319506ce4069d1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331fa25148c35653896b22a29903cc46"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a331fa25148c35653896b22a29903cc46">auxBuffersPerLeaf</a> () const </td></tr>
<tr class="memdesc:a331fa25148c35653896b22a29903cc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of auxiliary buffers per leaf node.  <a href="#a331fa25148c35653896b22a29903cc46">More...</a><br /></td></tr>
<tr class="separator:a331fa25148c35653896b22a29903cc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412b718c7c8ef03f8439e4882eeea860"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a412b718c7c8ef03f8439e4882eeea860">leafCount</a> () const </td></tr>
<tr class="memdesc:a412b718c7c8ef03f8439e4882eeea860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of leaf nodes.  <a href="#a412b718c7c8ef03f8439e4882eeea860">More...</a><br /></td></tr>
<tr class="separator:a412b718c7c8ef03f8439e4882eeea860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae641a7c4bebe08b387b32d0dbd3da98e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#ae641a7c4bebe08b387b32d0dbd3da98e">activeLeafVoxelCount</a> () const </td></tr>
<tr class="memdesc:ae641a7c4bebe08b387b32d0dbd3da98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of active voxels in the leaf nodes.  <a href="#ae641a7c4bebe08b387b32d0dbd3da98e">More...</a><br /></td></tr>
<tr class="separator:ae641a7c4bebe08b387b32d0dbd3da98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932dc28aa53e3961b2c4f8b3ff4c7242"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a932dc28aa53e3961b2c4f8b3ff4c7242">tree</a> () const </td></tr>
<tr class="memdesc:a932dc28aa53e3961b2c4f8b3ff4c7242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to tree associated with this manager.  <a href="#a932dc28aa53e3961b2c4f8b3ff4c7242">More...</a><br /></td></tr>
<tr class="separator:a932dc28aa53e3961b2c4f8b3ff4c7242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9041f381eeb1287165c1287603de9663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a9041f381eeb1287165c1287603de9663">tree</a> ()</td></tr>
<tr class="memdesc:a9041f381eeb1287165c1287603de9663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the tree associated with this manager.  <a href="#a9041f381eeb1287165c1287603de9663">More...</a><br /></td></tr>
<tr class="separator:a9041f381eeb1287165c1287603de9663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcdb35119698a5e8ce0059ae57fa887"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a63b17471dabe2990c3ad67e10d7f1973">RootNodeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a6dcdb35119698a5e8ce0059ae57fa887">root</a> () const </td></tr>
<tr class="memdesc:a6dcdb35119698a5e8ce0059ae57fa887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to root node associated with this manager.  <a href="#a6dcdb35119698a5e8ce0059ae57fa887">More...</a><br /></td></tr>
<tr class="separator:a6dcdb35119698a5e8ce0059ae57fa887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1969dd5ae7c1715c8abcfcd82aeeff85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a63b17471dabe2990c3ad67e10d7f1973">RootNodeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a1969dd5ae7c1715c8abcfcd82aeeff85">root</a> ()</td></tr>
<tr class="memdesc:a1969dd5ae7c1715c8abcfcd82aeeff85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the root node associated with this manager.  <a href="#a1969dd5ae7c1715c8abcfcd82aeeff85">More...</a><br /></td></tr>
<tr class="separator:a1969dd5ae7c1715c8abcfcd82aeeff85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55e9918b7eae715b762983ff43fe422"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#ad55e9918b7eae715b762983ff43fe422">isConstTree</a> () const </td></tr>
<tr class="memdesc:ad55e9918b7eae715b762983ff43fe422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the tree associated with this manager is immutable.  <a href="#ad55e9918b7eae715b762983ff43fe422">More...</a><br /></td></tr>
<tr class="separator:ad55e9918b7eae715b762983ff43fe422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a21299f2b9561affcdac1956dd9e37b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af311c60c070ae3bf132cc752e08d424a">LeafType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a7a21299f2b9561affcdac1956dd9e37b">leaf</a> (size_t leafIdx) const </td></tr>
<tr class="memdesc:a7a21299f2b9561affcdac1956dd9e37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node at index <em>leafIdx</em> in the array.  <a href="#a7a21299f2b9561affcdac1956dd9e37b">More...</a><br /></td></tr>
<tr class="separator:a7a21299f2b9561affcdac1956dd9e37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54178da485b68013cea72c2ef70824e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a15837204fc4fd8dc657b1de732ed5fa2">BufferType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aa54178da485b68013cea72c2ef70824e">getBuffer</a> (size_t leafIdx, size_t bufferIdx) const </td></tr>
<tr class="memdesc:aa54178da485b68013cea72c2ef70824e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the leaf or auxiliary buffer for the leaf node at index <em>leafIdx</em>. If <em>bufferIdx</em> is zero, return the leaf buffer, otherwise return the nth auxiliary buffer, where n = <em>bufferIdx</em> - 1.  <a href="#aa54178da485b68013cea72c2ef70824e">More...</a><br /></td></tr>
<tr class="separator:aa54178da485b68013cea72c2ef70824e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382a2616845396316bfdc4e92bd9468d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aa108a6bf58f9df0ca024104843d33d75">RangeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a382a2616845396316bfdc4e92bd9468d">getRange</a> (size_t grainsize=1) const </td></tr>
<tr class="memdesc:a382a2616845396316bfdc4e92bd9468d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <code>tbb::blocked_range</code> of leaf array indices.  <a href="#a382a2616845396316bfdc4e92bd9468d">More...</a><br /></td></tr>
<tr class="separator:a382a2616845396316bfdc4e92bd9468d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e36974eedb5516344a08fd19d6d1782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager_1_1LeafRange.html">LeafRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a9e36974eedb5516344a08fd19d6d1782">leafRange</a> (size_t grainsize=1) const </td></tr>
<tr class="memdesc:a9e36974eedb5516344a08fd19d6d1782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a TBB-compatible <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager_1_1LeafRange.html">LeafRange</a>.  <a href="#a9e36974eedb5516344a08fd19d6d1782">More...</a><br /></td></tr>
<tr class="separator:a9e36974eedb5516344a08fd19d6d1782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ac33d0549b786059b9c691f0a534f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a22ac33d0549b786059b9c691f0a534f7">swapLeafBuffer</a> (size_t bufferIdx, bool serial=false)</td></tr>
<tr class="memdesc:a22ac33d0549b786059b9c691f0a534f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap each leaf node's buffer with the nth corresponding auxiliary buffer, where n = <em>bufferIdx</em>.  <a href="#a22ac33d0549b786059b9c691f0a534f7">More...</a><br /></td></tr>
<tr class="separator:a22ac33d0549b786059b9c691f0a534f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288a8c0c3e8c6132e6284ab66cc591cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a288a8c0c3e8c6132e6284ab66cc591cd">swapBuffer</a> (size_t bufferIdx1, size_t bufferIdx2, bool serial=false)</td></tr>
<tr class="memdesc:a288a8c0c3e8c6132e6284ab66cc591cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap any two buffers for each leaf node.  <a href="#a288a8c0c3e8c6132e6284ab66cc591cd">More...</a><br /></td></tr>
<tr class="separator:a288a8c0c3e8c6132e6284ab66cc591cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5bb8c75cfd73036df566fba4dd693e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a2f5bb8c75cfd73036df566fba4dd693e">syncAuxBuffer</a> (size_t bufferIdx, bool serial=false)</td></tr>
<tr class="memdesc:a2f5bb8c75cfd73036df566fba4dd693e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync up the specified auxiliary buffer with the corresponding leaf node buffer.  <a href="#a2f5bb8c75cfd73036df566fba4dd693e">More...</a><br /></td></tr>
<tr class="separator:a2f5bb8c75cfd73036df566fba4dd693e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bad152cbc97be4c39b46f852cf523b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a3bad152cbc97be4c39b46f852cf523b4">syncAllBuffers</a> (bool serial=false)</td></tr>
<tr class="memdesc:a3bad152cbc97be4c39b46f852cf523b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync up all auxiliary buffers with their corresponding leaf node buffers.  <a href="#a3bad152cbc97be4c39b46f852cf523b4">More...</a><br /></td></tr>
<tr class="separator:a3bad152cbc97be4c39b46f852cf523b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449355fc31ee41387283def6d663f807"><td class="memTemplParams" colspan="2">template&lt;typename LeafOp &gt; </td></tr>
<tr class="memitem:a449355fc31ee41387283def6d663f807"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a449355fc31ee41387283def6d663f807">foreach</a> (const LeafOp &amp;op, bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:a449355fc31ee41387283def6d663f807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded method that applies a user-supplied functor to each leaf node in the <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html" title="This class manages a linear array of pointers to a given tree&#39;s leaf nodes, as well as optional auxil...">LeafManager</a>.  <a href="#a449355fc31ee41387283def6d663f807">More...</a><br /></td></tr>
<tr class="separator:a449355fc31ee41387283def6d663f807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564f198735d281f486addac56f65751d"><td class="memTemplParams" colspan="2">template&lt;typename LeafOp &gt; </td></tr>
<tr class="memitem:a564f198735d281f486addac56f65751d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a564f198735d281f486addac56f65751d">reduce</a> (LeafOp &amp;op, bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:a564f198735d281f486addac56f65751d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded method that applies a user-supplied functor to each leaf node in the <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html" title="This class manages a linear array of pointers to a given tree&#39;s leaf nodes, as well as optional auxil...">LeafManager</a>. Unlike foreach (defined above) this method performs a reduction on all the leaf nodes.  <a href="#a564f198735d281f486addac56f65751d">More...</a><br /></td></tr>
<tr class="separator:a564f198735d281f486addac56f65751d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a33a3cd99c0b9c78e1f6da3d9a36fdaff">getNodes</a> (ArrayT &amp;array)</td></tr>
<tr class="separator:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dda98f1a46783cb8638ef4a17462c0"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:ab4dda98f1a46783cb8638ef4a17462c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#ab4dda98f1a46783cb8638ef4a17462c0">getNodes</a> (ArrayT &amp;array) const </td></tr>
<tr class="separator:ab4dda98f1a46783cb8638ef4a17462c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16430caebaa4a65a8071f75394adb8f3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a16430caebaa4a65a8071f75394adb8f3">getPrefixSum</a> (size_t *&amp;offsets, size_t &amp;size, size_t grainSize=1) const </td></tr>
<tr class="memdesc:a16430caebaa4a65a8071f75394adb8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a linear array of prefix sums of offsets into the active voxels in the leafs. So <em>offsets</em>[n]+m is the offset to the mth active voxel in the nth leaf node (useful for user-managed value buffers, e.g. in <a class="el" href="LevelSetAdvect_8h.html" title="Hyperbolic advection of narrow-band level sets. ">tools/LevelSetAdvect.h</a>).  <a href="#a16430caebaa4a65a8071f75394adb8f3">More...</a><br /></td></tr>
<tr class="separator:a16430caebaa4a65a8071f75394adb8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79d211818696dc7678e3e5ada3d6848"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#ae79d211818696dc7678e3e5ada3d6848">operator()</a> (const <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aa108a6bf58f9df0ca024104843d33d75">RangeType</a> &amp;r) const </td></tr>
<tr class="memdesc:ae79d211818696dc7678e3e5ada3d6848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally by tbb::parallel_for() - never call it directly!  <a href="#ae79d211818696dc7678e3e5ada3d6848">More...</a><br /></td></tr>
<tr class="separator:ae79d211818696dc7678e3e5ada3d6848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abc9678b87fd0a3c643c20b733989bfa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#abc9678b87fd0a3c643c20b733989bfa7">rebuild</a> (size_t <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a331fa25148c35653896b22a29903cc46">auxBuffersPerLeaf</a>, bool serial=false)</td></tr>
<tr class="memdesc:abc9678b87fd0a3c643c20b733989bfa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repopulate the leaf array and delete and reallocate auxiliary buffers.  <a href="#abc9678b87fd0a3c643c20b733989bfa7">More...</a><br /></td></tr>
<tr class="separator:abc9678b87fd0a3c643c20b733989bfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2512a475143e9bf424983e31b14b6d90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a2512a475143e9bf424983e31b14b6d90">rebuild</a> (<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a932dc28aa53e3961b2c4f8b3ff4c7242">tree</a>, bool serial=false)</td></tr>
<tr class="memdesc:a2512a475143e9bf424983e31b14b6d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repopulate the leaf array and delete and reallocate auxiliary buffers.  <a href="#a2512a475143e9bf424983e31b14b6d90">More...</a><br /></td></tr>
<tr class="separator:a2512a475143e9bf424983e31b14b6d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b9faebed83c665e89d7dcd1ea73c5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a96b9faebed83c665e89d7dcd1ea73c5c">rebuild</a> (<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a932dc28aa53e3961b2c4f8b3ff4c7242">tree</a>, size_t <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a331fa25148c35653896b22a29903cc46">auxBuffersPerLeaf</a>, bool serial=false)</td></tr>
<tr class="memdesc:a96b9faebed83c665e89d7dcd1ea73c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repopulate the leaf array and delete and reallocate auxiliary buffers.  <a href="#a96b9faebed83c665e89d7dcd1ea73c5c">More...</a><br /></td></tr>
<tr class="separator:a96b9faebed83c665e89d7dcd1ea73c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a33812eef2746f526e18a7d13ad9d0eb3"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a33812eef2746f526e18a7d13ad9d0eb3">DEPTH</a> = 2</td></tr>
<tr class="separator:a33812eef2746f526e18a7d13ad9d0eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed029134efd058169d0a0d3cae1c6f32"><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aed029134efd058169d0a0d3cae1c6f32">IsConstTree</a> = <a class="el" href="structopenvdb_1_1v8__0_1_1tree_1_1leafmgr_1_1TreeTraits.html">leafmgr::TreeTraits</a>&lt;TreeT&gt;::IsConstTree</td></tr>
<tr class="separator:aed029134efd058169d0a0d3cae1c6f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TreeT&gt;<br />
class openvdb::v8_0::tree::LeafManager&lt; TreeT &gt;</h3>

<p>This class manages a linear array of pointers to a given tree's leaf nodes, as well as optional auxiliary buffers (one or more per leaf) that can be swapped with the leaf nodes' voxel data buffers. </p>
<p>The leaf array is useful for multithreaded computations over leaf voxels in a tree with static topology but varying voxel values. The auxiliary buffers are convenient for temporal integration. Efficient methods are provided for multithreaded swapping and sync'ing (i.e., copying the contents) of these buffers.</p>
<dl class="section note"><dt>Note</dt><dd>Buffer index 0 denotes a leaf node's internal voxel data buffer. Any auxiliary buffers are indexed starting from one. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a15837204fc4fd8dc657b1de732ed5fa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a15837204fc4fd8dc657b1de732ed5fa2">BufferType</a> =  typename <a class="el" href="structopenvdb_1_1v8__0_1_1CopyConstness.html">CopyConstness</a>&lt;<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a>, <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#ad8f9836a2f27a60d6b6a3e3801c11f47">NonConstBufferType</a>&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1f4485ee3a5799073a49bd3cb4c374a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a1f4485ee3a5799073a49bd3cb4c374a8">LeafIterType</a> =  typename <a class="el" href="structopenvdb_1_1v8__0_1_1tree_1_1leafmgr_1_1TreeTraits.html">leafmgr::TreeTraits</a>&lt;TreeT&gt;::<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a1f4485ee3a5799073a49bd3cb4c374a8">LeafIterType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aff34a091cd54db8860dbea7885fe7888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aff34a091cd54db8860dbea7885fe7888">LeafNodeType</a> =  <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af311c60c070ae3bf132cc752e08d424a">LeafType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af311c60c070ae3bf132cc752e08d424a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af311c60c070ae3bf132cc752e08d424a">LeafType</a> =  typename <a class="el" href="structopenvdb_1_1v8__0_1_1CopyConstness.html">CopyConstness</a>&lt;<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a>, <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a7947e6bf0b6e87b54dcce9c9f0ca68df">NonConstLeafType</a>&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8f9836a2f27a60d6b6a3e3801c11f47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#ad8f9836a2f27a60d6b6a3e3801c11f47">NonConstBufferType</a> =  typename LeafType::Buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7947e6bf0b6e87b54dcce9c9f0ca68df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a7947e6bf0b6e87b54dcce9c9f0ca68df">NonConstLeafType</a> =  typename TreeType::LeafNodeType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa108a6bf58f9df0ca024104843d33d75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aa108a6bf58f9df0ca024104843d33d75">RangeType</a> =  tbb::blocked_range&lt;size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a63b17471dabe2990c3ad67e10d7f1973"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a63b17471dabe2990c3ad67e10d7f1973">RootNodeType</a> =  typename TreeT::RootNodeType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af07a8c75c48174ee79d06fbfe43dd821"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> =  TreeT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a19fb67be7bc6aa858ee34277782a2209"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a19fb67be7bc6aa858ee34277782a2209">ValueType</a> =  typename TreeT::ValueType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6bad6c4b86a2ec52ce35cbd5519cfa45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html">LeafManager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>auxBuffersPerLeaf</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a tree reference and an auxiliary buffer count. </p>
<dl class="section note"><dt>Note</dt><dd>The default is no auxiliary buffers </dd></dl>

</div>
</div>
<a class="anchor" id="a80195dcd80d3614f522176fb87464046"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html">LeafManager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af311c60c070ae3bf132cc752e08d424a">LeafType</a> **&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af311c60c070ae3bf132cc752e08d424a">LeafType</a> **&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>auxBuffersPerLeaf</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct directly from an existing array of leafnodes. </p>
<dl class="section warning"><dt>Warning</dt><dd>The leafnodes are implicitly assumed to exist in the input <em>tree</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4564928988bed112c6e4a9db516ef2dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html">LeafManager</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html">LeafManager</a>&lt; TreeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shallow copy constructor called by tbb::parallel_for() threads</p>
<dl class="section note"><dt>Note</dt><dd>This should never get called directly </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae641a7c4bebe08b387b32d0dbd3da98e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> activeLeafVoxelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of active voxels in the leaf nodes. </p>
<dl class="section note"><dt>Note</dt><dd>Multi-threaded for better performance than <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1Tree.html#a489fdc4bfc99bb8d177e91dc282bb3ca" title="Return the number of active voxels stored in leaf nodes. ">Tree::activeLeafVoxelCount</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a96ee4d892d3cebd2319506ce4069d1ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t auxBufferCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number of allocated auxiliary buffers. </p>

</div>
</div>
<a class="anchor" id="a331fa25148c35653896b22a29903cc46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t auxBuffersPerLeaf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of auxiliary buffers per leaf node. </p>

</div>
</div>
<a class="anchor" id="a449355fc31ee41387283def6d663f807"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void foreach </td>
          <td>(</td>
          <td class="paramtype">const LeafOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threaded method that applies a user-supplied functor to each leaf node in the <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html" title="This class manages a linear array of pointers to a given tree&#39;s leaf nodes, as well as optional auxil...">LeafManager</a>. </p>
<p>The user-supplied functor needs to define the methods required for tbb::parallel_for.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>user-supplied functor, see examples for interface details. </td></tr>
    <tr><td class="paramname">threaded</td><td>optional toggle to disable threading, on by default. </td></tr>
    <tr><td class="paramname">grainSize</td><td>optional parameter to specify the grainsize for threading, one by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The functor object is deep-copied to create TBB tasks. This allows the function to use non-thread-safe members like a <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="comment">// Functor to offset a tree&#39;s voxel values with values from another tree.</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TreeType&gt;</div><div class="line"><span class="keyword">struct </span>OffsetOp</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Accessor = tree::ValueAccessor&lt;const TreeType&gt;;</div><div class="line"></div><div class="line">    OffsetOp(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a>&amp; <a class="code" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a932dc28aa53e3961b2c4f8b3ff4c7242">tree</a>): mRhsTreeAcc(tree) {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LeafNodeType&gt;</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#ae79d211818696dc7678e3e5ada3d6848">operator()</a>(<a class="code" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aff34a091cd54db8860dbea7885fe7888">LeafNodeType</a> &amp;lhsLeaf, <span class="keywordtype">size_t</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aff34a091cd54db8860dbea7885fe7888">LeafNodeType</a> *rhsLeaf = mRhsTreeAcc.probeConstLeaf(lhsLeaf.origin());</div><div class="line">        <span class="keywordflow">if</span> (rhsLeaf) {</div><div class="line">            <span class="keyword">typename</span> LeafNodeType::ValueOnIter iter = lhsLeaf.beginValueOn();</div><div class="line">            <span class="keywordflow">for</span> (; iter; ++iter) {</div><div class="line">                iter.setValue(iter.getValue() + rhsLeaf-&gt;getValue(iter.pos()));</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    Accessor mRhsTreeAcc;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// usage:</span></div><div class="line">tree::LeafManager&lt;FloatTree&gt; leafNodes(lhsTree);</div><div class="line">leafNodes.foreach(OffsetOp&lt;FloatTree&gt;(rhsTree));</div><div class="line"></div><div class="line"><span class="comment">// A functor that performs a min operation between different auxiliary buffers.</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> LeafManagerType&gt;</div><div class="line"><span class="keyword">struct </span>MinOp</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> <a class="code" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a15837204fc4fd8dc657b1de732ed5fa2">BufferType</a> = <span class="keyword">typename</span> LeafManagerType::BufferType;</div><div class="line"></div><div class="line">    MinOp(LeafManagerType&amp; leafNodes): mLeafs(leafNodes) {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LeafNodeType&gt;</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#ae79d211818696dc7678e3e5ada3d6848">operator()</a>(<a class="code" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aff34a091cd54db8860dbea7885fe7888">LeafNodeType</a> &amp;<a class="code" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a7a21299f2b9561affcdac1956dd9e37b">leaf</a>, <span class="keywordtype">size_t</span> leafIndex)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="comment">// get the first buffer</span></div><div class="line">        <a class="code" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a15837204fc4fd8dc657b1de732ed5fa2">BufferType</a>&amp; buffer = mLeafs.getBuffer(leafIndex, 1);</div><div class="line"></div><div class="line">        <span class="comment">// min ...</span></div><div class="line">    }</div><div class="line">    LeafManagerType&amp; mLeafs;</div><div class="line">};</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="aa54178da485b68013cea72c2ef70824e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a15837204fc4fd8dc657b1de732ed5fa2">BufferType</a>&amp; getBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>leafIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the leaf or auxiliary buffer for the leaf node at index <em>leafIdx</em>. If <em>bufferIdx</em> is zero, return the leaf buffer, otherwise return the nth auxiliary buffer, where n = <em>bufferIdx</em> - 1. </p>
<dl class="section note"><dt>Note</dt><dd>For performance reasons no range checks are performed on the inputs (other than assertions)! Since auxiliary buffers, unlike leaf buffers, might not exist, be especially careful when specifying the <em>bufferIdx</em>. </dd>
<dd>
For const trees, this method always returns a reference to a const buffer. It is safe to <code>const_cast</code> and modify any auxiliary buffer (<em>bufferIdx</em> &gt; 0), but it is not safe to modify the leaf buffer (<em>bufferIdx</em> = 0). </dd></dl>

</div>
</div>
<a class="anchor" id="a33a3cd99c0b9c78e1f6da3d9a36fdaff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4dda98f1a46783cb8638ef4a17462c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a16430caebaa4a65a8071f75394adb8f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t getPrefixSum </td>
          <td>(</td>
          <td class="paramtype">size_t *&amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a linear array of prefix sums of offsets into the active voxels in the leafs. So <em>offsets</em>[n]+m is the offset to the mth active voxel in the nth leaf node (useful for user-managed value buffers, e.g. in <a class="el" href="LevelSetAdvect_8h.html" title="Hyperbolic advection of narrow-band level sets. ">tools/LevelSetAdvect.h</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of active values in the leaf nodes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>array of prefix sums of offsets to active voxels </td></tr>
    <tr><td class="paramname">size</td><td>on input, the size of <em>offsets</em>; on output, its new size </td></tr>
    <tr><td class="paramname">grainSize</td><td>optional grain size for threading</td></tr>
  </table>
  </dd>
</dl>
<p>If <em>offsets</em> is <code>nullptr</code> or <em>size</em> is smaller than the total number of active voxels (the return value) then <em>offsets</em> is reallocated and <em>size</em> equals the total number of active voxels. </p>

</div>
</div>
<a class="anchor" id="a382a2616845396316bfdc4e92bd9468d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aa108a6bf58f9df0ca024104843d33d75">RangeType</a> getRange </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainsize</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <code>tbb::blocked_range</code> of leaf array indices. </p>
<dl class="section note"><dt>Note</dt><dd>Consider using <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a9e36974eedb5516344a08fd19d6d1782" title="Return a TBB-compatible LeafRange. ">leafRange()</a> instead, which provides access methods to leaf nodes and buffers. </dd></dl>

</div>
</div>
<a class="anchor" id="ad55e9918b7eae715b762983ff43fe422"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isConstTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the tree associated with this manager is immutable. </p>

</div>
</div>
<a class="anchor" id="a7a21299f2b9561affcdac1956dd9e37b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af311c60c070ae3bf132cc752e08d424a">LeafType</a>&amp; leaf </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>leafIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node at index <em>leafIdx</em> in the array. </p>
<dl class="section note"><dt>Note</dt><dd>For performance reasons no range check is performed (other than an assertion)! </dd></dl>

</div>
</div>
<a class="anchor" id="a412b718c7c8ef03f8439e4882eeea860"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t leafCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of leaf nodes. </p>

</div>
</div>
<a class="anchor" id="a9e36974eedb5516344a08fd19d6d1782"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager_1_1LeafRange.html">LeafRange</a> leafRange </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainsize</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a TBB-compatible <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager_1_1LeafRange.html">LeafRange</a>. </p>

</div>
</div>
<a class="anchor" id="ae79d211818696dc7678e3e5ada3d6848"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aa108a6bf58f9df0ca024104843d33d75">RangeType</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally by tbb::parallel_for() - never call it directly! </p>

</div>
</div>
<a class="anchor" id="a27df2921c5308dcf3b8814d90d9ab5e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebuild </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serial</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Re)initialize by resizing (if necessary) and repopulating the leaf array and by deleting existing auxiliary buffers and allocating new ones. </p>
<p>Call this method if the tree's topology, and therefore the number of leaf nodes, changes. New auxiliary buffers are initialized with copies of corresponding leaf node buffers. </p>

</div>
</div>
<a class="anchor" id="abc9678b87fd0a3c643c20b733989bfa7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebuild </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>auxBuffersPerLeaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repopulate the leaf array and delete and reallocate auxiliary buffers. </p>

</div>
</div>
<a class="anchor" id="a2512a475143e9bf424983e31b14b6d90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebuild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repopulate the leaf array and delete and reallocate auxiliary buffers. </p>

</div>
</div>
<a class="anchor" id="a96b9faebed83c665e89d7dcd1ea73c5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebuild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>auxBuffersPerLeaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repopulate the leaf array and delete and reallocate auxiliary buffers. </p>

</div>
</div>
<a class="anchor" id="aa8b77a7173180a24da3a10a28c0fe987"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebuildAuxBuffers </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>auxBuffersPerLeaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the number of auxiliary buffers. </p>
<p>If auxBuffersPerLeaf is 0, all existing auxiliary buffers are deleted. New auxiliary buffers are initialized with copies of corresponding leaf node buffers. This method does not rebuild the leaf array. </p>

</div>
</div>
<a class="anchor" id="a8b7eb7df4fd22eed01ec5883a2c6a829"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rebuildLeafArray </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serial</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the auxiliary buffers and rebuild the leaf array. </p>

</div>
</div>
<a class="anchor" id="a564f198735d281f486addac56f65751d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reduce </td>
          <td>(</td>
          <td class="paramtype">LeafOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threaded method that applies a user-supplied functor to each leaf node in the <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html" title="This class manages a linear array of pointers to a given tree&#39;s leaf nodes, as well as optional auxil...">LeafManager</a>. Unlike foreach (defined above) this method performs a reduction on all the leaf nodes. </p>
<p>The user-supplied functor needs to define the methods required for tbb::parallel_reduce.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>user-supplied functor, see examples for interface details. </td></tr>
    <tr><td class="paramname">threaded</td><td>optional toggle to disable threading, on by default. </td></tr>
    <tr><td class="paramname">grainSize</td><td>optional parameter to specify the grainsize for threading, one by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The functor object is deep-copied to create TBB tasks. This allows the function to use non-thread-safe members like a <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="comment">// Functor to count the number of negative (active) leaf values</span></div><div class="line"><span class="keyword">struct </span>CountOp</div><div class="line">{</div><div class="line">    CountOp() : mCounter(0) {}</div><div class="line">    CountOp(<span class="keyword">const</span> CountOp &amp;other) : mCounter(other.mCounter) {}</div><div class="line">    CountOp(<span class="keyword">const</span> CountOp &amp;other, tbb::split) : mCounter(0) {}</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LeafNodeType&gt;</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#ae79d211818696dc7678e3e5ada3d6848">operator()</a>(<a class="code" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#aff34a091cd54db8860dbea7885fe7888">LeafNodeType</a> &amp;<a class="code" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a7a21299f2b9561affcdac1956dd9e37b">leaf</a>, <span class="keywordtype">size_t</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">typename</span> LeafNodeType::ValueOnIter iter = leaf.beginValueOn();</div><div class="line">      <span class="keywordflow">for</span> (; iter; ++iter) <span class="keywordflow">if</span> (*iter &lt; 0.0f) ++mCounter;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">void</span> join(<span class="keyword">const</span> CountOp &amp;other) {mCounter += other.mCounter;}</div><div class="line">    <span class="keywordtype">size_t</span> mCounter;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// usage:</span></div><div class="line">tree::LeafManager&lt;FloatTree&gt; leafNodes(<a class="code" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a932dc28aa53e3961b2c4f8b3ff4c7242">tree</a>);</div><div class="line">MinValueOp <a class="code" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1composite.html#a20dd2e898c13642764a31c362ec00910">min</a>;</div><div class="line">leafNodes.reduce(min);</div><div class="line">std::cerr &lt;&lt; <span class="stringliteral">&quot;Number of negative active voxels = &quot;</span> &lt;&lt; min.mCounter &lt;&lt; std::endl;</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="affa2e44cef7e0e027e7fcc5a404ad58a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void removeAuxBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the auxiliary buffers, but don't rebuild the leaf array. </p>

</div>
</div>
<a class="anchor" id="a6dcdb35119698a5e8ce0059ae57fa887"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a63b17471dabe2990c3ad67e10d7f1973">RootNodeType</a>&amp; root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to root node associated with this manager. </p>

</div>
</div>
<a class="anchor" id="a1969dd5ae7c1715c8abcfcd82aeeff85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#a63b17471dabe2990c3ad67e10d7f1973">RootNodeType</a>&amp; root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the root node associated with this manager. </p>

</div>
</div>
<a class="anchor" id="a288a8c0c3e8c6132e6284ab66cc591cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool swapBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferIdx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferIdx2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap any two buffers for each leaf node. </p>
<dl class="section note"><dt>Note</dt><dd>Recall that the indexing of auxiliary buffers is 1-based, since buffer index 0 denotes the leaf node buffer. So buffer index 1 denotes the first auxiliary buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a22ac33d0549b786059b9c691f0a534f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool swapLeafBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap each leaf node's buffer with the nth corresponding auxiliary buffer, where n = <em>bufferIdx</em>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the swap was successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferIdx</td><td>index of the buffer that will be swapped with the corresponding leaf node buffer </td></tr>
    <tr><td class="paramname">serial</td><td>if false, swap buffers in parallel using multiple threads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Recall that the indexing of auxiliary buffers is 1-based, since buffer index 0 denotes the leaf node buffer. So buffer index 1 denotes the first auxiliary buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bad152cbc97be4c39b46f852cf523b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool syncAllBuffers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serial</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sync up all auxiliary buffers with their corresponding leaf node buffers. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the sync was successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial</td><td>if false, sync buffers in parallel using multiple threads. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f5bb8c75cfd73036df566fba4dd693e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool syncAuxBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sync up the specified auxiliary buffer with the corresponding leaf node buffer. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the sync was successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferIdx</td><td>index of the buffer that will contain a copy of the corresponding leaf node buffer </td></tr>
    <tr><td class="paramname">serial</td><td>if false, sync buffers in parallel using multiple threads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Recall that the indexing of auxiliary buffers is 1-based, since buffer index 0 denotes the leaf node buffer. So buffer index 1 denotes the first auxiliary buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a932dc28aa53e3961b2c4f8b3ff4c7242"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a>&amp; tree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to tree associated with this manager. </p>

</div>
</div>
<a class="anchor" id="a9041f381eeb1287165c1287603de9663"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html#af07a8c75c48174ee79d06fbfe43dd821">TreeType</a>&amp; tree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the tree associated with this manager. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a33812eef2746f526e18a7d13ad9d0eb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> DEPTH = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aed029134efd058169d0a0d3cae1c6f32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool IsConstTree = <a class="el" href="structopenvdb_1_1v8__0_1_1tree_1_1leafmgr_1_1TreeTraits.html">leafmgr::TreeTraits</a>&lt;TreeT&gt;::IsConstTree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="LeafManager_8h_source.html">LeafManager.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
