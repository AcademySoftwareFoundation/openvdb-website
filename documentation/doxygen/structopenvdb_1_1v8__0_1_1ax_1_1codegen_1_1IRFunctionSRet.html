<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: IRFunctionSRet&lt; SignatureT &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__0.html">v8_0</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax.html">ax</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html">codegen</a></li><li class="navelem"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionSRet.html">IRFunctionSRet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionSRet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IRFunctionSRet&lt; SignatureT &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a concrete IR function with the first argument as its return type.  
 <a href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionSRet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="FunctionTypes_8h_source.html">FunctionTypes.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1SRetFunction.html">SRetFunction&lt; SignatureT, IRFunction&lt; SignatureT &gt; &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8de268c51f9ff1f2957fd4d64658f2d1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionSRet.html#a8de268c51f9ff1f2957fd4d64658f2d1">BaseT</a> = <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1SRetFunction.html">SRetFunction</a>&lt; SignatureT, <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunction.html">IRFunction</a>&lt; SignatureT &gt;&gt;</td></tr>
<tr class="separator:a8de268c51f9ff1f2957fd4d64658f2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0369aa802ea699423de0552c44a42b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1SRetFunction.html#a1f0369aa802ea699423de0552c44a42b">Ptr</a> = std::shared_ptr&lt; <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1SRetFunction.html">SRetFunction</a>&lt; SignatureT, <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunction.html">IRFunction</a>&lt; SignatureT &gt; &gt;&gt;</td></tr>
<tr class="separator:a1f0369aa802ea699423de0552c44a42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2846ade648824cd69bd0fdc3d2cee4ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1SRetFunction.html#a2846ade648824cd69bd0fdc3d2cee4ca">Traits</a> = <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1FunctionTraits.html">FunctionTraits</a>&lt; SignatureT &gt;</td></tr>
<tr class="separator:a2846ade648824cd69bd0fdc3d2cee4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5edcb96ae02431063bec4c01fea613"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a2d5edcb96ae02431063bec4c01fea613">GeneratorCb</a> = std::function&lt; llvm::Value *(const std::vector&lt; llvm::Value * &gt; &amp;, llvm::IRBuilder&lt;&gt; &amp;)&gt;</td></tr>
<tr class="memdesc:a2d5edcb96ae02431063bec4c01fea613"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IR callback function which will write the LLVM IR for this function's body.  <a href="#a2d5edcb96ae02431063bec4c01fea613">More...</a><br /></td></tr>
<tr class="separator:a2d5edcb96ae02431063bec4c01fea613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8c90b86fef2410c5903bcdd9df708c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">SignatureMatch</a> { <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708cac9d3e887722f2bc482bcca9d41c512af">None</a> = 0, 
<a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708caff9abf2b1a689f70a77a18da50c01d9f">Size</a>, 
<a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708ca81a198911eba60d4033c233d3ec90ea1">Implicit</a>, 
<a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708cad2dd6ed7eca9210b09941bee2c62735f">Explicit</a>
 }<tr class="memdesc:aee8c90b86fef2410c5903bcdd9df708c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result type from calls to <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#ada1a5e0db7a1333bb336dc130f75a5d0" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>.  <a href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aee8c90b86fef2410c5903bcdd9df708c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e01da2c7ae6e5423d6ce55ac2b79eb7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionSRet.html#a3e01da2c7ae6e5423d6ce55ac2b79eb7">IRFunctionSRet</a> (const std::string &amp;<a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#a7735bbeb07320c3f746b21c6a598c732">symbol</a>, const <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a2d5edcb96ae02431063bec4c01fea613">IRFunctionBase::GeneratorCb</a> &amp;gen)</td></tr>
<tr class="separator:a3e01da2c7ae6e5423d6ce55ac2b79eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39c06fb897294831452116aac107ebf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionSRet.html#ad39c06fb897294831452116aac107ebf">~IRFunctionSRet</a> () override=default</td></tr>
<tr class="separator:ad39c06fb897294831452116aac107ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3478e56d6f1d7325e335df6cd51d951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">Function::SignatureMatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1SRetFunction.html#ae3478e56d6f1d7325e335df6cd51d951">match</a> (const std::vector&lt; llvm::Type * &gt; &amp;args, llvm::LLVMContext &amp;C) const  override</td></tr>
<tr class="memdesc:ae3478e56d6f1d7325e335df6cd51d951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of match which inserts the SRET type such that the base class methods ignore it.  <a href="#ae3478e56d6f1d7325e335df6cd51d951">More...</a><br /></td></tr>
<tr class="separator:ae3478e56d6f1d7325e335df6cd51d951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53beecbf86146a2e18686add3c227c3e"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1SRetFunction.html#a53beecbf86146a2e18686add3c227c3e">call</a> (const std::vector&lt; llvm::Value * &gt; &amp;args, llvm::IRBuilder&lt;&gt; &amp;B, const bool <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#a3c7bbe5ddababca6b3a2da7a23a25fc1">cast</a>) const  override</td></tr>
<tr class="memdesc:a53beecbf86146a2e18686add3c227c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of call which allocates the required SRET llvm::Value for this function.  <a href="#a53beecbf86146a2e18686add3c227c3e">More...</a><br /></td></tr>
<tr class="separator:a53beecbf86146a2e18686add3c227c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ee0943e6ecb389b72cda657aaaeced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1SRetFunction.html#a47ee0943e6ecb389b72cda657aaaeced">print</a> (llvm::LLVMContext &amp;C, std::ostream &amp;os, const char *name=nullptr, const bool axTypes=true) const  override</td></tr>
<tr class="memdesc:a47ee0943e6ecb389b72cda657aaaeced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of print to avoid printing out the SRET type.  <a href="#a47ee0943e6ecb389b72cda657aaaeced">More...</a><br /></td></tr>
<tr class="separator:a47ee0943e6ecb389b72cda657aaaeced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b75f35c6d4d6956bed1cbba4837069"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunction.html#a04b75f35c6d4d6956bed1cbba4837069">types</a> (std::vector&lt; llvm::Type * &gt; &amp;types, llvm::LLVMContext &amp;C) const  override</td></tr>
<tr class="memdesc:a04b75f35c6d4d6956bed1cbba4837069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a vector of llvm::Types which describe this function signature. This method is used by <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#a1c7d49fb9a9339c775f3a83d7dac9d69" title="Converts and creates this AX function into a llvm Function. ">Function::create</a>, <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#abd8791caa902661a1de7954693348c4a" title="Print this function&#39;s signature to the provided ostream. ">Function::print</a> and <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#ada1a5e0db7a1333bb336dc130f75a5d0" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>.  <a href="#a04b75f35c6d4d6956bed1cbba4837069">More...</a><br /></td></tr>
<tr class="separator:a04b75f35c6d4d6956bed1cbba4837069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362ecd72d1dfb66426eb7658c5147849"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a362ecd72d1dfb66426eb7658c5147849">setEmbedIR</a> (bool on)</td></tr>
<tr class="memdesc:a362ecd72d1dfb66426eb7658c5147849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the embedding of IR. Embedded IR is currently required for function which use parent function parameters.  <a href="#a362ecd72d1dfb66426eb7658c5147849">More...</a><br /></td></tr>
<tr class="separator:a362ecd72d1dfb66426eb7658c5147849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df3cf30dd6fd82aa659bba46b195a04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a6df3cf30dd6fd82aa659bba46b195a04">hasEmbedIR</a> () const </td></tr>
<tr class="separator:a6df3cf30dd6fd82aa659bba46b195a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd5821fd845e43ac5beca4358eef9b2"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#afcd5821fd845e43ac5beca4358eef9b2">create</a> (llvm::LLVMContext &amp;C, llvm::Module *M) const  override</td></tr>
<tr class="memdesc:afcd5821fd845e43ac5beca4358eef9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override for the creation of an IR function. This ensures that the body and prototype of the function are generated if a Module is provided.  <a href="#afcd5821fd845e43ac5beca4358eef9b2">More...</a><br /></td></tr>
<tr class="separator:afcd5821fd845e43ac5beca4358eef9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fea737cad05b175de71a0ebdc13612f"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#a5fea737cad05b175de71a0ebdc13612f">create</a> (llvm::Module &amp;M) const </td></tr>
<tr class="memdesc:a5fea737cad05b175de71a0ebdc13612f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method which always uses the provided module to find the function or insert it if necessary.  <a href="#a5fea737cad05b175de71a0ebdc13612f">More...</a><br /></td></tr>
<tr class="separator:a5fea737cad05b175de71a0ebdc13612f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac782da1f912bceb5d8ad00c8dc892ac"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#aac782da1f912bceb5d8ad00c8dc892ac">size</a> () const </td></tr>
<tr class="memdesc:aac782da1f912bceb5d8ad00c8dc892ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of arguments that this function has.  <a href="#aac782da1f912bceb5d8ad00c8dc892ac">More...</a><br /></td></tr>
<tr class="separator:aac782da1f912bceb5d8ad00c8dc892ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7735bbeb07320c3f746b21c6a598c732"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#a7735bbeb07320c3f746b21c6a598c732">symbol</a> () const </td></tr>
<tr class="memdesc:a7735bbeb07320c3f746b21c6a598c732"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function symbol name.  <a href="#a7735bbeb07320c3f746b21c6a598c732">More...</a><br /></td></tr>
<tr class="separator:a7735bbeb07320c3f746b21c6a598c732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54251bc604333f3dbb1a5ea4a4a808b8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#a54251bc604333f3dbb1a5ea4a4a808b8">argName</a> (const size_t idx) const </td></tr>
<tr class="memdesc:a54251bc604333f3dbb1a5ea4a4a808b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the descriptive name of the given argument index.  <a href="#a54251bc604333f3dbb1a5ea4a4a808b8">More...</a><br /></td></tr>
<tr class="separator:a54251bc604333f3dbb1a5ea4a4a808b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93871197f41264952182593a5c638a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#aa93871197f41264952182593a5c638a3">hasParamAttribute</a> (const size_t i, const llvm::Attribute::AttrKind &amp;kind) const </td></tr>
<tr class="memdesc:aa93871197f41264952182593a5c638a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder methods.  <a href="#aa93871197f41264952182593a5c638a3">More...</a><br /></td></tr>
<tr class="separator:aa93871197f41264952182593a5c638a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6187793e0d3c6b1098b1d037e5b9530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#af6187793e0d3c6b1098b1d037e5b9530">setArgumentNames</a> (std::vector&lt; const char * &gt; names)</td></tr>
<tr class="separator:af6187793e0d3c6b1098b1d037e5b9530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5158708275b343f58432634eff78ecf"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; const char * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#ac5158708275b343f58432634eff78ecf">dependencies</a> () const </td></tr>
<tr class="separator:ac5158708275b343f58432634eff78ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130dc8b5cf81200428494e2d63384483"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#a130dc8b5cf81200428494e2d63384483">setDependencies</a> (std::vector&lt; const char * &gt; deps)</td></tr>
<tr class="separator:a130dc8b5cf81200428494e2d63384483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb0a8f2ddba1d3d98741894a5db5f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#a6fb0a8f2ddba1d3d98741894a5db5f03">setFnAttributes</a> (const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;in)</td></tr>
<tr class="separator:a6fb0a8f2ddba1d3d98741894a5db5f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51952659e55f5546f5e3d8f6a4e56eb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#a51952659e55f5546f5e3d8f6a4e56eb3">setRetAttributes</a> (const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;in)</td></tr>
<tr class="separator:a51952659e55f5546f5e3d8f6a4e56eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359ce980d9f1de2430296ca2f3e42409"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#a359ce980d9f1de2430296ca2f3e42409">setParamAttributes</a> (const size_t i, const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;in)</td></tr>
<tr class="separator:a359ce980d9f1de2430296ca2f3e42409"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a38d7acd53db770ccd6b1eb4705229da9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a38d7acd53db770ccd6b1eb4705229da9">verifyResultType</a> (const llvm::Type *result, const llvm::Type *expected) const </td></tr>
<tr class="separator:a38d7acd53db770ccd6b1eb4705229da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a3c7bbe5ddababca6b3a2da7a23a25fc1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#a3c7bbe5ddababca6b3a2da7a23a25fc1">cast</a> (std::vector&lt; llvm::Value * &gt; &amp;args, const std::vector&lt; llvm::Type * &gt; &amp;<a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunction.html#a04b75f35c6d4d6956bed1cbba4837069">types</a>, llvm::IRBuilder&lt;&gt; &amp;B)</td></tr>
<tr class="memdesc:a3c7bbe5ddababca6b3a2da7a23a25fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the provided arguments to the given type as supported by implicit casting of function types. If the types already match OR if a cast cannot be performed, nothing is done to the argument.  <a href="#a3c7bbe5ddababca6b3a2da7a23a25fc1">More...</a><br /></td></tr>
<tr class="separator:a3c7bbe5ddababca6b3a2da7a23a25fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a759f26538364f576b1bf79b29ec229be"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a2d5edcb96ae02431063bec4c01fea613">GeneratorCb</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a759f26538364f576b1bf79b29ec229be">mGen</a></td></tr>
<tr class="separator:a759f26538364f576b1bf79b29ec229be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f06f4cf7b3192fa886efa709090daeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a9f06f4cf7b3192fa886efa709090daeb">mEmbedIR</a></td></tr>
<tr class="separator:a9f06f4cf7b3192fa886efa709090daeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename SignatureT&gt;<br />
struct openvdb::v8_0::ax::codegen::IRFunctionSRet&lt; SignatureT &gt;</h3>

<p>Represents a concrete IR function with the first argument as its return type. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a8de268c51f9ff1f2957fd4d64658f2d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionSRet.html#a8de268c51f9ff1f2957fd4d64658f2d1">BaseT</a> =  <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1SRetFunction.html">SRetFunction</a>&lt;SignatureT, <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunction.html">IRFunction</a>&lt;SignatureT&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2d5edcb96ae02431063bec4c01fea613"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a2d5edcb96ae02431063bec4c01fea613">GeneratorCb</a> =  std::function&lt;llvm::Value* (const std::vector&lt;llvm::Value*&gt;&amp;, llvm::IRBuilder&lt;&gt;&amp;)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The IR callback function which will write the LLVM IR for this function's body. </p>
<p>The first argument is the vector of functional arguments. i.e. a representation of the value that the callback has been invoked with. The last argument is the IR builder which should be used to generate the function body IR. </p><dl class="section note"><dt>Note</dt><dd>You can return a nullptr from this method which will represent a ret void, a ret void instruction, or an actual value </dd></dl>

</div>
</div>
<a class="anchor" id="a1f0369aa802ea699423de0552c44a42b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#a70d985fa48c8b1bd1f0d85cf96ec82d6">Ptr</a> =  std::shared_ptr&lt;<a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1SRetFunction.html">SRetFunction</a>&lt;SignatureT, <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunction.html">IRFunction</a>&lt; SignatureT &gt; &gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2846ade648824cd69bd0fdc3d2cee4ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunction.html#a2846ade648824cd69bd0fdc3d2cee4ca">Traits</a> =  <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1FunctionTraits.html">FunctionTraits</a>&lt;SignatureT&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="aee8c90b86fef2410c5903bcdd9df708c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">SignatureMatch</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The result type from calls to <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#ada1a5e0db7a1333bb336dc130f75a5d0" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aee8c90b86fef2410c5903bcdd9df708cac9d3e887722f2bc482bcca9d41c512af"></a>None&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee8c90b86fef2410c5903bcdd9df708caff9abf2b1a689f70a77a18da50c01d9f"></a>Size&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee8c90b86fef2410c5903bcdd9df708ca81a198911eba60d4033c233d3ec90ea1"></a>Implicit&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee8c90b86fef2410c5903bcdd9df708cad2dd6ed7eca9210b09941bee2c62735f"></a>Explicit&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3e01da2c7ae6e5423d6ce55ac2b79eb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionSRet.html">IRFunctionSRet</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a2d5edcb96ae02431063bec4c01fea613">IRFunctionBase::GeneratorCb</a> &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad39c06fb897294831452116aac107ebf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionSRet.html">IRFunctionSRet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a54251bc604333f3dbb1a5ea4a4a808b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* argName </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the descriptive name of the given argument index. </p>
<p>If the index is greater than the number of arguments, an empty string is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53beecbf86146a2e18686add3c227c3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* call </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>cast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override of call which allocates the required SRET llvm::Value for this function. </p>
<dl class="section note"><dt>Note</dt><dd>Unlike other function where the returned llvm::Value* is a llvm::CallInst (which also represents the return value), SRET functions return the allocated 1st argument i.e. not a llvm::CallInst </dd></dl>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a53beecbf86146a2e18686add3c227c3e">IRFunctionBase</a>.</p>

</div>
</div>
<a class="anchor" id="a3c7bbe5ddababca6b3a2da7a23a25fc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cast </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; llvm::Type * &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast the provided arguments to the given type as supported by implicit casting of function types. If the types already match OR if a cast cannot be performed, nothing is done to the argument. </p>

</div>
</div>
<a class="anchor" id="a5fea737cad05b175de71a0ebdc13612f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function* create </td>
          <td>(</td>
          <td class="paramtype">llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method which always uses the provided module to find the function or insert it if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The llvm::Module to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcd5821fd845e43ac5beca4358eef9b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function* create </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override for the creation of an IR function. This ensures that the body and prototype of the function are generated if a Module is provided. </p>
<dl class="section note"><dt>Note</dt><dd>A nullptr is returned if mEmbedIR is true and no action is performed. </dd>
<dd>
Throws if this function has been initialized with a nullptr generator callback. In this case, the function prototype will be created, but not the function body. </dd>
<dd>
Throws if the return type of the generator callback does not match the function prototype. In this case, both the prototype and the function body will be created and inserted, but the IR will be invalid. </dd></dl>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#a1c7d49fb9a9339c775f3a83d7dac9d69">Function</a>.</p>

</div>
</div>
<a class="anchor" id="ac5158708275b343f58432634eff78ecf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;const char*&gt;&amp; dependencies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6df3cf30dd6fd82aa659bba46b195a04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasEmbedIR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa93871197f41264952182593a5c638a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasParamAttribute </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Attribute::AttrKind &amp;&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builder methods. </p>

</div>
</div>
<a class="anchor" id="ae3478e56d6f1d7325e335df6cd51d951"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">Function::SignatureMatch</a> match </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Type * &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override of match which inserts the SRET type such that the base class methods ignore it. </p>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#ada1a5e0db7a1333bb336dc130f75a5d0">Function</a>.</p>

</div>
</div>
<a class="anchor" id="a47ee0943e6ecb389b72cda657aaaeced"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void print </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>axTypes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override of print to avoid printing out the SRET type. </p>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#abd8791caa902661a1de7954693348c4a">Function</a>.</p>

</div>
</div>
<a class="anchor" id="af6187793e0d3c6b1098b1d037e5b9530"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setArgumentNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a130dc8b5cf81200428494e2d63384483"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setDependencies </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>deps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a362ecd72d1dfb66426eb7658c5147849"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setEmbedIR </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable the embedding of IR. Embedded IR is currently required for function which use parent function parameters. </p>

</div>
</div>
<a class="anchor" id="a6fb0a8f2ddba1d3d98741894a5db5f03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setFnAttributes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a359ce980d9f1de2430296ca2f3e42409"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setParamAttributes </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a51952659e55f5546f5e3d8f6a4e56eb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setRetAttributes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aac782da1f912bceb5d8ad00c8dc892ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of arguments that this function has. </p>

</div>
</div>
<a class="anchor" id="a7735bbeb07320c3f746b21c6a598c732"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* symbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function symbol name. </p>
<p>This will be used as its identifier in IR and must be unique. </p>

</div>
</div>
<a class="anchor" id="a04b75f35c6d4d6956bed1cbba4837069"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type* types </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Type * &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a vector of llvm::Types which describe this function signature. This method is used by <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#a1c7d49fb9a9339c775f3a83d7dac9d69" title="Converts and creates this AX function into a llvm Function. ">Function::create</a>, <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#abd8791caa902661a1de7954693348c4a" title="Print this function&#39;s signature to the provided ostream. ">Function::print</a> and <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html#ada1a5e0db7a1333bb336dc130f75a5d0" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>. </p>

<p>Implements <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#aba87622bfcd6b5a4d1d04a750dacb0ea">IRFunctionBase</a>.</p>

</div>
</div>
<a class="anchor" id="a38d7acd53db770ccd6b1eb4705229da9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void verifyResultType </td>
          <td>(</td>
          <td class="paramtype">const llvm::Type *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Type *&#160;</td>
          <td class="paramname"><em>expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a9f06f4cf7b3192fa886efa709090daeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mEmbedIR</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a759f26538364f576b1bf79b29ec229be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1IRFunctionBase.html#a2d5edcb96ae02431063bec4c01fea613">GeneratorCb</a> mGen</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="FunctionTypes_8h_source.html">FunctionTypes.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
