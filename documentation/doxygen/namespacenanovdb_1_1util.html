<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: nanovdb::util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacenanovdb_1_1util.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">nanovdb::util Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:impl" id="r_impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenanovdb_1_1util_1_1impl.html">impl</a></td></tr>
<tr class="memitem:morphology" id="r_morphology"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenanovdb_1_1util_1_1morphology.html">morphology</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:conditional" id="r_conditional"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1conditional.html">conditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++11 implementation of std::conditional.  <a href="structnanovdb_1_1util_1_1conditional.html#details">More...</a><br /></td></tr>
<tr class="memitem:conditional_3C_20false_2C_20TrueT_2C_20FalseT_20_3E" id="r_conditional_3C_20false_2C_20TrueT_2C_20FalseT_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1conditional_3_01false_00_01TrueT_00_01FalseT_01_4.html">conditional&lt; false, TrueT, FalseT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of conditional.  <a href="structnanovdb_1_1util_1_1conditional_3_01false_00_01TrueT_00_01FalseT_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:disable_5Fif" id="r_disable_5Fif"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1disable__if.html">disable_if</a></td></tr>
<tr class="memitem:disable_5Fif_3C_20true_2C_20T_20_3E" id="r_disable_5Fif_3C_20true_2C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1disable__if_3_01true_00_01T_01_4.html">disable_if&lt; true, T &gt;</a></td></tr>
<tr class="memitem:enable_5Fif" id="r_enable_5Fif"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">enable_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++11 implementation of std::enable_if.  <a href="structnanovdb_1_1util_1_1enable__if.html#details">More...</a><br /></td></tr>
<tr class="memitem:enable_5Fif_3C_20true_2C_20T_20_3E" id="r_enable_5Fif_3C_20true_2C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1enable__if_3_01true_00_01T_01_4.html">enable_if&lt; true, T &gt;</a></td></tr>
<tr class="memitem:is_5Fconst" id="r_is_5Fconst"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1is__const.html">is_const</a></td></tr>
<tr class="memitem:is_5Fconst_3C_20const_20T_20_3E" id="r_is_5Fconst_3C_20const_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1is__const_3_01const_01T_01_4.html">is_const&lt; const T &gt;</a></td></tr>
<tr class="memitem:is_5Ffloating_5Fpoint" id="r_is_5Ffloating_5Fpoint"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++11 implementation of std::is_floating_point.  <a href="structnanovdb_1_1util_1_1is__floating__point.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fpointer" id="r_is_5Fpointer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1is__pointer.html">is_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait used to identify template parameter that are pointers.  <a href="structnanovdb_1_1util_1_1is__pointer.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fpointer_3C_20T_20_2A_20_3E" id="r_is_5Fpointer_3C_20T_20_2A_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1is__pointer_3_01T_01_5_01_4.html">is_pointer&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of pointers.  <a href="structnanovdb_1_1util_1_1is__pointer_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fsame" id="r_is_5Fsame"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1is__same.html">is_same</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++11 implementation of std::is_same.  <a href="structnanovdb_1_1util_1_1is__same.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fsame_3C_20T_2C_20T_20_3E" id="r_is_5Fsame_3C_20T_2C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1is__same_3_01T_00_01T_01_4.html">is_same&lt; T, T &gt;</a></td></tr>
<tr class="memitem:is_5Fsame_3C_20T0_2C_20T1_20_3E" id="r_is_5Fsame_3C_20T0_2C_20T1_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1is__same_3_01T0_00_01T1_01_4.html">is_same&lt; T0, T1 &gt;</a></td></tr>
<tr class="memitem:is_5Fspecialization" id="r_is_5Fspecialization"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1is__specialization.html">is_specialization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction used to determine if the first template parameter is a specialization of the class template given in the second template parameter.  <a href="structnanovdb_1_1util_1_1is__specialization.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fspecialization_3C_20TemplateType_3C_20Args_2E_2E_2E_20_3E_2C_20TemplateType_20_3E" id="r_is_5Fspecialization_3C_20TemplateType_3C_20Args_2E_2E_2E_20_3E_2C_20TemplateType_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1is__specialization_3_01TemplateType_3_01Args_8_8_8_01_4_00_01TemplateType_01_4.html">is_specialization&lt; TemplateType&lt; Args... &gt;, TemplateType &gt;</a></td></tr>
<tr class="memitem:match_5Fconst" id="r_match_5Fconst"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1match__const.html">match_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait used to transfer the const-ness of a reference type to another type.  <a href="structnanovdb_1_1util_1_1match__const.html#details">More...</a><br /></td></tr>
<tr class="memitem:match_5Fconst_3C_20T_2C_20const_20ReferenceT_20_3E" id="r_match_5Fconst_3C_20T_2C_20const_20ReferenceT_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1match__const_3_01T_00_01const_01ReferenceT_01_4.html">match_const&lt; T, const ReferenceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization used to transfer the const-ness of a reference type to another type.  <a href="structnanovdb_1_1util_1_1match__const_3_01T_00_01const_01ReferenceT_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:Range" id="r_Range"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnanovdb_1_1util_1_1Range.html">Range</a></td></tr>
<tr class="memitem:Range_3C_201_2C_20T_20_3E" id="r_Range_3C_201_2C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnanovdb_1_1util_1_1Range_3_011_00_01T_01_4.html">Range&lt; 1, T &gt;</a></td></tr>
<tr class="memitem:Range_3C_202_2C_20T_20_3E" id="r_Range_3C_202_2C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnanovdb_1_1util_1_1Range_3_012_00_01T_01_4.html">Range&lt; 2, T &gt;</a></td></tr>
<tr class="memitem:Range_3C_203_2C_20T_20_3E" id="r_Range_3C_203_2C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnanovdb_1_1util_1_1Range_3_013_00_01T_01_4.html">Range&lt; 3, T &gt;</a></td></tr>
<tr class="memitem:remove_5Fconst" id="r_remove_5Fconst"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1remove__const.html">remove_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait use to const from type. Default implementation is just a pass-through.  <a href="structnanovdb_1_1util_1_1remove__const.html#details">More...</a><br /></td></tr>
<tr class="memitem:remove_5Fconst_3C_20const_20T_20_3E" id="r_remove_5Fconst_3C_20const_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1remove__const_3_01const_01T_01_4.html">remove_const&lt; const T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of trait class use to remove const qualifier type from a type.  <a href="structnanovdb_1_1util_1_1remove__const_3_01const_01T_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:remove_5Fpointer" id="r_remove_5Fpointer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1remove__pointer.html">remove_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait use to remove pointer, i.e. "*", qualifier from a type. Default implementation is just a pass-through.  <a href="structnanovdb_1_1util_1_1remove__pointer.html#details">More...</a><br /></td></tr>
<tr class="memitem:remove_5Fpointer_3C_20T_20_2A_20_3E" id="r_remove_5Fpointer_3C_20T_20_2A_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1remove__pointer_3_01T_01_5_01_4.html">remove_pointer&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of trait class use to to remove pointer, i.e. "*", qualifier from a type.  <a href="structnanovdb_1_1util_1_1remove__pointer_3_01T_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:remove_5Freference" id="r_remove_5Freference"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1remove__reference.html">remove_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait use to remove reference, i.e. "&amp;", qualifier from a type. Default implementation is just a pass-through.  <a href="structnanovdb_1_1util_1_1remove__reference.html#details">More...</a><br /></td></tr>
<tr class="memitem:remove_5Freference_3C_20T_20_26_20_3E" id="r_remove_5Freference_3C_20T_20_26_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1util_1_1remove__reference_3_01T_01_6_01_4.html">remove_reference&lt; T &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization of trait class use to remove reference, i.e. "&amp;", qualifier from a type.  <a href="structnanovdb_1_1util_1_1remove__reference_3_01T_01_6_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:Split" id="r_Split"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnanovdb_1_1util_1_1Split.html">Split</a></td></tr>
<tr class="memitem:Timer" id="r_Timer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnanovdb_1_1util_1_1Timer.html">Timer</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af3673a774597551e15a27cdf4ac7e71d" id="r_af3673a774597551e15a27cdf4ac7e71d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3673a774597551e15a27cdf4ac7e71d">Range1D</a> = <a class="el" href="classnanovdb_1_1util_1_1Range.html">Range</a>&lt;1, size_t&gt;</td></tr>
<tr class="memitem:abf41916a456c149b99f70070d372b9d2" id="r_abf41916a456c149b99f70070d372b9d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf41916a456c149b99f70070d372b9d2">Range2D</a> = <a class="el" href="classnanovdb_1_1util_1_1Range.html">Range</a>&lt;2, size_t&gt;</td></tr>
<tr class="memitem:a6065157b6cb3382d22e4fd2fc70eb0c0" id="r_a6065157b6cb3382d22e4fd2fc70eb0c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6065157b6cb3382d22e4fd2fc70eb0c0">Range3D</a> = <a class="el" href="classnanovdb_1_1util_1_1Range.html">Range</a>&lt;3, size_t&gt;</td></tr>
<tr class="memitem:afd80b775b0bd95747206fc628ad065f0" id="r_afd80b775b0bd95747206fc628ad065f0"><td class="memTemplParams" colspan="2">template&lt;bool Test, typename T = void&gt; </td></tr>
<tr class="memitem:afd80b775b0bd95747206fc628ad065f0 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd80b775b0bd95747206fc628ad065f0">enable_if_t</a> = typename <a class="el" href="structnanovdb_1_1util_1_1enable__if.html">enable_if</a>&lt;Test, T&gt;::type</td></tr>
<tr class="memitem:aefa8141e3acbf997a858072900827516" id="r_aefa8141e3acbf997a858072900827516"><td class="memTemplParams" colspan="2">template&lt;bool Test, typename T = void&gt; </td></tr>
<tr class="memitem:aefa8141e3acbf997a858072900827516 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefa8141e3acbf997a858072900827516">disable_if_t</a> = typename <a class="el" href="structnanovdb_1_1util_1_1disable__if.html">disable_if</a>&lt;Test, T&gt;::type</td></tr>
<tr class="memitem:a9f453fbca8b93aa016556b17d03c9850" id="r_a9f453fbca8b93aa016556b17d03c9850"><td class="memTemplParams" colspan="2">template&lt;bool Test, class TrueT, class FalseT&gt; </td></tr>
<tr class="memitem:a9f453fbca8b93aa016556b17d03c9850 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f453fbca8b93aa016556b17d03c9850">conditional_t</a> = typename <a class="el" href="structnanovdb_1_1util_1_1conditional.html">conditional</a>&lt;Test, TrueT, FalseT&gt;::type</td></tr>
<tr class="memitem:a75ab6c9a804ec997a6e8cb9c5b36c3e4" id="r_a75ab6c9a804ec997a6e8cb9c5b36c3e4"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a75ab6c9a804ec997a6e8cb9c5b36c3e4 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75ab6c9a804ec997a6e8cb9c5b36c3e4">remove_const_t</a> = typename <a class="el" href="structnanovdb_1_1util_1_1remove__const.html">remove_const</a>&lt;T&gt;::type</td></tr>
<tr class="memitem:ad94dd578c8a2516de4794a7c247605f3" id="r_ad94dd578c8a2516de4794a7c247605f3"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ad94dd578c8a2516de4794a7c247605f3 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad94dd578c8a2516de4794a7c247605f3">remove_reference_t</a> = typename <a class="el" href="structnanovdb_1_1util_1_1remove__const.html">remove_const</a>&lt;T&gt;::type</td></tr>
<tr class="memitem:a81cba9b583535ccfde0e7eb172bbec71" id="r_a81cba9b583535ccfde0e7eb172bbec71"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a81cba9b583535ccfde0e7eb172bbec71 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81cba9b583535ccfde0e7eb172bbec71">remove_pointer_t</a> = typename <a class="el" href="structnanovdb_1_1util_1_1remove__pointer.html">remove_pointer</a>&lt;T&gt;::type</td></tr>
<tr class="memitem:acd9405e80b82bef0fb4b2312d512e3e8" id="r_acd9405e80b82bef0fb4b2312d512e3e8"><td class="memTemplParams" colspan="2">template&lt;typename T, typename ReferenceT&gt; </td></tr>
<tr class="memitem:acd9405e80b82bef0fb4b2312d512e3e8 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd9405e80b82bef0fb4b2312d512e3e8">match_const_t</a> = typename <a class="el" href="structnanovdb_1_1util_1_1match__const.html">match_const</a>&lt;T, ReferenceT&gt;::type</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aeecddc2b41154f35c7304658df4a4d85" id="r_aeecddc2b41154f35c7304658df4a4d85"><td class="memTemplParams" colspan="2">template&lt;typename RangeT, typename FuncT&gt; </td></tr>
<tr class="memitem:aeecddc2b41154f35c7304658df4a4d85 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeecddc2b41154f35c7304658df4a4d85">forEach</a> (RangeT range, const FuncT &amp;func)</td></tr>
<tr class="memdesc:aeecddc2b41154f35c7304658df4a4d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple wrapper for tbb::parallel_for with a naive std fallback  <br /></td></tr>
<tr class="memitem:aa574309e3ddb090bd7973b0898dd95c0" id="r_aa574309e3ddb090bd7973b0898dd95c0"><td class="memTemplParams" colspan="2">template&lt;typename FuncT&gt; </td></tr>
<tr class="memitem:aa574309e3ddb090bd7973b0898dd95c0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa574309e3ddb090bd7973b0898dd95c0">forEach</a> (size_t begin, size_t end, size_t grainSize, const FuncT &amp;func)</td></tr>
<tr class="memdesc:aa574309e3ddb090bd7973b0898dd95c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper for the function defined above.  <br /></td></tr>
<tr class="memitem:a7cd7d9ef9958d5c86962f2c129091c4a" id="r_a7cd7d9ef9958d5c86962f2c129091c4a"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class ContainerT, typename... T, typename FuncT&gt; </td></tr>
<tr class="memitem:a7cd7d9ef9958d5c86962f2c129091c4a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cd7d9ef9958d5c86962f2c129091c4a">forEach</a> (const ContainerT&lt; T... &gt; &amp;c, const FuncT &amp;func)</td></tr>
<tr class="memdesc:a7cd7d9ef9958d5c86962f2c129091c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper for the function defined above, which works with std::containers.  <br /></td></tr>
<tr class="memitem:ac906357e63c1a3a9cffceacbf311d022" id="r_ac906357e63c1a3a9cffceacbf311d022"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class ContainerT, typename... T, typename FuncT&gt; </td></tr>
<tr class="memitem:ac906357e63c1a3a9cffceacbf311d022 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac906357e63c1a3a9cffceacbf311d022">forEach</a> (const ContainerT&lt; T... &gt; &amp;c, size_t grainSize, const FuncT &amp;func)</td></tr>
<tr class="memdesc:ac906357e63c1a3a9cffceacbf311d022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper for the function defined above, which works with std::containers.  <br /></td></tr>
<tr class="memitem:a9fa34a074151d9dae08f4fcfcfc164f8" id="r_a9fa34a074151d9dae08f4fcfcfc164f8"><td class="memTemplParams" colspan="2">template&lt;typename Func, typename... Rest&gt; </td></tr>
<tr class="memitem:a9fa34a074151d9dae08f4fcfcfc164f8 template"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fa34a074151d9dae08f4fcfcfc164f8">invoke</a> (const Func &amp;taskFunc1, Rest... taskFuncN)</td></tr>
<tr class="memitem:ac06981b465ecffc4663e5b905abca429" id="r_ac06981b465ecffc4663e5b905abca429"><td class="memTemplParams" colspan="2">template&lt;typename T, typename OpT = std::plus&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ac06981b465ecffc4663e5b905abca429 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac06981b465ecffc4663e5b905abca429">prefixSum</a> (std::vector&lt; T &gt; &amp;vec, bool threaded=true, OpT op=OpT())</td></tr>
<tr class="memdesc:ac06981b465ecffc4663e5b905abca429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes inclusive prefix sum of a vector.  <br /></td></tr>
<tr class="memitem:ac18f6ee0142f7ddcf2caeee8c422f97a" id="r_ac18f6ee0142f7ddcf2caeee8c422f97a"><td class="memTemplParams" colspan="2">template&lt;typename T, typename Op&gt; </td></tr>
<tr class="memitem:ac18f6ee0142f7ddcf2caeee8c422f97a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac18f6ee0142f7ddcf2caeee8c422f97a">inclusiveScan</a> (T *array, size_t size, const T &amp;identity, bool threaded, Op op)</td></tr>
<tr class="memdesc:ac18f6ee0142f7ddcf2caeee8c422f97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inclusive scan includes in[i] when computing out[i].  <br /></td></tr>
<tr class="memitem:a4a7d097db592a925e7d4adb63fb764ff" id="r_a4a7d097db592a925e7d4adb63fb764ff"><td class="memTemplParams" colspan="2">template&lt;typename RangeT, typename T, typename FuncT, typename JoinT&gt; </td></tr>
<tr class="memitem:a4a7d097db592a925e7d4adb63fb764ff template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a7d097db592a925e7d4adb63fb764ff">reduce</a> (RangeT range, const T &amp;identity, const FuncT &amp;func, const JoinT &amp;join)</td></tr>
<tr class="memitem:a9bfe6769cee6e711d758b56c953192e8" id="r_a9bfe6769cee6e711d758b56c953192e8"><td class="memTemplParams" colspan="2">template&lt;typename T, typename FuncT, typename JoinT&gt; </td></tr>
<tr class="memitem:a9bfe6769cee6e711d758b56c953192e8 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bfe6769cee6e711d758b56c953192e8">reduce</a> (size_t begin, size_t end, size_t grainSize, const T &amp;identity, const FuncT &amp;func, const JoinT &amp;join)</td></tr>
<tr class="memdesc:a9bfe6769cee6e711d758b56c953192e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper to the function defined above.  <br /></td></tr>
<tr class="memitem:a6944240b47d28520b2479e88cba70098" id="r_a6944240b47d28520b2479e88cba70098"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class ContainerT, typename... ArgT, typename T, typename FuncT, typename JoinT&gt; </td></tr>
<tr class="memitem:a6944240b47d28520b2479e88cba70098 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6944240b47d28520b2479e88cba70098">reduce</a> (const ContainerT&lt; ArgT... &gt; &amp;c, const T &amp;identity, const FuncT &amp;func, const JoinT &amp;join)</td></tr>
<tr class="memdesc:a6944240b47d28520b2479e88cba70098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper that works with std::containers.  <br /></td></tr>
<tr class="memitem:a8e86a9eb8e5d6ab2dd7e9cc0133b1039" id="r_a8e86a9eb8e5d6ab2dd7e9cc0133b1039"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class ContainerT, typename... ArgT, typename T, typename FuncT, typename JoinT&gt; </td></tr>
<tr class="memitem:a8e86a9eb8e5d6ab2dd7e9cc0133b1039 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e86a9eb8e5d6ab2dd7e9cc0133b1039">reduce</a> (const ContainerT&lt; ArgT... &gt; &amp;c, size_t grainSize, const T &amp;identity, const FuncT &amp;func, const JoinT &amp;join)</td></tr>
<tr class="memdesc:a8e86a9eb8e5d6ab2dd7e9cc0133b1039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper that works with std::containers.  <br /></td></tr>
<tr class="memitem:adead617f07ae8f9cac9768fafb25dff5" id="r_adead617f07ae8f9cac9768fafb25dff5"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:adead617f07ae8f9cac9768fafb25dff5 template"><td class="memItemLeft" align="right" valign="top">T &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adead617f07ae8f9cac9768fafb25dff5">declval</a> () noexcept</td></tr>
<tr class="memdesc:adead617f07ae8f9cac9768fafb25dff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal implementation of std::declval, which converts any type <code>T</code> to.  <br /></td></tr>
<tr class="memitem:a77e7922c6a5dabb3b37e9803a0a25874" id="r_a77e7922c6a5dabb3b37e9803a0a25874"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77e7922c6a5dabb3b37e9803a0a25874">empty</a> (const char *str)</td></tr>
<tr class="memdesc:a77e7922c6a5dabb3b37e9803a0a25874"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if a c-string <code>str</code> is empty, that is its first value is '\0'  <br /></td></tr>
<tr class="memitem:a008e171a518fe0e0352f31b245e03875" id="r_a008e171a518fe0e0352f31b245e03875"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a008e171a518fe0e0352f31b245e03875">strlen</a> (const char *str)</td></tr>
<tr class="memdesc:a008e171a518fe0e0352f31b245e03875"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of a c-sting, excluding '\0'.  <br /></td></tr>
<tr class="memitem:a66e363031a1cbf510d5eafe40d49a790" id="r_a66e363031a1cbf510d5eafe40d49a790"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66e363031a1cbf510d5eafe40d49a790">strcpy</a> (char *dst, const char *src)</td></tr>
<tr class="memdesc:a66e363031a1cbf510d5eafe40d49a790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy characters from <code>src</code> to <code>dst</code>.  <br /></td></tr>
<tr class="memitem:a205a3bbe3202f23646528d9f3cd381ed" id="r_a205a3bbe3202f23646528d9f3cd381ed"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a205a3bbe3202f23646528d9f3cd381ed">strncpy</a> (char *dst, const char *src, size_t max)</td></tr>
<tr class="memdesc:a205a3bbe3202f23646528d9f3cd381ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the first num characters of <code>src</code> to <code>dst</code>. If the end of the source C string (which is signaled by a null-character) is found before <code>max</code> characters have been copied, <code>dst</code> is padded with zeros until a total of <code>max</code> characters have been written to it.  <br /></td></tr>
<tr class="memitem:a58636a29fe16a33a15bcd689d6f089db" id="r_a58636a29fe16a33a15bcd689d6f089db"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58636a29fe16a33a15bcd689d6f089db">strcpy</a> (char *dst, int num, int bas=10)</td></tr>
<tr class="memdesc:a58636a29fe16a33a15bcd689d6f089db"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a number to a string using a specific base  <br /></td></tr>
<tr class="memitem:a9517a4a50477f651785c09b27826d8ce" id="r_a9517a4a50477f651785c09b27826d8ce"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9517a4a50477f651785c09b27826d8ce">strcat</a> (char *dst, const char *src)</td></tr>
<tr class="memdesc:a9517a4a50477f651785c09b27826d8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a copy of the character string pointed to by <code>src</code> to the end of the character string pointed to by <code>dst</code> on the device.  <br /></td></tr>
<tr class="memitem:a95ea4ce3ac68bde0c80b5a14e06e3f0d" id="r_a95ea4ce3ac68bde0c80b5a14e06e3f0d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95ea4ce3ac68bde0c80b5a14e06e3f0d">strcat</a> (char *dst, int num, int bas=10)</td></tr>
<tr class="memdesc:a95ea4ce3ac68bde0c80b5a14e06e3f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">concatenates a number after a string using a specific base  <br /></td></tr>
<tr class="memitem:a32b497b12670b9b7eb7750351e6bfcad" id="r_a32b497b12670b9b7eb7750351e6bfcad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32b497b12670b9b7eb7750351e6bfcad">strcmp</a> (const char *lhs, const char *rhs)</td></tr>
<tr class="memdesc:a32b497b12670b9b7eb7750351e6bfcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two null-terminated byte strings lexicographically.  <br /></td></tr>
<tr class="memitem:a406ede5c8676c7e5b0abf7650378e422" id="r_a406ede5c8676c7e5b0abf7650378e422"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a406ede5c8676c7e5b0abf7650378e422">streq</a> (const char *lhs, const char *rhs)</td></tr>
<tr class="memdesc:a406ede5c8676c7e5b0abf7650378e422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if two null-terminated byte strings are the same.  <br /></td></tr>
<tr class="memitem:aaef038c38dd786a166c7c520ea7358e4" id="r_aaef038c38dd786a166c7c520ea7358e4"><td class="memTemplParams" colspan="2">template&lt;typename T, typename... Types&gt; </td></tr>
<tr class="memitem:aaef038c38dd786a166c7c520ea7358e4 template"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaef038c38dd786a166c7c520ea7358e4">sprint</a> (char *dst, T var1, Types... var2)</td></tr>
<tr class="memdesc:aaef038c38dd786a166c7c520ea7358e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints a variable number of string and/or numbers to a destination string  <br /></td></tr>
<tr class="memitem:a6517124bbf2d54437b35a919f21684fd" id="r_a6517124bbf2d54437b35a919f21684fd"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6517124bbf2d54437b35a919f21684fd">memzero</a> (void *dst, size_t byteCount)</td></tr>
<tr class="memdesc:a6517124bbf2d54437b35a919f21684fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero initialization of memory.  <br /></td></tr>
<tr class="memitem:a972cc5d2b189bd3d92d00636cf90fc25" id="r_a972cc5d2b189bd3d92d00636cf90fc25"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a972cc5d2b189bd3d92d00636cf90fc25">PtrDiff</a> (const void *p, const void *q)</td></tr>
<tr class="memdesc:a972cc5d2b189bd3d92d00636cf90fc25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance, in bytes, between two pointers, dist = p - q.  <br /></td></tr>
<tr class="memitem:a4d6d6c23a9043216bd7e98ac1afc42a2" id="r_a4d6d6c23a9043216bd7e98ac1afc42a2"><td class="memTemplParams" colspan="2">template&lt;typename DstT = void&gt; </td></tr>
<tr class="memitem:a4d6d6c23a9043216bd7e98ac1afc42a2 template"><td class="memItemLeft" align="right" valign="top">static DstT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d6d6c23a9043216bd7e98ac1afc42a2">PtrAdd</a> (void *p, int64_t offset)</td></tr>
<tr class="memdesc:a4d6d6c23a9043216bd7e98ac1afc42a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a byte offset to a non-const pointer to produce another non-const pointer.  <br /></td></tr>
<tr class="memitem:a52a7b4183a10694afb488451aea79e90" id="r_a52a7b4183a10694afb488451aea79e90"><td class="memTemplParams" colspan="2">template&lt;typename DstT = void&gt; </td></tr>
<tr class="memitem:a52a7b4183a10694afb488451aea79e90 template"><td class="memItemLeft" align="right" valign="top">static const DstT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52a7b4183a10694afb488451aea79e90">PtrAdd</a> (const void *p, int64_t offset)</td></tr>
<tr class="memdesc:a52a7b4183a10694afb488451aea79e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a byte offset to a const pointer to produce another const pointer.  <br /></td></tr>
<tr class="memitem:a86577b0e5b0a98f8f38a2bfdac26e652" id="r_a86577b0e5b0a98f8f38a2bfdac26e652"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86577b0e5b0a98f8f38a2bfdac26e652">findLowestOn</a> (uint32_t v)</td></tr>
<tr class="memdesc:a86577b0e5b0a98f8f38a2bfdac26e652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the lowest, i.e. least significant, on bit in the specified 32 bit word.  <br /></td></tr>
<tr class="memitem:a73c38a3b0f11d4a86f4686de4ef54bc8" id="r_a73c38a3b0f11d4a86f4686de4ef54bc8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73c38a3b0f11d4a86f4686de4ef54bc8">findLowestOn</a> (uint64_t v)</td></tr>
<tr class="memdesc:a73c38a3b0f11d4a86f4686de4ef54bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the lowest, i.e. least significant, on bit in the specified 64 bit word.  <br /></td></tr>
<tr class="memitem:a1285bd5ca3cc77697d29c50e598f0617" id="r_a1285bd5ca3cc77697d29c50e598f0617"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1285bd5ca3cc77697d29c50e598f0617">findHighestOn</a> (uint32_t v)</td></tr>
<tr class="memdesc:a1285bd5ca3cc77697d29c50e598f0617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the highest, i.e. most significant, on bit in the specified 32 bit word.  <br /></td></tr>
<tr class="memitem:a87413e92058cb81b8fe42e102cd36ab2" id="r_a87413e92058cb81b8fe42e102cd36ab2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87413e92058cb81b8fe42e102cd36ab2">findHighestOn</a> (uint64_t v)</td></tr>
<tr class="memdesc:a87413e92058cb81b8fe42e102cd36ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the highest, i.e. most significant, on bit in the specified 64 bit word.  <br /></td></tr>
<tr class="memitem:a0cf31f0377ddc583b6407691b69bdb2f" id="r_a0cf31f0377ddc583b6407691b69bdb2f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cf31f0377ddc583b6407691b69bdb2f">countOn</a> (uint64_t v)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afad3cfcd1c6b755ddbeb802cb5176947" id="r_afad3cfcd1c6b755ddbeb802cb5176947"><td class="memTemplParams" colspan="2">template&lt;typename T0, typename T1, typename ... T&gt; </td></tr>
<tr class="memitem:afad3cfcd1c6b755ddbeb802cb5176947 template"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afad3cfcd1c6b755ddbeb802cb5176947">is_same_v</a> = <a class="el" href="structnanovdb_1_1util_1_1is__same.html">is_same</a>&lt;T0, T1, T...&gt;::value</td></tr>
<tr class="memitem:a8a70da46bf8635132fd3757deb2fff94" id="r_a8a70da46bf8635132fd3757deb2fff94"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a8a70da46bf8635132fd3757deb2fff94 template"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a70da46bf8635132fd3757deb2fff94">is_floating_point_v</a> = <a class="el" href="structnanovdb_1_1util_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::value</td></tr>
<tr class="memitem:a0bf567b7866a96e4005d64743e0859b0" id="r_a0bf567b7866a96e4005d64743e0859b0"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a0bf567b7866a96e4005d64743e0859b0 template"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bf567b7866a96e4005d64743e0859b0">is_const_v</a> = <a class="el" href="structnanovdb_1_1util_1_1is__const.html">is_const</a>&lt;T&gt;::value</td></tr>
<tr class="memitem:a60d8a43ca3d5d473f1651ef5114c2628" id="r_a60d8a43ca3d5d473f1651ef5114c2628"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a60d8a43ca3d5d473f1651ef5114c2628 template"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60d8a43ca3d5d473f1651ef5114c2628">is_pointer_v</a> = <a class="el" href="structnanovdb_1_1util_1_1is__pointer.html">is_pointer</a>&lt;T&gt;::value</td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a9f453fbca8b93aa016556b17d03c9850" name="a9f453fbca8b93aa016556b17d03c9850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f453fbca8b93aa016556b17d03c9850">&#9670;&#160;</a></span>conditional_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Test, class TrueT, class FalseT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9f453fbca8b93aa016556b17d03c9850">conditional_t</a> = typename <a class="el" href="structnanovdb_1_1util_1_1conditional.html">conditional</a>&lt;Test, TrueT, FalseT&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefa8141e3acbf997a858072900827516" name="aefa8141e3acbf997a858072900827516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa8141e3acbf997a858072900827516">&#9670;&#160;</a></span>disable_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Test, typename T = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aefa8141e3acbf997a858072900827516">disable_if_t</a> = typename <a class="el" href="structnanovdb_1_1util_1_1disable__if.html">disable_if</a>&lt;Test, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd80b775b0bd95747206fc628ad065f0" name="afd80b775b0bd95747206fc628ad065f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd80b775b0bd95747206fc628ad065f0">&#9670;&#160;</a></span>enable_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Test, typename T = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afd80b775b0bd95747206fc628ad065f0">enable_if_t</a> = typename <a class="el" href="structnanovdb_1_1util_1_1enable__if.html">enable_if</a>&lt;Test, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd9405e80b82bef0fb4b2312d512e3e8" name="acd9405e80b82bef0fb4b2312d512e3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9405e80b82bef0fb4b2312d512e3e8">&#9670;&#160;</a></span>match_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ReferenceT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acd9405e80b82bef0fb4b2312d512e3e8">match_const_t</a> = typename <a class="el" href="structnanovdb_1_1util_1_1match__const.html">match_const</a>&lt;T, ReferenceT&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3673a774597551e15a27cdf4ac7e71d" name="af3673a774597551e15a27cdf4ac7e71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3673a774597551e15a27cdf4ac7e71d">&#9670;&#160;</a></span>Range1D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af3673a774597551e15a27cdf4ac7e71d">Range1D</a> = <a class="el" href="classnanovdb_1_1util_1_1Range.html">Range</a>&lt;1, size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf41916a456c149b99f70070d372b9d2" name="abf41916a456c149b99f70070d372b9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf41916a456c149b99f70070d372b9d2">&#9670;&#160;</a></span>Range2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abf41916a456c149b99f70070d372b9d2">Range2D</a> = <a class="el" href="classnanovdb_1_1util_1_1Range.html">Range</a>&lt;2, size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6065157b6cb3382d22e4fd2fc70eb0c0" name="a6065157b6cb3382d22e4fd2fc70eb0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6065157b6cb3382d22e4fd2fc70eb0c0">&#9670;&#160;</a></span>Range3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6065157b6cb3382d22e4fd2fc70eb0c0">Range3D</a> = <a class="el" href="classnanovdb_1_1util_1_1Range.html">Range</a>&lt;3, size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75ab6c9a804ec997a6e8cb9c5b36c3e4" name="a75ab6c9a804ec997a6e8cb9c5b36c3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ab6c9a804ec997a6e8cb9c5b36c3e4">&#9670;&#160;</a></span>remove_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a75ab6c9a804ec997a6e8cb9c5b36c3e4">remove_const_t</a> = typename <a class="el" href="structnanovdb_1_1util_1_1remove__const.html">remove_const</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81cba9b583535ccfde0e7eb172bbec71" name="a81cba9b583535ccfde0e7eb172bbec71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81cba9b583535ccfde0e7eb172bbec71">&#9670;&#160;</a></span>remove_pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a81cba9b583535ccfde0e7eb172bbec71">remove_pointer_t</a> = typename <a class="el" href="structnanovdb_1_1util_1_1remove__pointer.html">remove_pointer</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad94dd578c8a2516de4794a7c247605f3" name="ad94dd578c8a2516de4794a7c247605f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94dd578c8a2516de4794a7c247605f3">&#9670;&#160;</a></span>remove_reference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad94dd578c8a2516de4794a7c247605f3">remove_reference_t</a> = typename <a class="el" href="structnanovdb_1_1util_1_1remove__const.html">remove_const</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a0cf31f0377ddc583b6407691b69bdb2f" name="a0cf31f0377ddc583b6407691b69bdb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf31f0377ddc583b6407691b69bdb2f">&#9670;&#160;</a></span>countOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t countOn </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of bits that are on in the specified 64-bit word </dd></dl>

</div>
</div>
<a id="adead617f07ae8f9cac9768fafb25dff5" name="adead617f07ae8f9cac9768fafb25dff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adead617f07ae8f9cac9768fafb25dff5">&#9670;&#160;</a></span>declval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp;&amp; declval </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimal implementation of std::declval, which converts any type <code>T</code> to. </p>
<p>a reference type, making it possible to use member functions in the operand of the decltype specifier without the need to go through constructors. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Template type to be converted to T&amp;&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp;&amp; </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Unlike std::declval, this version does not work when T = void! However, NVRTC does not like std::declval, so we provide our own implementation. </dd></dl>

</div>
</div>
<a id="a77e7922c6a5dabb3b37e9803a0a25874" name="a77e7922c6a5dabb3b37e9803a0a25874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e7922c6a5dabb3b37e9803a0a25874">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tests if a c-string <code>str</code> is empty, that is its first value is '\0' </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>c-string to be tested for null termination </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if str[0] = '\0' </dd></dl>

</div>
</div>
<a id="a1285bd5ca3cc77697d29c50e598f0617" name="a1285bd5ca3cc77697d29c50e598f0617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1285bd5ca3cc77697d29c50e598f0617">&#9670;&#160;</a></span>findHighestOn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t findHighestOn </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the highest, i.e. most significant, on bit in the specified 32 bit word. </p>
<dl class="section warning"><dt>Warning</dt><dd>Assumes that at least one bit is set in the word, i.e. <em class="arg">v</em> != uint32_t(0)! </dd></dl>

</div>
</div>
<a id="a87413e92058cb81b8fe42e102cd36ab2" name="a87413e92058cb81b8fe42e102cd36ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87413e92058cb81b8fe42e102cd36ab2">&#9670;&#160;</a></span>findHighestOn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t findHighestOn </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the highest, i.e. most significant, on bit in the specified 64 bit word. </p>
<dl class="section warning"><dt>Warning</dt><dd>Assumes that at least one bit is set in the word, i.e. <em class="arg">v</em> != uint32_t(0)! </dd></dl>

</div>
</div>
<a id="a86577b0e5b0a98f8f38a2bfdac26e652" name="a86577b0e5b0a98f8f38a2bfdac26e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86577b0e5b0a98f8f38a2bfdac26e652">&#9670;&#160;</a></span>findLowestOn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t findLowestOn </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the lowest, i.e. least significant, on bit in the specified 32 bit word. </p>
<dl class="section warning"><dt>Warning</dt><dd>Assumes that at least one bit is set in the word, i.e. <em class="arg">v</em> != uint32_t(0)! </dd></dl>

</div>
</div>
<a id="a73c38a3b0f11d4a86f4686de4ef54bc8" name="a73c38a3b0f11d4a86f4686de4ef54bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c38a3b0f11d4a86f4686de4ef54bc8">&#9670;&#160;</a></span>findLowestOn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t findLowestOn </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the lowest, i.e. least significant, on bit in the specified 64 bit word. </p>
<dl class="section warning"><dt>Warning</dt><dd>Assumes that at least one bit is set in the word, i.e. <em class="arg">v</em> != uint32_t(0)! </dd></dl>

</div>
</div>
<a id="a7cd7d9ef9958d5c86962f2c129091c4a" name="a7cd7d9ef9958d5c86962f2c129091c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd7d9ef9958d5c86962f2c129091c4a">&#9670;&#160;</a></span>forEach() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class ContainerT, typename... T, typename FuncT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void forEach </td>
          <td>(</td>
          <td class="paramtype">const ContainerT&lt; T... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncT &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple wrapper for the function defined above, which works with std::containers. </p>

</div>
</div>
<a id="ac906357e63c1a3a9cffceacbf311d022" name="ac906357e63c1a3a9cffceacbf311d022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac906357e63c1a3a9cffceacbf311d022">&#9670;&#160;</a></span>forEach() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class ContainerT, typename... T, typename FuncT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void forEach </td>
          <td>(</td>
          <td class="paramtype">const ContainerT&lt; T... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncT &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple wrapper for the function defined above, which works with std::containers. </p>

</div>
</div>
<a id="aeecddc2b41154f35c7304658df4a4d85" name="aeecddc2b41154f35c7304658df4a4d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecddc2b41154f35c7304658df4a4d85">&#9670;&#160;</a></span>forEach() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename FuncT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void forEach </td>
          <td>(</td>
          <td class="paramtype">RangeT</td>          <td class="paramname"><span class="paramname"><em>range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncT &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>simple wrapper for tbb::parallel_for with a naive std fallback </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td><a class="el" href="classnanovdb_1_1util_1_1Range.html">Range</a>, CoordBBox, tbb::blocked_range, blocked_range2D, or blocked_range3D. </td></tr>
    <tr><td class="paramname">func</td><td>functor with the signature [](const RangeT&amp;){...},</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">std::vector&lt;int&gt; array(100);</div>
<div class="line"><span class="keyword">auto</span> func = [&amp;array](<span class="keyword">auto</span> &amp;r){<span class="keywordflow">for</span> (<span class="keyword">auto</span> i=r.begin(); i!=r.end(); ++i) array[i]=i;};</div>
<div class="line"><a class="code hl_function" href="#aeecddc2b41154f35c7304658df4a4d85">forEach</a>(array, func);</div>
<div class="ttc" id="anamespacenanovdb_1_1util_html_aeecddc2b41154f35c7304658df4a4d85"><div class="ttname"><a href="#aeecddc2b41154f35c7304658df4a4d85">nanovdb::util::forEach</a></div><div class="ttdeci">void forEach(RangeT range, const FuncT &amp;func)</div><div class="ttdoc">simple wrapper for tbb::parallel_for with a naive std fallback</div><div class="ttdef"><b>Definition</b> ForEach.h:42</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa574309e3ddb090bd7973b0898dd95c0" name="aa574309e3ddb090bd7973b0898dd95c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa574309e3ddb090bd7973b0898dd95c0">&#9670;&#160;</a></span>forEach() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void forEach </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncT &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple wrapper for the function defined above. </p>

</div>
</div>
<a id="ac18f6ee0142f7ddcf2caeee8c422f97a" name="ac18f6ee0142f7ddcf2caeee8c422f97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18f6ee0142f7ddcf2caeee8c422f97a">&#9670;&#160;</a></span>inclusiveScan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Op&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void inclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>identity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An inclusive scan includes in[i] when computing out[i]. </p>
<dl class="section note"><dt>Note</dt><dd>Inclusive prefix operation: for (i=1; i&lt;N; ++i) vec[i] = Op(vec[i],vec[i-1]) </dd></dl>

</div>
</div>
<a id="a9fa34a074151d9dae08f4fcfcfc164f8" name="a9fa34a074151d9dae08f4fcfcfc164f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa34a074151d9dae08f4fcfcfc164f8">&#9670;&#160;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func, typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int invoke </td>
          <td>(</td>
          <td class="paramtype">const Func &amp;</td>          <td class="paramname"><span class="paramname"><em>taskFunc1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest...</td>          <td class="paramname"><span class="paramname"><em>taskFuncN</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>1 for serial, 2 for tbb multi-threading, and 3 for std multi-threading </dd></dl>

</div>
</div>
<a id="a6517124bbf2d54437b35a919f21684fd" name="a6517124bbf2d54437b35a919f21684fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6517124bbf2d54437b35a919f21684fd">&#9670;&#160;</a></span>memzero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * memzero </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>byteCount</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero initialization of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>pointer to destination </td></tr>
    <tr><td class="paramname">byteCount</td><td>number of bytes to be initialized to zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>destination pointer <code>dst</code> </dd></dl>

</div>
</div>
<a id="ac06981b465ecffc4663e5b905abca429" name="ac06981b465ecffc4663e5b905abca429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06981b465ecffc4663e5b905abca429">&#9670;&#160;</a></span>prefixSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename OpT = std::plus&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T prefixSum </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OpT</td>          <td class="paramname"><span class="paramname"><em>op</em></span><span class="paramdefsep"> = </span><span class="paramdefval">OpT()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes inclusive prefix sum of a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements in the input/out vector </td></tr>
    <tr><td class="paramname">OpT</td><td>Type of operation performed on each element (defaults to sum) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>input and output vector </td></tr>
    <tr><td class="paramname">threaded</td><td>if true multi-threading is used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Inclusive prefix sum: for (i=1; i&lt;N; ++i) vec[i] += vec[i-1] </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>sum of all input elements, which is also the last element of the inclusive prefix sum </dd></dl>

</div>
</div>
<a id="a52a7b4183a10694afb488451aea79e90" name="a52a7b4183a10694afb488451aea79e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a7b4183a10694afb488451aea79e90">&#9670;&#160;</a></span>PtrAdd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DstT = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const DstT * PtrAdd </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a byte offset to a const pointer to produce another const pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DstT</td><td>Type of the return pointer (defaults to void) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>const input pointer, assumed to NOT be NULL </td></tr>
    <tr><td class="paramname">offset</td><td>signed byte offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const pointer defined as the offset of a const input pointer </dd></dl>

</div>
</div>
<a id="a4d6d6c23a9043216bd7e98ac1afc42a2" name="a4d6d6c23a9043216bd7e98ac1afc42a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6d6c23a9043216bd7e98ac1afc42a2">&#9670;&#160;</a></span>PtrAdd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DstT = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DstT * PtrAdd </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a byte offset to a non-const pointer to produce another non-const pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DstT</td><td>Type of the return pointer (defaults to void) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>non-const input pointer, assumed to NOT be NULL </td></tr>
    <tr><td class="paramname">offset</td><td>signed byte offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a non-const pointer defined as the offset of an input pointer </dd></dl>

</div>
</div>
<a id="a972cc5d2b189bd3d92d00636cf90fc25" name="a972cc5d2b189bd3d92d00636cf90fc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972cc5d2b189bd3d92d00636cf90fc25">&#9670;&#160;</a></span>PtrDiff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t PtrDiff </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the distance, in bytes, between two pointers, dist = p - q. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>fist pointer, assumed to NOT be NULL </td></tr>
    <tr><td class="paramname">q</td><td>second pointer, assumed to NOT be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>signed distance between pointer, p - q, addresses in units of bytes </dd></dl>

</div>
</div>
<a id="a6944240b47d28520b2479e88cba70098" name="a6944240b47d28520b2479e88cba70098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6944240b47d28520b2479e88cba70098">&#9670;&#160;</a></span>reduce() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class ContainerT, typename... ArgT, typename T, typename FuncT, typename JoinT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T reduce </td>
          <td>(</td>
          <td class="paramtype">const ContainerT&lt; ArgT... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>identity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncT &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const JoinT &amp;</td>          <td class="paramname"><span class="paramname"><em>join</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple wrapper that works with std::containers. </p>

</div>
</div>
<a id="a8e86a9eb8e5d6ab2dd7e9cc0133b1039" name="a8e86a9eb8e5d6ab2dd7e9cc0133b1039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e86a9eb8e5d6ab2dd7e9cc0133b1039">&#9670;&#160;</a></span>reduce() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class ContainerT, typename... ArgT, typename T, typename FuncT, typename JoinT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T reduce </td>
          <td>(</td>
          <td class="paramtype">const ContainerT&lt; ArgT... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>identity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncT &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const JoinT &amp;</td>          <td class="paramname"><span class="paramname"><em>join</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple wrapper that works with std::containers. </p>

</div>
</div>
<a id="a4a7d097db592a925e7d4adb63fb764ff" name="a4a7d097db592a925e7d4adb63fb764ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7d097db592a925e7d4adb63fb764ff">&#9670;&#160;</a></span>reduce() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT, typename T, typename FuncT, typename JoinT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T reduce </td>
          <td>(</td>
          <td class="paramtype">RangeT</td>          <td class="paramname"><span class="paramname"><em>range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>identity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncT &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const JoinT &amp;</td>          <td class="paramname"><span class="paramname"><em>join</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>reduction</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>RangeT can be <a class="el" href="classnanovdb_1_1util_1_1Range.html">Range&lt;dim,T&gt;</a>, CoordBBox, tbb::blocked_range, blocked_range2D, or blocked_range3D. </td></tr>
    <tr><td class="paramname">identity</td><td>initial value </td></tr>
    <tr><td class="paramname">func</td><td>functor with signature T FuncT::operator()(const RangeT&amp; range, const T&amp; a) const </td></tr>
    <tr><td class="paramname">join</td><td>functor with the signature T JoinT::operator()(const T&amp; a, const T&amp; b) const <div class="fragment"><div class="line">std::vector&lt;int&gt; array(100, 1);</div>
<div class="line"><span class="keyword">auto</span> func = [&amp;array](<span class="keyword">auto</span> &amp;r, <span class="keywordtype">int</span> a){<span class="keywordflow">for</span> (<span class="keyword">auto</span> i=r.begin(); i!=r.end(); ++i) a+=array[i]; <span class="keywordflow">return</span> a;};</div>
<div class="line"><span class="keywordtype">int</span> sum = <a class="code hl_function" href="#a4a7d097db592a925e7d4adb63fb764ff">reduce</a>(array, 0, func, [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b){<span class="keywordflow">return</span> a + b;});</div>
<div class="ttc" id="anamespacenanovdb_1_1util_html_a4a7d097db592a925e7d4adb63fb764ff"><div class="ttname"><a href="#a4a7d097db592a925e7d4adb63fb764ff">nanovdb::util::reduce</a></div><div class="ttdeci">T reduce(RangeT range, const T &amp;identity, const FuncT &amp;func, const JoinT &amp;join)</div><div class="ttdef"><b>Definition</b> Reduce.h:43</div></div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bfe6769cee6e711d758b56c953192e8" name="a9bfe6769cee6e711d758b56c953192e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfe6769cee6e711d758b56c953192e8">&#9670;&#160;</a></span>reduce() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename FuncT, typename JoinT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T reduce </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>identity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncT &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const JoinT &amp;</td>          <td class="paramname"><span class="paramname"><em>join</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple wrapper to the function defined above. </p>

</div>
</div>
<a id="aaef038c38dd786a166c7c520ea7358e4" name="aaef038c38dd786a166c7c520ea7358e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef038c38dd786a166c7c520ea7358e4">&#9670;&#160;</a></span>sprint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * sprint </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>var1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Types...</td>          <td class="paramname"><span class="paramname"><em>var2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prints a variable number of string and/or numbers to a destination string </p>

</div>
</div>
<a id="a9517a4a50477f651785c09b27826d8ce" name="a9517a4a50477f651785c09b27826d8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9517a4a50477f651785c09b27826d8ce">&#9670;&#160;</a></span>strcat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * strcat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a copy of the character string pointed to by <code>src</code> to the end of the character string pointed to by <code>dst</code> on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>pointer to the null-terminated byte string to append to. </td></tr>
    <tr><td class="paramname">src</td><td>pointer to the null-terminated byte string to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the character array being appended to. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Emulates the behaviour of std::strcat, except this version also runs on the GPU. </dd></dl>

</div>
</div>
<a id="a95ea4ce3ac68bde0c80b5a14e06e3f0d" name="a95ea4ce3ac68bde0c80b5a14e06e3f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ea4ce3ac68bde0c80b5a14e06e3f0d">&#9670;&#160;</a></span>strcat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * strcat </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bas</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>concatenates a number after a string using a specific base </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>null terminated destination string </td></tr>
    <tr><td class="paramname">num</td><td>signed number to be concatenated after <code>dst</code> </td></tr>
    <tr><td class="paramname">bas</td><td>base used when converting <code>num</code> to a string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>destination string <code>dst</code> </dd></dl>

</div>
</div>
<a id="a32b497b12670b9b7eb7750351e6bfcad" name="a32b497b12670b9b7eb7750351e6bfcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b497b12670b9b7eb7750351e6bfcad">&#9670;&#160;</a></span>strcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int strcmp </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two null-terminated byte strings lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>pointer to the null-terminated byte strings to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>pointer to the null-terminated byte strings to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negative value if <code>lhs</code> appears before <code>rhs</code> in lexicographical order. Zero if <code>lhs</code> and <code>rhs</code> compare equal. Positive value if <code>lhs</code> appears after <code>rhs</code> in lexicographical order. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Emulates the behaviour of std::strcmp, except this version also runs on the GPU. </dd></dl>

</div>
</div>
<a id="a66e363031a1cbf510d5eafe40d49a790" name="a66e363031a1cbf510d5eafe40d49a790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e363031a1cbf510d5eafe40d49a790">&#9670;&#160;</a></span>strcpy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * strcpy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy characters from <code>src</code> to <code>dst</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>pointer to the destination string. </td></tr>
    <tr><td class="paramname">src</td><td>pointer to the null-terminated source string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>destination string <code>dst</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Emulates the behaviour of std::strcpy, except this version also runs on the GPU. </dd></dl>

</div>
</div>
<a id="a58636a29fe16a33a15bcd689d6f089db" name="a58636a29fe16a33a15bcd689d6f089db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58636a29fe16a33a15bcd689d6f089db">&#9670;&#160;</a></span>strcpy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * strcpy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bas</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts a number to a string using a specific base </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination string </td></tr>
    <tr><td class="paramname">num</td><td>signed number to be concatenated after <code>dst</code> </td></tr>
    <tr><td class="paramname">bas</td><td>base used when converting <code>num</code> to a string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>destination string <code>dst</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Emulates the behaviour of itoa, except this verion also works on the GPU. </dd></dl>

</div>
</div>
<a id="a406ede5c8676c7e5b0abf7650378e422" name="a406ede5c8676c7e5b0abf7650378e422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406ede5c8676c7e5b0abf7650378e422">&#9670;&#160;</a></span>streq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool streq </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if two null-terminated byte strings are the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>pointer to the null-terminated byte strings to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>pointer to the null-terminated byte strings to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two c-strings are identical </dd></dl>

</div>
</div>
<a id="a008e171a518fe0e0352f31b245e03875" name="a008e171a518fe0e0352f31b245e03875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008e171a518fe0e0352f31b245e03875">&#9670;&#160;</a></span>strlen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlen </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>length of a c-sting, excluding '\0'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>c-string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of characters that precede the terminating null character. </dd></dl>

</div>
</div>
<a id="a205a3bbe3202f23646528d9f3cd381ed" name="a205a3bbe3202f23646528d9f3cd381ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205a3bbe3202f23646528d9f3cd381ed">&#9670;&#160;</a></span>strncpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * strncpy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the first num characters of <code>src</code> to <code>dst</code>. If the end of the source C string (which is signaled by a null-character) is found before <code>max</code> characters have been copied, <code>dst</code> is padded with zeros until a total of <code>max</code> characters have been written to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination string </td></tr>
    <tr><td class="paramname">src</td><td>source string </td></tr>
    <tr><td class="paramname">max</td><td>maximum number of character in destination string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>destination string <code>dst</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if strncpy(dst, src, max)[max-1]!='\0' then <code>src</code> has more characters than <code>max</code> and the return string needs to be manually null-terminated, i.e. strncpy(dst, src, max)[max-1]='\0' </dd></dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a0bf567b7866a96e4005d64743e0859b0" name="a0bf567b7866a96e4005d64743e0859b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf567b7866a96e4005d64743e0859b0">&#9670;&#160;</a></span>is_const_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_const_v = <a class="el" href="structnanovdb_1_1util_1_1is__const.html">is_const</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a70da46bf8635132fd3757deb2fff94" name="a8a70da46bf8635132fd3757deb2fff94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a70da46bf8635132fd3757deb2fff94">&#9670;&#160;</a></span>is_floating_point_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_floating_point_v = <a class="el" href="structnanovdb_1_1util_1_1is__floating__point.html">is_floating_point</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60d8a43ca3d5d473f1651ef5114c2628" name="a60d8a43ca3d5d473f1651ef5114c2628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d8a43ca3d5d473f1651ef5114c2628">&#9670;&#160;</a></span>is_pointer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_pointer_v = <a class="el" href="structnanovdb_1_1util_1_1is__pointer.html">is_pointer</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afad3cfcd1c6b755ddbeb802cb5176947" name="afad3cfcd1c6b755ddbeb802cb5176947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad3cfcd1c6b755ddbeb802cb5176947">&#9670;&#160;</a></span>is_same_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0, typename T1, typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_same_v = <a class="el" href="structnanovdb_1_1util_1_1is__same.html">is_same</a>&lt;T0, T1, T...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacenanovdb.html">nanovdb</a></li><li class="navelem"><a href="namespacenanovdb_1_1util.html">util</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
