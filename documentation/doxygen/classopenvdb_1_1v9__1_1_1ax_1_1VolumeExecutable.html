<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: VolumeExecutable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">9.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v9__1.html">v9_1</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v9__1_1_1ax.html">ax</a></li><li class="navelem"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">VolumeExecutable Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Object that encapsulates compiled AX code which can be executed on a collection of VDB volume grids. Executables are created by the compiler and hold the final immutable JIT compiled function and context.  
 <a href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VolumeExecutable_8h_source.html">openvdb_ax/compiler/VolumeExecutable.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ade0a25d0d6ba0e0a4d939aedcbb8fae0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a> { <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ade0a25d0d6ba0e0a4d939aedcbb8fae0a90651ebea9a35ec4e018c8157492e17c">ON</a>, 
<a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ade0a25d0d6ba0e0a4d939aedcbb8fae0a88559a0cfd8250c9d65970cc145c92d4">OFF</a>, 
<a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ade0a25d0d6ba0e0a4d939aedcbb8fae0ae1f2d5134ed2543d38a0de9751cf75d9">AUTO</a>
 }<tr class="memdesc:ade0a25d0d6ba0e0a4d939aedcbb8fae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The streaming type of active tiles during execution.  <a href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ade0a25d0d6ba0e0a4d939aedcbb8fae0">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ade0a25d0d6ba0e0a4d939aedcbb8fae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af607f22e4873b3369e942d9ebb3e72b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#af607f22e4873b3369e942d9ebb3e72b1">IterType</a> { <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#af607f22e4873b3369e942d9ebb3e72b1a90651ebea9a35ec4e018c8157492e17c">ON</a>, 
<a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#af607f22e4873b3369e942d9ebb3e72b1a88559a0cfd8250c9d65970cc145c92d4">OFF</a>, 
<a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#af607f22e4873b3369e942d9ebb3e72b1a5fb1f955b45e38e31789286a1790398d">ALL</a>
 }</td></tr>
<tr class="separator:af607f22e4873b3369e942d9ebb3e72b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b90227a9ef31b90a812f9f751cda33"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a81b90227a9ef31b90a812f9f751cda33">Ptr</a> = std::shared_ptr&lt; <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a> &gt;</td></tr>
<tr class="separator:a81b90227a9ef31b90a812f9f751cda33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad814a17f6ae499ae481cd4593c5f4533"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ad814a17f6ae499ae481cd4593c5f4533">~VolumeExecutable</a> ()</td></tr>
<tr class="separator:ad814a17f6ae499ae481cd4593c5f4533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecf152485d4534c5386e7244d15930b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#afecf152485d4534c5386e7244d15930b">VolumeExecutable</a> (const <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a> &amp;other)</td></tr>
<tr class="memdesc:afecf152485d4534c5386e7244d15930b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Shares the LLVM constructs but deep copies the settings. Multiple copies of an executor can be used at the same time safely.  <a href="#afecf152485d4534c5386e7244d15930b">More...</a><br /></td></tr>
<tr class="separator:afecf152485d4534c5386e7244d15930b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca28d3bd69799bef5435081d8ca285c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a1ca28d3bd69799bef5435081d8ca285c">setCreateMissing</a> (const bool flag)</td></tr>
<tr class="memdesc:a1ca28d3bd69799bef5435081d8ca285c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the behaviour when missing grids are accessed. Default behaviour is true, which creates them with default transforms and background values.  <a href="#a1ca28d3bd69799bef5435081d8ca285c">More...</a><br /></td></tr>
<tr class="separator:a1ca28d3bd69799bef5435081d8ca285c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7ff8f5fe5c4cac499044795bd075ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#aff7ff8f5fe5c4cac499044795bd075ec">getCreateMissing</a> () const </td></tr>
<tr class="separator:aff7ff8f5fe5c4cac499044795bd075ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa585cfdd56bad735e5b95b165862b223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#aa585cfdd56bad735e5b95b165862b223">setTreeExecutionLevel</a> (const <a class="el" href="namespaceopenvdb_1_1v9__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> min, const <a class="el" href="namespaceopenvdb_1_1v9__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> max)</td></tr>
<tr class="memdesc:aa585cfdd56bad735e5b95b165862b223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the execution level for this executable. This controls what nodes are processed when execute is called. Possible values depend on the OpenVDB configuration in use, however a value of 0 will always correspond to the lowest level (leaf-level). By default, the min level is zero (LeafNodeType::LEVEL) and the max level is the root node's level (RootNodeType::LEVEL). In other words, the default execution level settings process the whole of the tree.  <a href="#aa585cfdd56bad735e5b95b165862b223">More...</a><br /></td></tr>
<tr class="separator:aa585cfdd56bad735e5b95b165862b223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeba4e1c6cedbfda3fb609f8a9817ffe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#aeeba4e1c6cedbfda3fb609f8a9817ffe">setTreeExecutionLevel</a> (const <a class="el" href="namespaceopenvdb_1_1v9__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> level)</td></tr>
<tr class="separator:aeeba4e1c6cedbfda3fb609f8a9817ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35d61de81cc0c985bf7a95db014c7e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#af35d61de81cc0c985bf7a95db014c7e3">getTreeExecutionLevel</a> (<a class="el" href="namespaceopenvdb_1_1v9__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &amp;min, <a class="el" href="namespaceopenvdb_1_1v9__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &amp;max) const </td></tr>
<tr class="memdesc:af35d61de81cc0c985bf7a95db014c7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tree execution levels.  <a href="#af35d61de81cc0c985bf7a95db014c7e3">More...</a><br /></td></tr>
<tr class="separator:af35d61de81cc0c985bf7a95db014c7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e14a8daa02c1cd03f4718f58f378adb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a8e14a8daa02c1cd03f4718f58f378adb">setActiveTileStreaming</a> (const <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a> &amp;s)</td></tr>
<tr class="memdesc:a8e14a8daa02c1cd03f4718f58f378adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the behaviour of expansion of active tiles.  <a href="#a8e14a8daa02c1cd03f4718f58f378adb">More...</a><br /></td></tr>
<tr class="separator:a8e14a8daa02c1cd03f4718f58f378adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c59410546d77cceb6677e221ea04b86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a6c59410546d77cceb6677e221ea04b86">getActiveTileStreaming</a> () const </td></tr>
<tr class="separator:a6c59410546d77cceb6677e221ea04b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d9729b9d45e7ccf2c5732c9e4defd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a48d9729b9d45e7ccf2c5732c9e4defd2">getActiveTileStreaming</a> (const std::string &amp;name, const <a class="el" href="namespaceopenvdb_1_1v9__1_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a> &amp;type) const </td></tr>
<tr class="separator:a48d9729b9d45e7ccf2c5732c9e4defd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b2029c94153119e4d28d21126e597c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a89b2029c94153119e4d28d21126e597c">setValueIterator</a> (const <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#af607f22e4873b3369e942d9ebb3e72b1">IterType</a> &amp;iter)</td></tr>
<tr class="memdesc:a89b2029c94153119e4d28d21126e597c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value iterator type to use with this executable. Options are ON, OFF, ALL. Default is ON.  <a href="#a89b2029c94153119e4d28d21126e597c">More...</a><br /></td></tr>
<tr class="separator:a89b2029c94153119e4d28d21126e597c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed913e163e7bdd781632fbd21423d73b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#af607f22e4873b3369e942d9ebb3e72b1">IterType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#aed913e163e7bdd781632fbd21423d73b">getValueIterator</a> () const </td></tr>
<tr class="separator:aed913e163e7bdd781632fbd21423d73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f82f68e810ff3193b9faba2dcce508"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v9__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ae8f82f68e810ff3193b9faba2dcce508">getTreeExecutionLevel</a> () const </td></tr>
<tr class="separator:ae8f82f68e810ff3193b9faba2dcce508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4fde77c8d382cfa72bf9a0622222c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#afd4fde77c8d382cfa72bf9a0622222c5">setAttributeBindings</a> (const <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1AttributeBindings.html">AttributeBindings</a> &amp;bindings)</td></tr>
<tr class="memdesc:afd4fde77c8d382cfa72bf9a0622222c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set attribute bindings.  <a href="#afd4fde77c8d382cfa72bf9a0622222c5">More...</a><br /></td></tr>
<tr class="separator:afd4fde77c8d382cfa72bf9a0622222c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396791c4fb41a742a34dab8f5a2312fb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1AttributeBindings.html">AttributeBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a396791c4fb41a742a34dab8f5a2312fb">getAttributeBindings</a> () const </td></tr>
<tr class="separator:a396791c4fb41a742a34dab8f5a2312fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1a05061e87e8826cb21add59aa5611f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a1a05061e87e8826cb21add59aa5611f5">execute</a> (<a class="el" href="namespaceopenvdb_1_1v9__1.html#a0c9703e6ff5cc9deb6410c53412c22c3">openvdb::GridPtrVec</a> &amp;grids) const </td></tr>
<tr class="memdesc:a1a05061e87e8826cb21add59aa5611f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run this volume executable binary on target volumes.  <a href="#a1a05061e87e8826cb21add59aa5611f5">More...</a><br /></td></tr>
<tr class="separator:a1a05061e87e8826cb21add59aa5611f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8effd19c151d79a0aea93f1106563da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ab8effd19c151d79a0aea93f1106563da">execute</a> (<a class="el" href="classopenvdb_1_1v9__1_1_1GridBase.html">openvdb::GridBase</a> &amp;grids) const </td></tr>
<tr class="memdesc:ab8effd19c151d79a0aea93f1106563da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run this volume executable binary on target volumes.  <a href="#ab8effd19c151d79a0aea93f1106563da">More...</a><br /></td></tr>
<tr class="separator:ab8effd19c151d79a0aea93f1106563da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8f3948ab8d869447c5f585c45ed2086b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a8f3948ab8d869447c5f585c45ed2086b">setGrainSize</a> (const size_t g1)</td></tr>
<tr class="memdesc:a8f3948ab8d869447c5f585c45ed2086b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the threading grain sizes used when iterating over nodes in a VDB.  <a href="#a8f3948ab8d869447c5f585c45ed2086b">More...</a><br /></td></tr>
<tr class="separator:a8f3948ab8d869447c5f585c45ed2086b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cfbf4433635944ec76268cea607562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a12cfbf4433635944ec76268cea607562">setActiveTileStreamingGrainSize</a> (const size_t g2)</td></tr>
<tr class="memdesc:a12cfbf4433635944ec76268cea607562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the threading grain sizes used when iterating over nodes in a VDB.  <a href="#a12cfbf4433635944ec76268cea607562">More...</a><br /></td></tr>
<tr class="separator:a12cfbf4433635944ec76268cea607562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b0a96a503d6360bcdac038a60d5754"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a60b0a96a503d6360bcdac038a60d5754">getGrainSize</a> () const </td></tr>
<tr class="separator:a60b0a96a503d6360bcdac038a60d5754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03375634734fe1a0e93acc0d34df7008"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a03375634734fe1a0e93acc0d34df7008">getActiveTileStreamingGrainSize</a> () const </td></tr>
<tr class="separator:a03375634734fe1a0e93acc0d34df7008"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5f904e96618a83d59208fb22cdf11ff5"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a5f904e96618a83d59208fb22cdf11ff5">Compiler</a></td></tr>
<tr class="separator:a5f904e96618a83d59208fb22cdf11ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8da9c82256fc211311bff5dfcdc1525"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#af8da9c82256fc211311bff5dfcdc1525">::TestVolumeExecutable</a></td></tr>
<tr class="separator:af8da9c82256fc211311bff5dfcdc1525"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Object that encapsulates compiled AX code which can be executed on a collection of VDB volume grids. Executables are created by the compiler and hold the final immutable JIT compiled function and context. </p>
<p>The <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html" title="Object that encapsulates compiled AX code which can be executed on a collection of VDB volume grids...">VolumeExecutable</a> is returned from the <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1Compiler.html" title="The compiler class. This holds an llvm context and set of compiler options, and constructs executable...">ax::Compiler</a> when compiling AX code for volume execution. The class represents a typical AX executable object; immutable except for execution settings and implements 'execute' functions which can be called multiple times for arbitrary sets of inputs. The intended usage of these executables is to configure their runtime arguments and then call <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a1a05061e87e8826cb21add59aa5611f5" title="Run this volume executable binary on target volumes. ">VolumeExecutable::execute</a> with your VDBs. For example: </p><div class="fragment"><div class="line"><a class="code" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a81b90227a9ef31b90a812f9f751cda33">VolumeExecutable::Ptr</a> exe = compiler.compile&lt;<a class="code" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#afecf152485d4534c5386e7244d15930b">VolumeExecutable</a>&gt;(<span class="stringliteral">&quot;@a += 1&quot;</span>);</div><div class="line">exe-&gt;setTreeExecutionLevel(0); <span class="comment">// only process leaf nodes</span></div><div class="line">exe-&gt;setValueIterator(<a class="code" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#af607f22e4873b3369e942d9ebb3e72b1a5fb1f955b45e38e31789286a1790398d">VolumeExecutable::IterType::ALL</a>); <span class="comment">// process all values</span></div><div class="line">exe-&gt;execute(vdbs); <span class="comment">// run on a set of vdbs</span></div><div class="line">exe-&gt;execute(grid); <span class="comment">// run on a single vdb</span></div></div><!-- fragment --><p>The Volume executable is initialised with specific configurable settings:</p><ul>
<li>Iteration Level: min=0, max=RootNode::Level. By default, processes the entire VDB tree hierarchy. <dl class="section see"><dt>See also</dt><dd><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#aa585cfdd56bad735e5b95b165862b223" title="Set the execution level for this executable. This controls what nodes are processed when execute is c...">setTreeExecutionLevel</a></dd></dl>
</li>
<li>Iteration Type: ON By default, processes ACTIVE values. <dl class="section see"><dt>See also</dt><dd><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a89b2029c94153119e4d28d21126e597c" title="Set the value iterator type to use with this executable. Options are ON, OFF, ALL. Default is ON. ">setValueIterator</a></dd></dl>
</li>
<li>Active Tile Streaming: ON, OFF or AUTO depending on AX code. By default, if AX detects that the AX program may produce unique values for leaf level voxels that would otherwise comprise a given active tile, this setting is set to ON or AUTO. Otherwise it is set to OFF. <dl class="section see"><dt>See also</dt><dd><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a8e14a8daa02c1cd03f4718f58f378adb" title="Controls the behaviour of expansion of active tiles. ">setActiveTileStreaming</a></dd></dl>
</li>
<li>Grain sizes: 1:32 The default grain sizes passed to the tbb partitioner for leaf level processing and active tile processing. <dl class="section see"><dt>See also</dt><dd><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a8f3948ab8d869447c5f585c45ed2086b" title="Set the threading grain sizes used when iterating over nodes in a VDB. ">setGrainSize</a> </dd>
<dd>
<a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a12cfbf4433635944ec76268cea607562" title="Set the threading grain sizes used when iterating over nodes in a VDB. ">setActiveTileStreamingGrainSize</a></dd></dl>
For more in depth information, see the <a class="el" href="axcplusplus.html#vdbaxcompilerexe">Executables</a> documentation. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a81b90227a9ef31b90a812f9f751cda33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a81b90227a9ef31b90a812f9f751cda33">Ptr</a> =  std::shared_ptr&lt;<a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="af607f22e4873b3369e942d9ebb3e72b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#af607f22e4873b3369e942d9ebb3e72b1">IterType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="af607f22e4873b3369e942d9ebb3e72b1a90651ebea9a35ec4e018c8157492e17c"></a>ON&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af607f22e4873b3369e942d9ebb3e72b1a88559a0cfd8250c9d65970cc145c92d4"></a>OFF&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af607f22e4873b3369e942d9ebb3e72b1a5fb1f955b45e38e31789286a1790398d"></a>ALL&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ade0a25d0d6ba0e0a4d939aedcbb8fae0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The streaming type of active tiles during execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ON</td><td>active tiles are temporarily densified (converted to leaf level voxels) on an "as needed" basis and the subsequent voxel values are processed. The temporarily densified node is added to the tree only if a non constant voxel buffer is produced. Otherwise a child tile may be created or the original tile's value may simply be modified. </td></tr>
    <tr><td class="paramname">OFF</td><td>tile topologies are left unchanged and their single value is processed. </td></tr>
    <tr><td class="paramname">AUTO</td><td>the volume executable analyzes the compiled kernel and attempts to determine if expansion of active tiles would lead to different, non-constant values in the respective voxels. This is done on a per grid basis; ultimately each execution will be set to ON or OFF. This option will always fall back to ON if there is any chance the kernel may produce child nodes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The volume executable always runs an AUTO check on creation and will set itself to ON (if all grids always need child nodes), OFF (if grids never need child nodes) or remains as AUTO (if this depends on which grid is being processed).</dd></dl>
<p>When an AX kernel is run over coarser levels of the tree (i.e. not leaf voxels), it is often desirable to densify these areas into unique voxels such that they can each receive a unique value. For example, consider the following AX code which assigns a vector volume to the world space position of each voxel: </p><div class="fragment"><div class="line">v@v = getvoxelpws();</div></div><!-- fragment --><p> Active tiles hold a single value but comprise an area greater than that of a single voxel. As the above kernel varies with respect to a nodes position, we'd need to replace these tiles with leaf voxels to get unique per node values. The stream flag is initialised to ON in this case.</p>
<p>This behaviour, however, is not always desirable .i.e: </p><div class="fragment"><div class="line">v@v = {1,2,3};</div></div><!-- fragment --><p> In this instance, all values within a volume receive the same value and are not dependent on any spatially or iteratively varying metrics. The stream flag is set to OFF.</p>
<p>The AUTO flag is set in cases where the runtime access pattern of the inputs determines streaming: </p><div class="fragment"><div class="line">f@density = f@mask;</div><div class="line">f@mask = 0;</div></div><!-- fragment --><p> In this instance, the runtime topology and values of @mask determines whether child topology needs to be created in @density, but @mask itself does not need streaming. Streaming will be set to ON for density but OFF for mask.</p>
<dl class="section note"><dt>Note</dt><dd>This behaviour is only applied to active tiles. If the value iterator is set to OFF, this option is ignored. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This option can generate large amounts of leaf level voxels. It is recommended to use a good concurrent memory allocator (such as jemalloc) for the best performance. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ade0a25d0d6ba0e0a4d939aedcbb8fae0a90651ebea9a35ec4e018c8157492e17c"></a>ON&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ade0a25d0d6ba0e0a4d939aedcbb8fae0a88559a0cfd8250c9d65970cc145c92d4"></a>OFF&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ade0a25d0d6ba0e0a4d939aedcbb8fae0ae1f2d5134ed2543d38a0de9751cf75d9"></a>AUTO&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad814a17f6ae499ae481cd4593c5f4533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afecf152485d4534c5386e7244d15930b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. Shares the LLVM constructs but deep copies the settings. Multiple copies of an executor can be used at the same time safely. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1a05061e87e8826cb21add59aa5611f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v9__1.html#a0c9703e6ff5cc9deb6410c53412c22c3">openvdb::GridPtrVec</a> &amp;&#160;</td>
          <td class="paramname"><em>grids</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run this volume executable binary on target volumes. </p>
<p>This method reads from the stored settings on the executable to determine certain behaviour and runs the JIT compiled function across every valid VDB value. Topology may be changed, deleted or created.</p>
<p>This method is thread safe; it can be run concurrently from the same <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html" title="Object that encapsulates compiled AX code which can be executed on a collection of VDB volume grids...">VolumeExecutable</a> instance on different inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grids</td><td>The VDB Volumes to process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8effd19c151d79a0aea93f1106563da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v9__1_1_1GridBase.html">openvdb::GridBase</a> &amp;&#160;</td>
          <td class="paramname"><em>grids</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run this volume executable binary on target volumes. </p>
<p>This method reads from the stored settings on the executable to determine certain behaviour and runs the JIT compiled function across every valid VDB value. Topology may be changed, deleted or created.</p>
<p>This method is thread safe; it can be run concurrently from the same <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html" title="Object that encapsulates compiled AX code which can be executed on a collection of VDB volume grids...">VolumeExecutable</a> instance on different inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grids</td><td>The VDB Volumes to process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c59410546d77cceb6677e221ea04b86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a> getActiveTileStreaming </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current stream behaviour. </dd></dl>

</div>
</div>
<a class="anchor" id="a48d9729b9d45e7ccf2c5732c9e4defd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a> getActiveTileStreaming </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v9__1_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current stream behaviour for a particular grid. This is either ON or OFF. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the grid to query </td></tr>
    <tr><td class="paramname">type</td><td>The grids type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03375634734fe1a0e93acc0d34df7008"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t getActiveTileStreamingGrainSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current g2 grain size </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a12cfbf4433635944ec76268cea607562" title="Set the threading grain sizes used when iterating over nodes in a VDB. ">setActiveTileStreamingGrainSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a396791c4fb41a742a34dab8f5a2312fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1AttributeBindings.html">AttributeBindings</a>&amp; getAttributeBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current attribute bindings map </dd></dl>

</div>
</div>
<a class="anchor" id="aff7ff8f5fe5c4cac499044795bd075ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getCreateMissing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether this executable will generate new grids. </dd></dl>

</div>
</div>
<a class="anchor" id="a60b0a96a503d6360bcdac038a60d5754"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t getGrainSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current g1 grain size </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#a8f3948ab8d869447c5f585c45ed2086b" title="Set the threading grain sizes used when iterating over nodes in a VDB. ">setGrainSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af35d61de81cc0c985bf7a95db014c7e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getTreeExecutionLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v9__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v9__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tree execution levels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The minimum tree execution level </td></tr>
    <tr><td class="paramname">max</td><td>The maximum tree execution level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8f82f68e810ff3193b9faba2dcce508"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v9__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getTreeExecutionLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The tree execution level. </dd></dl>

</div>
</div>
<a class="anchor" id="aed913e163e7bdd781632fbd21423d73b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#af607f22e4873b3369e942d9ebb3e72b1">IterType</a> getValueIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current value iterator type </dd></dl>

</div>
</div>
<a class="anchor" id="a8e14a8daa02c1cd03f4718f58f378adb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setActiveTileStreaming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls the behaviour of expansion of active tiles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The behaviour to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12cfbf4433635944ec76268cea607562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setActiveTileStreamingGrainSize </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>g2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the threading grain sizes used when iterating over nodes in a VDB. </p>
<p>Two grain sizes are provided, the first of which (g1) is used to determine the chunk size of nodes which are not being streamed (see setActiveTileStream). Leaf node execution always uses this grain size. The default value for g1 is 1 which is typically appropriate for most AX kernels. The second grain size is used when streaming execution over active tiles in a VDB. This execution model differs significantly from typical leaf node execution due to the potential for substantially more memory to be allocated. The default value is 32, which works well for the default configuration of OpenVDB. If streaming is disabled, this value has no effect. </p><dl class="section note"><dt>Note</dt><dd>Setting g1 or g2 to zero has the effect of disabling multi-threading for the respective node executions. Setting both to zero will disable all multi-threading performed by the execute method. </dd></dl>

</div>
</div>
<a class="anchor" id="afd4fde77c8d382cfa72bf9a0622222c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setAttributeBindings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1AttributeBindings.html">AttributeBindings</a> &amp;&#160;</td>
          <td class="paramname"><em>bindings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set attribute bindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindings</td><td>A map of attribute bindings to expected names on the geometry to be executed over. By default the AX attributes will be bound to volumes of the same name. Supplying bindings for a subset of the attributes will leave the others unchanged. AX attributes can only bind to a single volume and vice versa. However, in a single set call these can be swapped e.g. a -&gt; b and b -&gt; a. When bindings are overriden through subsequent calls to this function, any dangling volumes will be automatically bound by name. To reset these bindings call get function and create a target set of bindings for each attribute of name -&gt; name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ca28d3bd69799bef5435081d8ca285c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setCreateMissing </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the behaviour when missing grids are accessed. Default behaviour is true, which creates them with default transforms and background values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Enables or disables the creation of missing attributes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f3948ab8d869447c5f585c45ed2086b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setGrainSize </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>g1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the threading grain sizes used when iterating over nodes in a VDB. </p>
<p>Two grain sizes are provided, the first of which (g1) is used to determine the chunk size of nodes which are not being streamed (see setActiveTileStream). Leaf node execution always uses this grain size. The default value for g1 is 1 which is typically appropriate for most AX kernels. The second grain size is used when streaming execution over active tiles in a VDB. This execution model differs significantly from typical leaf node execution due to the potential for substantially more memory to be allocated. The default value is 32, which works well for the default configuration of OpenVDB. If streaming is disabled, this value has no effect. </p><dl class="section note"><dt>Note</dt><dd>Setting g1 or g2 to zero has the effect of disabling multi-threading for the respective node executions. Setting both to zero will disable all multi-threading performed by the execute method. </dd></dl>

</div>
</div>
<a class="anchor" id="aa585cfdd56bad735e5b95b165862b223"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setTreeExecutionLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v9__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v9__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the execution level for this executable. This controls what nodes are processed when execute is called. Possible values depend on the OpenVDB configuration in use, however a value of 0 will always correspond to the lowest level (leaf-level). By default, the min level is zero (LeafNodeType::LEVEL) and the max level is the root node's level (RootNodeType::LEVEL). In other words, the default execution level settings process the whole of the tree. </p>
<dl class="section note"><dt>Note</dt><dd>A value larger that the number of levels in the tree (i.e. larger than the root node's level) will cause this method to throw a runtime error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The minimum tree execution level to set </td></tr>
    <tr><td class="paramname">max</td><td>The maximum tree execution level to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeeba4e1c6cedbfda3fb609f8a9817ffe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setTreeExecutionLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v9__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The tree execution level to set. Calls setTreeExecutionLevel with min and max arguments as level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89b2029c94153119e4d28d21126e597c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setValueIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1VolumeExecutable.html#af607f22e4873b3369e942d9ebb3e72b1">IterType</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value iterator type to use with this executable. Options are ON, OFF, ALL. Default is ON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The value iterator type to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="af8da9c82256fc211311bff5dfcdc1525"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::TestVolumeExecutable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f904e96618a83d59208fb22cdf11ff5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classopenvdb_1_1v9__1_1_1ax_1_1Compiler.html">Compiler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
