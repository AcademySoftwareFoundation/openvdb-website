<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: openvdb::v7_2::ax::codegen Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">7.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v7__2.html">v7_2</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax.html">ax</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html">codegen</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">openvdb::v7_2::ax::codegen Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1codegen__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1codegen__internal.html">codegen_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1AliasTypeMap.html">AliasTypeMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias mapping between two types, a frontend type T1 and a backend type T2. This class is the intended interface for binding objects which implement supported backend AX/IR types to this given backend type. More specifically, it's current and expected usage is limited to objects which hold a single member of a supported backend type and implements a StandardLayoutType as defined by the standard. Fundamentally, T1-&gt;T2 mapping should be supported by reinterpret_cast&lt;&gt; as defined by the type aliasing rules.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1AliasTypeMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object to array conversion methods to allow functions to return vector types. These containers provided an interface for automatic conversion of C++ objects to LLVM types as array types.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgumentIterator.html">ArgumentIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated argument iterator which implements various small functions per argument type, resolved at compile time.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgumentIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgumentIterator_3_01SignatureT_00_010_01_4.html">ArgumentIterator&lt; SignatureT, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1CFunction.html">CFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a concrete C function binding.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1CFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1CFunctionBase.html">CFunctionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all C bindings.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1CFunctionBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1CFunctionSRet.html">CFunctionSRet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a concrete C function binding with the first argument as its return type.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1CFunctionSRet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ComputeKernel.html">ComputeKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function definition and signature which is built by the ComputeGenerator.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ComputeKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ConstantFolder.html">ConstantFolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant folding support structure.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ConstantFolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ConstantFolder_3_01SignatureT_00_010_01_4.html">ConstantFolder&lt; SignatureT, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1Function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base/abstract representation of an AX function. Derived classes must implement the <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1Function.html#ad2e75a6e74e69d1563a9d41d626b30a0" title="Populate a vector of llvm::Types which describe this function signature. This method is used by Funct...">Function::types</a> call to describe their signature.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1Function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionBuilder.html">FunctionBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionBuilder.html" title="The FunctionBuilder class provides a builder pattern framework to allow easy and valid construction o...">FunctionBuilder</a> class provides a builder pattern framework to allow easy and valid construction of AX functions. There are a number of complex tasks which may need to be performed during construction of C or IR function which are delegated to this builder, whilst ensuring that the constructed functions are guaranteed to be valid.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionGroup.html">FunctionGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">todo  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionRegistry.html">FunctionRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function registry which is used for function code generation. Each time a function is visited within the AST, its identifier is used as a key into this registry for the corresponding function retrieval and execution. Functions can be inserted into the registry using <a class="el" href="classopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionRegistry.html#abaf1891724f1dc8b9769d863916ac114" title="Insert and register a function object to a function identifier. ">insert()</a> with a given identifier and pointer.  <a href="classopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionRegistry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionTraits.html">FunctionTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated function traits which provides compile-time index access to the types of the function signature.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionTraits_3_01R_07_6_08_07Args_8_8_8_08_4.html">FunctionTraits&lt; R(&amp;)(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionTraits_3_01R_07_5_08_07Args_8_8_8_08_4.html">FunctionTraits&lt; R(*)(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionTraits_3_01ReturnT_07Args_8_8_8_08_4.html">FunctionTraits&lt; ReturnT(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1int__t.html">int_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1int__t_3_0116_01_4.html">int_t&lt; 16 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1int__t_3_0132_01_4.html">int_t&lt; 32 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1int__t_3_0164_01_4.html">int_t&lt; 64 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1int__t_3_018_01_4.html">int_t&lt; 8 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1IRFunction.html">IRFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a concrete IR function.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1IRFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1IRFunctionBase.html">IRFunctionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base/abstract definition for an IR function.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1IRFunctionBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1IRFunctionSRet.html">IRFunctionSRet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a concrete IR function with the first argument as its return type.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1IRFunctionSRet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType.html">LLVMType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LLVM type mapping from pod types.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01ArgType_3_01T_00_01S_01_4_01_4.html">LLVMType&lt; ArgType&lt; T, S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01AXString_01_4.html">LLVMType&lt; AXString &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01char_01_4.html">LLVMType&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01const_01T_01_5_01_4.html">LLVMType&lt; const T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01const_01T_01_4.html">LLVMType&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01math_1_1Mat3_3_01T_01_4_01_4.html">LLVMType&lt; math::Mat3&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01math_1_1Mat4_3_01T_01_4_01_4.html">LLVMType&lt; math::Mat4&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01math_1_1Vec2_3_01T_01_4_01_4.html">LLVMType&lt; math::Vec2&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported aliasing for VDB math types, allowing use in external function signatures.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01math_1_1Vec2_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01math_1_1Vec3_3_01T_01_4_01_4.html">LLVMType&lt; math::Vec3&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01math_1_1Vec4_3_01T_01_4_01_4.html">LLVMType&lt; math::Vec4&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01T_01_5_01_4.html">LLVMType&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01T[S]_4.html">LLVMType&lt; T[S]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01void_01_5_01_4.html">LLVMType&lt; void * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1LLVMType_3_01void_01_4.html">LLVMType&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1PointKernel.html">PointKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function definition and signature which is built by the PointComputeGenerator.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1PointKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1PointRangeKernel.html">PointRangeKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An additonal function built by the PointComputeGenerator. Currently both compute and compute range functions have the same signature.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1PointRangeKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1SRetFunction.html">SRetFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated interface class for SRET functions. This struct provides the interface for functions that wish to return arrays (vectors or matrices) by internally remapping the first argument for the user. As far as LLVM and any bindings are concerned, the function signature remains unchanged - however the first argument becomes "invisible" to the user and is instead allocated by LLVM before the function is executed. Importantly, the argument has no impact on the user facing AX signature and doesn't affect declaration selection.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1SRetFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1SymbolTable.html">SymbolTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbol table which can be used to represent a single scoped set of a programs variables. This is simply an unordered map of strings to llvm::Values.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1SymbolTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1SymbolTableBlocks.html">SymbolTableBlocks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of unique ids to symbol tables which can be used to represent local variables within a program. New scopes can be added and erased where necessary and iterated through using <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1SymbolTableBlocks.html#a16cc8912b1b6547e53403c1a72ac9dea" title="Find a variable within the program starting at a given table index. If the given index does not exist...">find()</a>. Find assumes that tables are added through parented ascending ids.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1SymbolTableBlocks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol.html">TypeToSymbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to symbol conversions - these characters are used to build each functions unique signature. They differ from standard AX or LLVM syntax to be as short as possible i.e. vec4d, [4 x double] = d4.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01ArgType_3_01T_00_01S_01_4_01_4.html">TypeToSymbol&lt; ArgType&lt; T, S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01AXString_01_4.html">TypeToSymbol&lt; AXString &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01char_01_4.html">TypeToSymbol&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01const_01T_01_5_01_4.html">TypeToSymbol&lt; const T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01const_01T_01_4.html">TypeToSymbol&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01double_01_4.html">TypeToSymbol&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01float_01_4.html">TypeToSymbol&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01int16__t_01_4.html">TypeToSymbol&lt; int16_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01int32__t_01_4.html">TypeToSymbol&lt; int32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01int64__t_01_4.html">TypeToSymbol&lt; int64_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Mat3_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Mat3&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Mat4_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Mat4&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Vec2_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Vec2&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Vec3_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Vec3&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01math_1_1Vec4_3_01T_01_4_01_4.html">TypeToSymbol&lt; math::Vec4&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01T_01_5_01_4.html">TypeToSymbol&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01T[S]_4.html">TypeToSymbol&lt; T[S]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1TypeToSymbol_3_01void_01_4.html">TypeToSymbol&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1VolumeKernel.html">VolumeKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function definition and signature which is built by the VolumeComputeGenerator.  <a href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1VolumeKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a19491c62dae10fc5b97850b29231b0ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a19491c62dae10fc5b97850b29231b0ef">V2D</a> = <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt; double, 2 &gt;</td></tr>
<tr class="separator:a19491c62dae10fc5b97850b29231b0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf19fc2ebfc31df1b136083c7051c524"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#adf19fc2ebfc31df1b136083c7051c524">V2F</a> = <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt; float, 2 &gt;</td></tr>
<tr class="separator:adf19fc2ebfc31df1b136083c7051c524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39e79e84de78fa6188c1b812ef7c9c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#ac39e79e84de78fa6188c1b812ef7c9c0">V2I</a> = <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt; int32_t, 2 &gt;</td></tr>
<tr class="separator:ac39e79e84de78fa6188c1b812ef7c9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe076b1a292d8635a2e144ecb285be2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#afe076b1a292d8635a2e144ecb285be2c">V3D</a> = <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt; double, 3 &gt;</td></tr>
<tr class="separator:afe076b1a292d8635a2e144ecb285be2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a93313e37930c7ec565dc4f3eb36fd6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a3a93313e37930c7ec565dc4f3eb36fd6">V3F</a> = <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt; float, 3 &gt;</td></tr>
<tr class="separator:a3a93313e37930c7ec565dc4f3eb36fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b46918e9d7dca7ca333e39d3a80f525"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a7b46918e9d7dca7ca333e39d3a80f525">V3I</a> = <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt; int32_t, 3 &gt;</td></tr>
<tr class="separator:a7b46918e9d7dca7ca333e39d3a80f525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a5962a96d7ca3f39ad565d8fffd335"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a96a5962a96d7ca3f39ad565d8fffd335">V4D</a> = <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt; double, 4 &gt;</td></tr>
<tr class="separator:a96a5962a96d7ca3f39ad565d8fffd335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5289743e2fa6d363751795a25ec6dd19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a5289743e2fa6d363751795a25ec6dd19">V4F</a> = <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt; float, 4 &gt;</td></tr>
<tr class="separator:a5289743e2fa6d363751795a25ec6dd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da87a694970da5888f4db38a93c2ffb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a1da87a694970da5888f4db38a93c2ffb">V4I</a> = <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt; int32_t, 4 &gt;</td></tr>
<tr class="separator:a1da87a694970da5888f4db38a93c2ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2463f1262305b6a40aface8a10d5ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a4b2463f1262305b6a40aface8a10d5ff">M3D</a> = <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt; double, 9 &gt;</td></tr>
<tr class="separator:a4b2463f1262305b6a40aface8a10d5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54db21251983c9e341b3da7635e9766"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#aa54db21251983c9e341b3da7635e9766">M3F</a> = <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt; float, 9 &gt;</td></tr>
<tr class="separator:aa54db21251983c9e341b3da7635e9766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d45a6bbe207f32a91d91d9a3f545bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a50d45a6bbe207f32a91d91d9a3f545bb">M4D</a> = <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt; double, 16 &gt;</td></tr>
<tr class="separator:a50d45a6bbe207f32a91d91d9a3f545bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013d7b6412643a11b959eb75b974ef6c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a013d7b6412643a11b959eb75b974ef6c">M4F</a> = <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt; float, 16 &gt;</td></tr>
<tr class="separator:a013d7b6412643a11b959eb75b974ef6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b6ff3a4013769265f8c3dee2cbf17b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a86b6ff3a4013769265f8c3dee2cbf17b">CastFunction</a> = std::function&lt; llvm::Value *(llvm::IRBuilder&lt;&gt; &amp;, llvm::Value *, llvm::Type *)&gt;</td></tr>
<tr class="separator:a86b6ff3a4013769265f8c3dee2cbf17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af036ec3b03ba7981a9af071bce3c7648"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#af036ec3b03ba7981a9af071bce3c7648">BinaryFunction</a> = std::function&lt; llvm::Value *(llvm::IRBuilder&lt;&gt; &amp;, llvm::Value *, llvm::Value *)&gt;</td></tr>
<tr class="separator:af036ec3b03ba7981a9af071bce3c7648"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4a9ee9a0ec0a79d08c610b2d30d2c5d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionRegistry.html#af87f2a1a2395918a71eed11c61f94fc8">FunctionRegistry::UniquePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a4a9ee9a0ec0a79d08c610b2d30d2c5d3">createDefaultRegistry</a> (const <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *op=nullptr)</td></tr>
<tr class="memdesc:a4a9ee9a0ec0a79d08c610b2d30d2c5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a registry with the default set of registered functions including math functions, point functions and volume functions.  <a href="#a4a9ee9a0ec0a79d08c610b2d30d2c5d3">More...</a><br /></td></tr>
<tr class="separator:a4a9ee9a0ec0a79d08c610b2d30d2c5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8781a243c49f40b0e9b41b7e8b93e851"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a8781a243c49f40b0e9b41b7e8b93e851">insertStandardFunctions</a> (<a class="el" href="classopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionRegistry.html">FunctionRegistry</a> &amp;reg, const <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *options=nullptr)</td></tr>
<tr class="memdesc:a8781a243c49f40b0e9b41b7e8b93e851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a function registry with all available "standard" AX library function. This primarily consists of all mathematical ops on AX containers (scalars, vectors, matrices) and other stl built-ins.  <a href="#a8781a243c49f40b0e9b41b7e8b93e851">More...</a><br /></td></tr>
<tr class="separator:a8781a243c49f40b0e9b41b7e8b93e851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf330570662d8ed35f3b76193f69461"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a4bf330570662d8ed35f3b76193f69461">insertVDBPointFunctions</a> (<a class="el" href="classopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionRegistry.html">FunctionRegistry</a> &amp;reg, const <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *options=nullptr)</td></tr>
<tr class="memdesc:a4bf330570662d8ed35f3b76193f69461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a function registry with all available OpenVDB Point AX library function.  <a href="#a4bf330570662d8ed35f3b76193f69461">More...</a><br /></td></tr>
<tr class="separator:a4bf330570662d8ed35f3b76193f69461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e34d0af451f6aa344f9512e4a5f0c90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a6e34d0af451f6aa344f9512e4a5f0c90">insertVDBVolumeFunctions</a> (<a class="el" href="classopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionRegistry.html">FunctionRegistry</a> &amp;reg, const <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *options=nullptr)</td></tr>
<tr class="memdesc:a6e34d0af451f6aa344f9512e4a5f0c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a function registry with all available OpenVDB Volume AX library function.  <a href="#a6e34d0af451f6aa344f9512e4a5f0c90">More...</a><br /></td></tr>
<tr class="separator:a6e34d0af451f6aa344f9512e4a5f0c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690a4182b12b0f6a6beb121d6e795c0c"><td class="memTemplParams" colspan="2">template&lt;typename SignatureT &gt; </td></tr>
<tr class="memitem:a690a4182b12b0f6a6beb121d6e795c0c"><td class="memTemplItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a690a4182b12b0f6a6beb121d6e795c0c">llvmTypesFromSignature</a> (llvm::LLVMContext &amp;C, std::vector&lt; llvm::Type * &gt; *types=nullptr)</td></tr>
<tr class="memdesc:a690a4182b12b0f6a6beb121d6e795c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a vector of llvm types from a function signature declaration.  <a href="#a690a4182b12b0f6a6beb121d6e795c0c">More...</a><br /></td></tr>
<tr class="separator:a690a4182b12b0f6a6beb121d6e795c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6ed37845100370d8843bbb0a248f77"><td class="memTemplParams" colspan="2">template&lt;typename SignatureT &gt; </td></tr>
<tr class="memitem:a6b6ed37845100370d8843bbb0a248f77"><td class="memTemplItemLeft" align="right" valign="top">llvm::FunctionType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a6b6ed37845100370d8843bbb0a248f77">llvmFunctionTypeFromSignature</a> (llvm::LLVMContext &amp;C)</td></tr>
<tr class="memdesc:a6b6ed37845100370d8843bbb0a248f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an LLVM FunctionType from a function signature.  <a href="#a6b6ed37845100370d8843bbb0a248f77">More...</a><br /></td></tr>
<tr class="separator:a6b6ed37845100370d8843bbb0a248f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f5924634eb5a69f76f20c4b4674a1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a55f5924634eb5a69f76f20c4b4674a1f">printSignature</a> (std::ostream &amp;os, const std::vector&lt; llvm::Type * &gt; &amp;types, const llvm::Type *returnType, const char *name=nullptr, const std::vector&lt; const char * &gt; &amp;names={}, const bool axTypes=false)</td></tr>
<tr class="memdesc:a55f5924634eb5a69f76f20c4b4674a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a function signature to the provided ostream.  <a href="#a55f5924634eb5a69f76f20c4b4674a1f">More...</a><br /></td></tr>
<tr class="separator:a55f5924634eb5a69f76f20c4b4674a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0013600e52981c708958349aad91b56e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0013600e52981c708958349aad91b56e"><td class="memTemplItemLeft" align="right" valign="top">llvm::Constant *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a0013600e52981c708958349aad91b56e">llvmConstant</a> (const T t, llvm::Type *type)</td></tr>
<tr class="memdesc:a0013600e52981c708958349aad91b56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an llvm Constant holding a scalar value.  <a href="#a0013600e52981c708958349aad91b56e">More...</a><br /></td></tr>
<tr class="separator:a0013600e52981c708958349aad91b56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab513d427fc629be1746de7db624ea9a2"><td class="memItemLeft" align="right" valign="top">llvm::IntegerType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#ab513d427fc629be1746de7db624ea9a2">llvmIntType</a> (const uint32_t size, llvm::LLVMContext &amp;C)</td></tr>
<tr class="memdesc:ab513d427fc629be1746de7db624ea9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an llvm IntegerType given a requested size and context.  <a href="#ab513d427fc629be1746de7db624ea9a2">More...</a><br /></td></tr>
<tr class="separator:ab513d427fc629be1746de7db624ea9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e85b235ef6946a16ba1261ad74e47e"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a32e85b235ef6946a16ba1261ad74e47e">llvmFloatType</a> (const uint32_t size, llvm::LLVMContext &amp;C)</td></tr>
<tr class="memdesc:a32e85b235ef6946a16ba1261ad74e47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an llvm floating point Type given a requested size and context.  <a href="#a32e85b235ef6946a16ba1261ad74e47e">More...</a><br /></td></tr>
<tr class="separator:a32e85b235ef6946a16ba1261ad74e47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c91c78680ca47f8f72386a9b2ebb486"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a0c91c78680ca47f8f72386a9b2ebb486">llvmTypeFromToken</a> (const <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a> &amp;type, llvm::LLVMContext &amp;C)</td></tr>
<tr class="memdesc:a0c91c78680ca47f8f72386a9b2ebb486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an llvm type representing a type defined by a string.  <a href="#a0c91c78680ca47f8f72386a9b2ebb486">More...</a><br /></td></tr>
<tr class="separator:a0c91c78680ca47f8f72386a9b2ebb486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab7d041c838af53c88857b4aab664b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#acab7d041c838af53c88857b4aab664b9">tokenFromLLVMType</a> (const llvm::Type *type)</td></tr>
<tr class="memdesc:acab7d041c838af53c88857b4aab664b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a corresponding AX token which represents the given LLVM Type.  <a href="#acab7d041c838af53c88857b4aab664b9">More...</a><br /></td></tr>
<tr class="separator:acab7d041c838af53c88857b4aab664b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932191a045e76905a9e7e76155e69fa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a932191a045e76905a9e7e76155e69fa0">valuesToTypes</a> (const std::vector&lt; llvm::Value * &gt; &amp;values, std::vector&lt; llvm::Type * &gt; &amp;types)</td></tr>
<tr class="memdesc:a932191a045e76905a9e7e76155e69fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a vector of llvm Types from a vector of llvm values.  <a href="#a932191a045e76905a9e7e76155e69fa0">More...</a><br /></td></tr>
<tr class="separator:a932191a045e76905a9e7e76155e69fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bdb1f014a6367ae360031783585ad5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a91bdb1f014a6367ae360031783585ad5">llvmTypeToString</a> (const llvm::Type *const type, std::string &amp;str)</td></tr>
<tr class="memdesc:a91bdb1f014a6367ae360031783585ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints an llvm type to a std string.  <a href="#a91bdb1f014a6367ae360031783585ad5">More...</a><br /></td></tr>
<tr class="separator:a91bdb1f014a6367ae360031783585ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb0cfc528aafabe1b1f618ab24fad4b"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a4eb0cfc528aafabe1b1f618ab24fad4b">getBaseContainedType</a> (llvm::Type *const type)</td></tr>
<tr class="memdesc:a4eb0cfc528aafabe1b1f618ab24fad4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base llvm value which is being pointed to through any number of layered pointers.  <a href="#a4eb0cfc528aafabe1b1f618ab24fad4b">More...</a><br /></td></tr>
<tr class="separator:a4eb0cfc528aafabe1b1f618ab24fad4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656906a31095231b82efe15675a763f3"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a656906a31095231b82efe15675a763f3"><td class="memTemplItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a656906a31095231b82efe15675a763f3">llvmPointerFromAddress</a> (const ValueT *const &amp;ptr, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a656906a31095231b82efe15675a763f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an llvm value representing a pointer to the provided ptr builtin ValueT.  <a href="#a656906a31095231b82efe15675a763f3">More...</a><br /></td></tr>
<tr class="separator:a656906a31095231b82efe15675a763f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c6514874aa6a077e3cb9741d4236ae"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a54c6514874aa6a077e3cb9741d4236ae">insertStaticAlloca</a> (llvm::IRBuilder&lt;&gt; &amp;B, llvm::Type *type, llvm::Value *size=nullptr)</td></tr>
<tr class="memdesc:a54c6514874aa6a077e3cb9741d4236ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a stack allocation at the beginning of the current function of the provided type and size. The IRBuilder's insertion point must be set to a BasicBlock with a valid <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a> parent.  <a href="#a54c6514874aa6a077e3cb9741d4236ae">More...</a><br /></td></tr>
<tr class="separator:a54c6514874aa6a077e3cb9741d4236ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066a335df1113aa7800057226a00aae8"><td class="memItemLeft" align="right" valign="top">llvm::Argument *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a066a335df1113aa7800057226a00aae8">extractArgument</a> (llvm::Function *F, const size_t idx)</td></tr>
<tr class="separator:a066a335df1113aa7800057226a00aae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddb950365b7bfca6d0a0019ebbd8871"><td class="memItemLeft" align="right" valign="top">llvm::Argument *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#aeddb950365b7bfca6d0a0019ebbd8871">extractArgument</a> (llvm::Function *F, const std::string &amp;name)</td></tr>
<tr class="separator:aeddb950365b7bfca6d0a0019ebbd8871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da92c1d0e5dec19ed0b89f6c448d02e"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a0da92c1d0e5dec19ed0b89f6c448d02e">typePrecedence</a> (llvm::Type *const typeA, llvm::Type *const typeB)</td></tr>
<tr class="memdesc:a0da92c1d0e5dec19ed0b89f6c448d02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest order type from two LLVM Scalar types.  <a href="#a0da92c1d0e5dec19ed0b89f6c448d02e">More...</a><br /></td></tr>
<tr class="separator:a0da92c1d0e5dec19ed0b89f6c448d02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1309c381c0dd0474de50930b9e80153d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a86b6ff3a4013769265f8c3dee2cbf17b">CastFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a1309c381c0dd0474de50930b9e80153d">llvmArithmeticConversion</a> (const llvm::Type *const sourceType, const llvm::Type *const targetType, const std::string &amp;twine=&quot;&quot;)</td></tr>
<tr class="memdesc:a1309c381c0dd0474de50930b9e80153d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a CastFunction which represents the corresponding instruction to convert a source llvm Type to a target llvm Type. If the conversion is unsupported, throws an error.  <a href="#a1309c381c0dd0474de50930b9e80153d">More...</a><br /></td></tr>
<tr class="separator:a1309c381c0dd0474de50930b9e80153d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd24366258ae9d53689f680a1e11ea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#af036ec3b03ba7981a9af071bce3c7648">BinaryFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a7fd24366258ae9d53689f680a1e11ea0">llvmBinaryConversion</a> (const llvm::Type *const type, const <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">ast::tokens::OperatorToken</a> &amp;token, const std::string &amp;twine=&quot;&quot;)</td></tr>
<tr class="memdesc:a7fd24366258ae9d53689f680a1e11ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a BinaryFunction representing the corresponding instruction to peform on two scalar values, relative to a provided operator token. Note that not all operations are supported on floating point types! If the token is not supported, or the llvm type is not a scalar type, throws an error.  <a href="#a7fd24366258ae9d53689f680a1e11ea0">More...</a><br /></td></tr>
<tr class="separator:a7fd24366258ae9d53689f680a1e11ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad731a0bbe365ffbfa420f552dbd15301"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#ad731a0bbe365ffbfa420f552dbd15301">isValidCast</a> (llvm::Type *from, llvm::Type *to)</td></tr>
<tr class="memdesc:ad731a0bbe365ffbfa420f552dbd15301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the llvm Type 'from' can be safely cast to the llvm Type 'to'.  <a href="#ad731a0bbe365ffbfa420f552dbd15301">More...</a><br /></td></tr>
<tr class="separator:ad731a0bbe365ffbfa420f552dbd15301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef1f13e3b401760605a3f029e6bbcef"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a4ef1f13e3b401760605a3f029e6bbcef">arithmeticConversion</a> (llvm::Value *value, llvm::Type *targetType, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a4ef1f13e3b401760605a3f029e6bbcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a scalar llvm Value to a target scalar llvm Type. Returns the cast scalar value of type targetType.  <a href="#a4ef1f13e3b401760605a3f029e6bbcef">More...</a><br /></td></tr>
<tr class="separator:a4ef1f13e3b401760605a3f029e6bbcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a44e5fbd703b1966082f8f99090483"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a57a44e5fbd703b1966082f8f99090483">arrayCast</a> (llvm::Value *ptrToArray, llvm::Type *targetElementType, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a57a44e5fbd703b1966082f8f99090483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts an array to another array of equal size but of a different element type. Both source and target array element types must be scalar types. The source array llvm Value should be a pointer to the array to cast.  <a href="#a57a44e5fbd703b1966082f8f99090483">More...</a><br /></td></tr>
<tr class="separator:a57a44e5fbd703b1966082f8f99090483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bfcc557b26bbd03b288780d34e3824"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a46bfcc557b26bbd03b288780d34e3824">arithmeticConversion</a> (std::vector&lt; llvm::Value * &gt; &amp;values, llvm::Type *targetElementType, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a46bfcc557b26bbd03b288780d34e3824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of loaded llvm scalar values of the same type to a target scalar type. Each value is converted individually and the loaded result stored in the same location within values.  <a href="#a46bfcc557b26bbd03b288780d34e3824">More...</a><br /></td></tr>
<tr class="separator:a46bfcc557b26bbd03b288780d34e3824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcf19917f14365b54d655e659c57d76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a7bcf19917f14365b54d655e659c57d76">arithmeticConversion</a> (std::vector&lt; llvm::Value * &gt; &amp;values, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a7bcf19917f14365b54d655e659c57d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of loaded llvm scalar values to the highest precision type stored amongst them. Any values which are not scalar types are ignored.  <a href="#a7bcf19917f14365b54d655e659c57d76">More...</a><br /></td></tr>
<tr class="separator:a7bcf19917f14365b54d655e659c57d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9aac2f34d484624cab39744854e22ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#aa9aac2f34d484624cab39744854e22ee">arithmeticConversion</a> (llvm::Value *&amp;valueA, llvm::Value *&amp;valueB, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:aa9aac2f34d484624cab39744854e22ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses the highest order llvm Type as defined by typePrecedence from either of the two incoming values and casts the other value to the choosen type if it is not already. The types of valueA and valueB are guaranteed to match. Both values must be scalar LLVM types.  <a href="#aa9aac2f34d484624cab39744854e22ee">More...</a><br /></td></tr>
<tr class="separator:aa9aac2f34d484624cab39744854e22ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0005520eaf3f44abbdada07bd8526148"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a0005520eaf3f44abbdada07bd8526148">boolComparison</a> (llvm::Value *value, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a0005520eaf3f44abbdada07bd8526148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a C style boolean comparison from a given scalar LLVM value.  <a href="#a0005520eaf3f44abbdada07bd8526148">More...</a><br /></td></tr>
<tr class="separator:a0005520eaf3f44abbdada07bd8526148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c2b68ec30c5ab2afb6c693ae1a9628"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a45c2b68ec30c5ab2afb6c693ae1a9628">binaryOperator</a> (llvm::Value *lhs, llvm::Value *rhs, const <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">ast::tokens::OperatorToken</a> &amp;token, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="separator:a45c2b68ec30c5ab2afb6c693ae1a9628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a31582231de947feaf8179873b30813"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a5a31582231de947feaf8179873b30813">arrayIndexUnpack</a> (llvm::Value *ptrToArray, const int16_t index, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a5a31582231de947feaf8179873b30813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a particular element of an array and return a pointer to that element The provided llvm Value is expected to be a pointer to an array.  <a href="#a5a31582231de947feaf8179873b30813">More...</a><br /></td></tr>
<tr class="separator:a5a31582231de947feaf8179873b30813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953977825a4680bbe6321f804bcccc60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a953977825a4680bbe6321f804bcccc60">arrayUnpack</a> (llvm::Value *ptrToArray, std::vector&lt; llvm::Value * &gt; &amp;values, llvm::IRBuilder&lt;&gt; &amp;builder, const bool loadElements=false)</td></tr>
<tr class="memdesc:a953977825a4680bbe6321f804bcccc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack an array type into llvm Values which represent all its elements The provided llvm Value is expected to be a pointer to an array If loadElements is true, values will store loaded llvm values instead of pointers to the array elements.  <a href="#a953977825a4680bbe6321f804bcccc60">More...</a><br /></td></tr>
<tr class="separator:a953977825a4680bbe6321f804bcccc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e133207eabdc7184d43256d6d2705b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a5e133207eabdc7184d43256d6d2705b5">array3Unpack</a> (llvm::Value *ptrToArray, llvm::Value *&amp;value1, llvm::Value *&amp;value2, llvm::Value *&amp;value3, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a5e133207eabdc7184d43256d6d2705b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack the first three elements of an array. The provided llvm Value is expected to be a pointer to an array.  <a href="#a5e133207eabdc7184d43256d6d2705b5">More...</a><br /></td></tr>
<tr class="separator:a5e133207eabdc7184d43256d6d2705b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956f0eddfc85de1a881ad8e661c060d5"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a956f0eddfc85de1a881ad8e661c060d5">array3Pack</a> (llvm::Value *value1, llvm::Value *value2, llvm::Value *value3, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a956f0eddfc85de1a881ad8e661c060d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack three values into a new array and return a pointer to the newly allocated array. If the values are of a mismatching type, the highets order type is uses, as defined by typePrecedence. All llvm values are expected to a be a loaded scalar type.  <a href="#a956f0eddfc85de1a881ad8e661c060d5">More...</a><br /></td></tr>
<tr class="separator:a956f0eddfc85de1a881ad8e661c060d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04934cd8560c9c995d25b733e52ba3ec"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a04934cd8560c9c995d25b733e52ba3ec">arrayPack</a> (llvm::Value *value, llvm::IRBuilder&lt;&gt; &amp;builder, const size_t size=3)</td></tr>
<tr class="memdesc:a04934cd8560c9c995d25b733e52ba3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a loaded llvm scalar value into a new array of a specified size and return a pointer to the newly allocated array. Each element of the new array will have the value of the given scalar.  <a href="#a04934cd8560c9c995d25b733e52ba3ec">More...</a><br /></td></tr>
<tr class="separator:a04934cd8560c9c995d25b733e52ba3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace389e2437b2ccc198c2a2d87e0a34a4"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#ace389e2437b2ccc198c2a2d87e0a34a4">arrayPack</a> (const std::vector&lt; llvm::Value * &gt; &amp;values, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:ace389e2437b2ccc198c2a2d87e0a34a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a vector of loaded llvm scalar values into a new array of equal size and return a pointer to the newly allocated array.  <a href="#ace389e2437b2ccc198c2a2d87e0a34a4">More...</a><br /></td></tr>
<tr class="separator:ace389e2437b2ccc198c2a2d87e0a34a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cb43b3cf695af70103c16aa07fe3eb"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#ac4cb43b3cf695af70103c16aa07fe3eb">arrayPackCast</a> (std::vector&lt; llvm::Value * &gt; &amp;values, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:ac4cb43b3cf695af70103c16aa07fe3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a vector of loaded llvm scalar values into a new array of equal size and return a pointer to the newly allocated array. arrayPackCast first checks all the contained types in values and casts all types to the highest order type present. All llvm values in values are expected to be loaded scalar types.  <a href="#ac4cb43b3cf695af70103c16aa07fe3eb">More...</a><br /></td></tr>
<tr class="separator:ac4cb43b3cf695af70103c16aa07fe3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7016dcf003a4e417c678f640b63c284e"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a7016dcf003a4e417c678f640b63c284e">scalarToMatrix</a> (llvm::Value *scalar, llvm::IRBuilder&lt;&gt; &amp;builder, const size_t dim=3)</td></tr>
<tr class="separator:a7016dcf003a4e417c678f640b63c284e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="af036ec3b03ba7981a9af071bce3c7648"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#af036ec3b03ba7981a9af071bce3c7648">BinaryFunction</a> =  std::function&lt;llvm::Value* (llvm::IRBuilder&lt;&gt;&amp;, llvm::Value*, llvm::Value*)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a86b6ff3a4013769265f8c3dee2cbf17b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a86b6ff3a4013769265f8c3dee2cbf17b">CastFunction</a> =  std::function&lt;llvm::Value* (llvm::IRBuilder&lt;&gt;&amp;, llvm::Value*, llvm::Type*)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a> definitions for some types returned from automatic token to llvm IR operations. See llvmArithmeticConversion and llvmBianryConversion </dd></dl>

</div>
</div>
<a class="anchor" id="a4b2463f1262305b6a40aface8a10d5ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a4b2463f1262305b6a40aface8a10d5ff">M3D</a> =  <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 9&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa54db21251983c9e341b3da7635e9766"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#aa54db21251983c9e341b3da7635e9766">M3F</a> =  <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 9&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a50d45a6bbe207f32a91d91d9a3f545bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a50d45a6bbe207f32a91d91d9a3f545bb">M4D</a> =  <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 16&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a013d7b6412643a11b959eb75b974ef6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a013d7b6412643a11b959eb75b974ef6c">M4F</a> =  <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 16&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a19491c62dae10fc5b97850b29231b0ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a19491c62dae10fc5b97850b29231b0ef">V2D</a> =  <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adf19fc2ebfc31df1b136083c7051c524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#adf19fc2ebfc31df1b136083c7051c524">V2F</a> =  <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac39e79e84de78fa6188c1b812ef7c9c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#ac39e79e84de78fa6188c1b812ef7c9c0">V2I</a> =  <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;int32_t, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afe076b1a292d8635a2e144ecb285be2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#afe076b1a292d8635a2e144ecb285be2c">V3D</a> =  <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3a93313e37930c7ec565dc4f3eb36fd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a3a93313e37930c7ec565dc4f3eb36fd6">V3F</a> =  <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b46918e9d7dca7ca333e39d3a80f525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a7b46918e9d7dca7ca333e39d3a80f525">V3I</a> =  <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;int32_t, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a96a5962a96d7ca3f39ad565d8fffd335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a96a5962a96d7ca3f39ad565d8fffd335">V4D</a> =  <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;double, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5289743e2fa6d363751795a25ec6dd19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a5289743e2fa6d363751795a25ec6dd19">V4F</a> =  <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;float, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1da87a694970da5888f4db38a93c2ffb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a1da87a694970da5888f4db38a93c2ffb">V4I</a> =  <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1ArgType.html">ArgType</a>&lt;int32_t, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4ef1f13e3b401760605a3f029e6bbcef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* openvdb::v7_2::ax::codegen::arithmeticConversion </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>targetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a scalar llvm Value to a target scalar llvm Type. Returns the cast scalar value of type targetType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A llvm scalar value to convert </td></tr>
    <tr><td class="paramname">targetType</td><td>The target llvm scalar type to convert to </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46bfcc557b26bbd03b288780d34e3824"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v7_2::ax::codegen::arithmeticConversion </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>targetElementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a vector of loaded llvm scalar values of the same type to a target scalar type. Each value is converted individually and the loaded result stored in the same location within values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of llvm scalar values to convert </td></tr>
    <tr><td class="paramname">targetElementType</td><td>The target llvm scalar type to convert each value of the input vector </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bcf19917f14365b54d655e659c57d76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v7_2::ax::codegen::arithmeticConversion </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a vector of loaded llvm scalar values to the highest precision type stored amongst them. Any values which are not scalar types are ignored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of llvm scalar values to convert </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9aac2f34d484624cab39744854e22ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v7_2::ax::codegen::arithmeticConversion </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&amp;&#160;</td>
          <td class="paramname"><em>valueA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&amp;&#160;</td>
          <td class="paramname"><em>valueB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chooses the highest order llvm Type as defined by typePrecedence from either of the two incoming values and casts the other value to the choosen type if it is not already. The types of valueA and valueB are guaranteed to match. Both values must be scalar LLVM types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valueA</td><td>The first llvm value </td></tr>
    <tr><td class="paramname">valueB</td><td>The second llvm value </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a956f0eddfc85de1a881ad8e661c060d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* openvdb::v7_2::ax::codegen::array3Pack </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>value3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack three values into a new array and return a pointer to the newly allocated array. If the values are of a mismatching type, the highets order type is uses, as defined by typePrecedence. All llvm values are expected to a be a loaded scalar type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value1</td><td>The first array value </td></tr>
    <tr><td class="paramname">value2</td><td>The second array value </td></tr>
    <tr><td class="paramname">value3</td><td>The third array value </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e133207eabdc7184d43256d6d2705b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v7_2::ax::codegen::array3Unpack </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>ptrToArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&amp;&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&amp;&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&amp;&#160;</td>
          <td class="paramname"><em>value3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack the first three elements of an array. The provided llvm Value is expected to be a pointer to an array. </p>
<dl class="section note"><dt>Note</dt><dd>The elements are note loaded</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrToArray</td><td>A llvm value which is a pointer to a llvm array </td></tr>
    <tr><td class="paramname">value1</td><td>The first array value </td></tr>
    <tr><td class="paramname">value2</td><td>The second array value </td></tr>
    <tr><td class="paramname">value3</td><td>The third array value </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57a44e5fbd703b1966082f8f99090483"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* openvdb::v7_2::ax::codegen::arrayCast </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>ptrToArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>targetElementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts an array to another array of equal size but of a different element type. Both source and target array element types must be scalar types. The source array llvm Value should be a pointer to the array to cast. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrToArray</td><td>A llvm value which is a pointer to a llvm array </td></tr>
    <tr><td class="paramname">targetElementType</td><td>The target llvm scalar type to convert each element of the input array </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a31582231de947feaf8179873b30813"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* openvdb::v7_2::ax::codegen::arrayIndexUnpack </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>ptrToArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a particular element of an array and return a pointer to that element The provided llvm Value is expected to be a pointer to an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrToArray</td><td>A llvm value which is a pointer to a llvm array </td></tr>
    <tr><td class="paramname">index</td><td>The index at which to access the array </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04934cd8560c9c995d25b733e52ba3ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* openvdb::v7_2::ax::codegen::arrayPack </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a loaded llvm scalar value into a new array of a specified size and return a pointer to the newly allocated array. Each element of the new array will have the value of the given scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The uniform scalar llvm value to pack into the array </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
    <tr><td class="paramname">size</td><td>The size of the newly allocated array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace389e2437b2ccc198c2a2d87e0a34a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* openvdb::v7_2::ax::codegen::arrayPack </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a vector of loaded llvm scalar values into a new array of equal size and return a pointer to the newly allocated array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of loaded llvm scalar values to pack </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4cb43b3cf695af70103c16aa07fe3eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* openvdb::v7_2::ax::codegen::arrayPackCast </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pack a vector of loaded llvm scalar values into a new array of equal size and return a pointer to the newly allocated array. arrayPackCast first checks all the contained types in values and casts all types to the highest order type present. All llvm values in values are expected to be loaded scalar types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of loaded llvm scalar values to pack </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a953977825a4680bbe6321f804bcccc60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v7_2::ax::codegen::arrayUnpack </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>ptrToArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>loadElements</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack an array type into llvm Values which represent all its elements The provided llvm Value is expected to be a pointer to an array If loadElements is true, values will store loaded llvm values instead of pointers to the array elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrToArray</td><td>A llvm value which is a pointer to a llvm array </td></tr>
    <tr><td class="paramname">values</td><td>A vector of llvm values where to store the array elements </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
    <tr><td class="paramname">loadElements</td><td>Whether or not to load each array element into a register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45c2b68ec30c5ab2afb6c693ae1a9628"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* openvdb::v7_2::ax::codegen::binaryOperator </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">ast::tokens::OperatorToken</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@ brief Performs a binary operation on two loaded llvm scalar values of the same type. The type of operation performed is defined by the token (see the list of supported tokens in <a class="el" href="Tokens_8h.html" title="Various function and operator tokens used throughout the AST and code generation. ...">ast/Tokens.h</a>. Returns a loaded llvm scalar result</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side value of the binary operation </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side value of the binary operation </td></tr>
    <tr><td class="paramname">token</td><td>The token representing the binary operation to perform </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0005520eaf3f44abbdada07bd8526148"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* openvdb::v7_2::ax::codegen::boolComparison </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a C style boolean comparison from a given scalar LLVM value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar llvm value to convert to a boolean </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a9ee9a0ec0a79d08c610b2d30d2c5d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionRegistry.html#af87f2a1a2395918a71eed11c61f94fc8">FunctionRegistry::UniquePtr</a> createDefaultRegistry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *&#160;</td>
          <td class="paramname"><em>op</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a registry with the default set of registered functions including math functions, point functions and volume functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The current function options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a066a335df1113aa7800057226a00aae8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Argument* openvdb::v7_2::ax::codegen::extractArgument </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeddb950365b7bfca6d0a0019ebbd8871"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Argument* openvdb::v7_2::ax::codegen::extractArgument </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4eb0cfc528aafabe1b1f618ab24fad4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type* openvdb::v7_2::ax::codegen::getBaseContainedType </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *const&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the base llvm value which is being pointed to through any number of layered pointers. </p>
<dl class="section note"><dt>Note</dt><dd>This function does not check for cyclical pointer dependencies</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>A llvm pointer type to traverse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8781a243c49f40b0e9b41b7e8b93e851"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v7_2::ax::codegen::insertStandardFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionRegistry.html">FunctionRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates a function registry with all available "standard" AX library function. This primarily consists of all mathematical ops on AX containers (scalars, vectors, matrices) and other stl built-ins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The function registry to populate </td></tr>
    <tr><td class="paramname">options</td><td>The current function options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54c6514874aa6a077e3cb9741d4236ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* openvdb::v7_2::ax::codegen::insertStaticAlloca </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>size</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a stack allocation at the beginning of the current function of the provided type and size. The IRBuilder's insertion point must be set to a BasicBlock with a valid <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a> parent. </p>
<dl class="section note"><dt>Note</dt><dd>If a size is provided, the size must not depend on any other instructions. If it does, invalid LLVM IR will bb generated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td>The IRBuilder </td></tr>
    <tr><td class="paramname">type</td><td>The type to allocate </td></tr>
    <tr><td class="paramname">size</td><td>Optional count of allocations. If nullptr, runs a single allocation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4bf330570662d8ed35f3b76193f69461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v7_2::ax::codegen::insertVDBPointFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionRegistry.html">FunctionRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates a function registry with all available OpenVDB Point AX library function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The function registry to populate </td></tr>
    <tr><td class="paramname">options</td><td>The current function options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e34d0af451f6aa344f9512e4a5f0c90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v7_2::ax::codegen::insertVDBVolumeFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v7__2_1_1ax_1_1codegen_1_1FunctionRegistry.html">FunctionRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v7__2_1_1ax_1_1FunctionOptions.html">FunctionOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates a function registry with all available OpenVDB Volume AX library function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The function registry to populate </td></tr>
    <tr><td class="paramname">options</td><td>The current function options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad731a0bbe365ffbfa420f552dbd15301"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openvdb::v7_2::ax::codegen::isValidCast </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the llvm Type 'from' can be safely cast to the llvm Type 'to'. </p>

</div>
</div>
<a class="anchor" id="a1309c381c0dd0474de50930b9e80153d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#a86b6ff3a4013769265f8c3dee2cbf17b">CastFunction</a> openvdb::v7_2::ax::codegen::llvmArithmeticConversion </td>
          <td>(</td>
          <td class="paramtype">const llvm::Type *const&#160;</td>
          <td class="paramname"><em>sourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Type *const&#160;</td>
          <td class="paramname"><em>targetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>twine</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a CastFunction which represents the corresponding instruction to convert a source llvm Type to a target llvm Type. If the conversion is unsupported, throws an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceType</td><td>The source type to cast </td></tr>
    <tr><td class="paramname">targetType</td><td>The target type to cast to </td></tr>
    <tr><td class="paramname">twine</td><td>An optional string description of the cast function. This can be used for for more verbose llvm information on IR compilation failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fd24366258ae9d53689f680a1e11ea0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1codegen.html#af036ec3b03ba7981a9af071bce3c7648">BinaryFunction</a> openvdb::v7_2::ax::codegen::llvmBinaryConversion </td>
          <td>(</td>
          <td class="paramtype">const llvm::Type *const&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">ast::tokens::OperatorToken</a> &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>twine</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a BinaryFunction representing the corresponding instruction to peform on two scalar values, relative to a provided operator token. Note that not all operations are supported on floating point types! If the token is not supported, or the llvm type is not a scalar type, throws an error. </p>
<dl class="section note"><dt>Note</dt><dd>Various default arguments are bound to provide a simple function call signature. For floating point operations, this includes a null pointer to the optional metadata node. For integer operations, this includes disabling all overflow/rounding optimisations</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type defining the precision of the binary operation </td></tr>
    <tr><td class="paramname">token</td><td>The token used to create the relative binary operation </td></tr>
    <tr><td class="paramname">twine</td><td>An optional string description of the binary function. This can be used for for more verbose llvm information on IR compilation failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0013600e52981c708958349aad91b56e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Constant* openvdb::v7_2::ax::codegen::llvmConstant </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an llvm Constant holding a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The scalar constant </td></tr>
    <tr><td class="paramname">type</td><td>The LLVM type. Can differ from the type of t, in which case the value will be cast to the llvm type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32e85b235ef6946a16ba1261ad74e47e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type* openvdb::v7_2::ax::codegen::llvmFloatType </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an llvm floating point Type given a requested size and context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the float to request, i.e. float - 32, double - 64 etc. </td></tr>
    <tr><td class="paramname">C</td><td>The LLVMContext to request the Type from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b6ed37845100370d8843bbb0a248f77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::FunctionType* openvdb::v7_2::ax::codegen::llvmFunctionTypeFromSignature </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate an LLVM FunctionType from a function signature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The llvm context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab513d427fc629be1746de7db624ea9a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::IntegerType* openvdb::v7_2::ax::codegen::llvmIntType </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an llvm IntegerType given a requested size and context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of bits of the integer type </td></tr>
    <tr><td class="paramname">C</td><td>The LLVMContext to request the Type from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a656906a31095231b82efe15675a763f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* openvdb::v7_2::ax::codegen::llvmPointerFromAddress </td>
          <td>(</td>
          <td class="paramtype">const ValueT *const &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an llvm value representing a pointer to the provided ptr builtin ValueT. </p>
<dl class="section note"><dt>Note</dt><dd>This is probably not a suitable solution for anything other than POD types and should be used with caution.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to a type of ValueT whose address will be computed and returned </td></tr>
    <tr><td class="paramname">builder</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c91c78680ca47f8f72386a9b2ebb486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type* openvdb::v7_2::ax::codegen::llvmTypeFromToken </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an llvm type representing a type defined by a string. </p>
<dl class="section note"><dt>Note</dt><dd>For string types, this function returns the element type, not the object type! The llvm type representing a char block of memory is LLVMType&lt;char*&gt;::get(C); </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The AX token type </td></tr>
    <tr><td class="paramname">C</td><td>The LLVMContext to request the Type from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a690a4182b12b0f6a6beb121d6e795c0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type* openvdb::v7_2::ax::codegen::llvmTypesFromSignature </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; llvm::Type * &gt; *&#160;</td>
          <td class="paramname"><em>types</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a vector of llvm types from a function signature declaration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The llvm context </td></tr>
    <tr><td class="paramname">types</td><td>A vector of types to populate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91bdb1f014a6367ae360031783585ad5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v7_2::ax::codegen::llvmTypeToString </td>
          <td>(</td>
          <td class="paramtype">const llvm::Type *const&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints an llvm type to a std string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The llvm type to convert </td></tr>
    <tr><td class="paramname">str</td><td>The string to store the type info to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55f5924634eb5a69f76f20c4b4674a1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v7_2::ax::codegen::printSignature </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; llvm::Type * &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Type *&#160;</td>
          <td class="paramname"><em>returnType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const char * &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>axTypes</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a function signature to the provided ostream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The stream to print to </td></tr>
    <tr><td class="paramname">types</td><td>The function argument types </td></tr>
    <tr><td class="paramname">returnType</td><td>The return type of the function. Must not be a nullptr </td></tr>
    <tr><td class="paramname">name</td><td>The name of the function. If not provided, the return type neighbours the first parenthesis </td></tr>
    <tr><td class="paramname">names</td><td>Names of the function parameters. If a name is nullptr, it skipped </td></tr>
    <tr><td class="paramname">axTypes</td><td>Whether to try and convert the llvm::Types provided to AX types. If false, the llvm types are used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7016dcf003a4e417c678f640b63c284e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* openvdb::v7_2::ax::codegen::scalarToMatrix </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acab7d041c838af53c88857b4aab664b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a> openvdb::v7_2::ax::codegen::tokenFromLLVMType </td>
          <td>(</td>
          <td class="paramtype">const llvm::Type *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a corresponding AX token which represents the given LLVM Type. </p>
<dl class="section note"><dt>Note</dt><dd>If the type does not exist in AX, <a class="el" href="namespaceopenvdb_1_1v7__2_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7a6ce26a62afab55d7606ad4e92428b30c">ast::tokens::UNKNOWN</a> is returned. Must not be a nullptr. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>a valid LLVM Type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0da92c1d0e5dec19ed0b89f6c448d02e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type* openvdb::v7_2::ax::codegen::typePrecedence </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *const&#160;</td>
          <td class="paramname"><em>typeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *const&#160;</td>
          <td class="paramname"><em>typeB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the highest order type from two LLVM Scalar types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeA</td><td>The first scalar llvm type </td></tr>
    <tr><td class="paramname">typeB</td><td>The second scalar llvm type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a932191a045e76905a9e7e76155e69fa0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v7_2::ax::codegen::valuesToTypes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; llvm::Type * &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a vector of llvm Types from a vector of llvm values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of llvm values to retrieve types from </td></tr>
    <tr><td class="paramname">types</td><td>A vector of llvm types to populate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
