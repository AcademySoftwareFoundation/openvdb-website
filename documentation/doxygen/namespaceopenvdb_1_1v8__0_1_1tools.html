<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: openvdb::v8_0::tools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__0.html">v8_0</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html">tools</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">openvdb::v8_0::tools Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1activation"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1activation.html">activation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1clip__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1clip__internal.html">clip_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1composite"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1composite.html">composite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1diagnostics__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1diagnostics__internal.html">diagnostics_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1ds"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1ds.html">ds</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1filter__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1filter__internal.html">filter_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1gridop"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1gridop.html">gridop</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1level__set__fracture__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1level__set__fracture__internal.html">level_set_fracture_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1level__set__util__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1level__set__util__internal.html">level_set_util_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1local__util"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1local__util.html">local_util</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1lstrack"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1lstrack.html">lstrack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1mask__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1mask__internal.html">mask_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1merge__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1merge__internal.html">merge_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1mesh__to__volume__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1mesh__to__volume__internal.html">mesh_to_volume_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1p2ls__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1p2ls__internal.html">p2ls_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1particle__atlas__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1particle__atlas__internal.html">particle_atlas_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1point__index__grid__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1point__index__grid__internal.html">point_index_grid_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1point__partitioner__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1point__partitioner__internal.html">point_partitioner_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1poisson"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1poisson.html">poisson</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1potential__flow__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1potential__flow__internal.html">potential_flow_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1Scheme"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1Scheme.html">Scheme</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1stats__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1stats__internal.html">stats_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1ttls__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1ttls__internal.html">ttls_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1v2s__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1v2s__internal.html">v2s_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1valxform"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1valxform.html">valxform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1tools_1_1volume__to__mesh__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1volume__to__mesh__internal.html">volume_to_mesh_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ABTransform.html">ABTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the Transformer functor interface (specifically, the <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ABTransform.html#a9ce6bbb194d837844498a30647002012">isAffine()</a>, <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ABTransform.html#a273dcce2c3a35b295964de4702f943da">transform()</a> and <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ABTransform.html#a7d9008b60b1759bc490ef3cac79582c8">invTransform()</a> methods) for a transform that maps an A grid into a B grid's index space such that, after resampling, A's index space and transform match B's index space and transform.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1ABTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1AlphaMask.html">AlphaMask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1BaseCamera.html">BaseCamera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for the perspective and orthographic cameras.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1BaseCamera.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1BasePointScatter.html">BasePointScatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of base class.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1BasePointScatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1BaseShader.html">BaseShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for the shaders.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1BaseShader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1BoxSampler.html">BoxSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ChangeBackgroundOp.html">ChangeBackgroundOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ChangeLevelSetBackgroundOp.html">ChangeLevelSetBackgroundOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CheckDivergence.html">CheckDivergence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the divergence against a range.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1CheckDivergence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CheckEikonal.html">CheckEikonal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the norm of the gradient at zero-crossing voxels against a range.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1CheckEikonal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CheckFinite.html">CheckFinite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for both NaN and inf values, i.e. any value that is not finite.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1CheckFinite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1CheckFogVolume.html">CheckFogVolume</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that performs various types of checks on fog volumes.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1CheckFogVolume.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CheckInf.html">CheckInf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for infinite values, e.g. 1/0 or -1/0.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1CheckInf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1CheckLevelSet.html">CheckLevelSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that performs various types of checks on narrow-band level sets.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1CheckLevelSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CheckMagnitude.html">CheckMagnitude</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the magnitude of a value, a, is close to a fixed magnitude, b, given a fixed tolerance c. That is | |a| - |b| | &lt;= c.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1CheckMagnitude.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CheckMax.html">CheckMax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a value against a maximum.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1CheckMax.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CheckMin.html">CheckMin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a value against a minimum.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1CheckMin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CheckNan.html">CheckNan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks NaN values.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1CheckNan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CheckNormGrad.html">CheckNormGrad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the norm of the gradient against a range, i.e., |&nabla;&Phi;| &isin; [min, max].  <a href="structopenvdb_1_1v8__0_1_1tools_1_1CheckNormGrad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CheckRange.html">CheckRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a value against a range.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1CheckRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ClosestPointProjector.html">ClosestPointProjector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ClosestSurfacePoint.html">ClosestSurfacePoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accelerated closest surface point queries for narrow band level sets.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1ClosestSurfacePoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CompReplaceOp.html">CompReplaceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ConstrainedPointAdvect.html">ConstrainedPointAdvect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ContiguousOp.html">ContiguousOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a wrapper struct used to avoid unnecessary computation of memory access from <code>Coord</code> when all offsets are guaranteed to be within the dense grid.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1ContiguousOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1CopyFromDense.html">CopyFromDense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the values from a dense grid into an OpenVDB tree.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1CopyFromDense.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1CopyToDense.html">CopyToDense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an OpenVDB tree into an existing dense grid.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1CopyToDense.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Cpt.html">Cpt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the closest-point transform of a scalar grid.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1Cpt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CsgDifferenceOp.html">CsgDifferenceOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DynamicNodeManager operator to merge two trees using a CSG difference.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1CsgDifferenceOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CsgUnionOrIntersectionOp.html">CsgUnionOrIntersectionOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DynamicNodeManager operator to merge trees using a CSG union or intersection.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1CsgUnionOrIntersectionOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Curl.html">Curl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the curl of a vector grid.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1Curl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Dense.html">Dense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Dense.html" title="Dense is a simple dense grid API used by the CopyToDense and CopyFromDense classes defined below...">Dense</a> is a simple dense grid API used by the <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1CopyToDense.html" title="Copy an OpenVDB tree into an existing dense grid. ">CopyToDense</a> and <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1CopyFromDense.html" title="Copy the values from a dense grid into an OpenVDB tree. ">CopyFromDense</a> classes defined below.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1Dense.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DenseBase.html">DenseBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Dense.html" title="Dense is a simple dense grid API used by the CopyToDense and CopyFromDense classes defined below...">Dense</a> which is defined below.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1DenseBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DenseBase_3_01ValueT_00_01LayoutXYZ_01_4.html">DenseBase&lt; ValueT, LayoutXYZ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial template specialization of <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DenseBase.html" title="Base class for Dense which is defined below. ">DenseBase</a>.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1DenseBase_3_01ValueT_00_01LayoutXYZ_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DenseBase_3_01ValueT_00_01LayoutZYX_01_4.html">DenseBase&lt; ValueT, LayoutZYX &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial template specialization of <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DenseBase.html" title="Base class for Dense which is defined below. ">DenseBase</a>.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1DenseBase_3_01ValueT_00_01LayoutZYX_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DenseTransformer.html">DenseTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that applies a functor to the index space intersection of a prescribed bounding box and the dense grid. NB: This class only supports DenseGrids with ZYX memory layout.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1DenseTransformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DenseUniformPointScatter.html">DenseUniformPointScatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters a fixed (and integer) number of points in all active voxels and tiles.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1DenseUniformPointScatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Diagnose.html">Diagnose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs multithreaded diagnostics of a grid.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1Diagnose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DiffuseShader.html">DiffuseShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple diffuse Lambertian surface shader.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1DiffuseShader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DiffuseShader_3_01Film_1_1RGBA_00_01SamplerType_01_4.html">DiffuseShader&lt; Film::RGBA, SamplerType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DilationOp.html">DilationOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that performs multi-threaded dilation with support for active tiles.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1DilationOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1DimToWord.html">DimToWord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from a Log2Dim to a data type of size 2^Log2Dim bits.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1DimToWord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1DimToWord_3_013_01_4.html">DimToWord&lt; 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1DimToWord_3_014_01_4.html">DimToWord&lt; 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1DimToWord_3_015_01_4.html">DimToWord&lt; 5 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1DimToWord_3_016_01_4.html">DimToWord&lt; 6 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DiracDelta.html">DiracDelta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smeared-out and continuous Dirac Delta function.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1DiracDelta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DiscreteField.html">DiscreteField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thin wrapper class for a velocity grid.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1DiscreteField.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Divergence.html">Divergence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the divergence of a vector grid.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1Divergence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1DSConverter.html">DSConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DualGridSampler.html">DualGridSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple convenience class that allows for sampling from a source grid into the index space of a target grid. At construction the source and target grids are checked for alignment which potentially renders interpolation unnecessary. Else interpolation is performed according to the templated <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1Sampler.html" title="Provises a unified interface for sampling, i.e. interpolation. ">Sampler</a> type.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1DualGridSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DualGridSampler_3_01tree_1_1ValueAccessor_3_01TreeT_01_4_00_01SamplerT_01_4.html">DualGridSampler&lt; tree::ValueAccessor&lt; TreeT &gt;, SamplerT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1DualGridSampler.html" title="This is a simple convenience class that allows for sampling from a source grid into the index space o...">DualGridSampler</a> for construction from a ValueAccessor type.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1DualGridSampler_3_01tree_1_1ValueAccessor_3_01TreeT_01_4_00_01SamplerT_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1EnrightField.html">EnrightField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analytical, divergence-free and periodic velocity field.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1EnrightField.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ExtractAll.html">ExtractAll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple utility class used by <code>extractSparseTreeWithMask</code>  <a href="structopenvdb_1_1v8__0_1_1tools_1_1ExtractAll.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1FastSweeping.html">FastSweeping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes signed distance values from an initial iso-surface and optionally performs velocty extension at the same time. This is done by means of a novel sparse and parallel fast sweeping algorithm based on a first order Goudonov's scheme.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1FastSweeping.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Film.html">Film</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class that allows for concurrent writes to pixels in an image, background initialization of the image, and PPM or EXR file output.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1Film.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Filter.html">Filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume filtering (e.g., diffusion) with optional alpha masking.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1Filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1FindActiveValues.html">FindActiveValues</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the active values in a tree which intersects a bounding box.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1FindActiveValues.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Gradient.html">Gradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of a scalar grid.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1Gradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1GridResampler.html">GridResampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1GridSampler.html">GridSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides the interface for continuous sampling of values in a tree.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1GridSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1GridSampler_3_01tree_1_1ValueAccessor_3_01TreeT_01_4_00_01SamplerType_01_4.html">GridSampler&lt; tree::ValueAccessor&lt; TreeT &gt;, SamplerType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1GridSampler.html" title="Class that provides the interface for continuous sampling of values in a tree. ">GridSampler</a> for construction from a ValueAccessor type.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1GridSampler_3_01tree_1_1ValueAccessor_3_01TreeT_01_4_00_01SamplerType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1GridTransformer.html">GridTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1GridTransformer.html" title="A GridTransformer applies a geometric transformation to an input grid using one of several sampling s...">GridTransformer</a> applies a geometric transformation to an input grid using one of several sampling schemes, and stores the result in an output grid.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1GridTransformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1HalfWidthOp.html">HalfWidthOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1HalfWidthOp_3_01bool_01_4.html">HalfWidthOp&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1HomogeneousMatMul.html">HomogeneousMatMul</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1InactivePruneOp.html">InactivePruneOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Laplacian.html">Laplacian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetAdvection.html">LevelSetAdvection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic advection of narrow-band level sets in an external velocity field.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetAdvection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetFilter.html">LevelSetFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filtering (e.g. diffusion) of narrow-band level sets. An optional scalar field can be used to produce a (smooth) alpha mask for the filtering.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetFracture.html">LevelSetFracture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level set fracturing.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetFracture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetMeasure.html">LevelSetMeasure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-threaded computation of surface area, volume and average mean-curvature for narrow band level sets.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetMeasure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetMorphing.html">LevelSetMorphing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape morphology of level sets. Morphing from a source narrow-band level sets to a target narrow-band level set.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetMorphing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetPruneOp.html">LevelSetPruneOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetRayIntersector.html">LevelSetRayIntersector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the public API for intersecting a ray with a narrow-band level set.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetRayIntersector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetRayTracer.html">LevelSetRayTracer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (very) simple multithreaded ray tracer specifically for narrow-band level sets.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetRayTracer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetSphere.html">LevelSetSphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a signed distance field (or narrow band level set) to a single sphere.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetSphere.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetTracker.html">LevelSetTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs multi-threaded interface tracking of narrow band level sets.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetTracker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1LinearSearchImpl.html">LinearSearchImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements linear iterative search for an iso-value of the level set along the direction of the ray.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1LinearSearchImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Magnitude.html">Magnitude</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1MatMul.html">MatMul</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1MatMulNormalize.html">MatMulNormalize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1MatteShader.html">MatteShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shader that produces a simple matte.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1MatteShader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1MatteShader_3_01Film_1_1RGBA_00_01SamplerType_01_4.html">MatteShader&lt; Film::RGBA, SamplerType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1MeanCurvature.html">MeanCurvature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1MeshToVoxelEdgeData.html">MeshToVoxelEdgeData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts and stores voxel edge intersection data from a mesh.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1MeshToVoxelEdgeData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Morphology.html">Morphology</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1MultiResGrid.html">MultiResGrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1NonUniformPointScatter.html">NonUniformPointScatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-uniform scatters of point in the active voxels. The local point count is implicitly defined as a product of of a global density (called pointsPerVolume) and the local voxel (or tile) value.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1NonUniformPointScatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Normalize.html">Normalize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1NormalShader.html">NormalShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color shader that treats the surface normal (x, y, z) as an RGB color.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1NormalShader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1NormalShader_3_01Film_1_1RGBA_00_01SamplerType_01_4.html">NormalShader&lt; Film::RGBA, SamplerType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1OrthographicCamera.html">OrthographicCamera</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ParticleAtlas.html">ParticleAtlas</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ParticlesToLevelSet.html">ParticlesToLevelSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1PerspectiveCamera.html">PerspectiveCamera</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1PointAdvect.html">PointAdvect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1PointIndexFilter.html">PointIndexFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1PointIndexIterator.html">PointIndexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accelerated range and nearest-neighbor searches for point index grids.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1PointIndexIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1PointIndexLeafNode.html">PointIndexLeafNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1PointPartitioner.html">PointPartitioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1PointSampler.html">PointSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1PointsToMask.html">PointsToMask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes every voxel of a grid active if it contains a point.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1PointsToMask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1PolygonPool.html">PolygonPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of quads and triangles.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1PolygonPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1PositionShader.html">PositionShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color shader that treats position (x, y, z) as an RGB color in a cube defined from an axis-aligned bounding box in world space.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1PositionShader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1PositionShader_3_01Film_1_1RGBA_00_01SamplerType_01_4.html">PositionShader&lt; Film::RGBA, SamplerType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1QuadAndTriangleDataAdapter.html">QuadAndTriangleDataAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contiguous quad and triangle data adapter class.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1QuadAndTriangleDataAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1QuadraticSampler.html">QuadraticSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1Sampler.html">Sampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provises a unified interface for sampling, i.e. interpolation.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1Sampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1Sampler_3_010_00_01false_01_4.html">Sampler&lt; 0, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1Sampler_3_010_00_01true_01_4.html">Sampler&lt; 0, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1Sampler_3_011_00_01false_01_4.html">Sampler&lt; 1, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1Sampler_3_011_00_01true_01_4.html">Sampler&lt; 1, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1Sampler_3_012_00_01false_01_4.html">Sampler&lt; 2, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1Sampler_3_012_00_01true_01_4.html">Sampler&lt; 2, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html#a8b727e6fbafe29f45e41f6dd34442324">ScalarToVectorConverter&lt;ScalarGridType&gt;::Type</a> is the type of a grid having the same tree configuration as ScalarGridType but value type Vec3&lt;T&gt; where T is ScalarGridType::ValueType.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1SignedFloodFillOp.html">SignedFloodFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1SparseExtractor.html">SparseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor-based class used to extract data that satisfies some criteria defined by the embedded <code>OpType</code> functor. The <code>extractSparseTree</code> function wraps this class.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1SparseExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1SparseMaskedExtractor.html">SparseMaskedExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor-based class used to extract data from a dense grid, at the index-space intersection with a supplied mask in the form of a sparse tree. The <code>extractSparseTreeWithMask</code> function wraps this class.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1SparseMaskedExtractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1SparseToDenseCompositor.html">SparseToDenseCompositor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1StaggeredBoxSampler.html">StaggeredBoxSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1StaggeredPointSampler.html">StaggeredPointSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1StaggeredQuadraticSampler.html">StaggeredQuadraticSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1TileData.html">TileData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that encodes a bounding box, value and level of a tile.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1TileData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1TolerancePruneOp.html">TolerancePruneOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1TreeToMerge.html">TreeToMerge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience class that contains a pointer to a tree to be stolen or deep copied depending on the tag dispatch class used and a subset of methods to retrieve data from the tree.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1TreeToMerge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1UniformPointScatter.html">UniformPointScatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The two point scatters <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1UniformPointScatter.html" title="The two point scatters UniformPointScatter and NonUniformPointScatter depend on the following two cla...">UniformPointScatter</a> and <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1NonUniformPointScatter.html" title="Non-uniform scatters of point in the active voxels. The local point count is implicitly defined as a ...">NonUniformPointScatter</a> depend on the following two classes:  <a href="classopenvdb_1_1v8__0_1_1tools_1_1UniformPointScatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html#a11740aac462a0be7c37c692175a28e3a">VectorToScalarConverter&lt;VectorGridType&gt;::Type</a> is the type of a grid having the same tree configuration as VectorGridType but a scalar value type, T, where T is the type of the original vector components.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarGrid.html">VectorToScalarGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to convert a vector-valued grid type to a scalar grid type.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1VelocityIntegrator.html">VelocityIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Runge-Kutta time integration of variable order in a static velocity field.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1VelocityIntegrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1VelocitySampler.html">VelocitySampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1VolumeAdvection.html">VolumeAdvection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs advections of an arbitrary type of volume in a static velocity field. The advections are performed by means of various derivatives of Semi-Lagrangian integration, i.e. backwards tracking along the hyperbolic characteristics followed by interpolation.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1VolumeAdvection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1VolumeRayIntersector.html">VolumeRayIntersector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the public API for intersecting a ray with a generic (e.g. density) volume.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1VolumeRayIntersector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1VolumeRender.html">VolumeRender</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (very) simple multithreaded volume render specifically for scalar density.  <a href="classopenvdb_1_1v8__0_1_1tools_1_1VolumeRender.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VolumeToMesh.html">VolumeToMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh any scalar grid that has a continuous isosurface.  <a href="structopenvdb_1_1v8__0_1_1tools_1_1VolumeToMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa2bd678647ee7c097628900599ecd911"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:aa2bd678647ee7c097628900599ecd911"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aa2bd678647ee7c097628900599ecd911">CsgUnionOp</a> = <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CsgUnionOrIntersectionOp.html">CsgUnionOrIntersectionOp</a>&lt; TreeT, true &gt;</td></tr>
<tr class="separator:aa2bd678647ee7c097628900599ecd911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15acb14744ad597506ab2c876df1e3c0"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:a15acb14744ad597506ab2c876df1e3c0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a15acb14744ad597506ab2c876df1e3c0">CsgIntersectionOp</a> = <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CsgUnionOrIntersectionOp.html">CsgUnionOrIntersectionOp</a>&lt; TreeT, false &gt;</td></tr>
<tr class="separator:a15acb14744ad597506ab2c876df1e3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b5eb564884170a157dd5ea34c183f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ae0b5eb564884170a157dd5ea34c183f5">ParticleIndexAtlas</a> = <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ParticleAtlas.html">ParticleAtlas</a>&lt; <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#acfb828103bf471f9c51ea65d156e4498">PointIndexGrid</a> &gt;</td></tr>
<tr class="separator:ae0b5eb564884170a157dd5ea34c183f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59b06fbf7e8c0f817695e92b0a86db1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#af59b06fbf7e8c0f817695e92b0a86db1">PointIndexTree</a> = <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1Tree.html">tree::Tree</a>&lt; <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1RootNode.html">tree::RootNode</a>&lt; <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1InternalNode.html">tree::InternalNode</a>&lt; <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1InternalNode.html">tree::InternalNode</a>&lt; <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1PointIndexLeafNode.html">PointIndexLeafNode</a>&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a58d2265df00dc40b96bfbdc675052994">PointIndex32</a>, 3 &gt;, 4 &gt;, 5 &gt;&gt;&gt;</td></tr>
<tr class="memdesc:af59b06fbf7e8c0f817695e92b0a86db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point index tree configured to match the default OpenVDB tree configuration.  <a href="#af59b06fbf7e8c0f817695e92b0a86db1">More...</a><br /></td></tr>
<tr class="separator:af59b06fbf7e8c0f817695e92b0a86db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb828103bf471f9c51ea65d156e4498"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#acfb828103bf471f9c51ea65d156e4498">PointIndexGrid</a> = <a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html">Grid</a>&lt; <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#af59b06fbf7e8c0f817695e92b0a86db1">PointIndexTree</a> &gt;</td></tr>
<tr class="memdesc:acfb828103bf471f9c51ea65d156e4498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point index grid.  <a href="#acfb828103bf471f9c51ea65d156e4498">More...</a><br /></td></tr>
<tr class="separator:acfb828103bf471f9c51ea65d156e4498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bc789f19484fd8102225765173f548"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a52bc789f19484fd8102225765173f548">UInt32PointPartitioner</a> = <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1PointPartitioner.html">PointPartitioner</a>&lt; uint32_t, 3 &gt;</td></tr>
<tr class="separator:a52bc789f19484fd8102225765173f548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a48d92c3835e9c28ed5fd3c9a416d3585"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a48d92c3835e9c28ed5fd3c9a416d3585">PointList</a> = std::unique_ptr&lt; openvdb::Vec3s[]&gt;</td></tr>
<tr class="memdesc:a48d92c3835e9c28ed5fd3c9a416d3585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point and primitive list types.  <a href="#a48d92c3835e9c28ed5fd3c9a416d3585">More...</a><br /></td></tr>
<tr class="separator:a48d92c3835e9c28ed5fd3c9a416d3585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c6e4a427196ef80116eb8fd76a62b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aa4c6e4a427196ef80116eb8fd76a62b6">PolygonPoolList</a> = std::unique_ptr&lt; <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1PolygonPool.html">PolygonPool</a>[]&gt;</td></tr>
<tr class="memdesc:aa4c6e4a427196ef80116eb8fd76a62b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point and primitive list types.  <a href="#aa4c6e4a427196ef80116eb8fd76a62b6">More...</a><br /></td></tr>
<tr class="separator:aa4c6e4a427196ef80116eb8fd76a62b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8206a04f26f57965d9cb369acafa33d7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8206a04f26f57965d9cb369acafa33d7">MemoryLayout</a> { <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8206a04f26f57965d9cb369acafa33d7a696de54548c230cf353790fc1f73117f">LayoutXYZ</a>, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8206a04f26f57965d9cb369acafa33d7ac4b2238a60f4ee86d9ed5a72a13fe814">LayoutZYX</a>
 }</td></tr>
<tr class="separator:a8206a04f26f57965d9cb369acafa33d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af148611e5ef140a0121ee996fb8321"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a4af148611e5ef140a0121ee996fb8321">DSCompositeOp</a> { <br />
&#160;&#160;<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a4af148611e5ef140a0121ee996fb8321a812485f135c6cee2586b34b814cddc6a">DS_OVER</a>, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a4af148611e5ef140a0121ee996fb8321a8d4beb09c71b751771158b53d1cf99c3">DS_ADD</a>, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a4af148611e5ef140a0121ee996fb8321afa18e1086c47d6d467d2ca6e708f739b">DS_SUB</a>, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a4af148611e5ef140a0121ee996fb8321a85f583b7144fce0c85930f1a01c25a72">DS_MIN</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a4af148611e5ef140a0121ee996fb8321abab98682392bb93a93278797f8db5d75">DS_MAX</a>, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a4af148611e5ef140a0121ee996fb8321a697b1fa695bcb46b82bc1f22ff61855a">DS_MULT</a>, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a4af148611e5ef140a0121ee996fb8321ab5356cf273f92049213e30c3444f149b">DS_SET</a>
<br />
 }</td></tr>
<tr class="separator:a4af148611e5ef140a0121ee996fb8321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2623bf4797b966b29fbe45c87e60481c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2623bf4797b966b29fbe45c87e60481c">MeshToVolumeFlags</a> { <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2623bf4797b966b29fbe45c87e60481ca99d80e217668e63e75cbd0591f034f70">UNSIGNED_DISTANCE_FIELD</a> = 0x1, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2623bf4797b966b29fbe45c87e60481ca145012afd1cbb669fe4c8c94b041abc4">DISABLE_INTERSECTING_VOXEL_REMOVAL</a> = 0x2, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2623bf4797b966b29fbe45c87e60481ca414a054233ec27d0ec60800ea7e73332">DISABLE_RENORMALIZATION</a> = 0x4, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2623bf4797b966b29fbe45c87e60481ca4d48077f5cf6edf9cb34cf66d4d88505">DISABLE_NARROW_BAND_TRIMMING</a> = 0x8
 }<tr class="memdesc:a2623bf4797b966b29fbe45c87e60481c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh to volume conversion flags.  <a href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2623bf4797b966b29fbe45c87e60481c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2623bf4797b966b29fbe45c87e60481c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d3cd59d1264144ae21e5250166cfc2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a> { <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a> = 6, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a6d84698cb77f59ae061433cbb1313bbf">NN_FACE_EDGE</a> = 18, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a2cbda8f22b738858b06cb668117278ee">NN_FACE_EDGE_VERTEX</a> = 26
 }<tr class="memdesc:a31d3cd59d1264144ae21e5250166cfc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Voxel topology of nearest neighbors.  <a href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a31d3cd59d1264144ae21e5250166cfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a17ca003c7f18f411cab4e8b4f6e74"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac7a17ca003c7f18f411cab4e8b4f6e74">TilePolicy</a> { <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac7a17ca003c7f18f411cab4e8b4f6e74ab6e5cc3f7167ba290c413016ae105d99">IGNORE_TILES</a>, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac7a17ca003c7f18f411cab4e8b4f6e74ab3c4d64060dcfe7f0949fb11f8ad789c">EXPAND_TILES</a>, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac7a17ca003c7f18f411cab4e8b4f6e74ab963e977b12771992aceaf779527c26f">PRESERVE_TILES</a>
 }<tr class="memdesc:ac7a17ca003c7f18f411cab4e8b4f6e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different policies when dilating trees with active tiles.  <a href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac7a17ca003c7f18f411cab4e8b4f6e74">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac7a17ca003c7f18f411cab4e8b4f6e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2215bf270a4991ca057bb6efb294846b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2215bf270a4991ca057bb6efb294846baa911a2c909b228a84da11c9e7ec8d6f4">POLYFLAG_EXTERIOR</a> = 0x1, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2215bf270a4991ca057bb6efb294846ba6162751648b85f251927667c2b51ca67">POLYFLAG_FRACTURE_SEAM</a> = 0x2, 
<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2215bf270a4991ca057bb6efb294846bacbee21124fa14157f6c0c992c4728c7b">POLYFLAG_SUBDIVIDED</a> = 0x4
 }<tr class="memdesc:a2215bf270a4991ca057bb6efb294846b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polygon flags, used for reference based meshing.  <a href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2215bf270a4991ca057bb6efb294846b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2215bf270a4991ca057bb6efb294846b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad795f2f3910144753a5e03d12f4703de"><td class="memTemplParams" colspan="2">template&lt;typename TreeOrLeafManagerT &gt; </td></tr>
<tr class="memitem:ad795f2f3910144753a5e03d12f4703de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ad795f2f3910144753a5e03d12f4703de">changeBackground</a> (TreeOrLeafManagerT &amp;tree, const typename TreeOrLeafManagerT::ValueType &amp;background, bool threaded=true, size_t grainSize=32)</td></tr>
<tr class="memdesc:ad795f2f3910144753a5e03d12f4703de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the background value in all the nodes of a tree.  <a href="#ad795f2f3910144753a5e03d12f4703de">More...</a><br /></td></tr>
<tr class="separator:ad795f2f3910144753a5e03d12f4703de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b9e9c02f534160f2571613f2d67ef5"><td class="memTemplParams" colspan="2">template&lt;typename TreeOrLeafManagerT &gt; </td></tr>
<tr class="memitem:ae9b9e9c02f534160f2571613f2d67ef5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ae9b9e9c02f534160f2571613f2d67ef5">changeLevelSetBackground</a> (TreeOrLeafManagerT &amp;tree, const typename TreeOrLeafManagerT::ValueType &amp;halfWidth, bool threaded=true, size_t grainSize=32)</td></tr>
<tr class="memdesc:ae9b9e9c02f534160f2571613f2d67ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the background value in all the nodes of a floating-point tree containing a symmetric narrow-band level set.  <a href="#ae9b9e9c02f534160f2571613f2d67ef5">More...</a><br /></td></tr>
<tr class="separator:ae9b9e9c02f534160f2571613f2d67ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7573006df5786ba9cd6c564e4bd589ac"><td class="memTemplParams" colspan="2">template&lt;typename TreeOrLeafManagerT &gt; </td></tr>
<tr class="memitem:a7573006df5786ba9cd6c564e4bd589ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a7573006df5786ba9cd6c564e4bd589ac">changeAsymmetricLevelSetBackground</a> (TreeOrLeafManagerT &amp;tree, const typename TreeOrLeafManagerT::ValueType &amp;outsideWidth, const typename TreeOrLeafManagerT::ValueType &amp;insideWidth, bool threaded=true, size_t grainSize=32)</td></tr>
<tr class="memdesc:a7573006df5786ba9cd6c564e4bd589ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the background values in all the nodes of a floating-point tree containing a possibly asymmetric narrow-band level set.  <a href="#a7573006df5786ba9cd6c564e4bd589ac">More...</a><br /></td></tr>
<tr class="separator:a7573006df5786ba9cd6c564e4bd589ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2667c6fe1ab087fded41b3b3f1fa4b"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a9a2667c6fe1ab087fded41b3b3f1fa4b"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a9a2667c6fe1ab087fded41b3b3f1fa4b">clip</a> (const GridType &amp;grid, const <a class="el" href="namespaceopenvdb_1_1v8__0.html#aa7e17f708810f66dc1d195abaf1e9dbf">BBoxd</a> &amp;bbox, bool keepInterior=true)</td></tr>
<tr class="memdesc:a9a2667c6fe1ab087fded41b3b3f1fa4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip the given grid against a world-space bounding box and return a new grid containing the result.  <a href="#a9a2667c6fe1ab087fded41b3b3f1fa4b">More...</a><br /></td></tr>
<tr class="separator:a9a2667c6fe1ab087fded41b3b3f1fa4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b28ca7a4cb9e950e833fac3988a28b"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a92b28ca7a4cb9e950e833fac3988a28b"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a92b28ca7a4cb9e950e833fac3988a28b">clip</a> (const GridType &amp;grid, const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1NonlinearFrustumMap.html">math::NonlinearFrustumMap</a> &amp;frustum, bool keepInterior=true)</td></tr>
<tr class="memdesc:a92b28ca7a4cb9e950e833fac3988a28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip the given grid against a frustum and return a new grid containing the result.  <a href="#a92b28ca7a4cb9e950e833fac3988a28b">More...</a><br /></td></tr>
<tr class="separator:a92b28ca7a4cb9e950e833fac3988a28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97505ce1787d419b22343fe78600db06"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskTreeType &gt; </td></tr>
<tr class="memitem:a97505ce1787d419b22343fe78600db06"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a97505ce1787d419b22343fe78600db06">clip</a> (const GridType &amp;grid, const <a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html">Grid</a>&lt; MaskTreeType &gt; &amp;mask, bool keepInterior=true)</td></tr>
<tr class="memdesc:a97505ce1787d419b22343fe78600db06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip a grid against the active voxels of another grid and return a new grid containing the result.  <a href="#a97505ce1787d419b22343fe78600db06">More...</a><br /></td></tr>
<tr class="separator:a97505ce1787d419b22343fe78600db06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003db10da0696d7e120eff0477bc782c"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT &gt; </td></tr>
<tr class="memitem:a003db10da0696d7e120eff0477bc782c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a003db10da0696d7e120eff0477bc782c">csgUnion</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b, bool <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8057e1165c928a37703f90eb9496083c">prune</a>=true)</td></tr>
<tr class="memdesc:a003db10da0696d7e120eff0477bc782c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two level set grids, replace the A grid with the union of A and B.  <a href="#a003db10da0696d7e120eff0477bc782c">More...</a><br /></td></tr>
<tr class="separator:a003db10da0696d7e120eff0477bc782c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de3e11a37615c24f9c5e50bdc2a06e7"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT &gt; </td></tr>
<tr class="memitem:a7de3e11a37615c24f9c5e50bdc2a06e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a7de3e11a37615c24f9c5e50bdc2a06e7">csgIntersection</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b, bool <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8057e1165c928a37703f90eb9496083c">prune</a>=true)</td></tr>
<tr class="memdesc:a7de3e11a37615c24f9c5e50bdc2a06e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two level set grids, replace the A grid with the intersection of A and B.  <a href="#a7de3e11a37615c24f9c5e50bdc2a06e7">More...</a><br /></td></tr>
<tr class="separator:a7de3e11a37615c24f9c5e50bdc2a06e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2d62ce38b1969798cdc45baf2c9df3"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT &gt; </td></tr>
<tr class="memitem:a1e2d62ce38b1969798cdc45baf2c9df3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a1e2d62ce38b1969798cdc45baf2c9df3">csgDifference</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b, bool <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8057e1165c928a37703f90eb9496083c">prune</a>=true)</td></tr>
<tr class="memdesc:a1e2d62ce38b1969798cdc45baf2c9df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two level set grids, replace the A grid with the difference A / B.  <a href="#a1e2d62ce38b1969798cdc45baf2c9df3">More...</a><br /></td></tr>
<tr class="separator:a1e2d62ce38b1969798cdc45baf2c9df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a3bda1cab85509556b73d1467a004f"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT &gt; </td></tr>
<tr class="memitem:a99a3bda1cab85509556b73d1467a004f"><td class="memTemplItemLeft" align="right" valign="top">GridOrTreeT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a99a3bda1cab85509556b73d1467a004f">csgUnionCopy</a> (const GridOrTreeT &amp;a, const GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:a99a3bda1cab85509556b73d1467a004f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded CSG union operation that produces a new grid or tree from immutable inputs.  <a href="#a99a3bda1cab85509556b73d1467a004f">More...</a><br /></td></tr>
<tr class="separator:a99a3bda1cab85509556b73d1467a004f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add41b6c432f26145649e640fa76dc25d"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT &gt; </td></tr>
<tr class="memitem:add41b6c432f26145649e640fa76dc25d"><td class="memTemplItemLeft" align="right" valign="top">GridOrTreeT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#add41b6c432f26145649e640fa76dc25d">csgIntersectionCopy</a> (const GridOrTreeT &amp;a, const GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:add41b6c432f26145649e640fa76dc25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded CSG intersection operation that produces a new grid or tree from immutable inputs.  <a href="#add41b6c432f26145649e640fa76dc25d">More...</a><br /></td></tr>
<tr class="separator:add41b6c432f26145649e640fa76dc25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7029f32f9814fd95e23d202c37b8da5b"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT &gt; </td></tr>
<tr class="memitem:a7029f32f9814fd95e23d202c37b8da5b"><td class="memTemplItemLeft" align="right" valign="top">GridOrTreeT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a7029f32f9814fd95e23d202c37b8da5b">csgDifferenceCopy</a> (const GridOrTreeT &amp;a, const GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:a7029f32f9814fd95e23d202c37b8da5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded CSG difference operation that produces a new grid or tree from immutable inputs.  <a href="#a7029f32f9814fd95e23d202c37b8da5b">More...</a><br /></td></tr>
<tr class="separator:a7029f32f9814fd95e23d202c37b8da5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89a5ef4e61074f401e72aef834afda1"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT &gt; </td></tr>
<tr class="memitem:ab89a5ef4e61074f401e72aef834afda1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ab89a5ef4e61074f401e72aef834afda1">compMax</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:ab89a5ef4e61074f401e72aef834afda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given grids A and B, compute max(a, b) per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty.  <a href="#ab89a5ef4e61074f401e72aef834afda1">More...</a><br /></td></tr>
<tr class="separator:ab89a5ef4e61074f401e72aef834afda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f06ce463a63898a09fea378ac6912e"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT &gt; </td></tr>
<tr class="memitem:ad0f06ce463a63898a09fea378ac6912e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ad0f06ce463a63898a09fea378ac6912e">compMin</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:ad0f06ce463a63898a09fea378ac6912e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given grids A and B, compute min(a, b) per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty.  <a href="#ad0f06ce463a63898a09fea378ac6912e">More...</a><br /></td></tr>
<tr class="separator:ad0f06ce463a63898a09fea378ac6912e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e57293906eddd0c42c4df3e64cc800"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT &gt; </td></tr>
<tr class="memitem:ab3e57293906eddd0c42c4df3e64cc800"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ab3e57293906eddd0c42c4df3e64cc800">compSum</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:ab3e57293906eddd0c42c4df3e64cc800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given grids A and B, compute a + b per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty.  <a href="#ab3e57293906eddd0c42c4df3e64cc800">More...</a><br /></td></tr>
<tr class="separator:ab3e57293906eddd0c42c4df3e64cc800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd7d6918702cd795e831789812c9ac1"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT &gt; </td></tr>
<tr class="memitem:abdd7d6918702cd795e831789812c9ac1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#abdd7d6918702cd795e831789812c9ac1">compMul</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:abdd7d6918702cd795e831789812c9ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given grids A and B, compute a * b per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty.  <a href="#abdd7d6918702cd795e831789812c9ac1">More...</a><br /></td></tr>
<tr class="separator:abdd7d6918702cd795e831789812c9ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001d3e901a369bb50ed1b4e78e57b303"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT &gt; </td></tr>
<tr class="memitem:a001d3e901a369bb50ed1b4e78e57b303"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a001d3e901a369bb50ed1b4e78e57b303">compDiv</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:a001d3e901a369bb50ed1b4e78e57b303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given grids A and B, compute a / b per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty.  <a href="#a001d3e901a369bb50ed1b4e78e57b303">More...</a><br /></td></tr>
<tr class="separator:a001d3e901a369bb50ed1b4e78e57b303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7784bcd2c95e7b015e6fc2c3c9d5d9"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT &gt; </td></tr>
<tr class="memitem:a0a7784bcd2c95e7b015e6fc2c3c9d5d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a0a7784bcd2c95e7b015e6fc2c3c9d5d9">compReplace</a> (GridOrTreeT &amp;a, const GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:a0a7784bcd2c95e7b015e6fc2c3c9d5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the active voxels of B into A.  <a href="#a0a7784bcd2c95e7b015e6fc2c3c9d5d9">More...</a><br /></td></tr>
<tr class="separator:a0a7784bcd2c95e7b015e6fc2c3c9d5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2b7fa45d550d8a5349495d0d37090f"><td class="memTemplParams" colspan="2">template&lt;typename TreeT , typename OpT  = composite::CopyOp&lt;TreeT&gt;&gt; </td></tr>
<tr class="memitem:a1e2b7fa45d550d8a5349495d0d37090f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a1e2b7fa45d550d8a5349495d0d37090f">compActiveLeafVoxels</a> (TreeT &amp;srcTree, TreeT &amp;dstTree, OpT op=composite::CopyOp&lt; TreeT &gt;())</td></tr>
<tr class="memdesc:a1e2b7fa45d550d8a5349495d0d37090f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite the active values in leaf nodes, i.e. active voxels, of a source tree into a destination tree.  <a href="#a1e2b7fa45d550d8a5349495d0d37090f">More...</a><br /></td></tr>
<tr class="separator:a1e2b7fa45d550d8a5349495d0d37090f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd41a08ed8ea7c1a7d33146b8d17ce1"><td class="memTemplParams" colspan="2">template&lt;typename DenseT , typename GridOrTreeT &gt; </td></tr>
<tr class="memitem:acbd41a08ed8ea7c1a7d33146b8d17ce1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#acbd41a08ed8ea7c1a7d33146b8d17ce1">copyToDense</a> (const GridOrTreeT &amp;sparse, DenseT &amp;dense, bool serial=false)</td></tr>
<tr class="memdesc:acbd41a08ed8ea7c1a7d33146b8d17ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a dense grid with the values of voxels from a sparse grid, where the sparse grid intersects the dense grid.  <a href="#acbd41a08ed8ea7c1a7d33146b8d17ce1">More...</a><br /></td></tr>
<tr class="separator:acbd41a08ed8ea7c1a7d33146b8d17ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718fc3e33310680728f4fbf04db240c0"><td class="memTemplParams" colspan="2">template&lt;typename DenseT , typename GridOrTreeT &gt; </td></tr>
<tr class="memitem:a718fc3e33310680728f4fbf04db240c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a718fc3e33310680728f4fbf04db240c0">copyFromDense</a> (const DenseT &amp;dense, GridOrTreeT &amp;sparse, const typename GridOrTreeT::ValueType &amp;tolerance, bool serial=false)</td></tr>
<tr class="memdesc:a718fc3e33310680728f4fbf04db240c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a sparse grid with the values of all of the voxels of a dense grid.  <a href="#a718fc3e33310680728f4fbf04db240c0">More...</a><br /></td></tr>
<tr class="separator:a718fc3e33310680728f4fbf04db240c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586a786ed67c81b31e7bcc11c70df047"><td class="memTemplParams" colspan="2">template&lt;typename OpType , typename DenseType &gt; </td></tr>
<tr class="memitem:a586a786ed67c81b31e7bcc11c70df047"><td class="memTemplItemLeft" align="right" valign="top">OpType::ResultTreeType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a586a786ed67c81b31e7bcc11c70df047">extractSparseTree</a> (const DenseType &amp;dense, const OpType &amp;functor, const typename OpType::ResultValueType &amp;background, bool threaded=true)</td></tr>
<tr class="memdesc:a586a786ed67c81b31e7bcc11c70df047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selectively extract and transform data from a dense grid, producing a sparse tree with leaf nodes only (e.g. create a tree from the square of values greater than a cutoff.)  <a href="#a586a786ed67c81b31e7bcc11c70df047">More...</a><br /></td></tr>
<tr class="separator:a586a786ed67c81b31e7bcc11c70df047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e62f3b18a1d40b3195c83b4d76c1e5"><td class="memTemplParams" colspan="2">template&lt;typename DenseType , typename MaskTreeType &gt; </td></tr>
<tr class="memitem:ae1e62f3b18a1d40b3195c83b4d76c1e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1DSConverter.html">DSConverter</a>&lt; DenseType, MaskTreeType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ae1e62f3b18a1d40b3195c83b4d76c1e5">extractSparseTreeWithMask</a> (const DenseType &amp;dense, const MaskTreeType &amp;mask, const typename DenseType::ValueType &amp;background, bool threaded=true)</td></tr>
<tr class="memdesc:ae1e62f3b18a1d40b3195c83b4d76c1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from the intersection of a sparse tree and a dense input grid. The resulting tree has the same configuration as the sparse tree, but holds the data type specified by the dense input.  <a href="#ae1e62f3b18a1d40b3195c83b4d76c1e5">More...</a><br /></td></tr>
<tr class="separator:ae1e62f3b18a1d40b3195c83b4d76c1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcc7df3409df7357565d418f7fb6e3a"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename OpType &gt; </td></tr>
<tr class="memitem:a8fcc7df3409df7357565d418f7fb6e3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8fcc7df3409df7357565d418f7fb6e3a">transformDense</a> (<a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Dense.html">Dense</a>&lt; ValueT, openvdb::tools::LayoutZYX &gt; &amp;dense, const openvdb::CoordBBox &amp;bbox, const OpType &amp;op, bool parallel=true)</td></tr>
<tr class="separator:a8fcc7df3409df7357565d418f7fb6e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53b377981f3baf29cef347335e3588b"><td class="memTemplParams" colspan="2">template&lt;DSCompositeOp , typename TreeT &gt; </td></tr>
<tr class="memitem:ac53b377981f3baf29cef347335e3588b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac53b377981f3baf29cef347335e3588b">compositeToDense</a> (<a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Dense.html">Dense</a>&lt; typename TreeT::ValueType, <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8206a04f26f57965d9cb369acafa33d7ac4b2238a60f4ee86d9ed5a72a13fe814">LayoutZYX</a> &gt; &amp;dense, const TreeT &amp;source, const TreeT &amp;alpha, const typename TreeT::ValueType beta, const typename TreeT::ValueType strength, bool threaded=true)</td></tr>
<tr class="memdesc:ac53b377981f3baf29cef347335e3588b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite data from a sparse tree into a dense array of the same value type.  <a href="#ac53b377981f3baf29cef347335e3588b">More...</a><br /></td></tr>
<tr class="separator:ac53b377981f3baf29cef347335e3588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac976d1526021421d99c73e70d726fe"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename PointwiseOpT &gt; </td></tr>
<tr class="memitem:a9ac976d1526021421d99c73e70d726fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a9ac976d1526021421d99c73e70d726fe">transformDense</a> (<a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Dense.html">Dense</a>&lt; ValueT, openvdb::tools::LayoutZYX &gt; &amp;dense, const openvdb::CoordBBox &amp;bbox, const PointwiseOpT &amp;functor, bool parallel)</td></tr>
<tr class="memdesc:a9ac976d1526021421d99c73e70d726fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a point-wise functor to the intersection of a dense grid and a given bounding box.  <a href="#a9ac976d1526021421d99c73e70d726fe">More...</a><br /></td></tr>
<tr class="separator:a9ac976d1526021421d99c73e70d726fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07091e4e6f1cfb869111d233da6d9b9"><td class="memTemplParams" colspan="2">template&lt;class GridType &gt; </td></tr>
<tr class="memitem:ae07091e4e6f1cfb869111d233da6d9b9"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ae07091e4e6f1cfb869111d233da6d9b9">checkLevelSet</a> (const GridType &amp;grid, size_t number=9)</td></tr>
<tr class="memdesc:ae07091e4e6f1cfb869111d233da6d9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform checks on a grid to see if it is a valid symmetric, narrow-band level set.  <a href="#ae07091e4e6f1cfb869111d233da6d9b9">More...</a><br /></td></tr>
<tr class="separator:ae07091e4e6f1cfb869111d233da6d9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03bd92afef729f144e63f37f417c96d"><td class="memTemplParams" colspan="2">template&lt;class GridType &gt; </td></tr>
<tr class="memitem:ab03bd92afef729f144e63f37f417c96d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ab03bd92afef729f144e63f37f417c96d">checkFogVolume</a> (const GridType &amp;grid, size_t number=6)</td></tr>
<tr class="memdesc:ab03bd92afef729f144e63f37f417c96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform checks on a grid to see if it is a valid fog volume.  <a href="#ab03bd92afef729f144e63f37f417c96d">More...</a><br /></td></tr>
<tr class="separator:ab03bd92afef729f144e63f37f417c96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136006bbdda1e616071dba827c34be79"><td class="memTemplParams" colspan="2">template&lt;class GridType &gt; </td></tr>
<tr class="memitem:a136006bbdda1e616071dba827c34be79"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a136006bbdda1e616071dba827c34be79">uniqueInactiveValues</a> (const GridType &amp;grid, std::vector&lt; typename GridType::ValueType &gt; &amp;values, size_t numValues)</td></tr>
<tr class="memdesc:a136006bbdda1e616071dba827c34be79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded method to find unique inactive values.  <a href="#a136006bbdda1e616071dba827c34be79">More...</a><br /></td></tr>
<tr class="separator:a136006bbdda1e616071dba827c34be79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b0661a0aaa5a3b5badaf557459dcc8"><td class="memTemplParams" colspan="2">template&lt;typename GridT &gt; </td></tr>
<tr class="memitem:a09b0661a0aaa5a3b5badaf557459dcc8"><td class="memTemplItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a09b0661a0aaa5a3b5badaf557459dcc8">fogToSdf</a> (const GridT &amp;fogGrid, typename GridT::ValueType isoValue, int nIter=1)</td></tr>
<tr class="memdesc:a09b0661a0aaa5a3b5badaf557459dcc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar fog volume into a signed distance function. Active input voxels with scalar values above the given isoValue will have NEGATIVE distance values on output, i.e. they are assumed to be INSIDE the iso-surface.  <a href="#a09b0661a0aaa5a3b5badaf557459dcc8">More...</a><br /></td></tr>
<tr class="separator:a09b0661a0aaa5a3b5badaf557459dcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec6859a45f6b4fa6c0beb9687eabacd"><td class="memTemplParams" colspan="2">template&lt;typename GridT &gt; </td></tr>
<tr class="memitem:a5ec6859a45f6b4fa6c0beb9687eabacd"><td class="memTemplItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a5ec6859a45f6b4fa6c0beb9687eabacd">sdfToSdf</a> (const GridT &amp;sdfGrid, typename GridT::ValueType isoValue=0, int nIter=1)</td></tr>
<tr class="memdesc:a5ec6859a45f6b4fa6c0beb9687eabacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an existing approximate SDF it solves the Eikonal equation for all its active voxels. Active input voxels with a signed distance value above the given isoValue will have POSITIVE distance values on output, i.e. they are assumed to be OUTSIDE the iso-surface.  <a href="#a5ec6859a45f6b4fa6c0beb9687eabacd">More...</a><br /></td></tr>
<tr class="separator:a5ec6859a45f6b4fa6c0beb9687eabacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a364ccf87a335cf241e6d90f026744"><td class="memTemplParams" colspan="2">template&lt;typename FogGridT , typename ExtOpT , typename ExtValueT &gt; </td></tr>
<tr class="memitem:ad3a364ccf87a335cf241e6d90f026744"><td class="memTemplItemLeft" align="right" valign="top">FogGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ad3a364ccf87a335cf241e6d90f026744">fogToExt</a> (const FogGridT &amp;fogGrid, const ExtOpT &amp;op, const ExtValueT &amp;background, typename FogGridT::ValueType isoValue, int nIter=1)</td></tr>
<tr class="memdesc:ad3a364ccf87a335cf241e6d90f026744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the extension of a field, defined by the specified functor, off an iso-surface from an input FOG volume.  <a href="#ad3a364ccf87a335cf241e6d90f026744">More...</a><br /></td></tr>
<tr class="separator:ad3a364ccf87a335cf241e6d90f026744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f5c23566a92043e7c3099699a86492"><td class="memTemplParams" colspan="2">template&lt;typename SdfGridT , typename ExtOpT , typename ExtValueT &gt; </td></tr>
<tr class="memitem:aa6f5c23566a92043e7c3099699a86492"><td class="memTemplItemLeft" align="right" valign="top">SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aa6f5c23566a92043e7c3099699a86492">sdfToExt</a> (const SdfGridT &amp;sdfGrid, const ExtOpT &amp;op, const ExtValueT &amp;background, typename SdfGridT::ValueType isoValue=0, int nIter=1)</td></tr>
<tr class="memdesc:aa6f5c23566a92043e7c3099699a86492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the extension of a scalar field, defined by the specified functor, off an iso-surface from an input SDF volume.  <a href="#aa6f5c23566a92043e7c3099699a86492">More...</a><br /></td></tr>
<tr class="separator:aa6f5c23566a92043e7c3099699a86492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fa3d058b61aff63b0ce92fd718da48"><td class="memTemplParams" colspan="2">template&lt;typename FogGridT , typename ExtOpT , typename ExtValueT &gt; </td></tr>
<tr class="memitem:ac3fa3d058b61aff63b0ce92fd718da48"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename FogGridT::Ptr, typename FogGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac3fa3d058b61aff63b0ce92fd718da48">fogToSdfAndExt</a> (const FogGridT &amp;fogGrid, const ExtOpT &amp;op, const ExtValueT &amp;background, typename FogGridT::ValueType isoValue, int nIter=1)</td></tr>
<tr class="memdesc:ac3fa3d058b61aff63b0ce92fd718da48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the signed distance field and the extension of a scalar field, defined by the specified functor, off an iso-surface from an input FOG volume.  <a href="#ac3fa3d058b61aff63b0ce92fd718da48">More...</a><br /></td></tr>
<tr class="separator:ac3fa3d058b61aff63b0ce92fd718da48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b430d0d5e79eaa7c822b7ec72d45fb7"><td class="memTemplParams" colspan="2">template&lt;typename SdfGridT , typename ExtOpT , typename ExtValueT &gt; </td></tr>
<tr class="memitem:a6b430d0d5e79eaa7c822b7ec72d45fb7"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename SdfGridT::Ptr, typename SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a6b430d0d5e79eaa7c822b7ec72d45fb7">sdfToSdfAndExt</a> (const SdfGridT &amp;sdfGrid, const ExtOpT &amp;op, const ExtValueT &amp;background, typename SdfGridT::ValueType isoValue=0, int nIter=1)</td></tr>
<tr class="memdesc:a6b430d0d5e79eaa7c822b7ec72d45fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the signed distance field and the extension of a scalar field, defined by the specified functor, off an iso-surface from an input SDF volume.  <a href="#a6b430d0d5e79eaa7c822b7ec72d45fb7">More...</a><br /></td></tr>
<tr class="separator:a6b430d0d5e79eaa7c822b7ec72d45fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697de92ff0bec5d6b6ada6fdb3966af7"><td class="memTemplParams" colspan="2">template&lt;typename GridT &gt; </td></tr>
<tr class="memitem:a697de92ff0bec5d6b6ada6fdb3966af7"><td class="memTemplItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a697de92ff0bec5d6b6ada6fdb3966af7">dilateSdf</a> (const GridT &amp;sdfGrid, int dilation, <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a> nn=<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a>, int nIter=1)</td></tr>
<tr class="memdesc:a697de92ff0bec5d6b6ada6fdb3966af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dilates an existing signed distance filed by a specified number of voxels.  <a href="#a697de92ff0bec5d6b6ada6fdb3966af7">More...</a><br /></td></tr>
<tr class="separator:a697de92ff0bec5d6b6ada6fdb3966af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa310f2f224f5b386b70dd8645b39b133"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename MaskTreeT &gt; </td></tr>
<tr class="memitem:aa310f2f224f5b386b70dd8645b39b133"><td class="memTemplItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aa310f2f224f5b386b70dd8645b39b133">maskSdf</a> (const GridT &amp;sdfGrid, const <a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html">Grid</a>&lt; MaskTreeT &gt; &amp;mask, bool ignoreActiveTiles=false, int nIter=1)</td></tr>
<tr class="memdesc:aa310f2f224f5b386b70dd8645b39b133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills mask by extending an existing signed distance field into the active values of this input ree of arbitrary value type.  <a href="#aa310f2f224f5b386b70dd8645b39b133">More...</a><br /></td></tr>
<tr class="separator:aa310f2f224f5b386b70dd8645b39b133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1651975d1f7c66871d5e18c45fae099a"><td class="memTemplParams" colspan="2">template&lt;typename SdfGridT , typename OpT , typename ExtValueT &gt; </td></tr>
<tr class="memitem:a1651975d1f7c66871d5e18c45fae099a"><td class="memTemplItemLeft" align="right" valign="top">SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a1651975d1f7c66871d5e18c45fae099a">sdfToExt</a> (const SdfGridT &amp;sdfGrid, const OpT &amp;op, const ExtValueT &amp;background, typename SdfGridT::ValueType isoValue, int nIter)</td></tr>
<tr class="separator:a1651975d1f7c66871d5e18c45fae099a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1562d5f6c1e6d39636666756be0234a3"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:a1562d5f6c1e6d39636666756be0234a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a1562d5f6c1e6d39636666756be0234a3">anyActiveValues</a> (const TreeT &amp;tree, const CoordBBox &amp;bbox)</td></tr>
<tr class="memdesc:a1562d5f6c1e6d39636666756be0234a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the bounding box intersects any of the active values in a tree, i.e. either active voxels or active tiles.  <a href="#a1562d5f6c1e6d39636666756be0234a3">More...</a><br /></td></tr>
<tr class="separator:a1562d5f6c1e6d39636666756be0234a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddfbc3ca506b15623bcffd355f2e749"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:a8ddfbc3ca506b15623bcffd355f2e749"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8ddfbc3ca506b15623bcffd355f2e749">anyActiveVoxels</a> (const TreeT &amp;tree, const CoordBBox &amp;bbox)</td></tr>
<tr class="memdesc:a8ddfbc3ca506b15623bcffd355f2e749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the bounding box intersects any of the active voxels in a tree, i.e. ignores active tile values.  <a href="#a8ddfbc3ca506b15623bcffd355f2e749">More...</a><br /></td></tr>
<tr class="separator:a8ddfbc3ca506b15623bcffd355f2e749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0a2e1f38b296a8dd5f1494efb51bed"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:a7b0a2e1f38b296a8dd5f1494efb51bed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a7b0a2e1f38b296a8dd5f1494efb51bed">anyActiveTiles</a> (const TreeT &amp;tree, const CoordBBox &amp;bbox)</td></tr>
<tr class="memdesc:a7b0a2e1f38b296a8dd5f1494efb51bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the bounding box intersects any of the active tiles in a tree, i.e. ignores active leaf values.  <a href="#a7b0a2e1f38b296a8dd5f1494efb51bed">More...</a><br /></td></tr>
<tr class="separator:a7b0a2e1f38b296a8dd5f1494efb51bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8ca0caf60c323917088490510fa8e8"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:add8ca0caf60c323917088490510fa8e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#add8ca0caf60c323917088490510fa8e8">noActiveValues</a> (const TreeT &amp;tree, const CoordBBox &amp;bbox)</td></tr>
<tr class="memdesc:add8ca0caf60c323917088490510fa8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the bounding box intersects none of the active values in a tree, i.e. neither active voxels or active tiles.  <a href="#add8ca0caf60c323917088490510fa8e8">More...</a><br /></td></tr>
<tr class="separator:add8ca0caf60c323917088490510fa8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d05f8d7abe330825f886373991c52e3"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:a0d05f8d7abe330825f886373991c52e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a0d05f8d7abe330825f886373991c52e3">countActiveValues</a> (const TreeT &amp;tree, const CoordBBox &amp;bbox)</td></tr>
<tr class="memdesc:a0d05f8d7abe330825f886373991c52e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of active values that intersects a bounding box intersects, i.e. the count includes both active voxels and virtual voxels in active tiles.  <a href="#a0d05f8d7abe330825f886373991c52e3">More...</a><br /></td></tr>
<tr class="separator:a0d05f8d7abe330825f886373991c52e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5662e54e5608edc934c09c8bac2ec3ea"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:a5662e54e5608edc934c09c8bac2ec3ea"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1TileData.html">TileData</a>&lt; typename TreeT::ValueType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a5662e54e5608edc934c09c8bac2ec3ea">activeTiles</a> (const TreeT &amp;tree, const CoordBBox &amp;bbox)</td></tr>
<tr class="memdesc:a5662e54e5608edc934c09c8bac2ec3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with bounding boxes that represents all the intersections between active tiles in the tree and the specified bounding box.  <a href="#a5662e54e5608edc934c09c8bac2ec3ea">More...</a><br /></td></tr>
<tr class="separator:a5662e54e5608edc934c09c8bac2ec3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea23457a3376d6fb611bd3f46fdffd61"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:aea23457a3376d6fb611bd3f46fdffd61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aea23457a3376d6fb611bd3f46fdffd61">cpt</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:aea23457a3376d6fb611bd3f46fdffd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Closest-Point Transform (CPT) from a distance field.  <a href="#aea23457a3376d6fb611bd3f46fdffd61">More...</a><br /></td></tr>
<tr class="separator:aea23457a3376d6fb611bd3f46fdffd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4a7dc00308e20a77a2dfd6cb598fb4"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT , typename InterruptT &gt; </td></tr>
<tr class="memitem:a0a4a7dc00308e20a77a2dfd6cb598fb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a0a4a7dc00308e20a77a2dfd6cb598fb4">cpt</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="separator:a0a4a7dc00308e20a77a2dfd6cb598fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7dc67879556a352c2236a0ea414af2"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:acc7dc67879556a352c2236a0ea414af2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#acc7dc67879556a352c2236a0ea414af2">cpt</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="separator:acc7dc67879556a352c2236a0ea414af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae66f8ee5791c6d49fffc3bf7e3b5bbb"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT &gt; </td></tr>
<tr class="memitem:aae66f8ee5791c6d49fffc3bf7e3b5bbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aae66f8ee5791c6d49fffc3bf7e3b5bbb">cpt</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="separator:aae66f8ee5791c6d49fffc3bf7e3b5bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7270767850c4f3241bce09b730d84a"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:a1d7270767850c4f3241bce09b730d84a"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a1d7270767850c4f3241bce09b730d84a">curl</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:a1d7270767850c4f3241bce09b730d84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the curl of the given vector-valued grid.  <a href="#a1d7270767850c4f3241bce09b730d84a">More...</a><br /></td></tr>
<tr class="separator:a1d7270767850c4f3241bce09b730d84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2279de4cd703914497d7733aefbb6e"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT , typename InterruptT &gt; </td></tr>
<tr class="memitem:a8b2279de4cd703914497d7733aefbb6e"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8b2279de4cd703914497d7733aefbb6e">curl</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="separator:a8b2279de4cd703914497d7733aefbb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae356c0a65b83cc69595672c59c63655a"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:ae356c0a65b83cc69595672c59c63655a"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ae356c0a65b83cc69595672c59c63655a">curl</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="separator:ae356c0a65b83cc69595672c59c63655a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce39fc3fd3d9396e5de29e9a97d77d6"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT &gt; </td></tr>
<tr class="memitem:adce39fc3fd3d9396e5de29e9a97d77d6"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#adce39fc3fd3d9396e5de29e9a97d77d6">curl</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="separator:adce39fc3fd3d9396e5de29e9a97d77d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d4adc505e30de4684d20efdcb66512"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:ad9d4adc505e30de4684d20efdcb66512"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ad9d4adc505e30de4684d20efdcb66512">divergence</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:ad9d4adc505e30de4684d20efdcb66512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the divergence of the given vector-valued grid.  <a href="#ad9d4adc505e30de4684d20efdcb66512">More...</a><br /></td></tr>
<tr class="separator:ad9d4adc505e30de4684d20efdcb66512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4342922999466ca1d2481c6c0d083b1"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT , typename InterruptT &gt; </td></tr>
<tr class="memitem:ab4342922999466ca1d2481c6c0d083b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ab4342922999466ca1d2481c6c0d083b1">divergence</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="separator:ab4342922999466ca1d2481c6c0d083b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32740877aa270bb22ecb4762b2d64951"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a32740877aa270bb22ecb4762b2d64951"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a32740877aa270bb22ecb4762b2d64951">divergence</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="separator:a32740877aa270bb22ecb4762b2d64951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5d7a9409e1d987c8f9f17e4a8d9eac"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT &gt; </td></tr>
<tr class="memitem:afc5d7a9409e1d987c8f9f17e4a8d9eac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#afc5d7a9409e1d987c8f9f17e4a8d9eac">divergence</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="separator:afc5d7a9409e1d987c8f9f17e4a8d9eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d4d89cd34db1794e9a615dec11dc0f"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:a61d4d89cd34db1794e9a615dec11dc0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a61d4d89cd34db1794e9a615dec11dc0f">gradient</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:a61d4d89cd34db1794e9a615dec11dc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the given scalar grid.  <a href="#a61d4d89cd34db1794e9a615dec11dc0f">More...</a><br /></td></tr>
<tr class="separator:a61d4d89cd34db1794e9a615dec11dc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cad07124b4f4d6a7b15021ee86b2c2f"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT , typename InterruptT &gt; </td></tr>
<tr class="memitem:a8cad07124b4f4d6a7b15021ee86b2c2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8cad07124b4f4d6a7b15021ee86b2c2f">gradient</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="separator:a8cad07124b4f4d6a7b15021ee86b2c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52272e8e0845e2d3c0dbd195c00a2b9"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:ac52272e8e0845e2d3c0dbd195c00a2b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac52272e8e0845e2d3c0dbd195c00a2b9">gradient</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="separator:ac52272e8e0845e2d3c0dbd195c00a2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a940c5624461c9ba8a59ab1870f85a6"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT &gt; </td></tr>
<tr class="memitem:a4a940c5624461c9ba8a59ab1870f85a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a4a940c5624461c9ba8a59ab1870f85a6">gradient</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="separator:a4a940c5624461c9ba8a59ab1870f85a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55f3361b55d27809c1da5bf33db393a"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:af55f3361b55d27809c1da5bf33db393a"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#af55f3361b55d27809c1da5bf33db393a">laplacian</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:af55f3361b55d27809c1da5bf33db393a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Laplacian.html">Laplacian</a> of the given scalar grid.  <a href="#af55f3361b55d27809c1da5bf33db393a">More...</a><br /></td></tr>
<tr class="separator:af55f3361b55d27809c1da5bf33db393a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8b10bc1b3daa909a50c4b1a68c1c79"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT , typename InterruptT &gt; </td></tr>
<tr class="memitem:a2c8b10bc1b3daa909a50c4b1a68c1c79"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2c8b10bc1b3daa909a50c4b1a68c1c79">laplacian</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="separator:a2c8b10bc1b3daa909a50c4b1a68c1c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab078dffd97b0801b1575dfe0592e3c5d"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:ab078dffd97b0801b1575dfe0592e3c5d"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ab078dffd97b0801b1575dfe0592e3c5d">laplacian</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="separator:ab078dffd97b0801b1575dfe0592e3c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9596e04716318ee74de2e07f47c69910"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT &gt; </td></tr>
<tr class="memitem:a9596e04716318ee74de2e07f47c69910"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a9596e04716318ee74de2e07f47c69910">laplacian</a> (const GridType &amp;grid, const MaskT mask, bool threaded=true)</td></tr>
<tr class="separator:a9596e04716318ee74de2e07f47c69910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad8501c4e8a1e0f613d880f3431d6ca"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:a5ad8501c4e8a1e0f613d880f3431d6ca"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a5ad8501c4e8a1e0f613d880f3431d6ca">meanCurvature</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:a5ad8501c4e8a1e0f613d880f3431d6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean curvature of the given grid.  <a href="#a5ad8501c4e8a1e0f613d880f3431d6ca">More...</a><br /></td></tr>
<tr class="separator:a5ad8501c4e8a1e0f613d880f3431d6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e0a1a825212802a6a672420f1be648"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT , typename InterruptT &gt; </td></tr>
<tr class="memitem:a85e0a1a825212802a6a672420f1be648"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a85e0a1a825212802a6a672420f1be648">meanCurvature</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="separator:a85e0a1a825212802a6a672420f1be648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a0ea5918b4710b87cf20d0af0991e8"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:ae4a0ea5918b4710b87cf20d0af0991e8"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ae4a0ea5918b4710b87cf20d0af0991e8">meanCurvature</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="separator:ae4a0ea5918b4710b87cf20d0af0991e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202d03198722a082c8d5aae0afbe2da0"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT &gt; </td></tr>
<tr class="memitem:a202d03198722a082c8d5aae0afbe2da0"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a202d03198722a082c8d5aae0afbe2da0">meanCurvature</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="separator:a202d03198722a082c8d5aae0afbe2da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9370eee6dbb6de354a68a54b9cdd1dba"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:a9370eee6dbb6de354a68a54b9cdd1dba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a9370eee6dbb6de354a68a54b9cdd1dba">magnitude</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:a9370eee6dbb6de354a68a54b9cdd1dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the magnitudes of the vectors of the given vector-valued grid.  <a href="#a9370eee6dbb6de354a68a54b9cdd1dba">More...</a><br /></td></tr>
<tr class="separator:a9370eee6dbb6de354a68a54b9cdd1dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fe38fb2a95969530d664ef92f7dcae"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT , typename InterruptT &gt; </td></tr>
<tr class="memitem:a06fe38fb2a95969530d664ef92f7dcae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a06fe38fb2a95969530d664ef92f7dcae">magnitude</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="separator:a06fe38fb2a95969530d664ef92f7dcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c05f5bd0fd548da639aa5cfd1dd05bf"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a4c05f5bd0fd548da639aa5cfd1dd05bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a4c05f5bd0fd548da639aa5cfd1dd05bf">magnitude</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="separator:a4c05f5bd0fd548da639aa5cfd1dd05bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bae762c6ce7763de58417791f9af0b"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT &gt; </td></tr>
<tr class="memitem:a15bae762c6ce7763de58417791f9af0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a15bae762c6ce7763de58417791f9af0b">magnitude</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="separator:a15bae762c6ce7763de58417791f9af0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c0227e6c84797a06542df58c2b564d"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:af5c0227e6c84797a06542df58c2b564d"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#af5c0227e6c84797a06542df58c2b564d">normalize</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:af5c0227e6c84797a06542df58c2b564d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Normalize.html">Normalize</a> the vectors of the given vector-valued grid.  <a href="#af5c0227e6c84797a06542df58c2b564d">More...</a><br /></td></tr>
<tr class="separator:af5c0227e6c84797a06542df58c2b564d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b083e3b964ba0f08ff56bf2d50981e"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT , typename InterruptT &gt; </td></tr>
<tr class="memitem:ac1b083e3b964ba0f08ff56bf2d50981e"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac1b083e3b964ba0f08ff56bf2d50981e">normalize</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="separator:ac1b083e3b964ba0f08ff56bf2d50981e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154fe714133a26d9e3e1e6785f7f90b2"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a154fe714133a26d9e3e1e6785f7f90b2"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a154fe714133a26d9e3e1e6785f7f90b2">normalize</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="separator:a154fe714133a26d9e3e1e6785f7f90b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9b68b9b87c65865b48deac6efa79c0"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MaskT &gt; </td></tr>
<tr class="memitem:a3f9b68b9b87c65865b48deac6efa79c0"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a3f9b68b9b87c65865b48deac6efa79c0">normalize</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="separator:a3f9b68b9b87c65865b48deac6efa79c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae190c2befe2b252b8d930bd632964ab7"><td class="memTemplParams" colspan="2">template&lt;typename Sampler , typename Interrupter , typename GridType &gt; </td></tr>
<tr class="memitem:ae190c2befe2b252b8d930bd632964ab7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ae190c2befe2b252b8d930bd632964ab7">resampleToMatch</a> (const GridType &amp;inGrid, GridType &amp;outGrid, Interrupter &amp;interrupter)</td></tr>
<tr class="memdesc:ae190c2befe2b252b8d930bd632964ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resample an input grid into an output grid of the same type such that, after resampling, the input and output grids coincide (apart from sampling artifacts), but the output grid's transform is unchanged.  <a href="#ae190c2befe2b252b8d930bd632964ab7">More...</a><br /></td></tr>
<tr class="separator:ae190c2befe2b252b8d930bd632964ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c63aac5d546c4e73dd5f2e8bf734ca"><td class="memTemplParams" colspan="2">template&lt;typename Sampler , typename GridType &gt; </td></tr>
<tr class="memitem:af4c63aac5d546c4e73dd5f2e8bf734ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#af4c63aac5d546c4e73dd5f2e8bf734ca">resampleToMatch</a> (const GridType &amp;inGrid, GridType &amp;outGrid)</td></tr>
<tr class="memdesc:af4c63aac5d546c4e73dd5f2e8bf734ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resample an input grid into an output grid of the same type such that, after resampling, the input and output grids coincide (apart from sampling artifacts), but the output grid's transform is unchanged.  <a href="#af4c63aac5d546c4e73dd5f2e8bf734ca">More...</a><br /></td></tr>
<tr class="separator:af4c63aac5d546c4e73dd5f2e8bf734ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04cb644cc1e7f5d3135977bbd2b2c9e"><td class="memTemplParams" colspan="2">template&lt;typename Sampler , typename Interrupter , typename GridType &gt; </td></tr>
<tr class="memitem:ad04cb644cc1e7f5d3135977bbd2b2c9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ad04cb644cc1e7f5d3135977bbd2b2c9e">doResampleToMatch</a> (const GridType &amp;inGrid, GridType &amp;outGrid, Interrupter &amp;interrupter)</td></tr>
<tr class="separator:ad04cb644cc1e7f5d3135977bbd2b2c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21904c4bdeb53424433206487628a32f"><td class="memTemplParams" colspan="2">template&lt;class GridType &gt; </td></tr>
<tr class="memitem:a21904c4bdeb53424433206487628a32f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a21904c4bdeb53424433206487628a32f">levelSetArea</a> (const GridType &amp;grid, bool useWorldSpace=true)</td></tr>
<tr class="memdesc:a21904c4bdeb53424433206487628a32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the surface area of a narrow-band level set.  <a href="#a21904c4bdeb53424433206487628a32f">More...</a><br /></td></tr>
<tr class="separator:a21904c4bdeb53424433206487628a32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4a922db530a6e630c3215bec543805"><td class="memTemplParams" colspan="2">template&lt;class GridType &gt; </td></tr>
<tr class="memitem:a4a4a922db530a6e630c3215bec543805"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a4a4a922db530a6e630c3215bec543805">levelSetVolume</a> (const GridType &amp;grid, bool useWorldSpace=true)</td></tr>
<tr class="memdesc:a4a4a922db530a6e630c3215bec543805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the volume of a narrow-band level set surface.  <a href="#a4a4a922db530a6e630c3215bec543805">More...</a><br /></td></tr>
<tr class="separator:a4a4a922db530a6e630c3215bec543805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1d5d4e92ad027e268d355a6c20fddb"><td class="memTemplParams" colspan="2">template&lt;class GridType &gt; </td></tr>
<tr class="memitem:a7f1d5d4e92ad027e268d355a6c20fddb"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a7f1d5d4e92ad027e268d355a6c20fddb">levelSetEulerCharacteristic</a> (const GridType &amp;grid)</td></tr>
<tr class="memdesc:a7f1d5d4e92ad027e268d355a6c20fddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Euler Characteristics of a narrow-band level set surface (possibly disconnected).  <a href="#a7f1d5d4e92ad027e268d355a6c20fddb">More...</a><br /></td></tr>
<tr class="separator:a7f1d5d4e92ad027e268d355a6c20fddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8497642e2adea02d80cd84003e8626"><td class="memTemplParams" colspan="2">template&lt;class GridType &gt; </td></tr>
<tr class="memitem:a5e8497642e2adea02d80cd84003e8626"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a5e8497642e2adea02d80cd84003e8626">levelSetGenus</a> (const GridType &amp;grid)</td></tr>
<tr class="memdesc:a5e8497642e2adea02d80cd84003e8626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the genus of a narrow-band level set surface.  <a href="#a5e8497642e2adea02d80cd84003e8626">More...</a><br /></td></tr>
<tr class="separator:a5e8497642e2adea02d80cd84003e8626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2b53898f455d8e5963c5de67c71c34"><td class="memTemplParams" colspan="2">template&lt;class GridT &gt; </td></tr>
<tr class="memitem:ace2b53898f455d8e5963c5de67c71c34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ace2b53898f455d8e5963c5de67c71c34">levelSetArea</a> (const GridT &amp;grid, bool useWorldUnits)</td></tr>
<tr class="separator:ace2b53898f455d8e5963c5de67c71c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e985b678d35b43dfd0b2bcb0d1d01d8"><td class="memTemplParams" colspan="2">template&lt;class GridT &gt; </td></tr>
<tr class="memitem:a3e985b678d35b43dfd0b2bcb0d1d01d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a3e985b678d35b43dfd0b2bcb0d1d01d8">levelSetVolume</a> (const GridT &amp;grid, bool useWorldUnits)</td></tr>
<tr class="separator:a3e985b678d35b43dfd0b2bcb0d1d01d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f3f620c49f508bbfe2cddda18c66d9"><td class="memTemplParams" colspan="2">template&lt;class GridT &gt; </td></tr>
<tr class="memitem:a19f3f620c49f508bbfe2cddda18c66d9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a19f3f620c49f508bbfe2cddda18c66d9">levelSetEulerCharacteristic</a> (const GridT &amp;grid)</td></tr>
<tr class="separator:a19f3f620c49f508bbfe2cddda18c66d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f57ec0f6bb9d933e6532c58aeb0918"><td class="memTemplParams" colspan="2">template&lt;class GridT &gt; </td></tr>
<tr class="memitem:ab5f57ec0f6bb9d933e6532c58aeb0918"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ab5f57ec0f6bb9d933e6532c58aeb0918">levelSetGenus</a> (const GridT &amp;grid)</td></tr>
<tr class="separator:ab5f57ec0f6bb9d933e6532c58aeb0918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55629b59f05b1a45ea3edf5f4303b7d2"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:a55629b59f05b1a45ea3edf5f4303b7d2"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a55629b59f05b1a45ea3edf5f4303b7d2">createLevelSetPlatonic</a> (int faceCount, float scale=1.0f, const Vec3f &amp;center=Vec3f(0.0f), float voxelSize=0.1f, float halfWidth=float(LEVEL_SET_HALF_WIDTH), InterruptT *interrupt=nullptr)</td></tr>
<tr class="memdesc:a55629b59f05b1a45ea3edf5f4303b7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a platonic solid.  <a href="#a55629b59f05b1a45ea3edf5f4303b7d2">More...</a><br /></td></tr>
<tr class="separator:a55629b59f05b1a45ea3edf5f4303b7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5daf496fca49e34b4a7a47a366409641"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a5daf496fca49e34b4a7a47a366409641"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a5daf496fca49e34b4a7a47a366409641">createLevelSetPlatonic</a> (int faceCount, float scale=1.0f, const Vec3f &amp;center=Vec3f(0.0f), float voxelSize=0.1f, float halfWidth=float(LEVEL_SET_HALF_WIDTH))</td></tr>
<tr class="memdesc:a5daf496fca49e34b4a7a47a366409641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a platonic solid.  <a href="#a5daf496fca49e34b4a7a47a366409641">More...</a><br /></td></tr>
<tr class="separator:a5daf496fca49e34b4a7a47a366409641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba062fce46a33580873b119f2725b97"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:a9ba062fce46a33580873b119f2725b97"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a9ba062fce46a33580873b119f2725b97">createLevelSetTetrahedron</a> (float scale=1.0f, const Vec3f &amp;center=Vec3f(0.0f), float voxelSize=0.1f, float halfWidth=float(LEVEL_SET_HALF_WIDTH), InterruptT *interrupt=nullptr)</td></tr>
<tr class="memdesc:a9ba062fce46a33580873b119f2725b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tetrahedron.  <a href="#a9ba062fce46a33580873b119f2725b97">More...</a><br /></td></tr>
<tr class="separator:a9ba062fce46a33580873b119f2725b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68b863f0eab591d85b4d3b0123196bd"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:ad68b863f0eab591d85b4d3b0123196bd"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ad68b863f0eab591d85b4d3b0123196bd">createLevelSetTetrahedron</a> (float scale=1.0f, const Vec3f &amp;center=Vec3f(0.0f), float voxelSize=0.1f, float halfWidth=float(LEVEL_SET_HALF_WIDTH))</td></tr>
<tr class="memdesc:ad68b863f0eab591d85b4d3b0123196bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tetrahedron.  <a href="#ad68b863f0eab591d85b4d3b0123196bd">More...</a><br /></td></tr>
<tr class="separator:ad68b863f0eab591d85b4d3b0123196bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4647d0e8bc878c1795a0510d7222a0b3"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:a4647d0e8bc878c1795a0510d7222a0b3"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a4647d0e8bc878c1795a0510d7222a0b3">createLevelSetCube</a> (float scale=1.0f, const Vec3f &amp;center=Vec3f(0.0f), float voxelSize=0.1f, float halfWidth=float(LEVEL_SET_HALF_WIDTH), InterruptT *interrupt=nullptr)</td></tr>
<tr class="memdesc:a4647d0e8bc878c1795a0510d7222a0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a cube.  <a href="#a4647d0e8bc878c1795a0510d7222a0b3">More...</a><br /></td></tr>
<tr class="separator:a4647d0e8bc878c1795a0510d7222a0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61101c3365a960b7ebb627f46bdbe43"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:af61101c3365a960b7ebb627f46bdbe43"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#af61101c3365a960b7ebb627f46bdbe43">createLevelSetCube</a> (float scale=1.0f, const Vec3f &amp;center=Vec3f(0.0f), float voxelSize=0.1f, float halfWidth=float(LEVEL_SET_HALF_WIDTH))</td></tr>
<tr class="memdesc:af61101c3365a960b7ebb627f46bdbe43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a cube.  <a href="#af61101c3365a960b7ebb627f46bdbe43">More...</a><br /></td></tr>
<tr class="separator:af61101c3365a960b7ebb627f46bdbe43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0ac6470c087f2f96b8efef46bc190c"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:a0d0ac6470c087f2f96b8efef46bc190c"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a0d0ac6470c087f2f96b8efef46bc190c">createLevelSetOctahedron</a> (float scale=1.0f, const Vec3f &amp;center=Vec3f(0.0f), float voxelSize=0.1f, float halfWidth=float(LEVEL_SET_HALF_WIDTH), InterruptT *interrupt=nullptr)</td></tr>
<tr class="memdesc:a0d0ac6470c087f2f96b8efef46bc190c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an octahedron.  <a href="#a0d0ac6470c087f2f96b8efef46bc190c">More...</a><br /></td></tr>
<tr class="separator:a0d0ac6470c087f2f96b8efef46bc190c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6985a9cbbaddaf2f11d3adf2ed90cbd3"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a6985a9cbbaddaf2f11d3adf2ed90cbd3"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a6985a9cbbaddaf2f11d3adf2ed90cbd3">createLevelSetOctahedron</a> (float scale=1.0f, const Vec3f &amp;center=Vec3f(0.0f), float voxelSize=0.1f, float halfWidth=float(LEVEL_SET_HALF_WIDTH))</td></tr>
<tr class="memdesc:a6985a9cbbaddaf2f11d3adf2ed90cbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an octahedron.  <a href="#a6985a9cbbaddaf2f11d3adf2ed90cbd3">More...</a><br /></td></tr>
<tr class="separator:a6985a9cbbaddaf2f11d3adf2ed90cbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327bb0281010fd9a5cb2bee6e1e85ddd"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:a327bb0281010fd9a5cb2bee6e1e85ddd"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a327bb0281010fd9a5cb2bee6e1e85ddd">createLevelSetDodecahedron</a> (float scale=1.0f, const Vec3f &amp;center=Vec3f(0.0f), float voxelSize=0.1f, float halfWidth=float(LEVEL_SET_HALF_WIDTH), InterruptT *interrupt=nullptr)</td></tr>
<tr class="memdesc:a327bb0281010fd9a5cb2bee6e1e85ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a dodecahedron.  <a href="#a327bb0281010fd9a5cb2bee6e1e85ddd">More...</a><br /></td></tr>
<tr class="separator:a327bb0281010fd9a5cb2bee6e1e85ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653823e30ee298adfb1bd07bdb1d57d8"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a653823e30ee298adfb1bd07bdb1d57d8"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a653823e30ee298adfb1bd07bdb1d57d8">createLevelSetDodecahedron</a> (float scale=1.0f, const Vec3f &amp;center=Vec3f(0.0f), float voxelSize=0.1f, float halfWidth=float(LEVEL_SET_HALF_WIDTH))</td></tr>
<tr class="memdesc:a653823e30ee298adfb1bd07bdb1d57d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a dodecahedron.  <a href="#a653823e30ee298adfb1bd07bdb1d57d8">More...</a><br /></td></tr>
<tr class="separator:a653823e30ee298adfb1bd07bdb1d57d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dc176d9b993ff0f4658dcbd37904bc"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:a74dc176d9b993ff0f4658dcbd37904bc"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a74dc176d9b993ff0f4658dcbd37904bc">createLevelSetIcosahedron</a> (float scale=1.0f, const Vec3f &amp;center=Vec3f(0.0f), float voxelSize=0.1f, float halfWidth=float(LEVEL_SET_HALF_WIDTH), InterruptT *interrupt=nullptr)</td></tr>
<tr class="memdesc:a74dc176d9b993ff0f4658dcbd37904bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an icosahedron.  <a href="#a74dc176d9b993ff0f4658dcbd37904bc">More...</a><br /></td></tr>
<tr class="separator:a74dc176d9b993ff0f4658dcbd37904bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584442a160cdf1a28af335046732487f"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a584442a160cdf1a28af335046732487f"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a584442a160cdf1a28af335046732487f">createLevelSetIcosahedron</a> (float scale=1.0f, const Vec3f &amp;center=Vec3f(0.0f), float voxelSize=0.1f, float halfWidth=float(LEVEL_SET_HALF_WIDTH))</td></tr>
<tr class="memdesc:a584442a160cdf1a28af335046732487f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an icosahedron.  <a href="#a584442a160cdf1a28af335046732487f">More...</a><br /></td></tr>
<tr class="separator:a584442a160cdf1a28af335046732487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af574939742ed86a148731292520c8e30"><td class="memTemplParams" colspan="2">template&lt;class GridType &gt; </td></tr>
<tr class="memitem:af574939742ed86a148731292520c8e30"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#af574939742ed86a148731292520c8e30">levelSetRebuild</a> (const GridType &amp;grid, float isovalue=0, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">math::Transform</a> *xform=nullptr)</td></tr>
<tr class="memdesc:af574939742ed86a148731292520c8e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new grid of type <code>GridType</code> that contains a narrow-band level set representation of an isosurface of a given grid.  <a href="#af574939742ed86a148731292520c8e30">More...</a><br /></td></tr>
<tr class="separator:af574939742ed86a148731292520c8e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce3a230f06d4e222727e1046bc6ae3c"><td class="memTemplParams" colspan="2">template&lt;class GridType &gt; </td></tr>
<tr class="memitem:a9ce3a230f06d4e222727e1046bc6ae3c"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a9ce3a230f06d4e222727e1046bc6ae3c">levelSetRebuild</a> (const GridType &amp;grid, float isovalue, float exBandWidth, float inBandWidth, const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">math::Transform</a> *xform=nullptr)</td></tr>
<tr class="memdesc:a9ce3a230f06d4e222727e1046bc6ae3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new grid of type <code>GridType</code> that contains a narrow-band level set representation of an isosurface of a given grid.  <a href="#a9ce3a230f06d4e222727e1046bc6ae3c">More...</a><br /></td></tr>
<tr class="separator:a9ce3a230f06d4e222727e1046bc6ae3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b42eee5e13c85a68dfad82c21d510a1"><td class="memTemplParams" colspan="2">template&lt;class GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:a9b42eee5e13c85a68dfad82c21d510a1"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a9b42eee5e13c85a68dfad82c21d510a1">levelSetRebuild</a> (const GridType &amp;grid, float isovalue, float exBandWidth, float inBandWidth, const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">math::Transform</a> *xform=nullptr, InterruptT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a9b42eee5e13c85a68dfad82c21d510a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new grid of type <code>GridType</code> that contains a narrow-band level set representation of an isosurface of a given grid.  <a href="#a9b42eee5e13c85a68dfad82c21d510a1">More...</a><br /></td></tr>
<tr class="separator:a9b42eee5e13c85a68dfad82c21d510a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e7b3c363d0d3a15b5859c4b06e9d8b"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename InterruptT &gt; </td></tr>
<tr class="memitem:a47e7b3c363d0d3a15b5859c4b06e9d8b"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a47e7b3c363d0d3a15b5859c4b06e9d8b">createLevelSetSphere</a> (float radius, const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">openvdb::Vec3f</a> &amp;center, float voxelSize, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), InterruptT *interrupt=nullptr, bool threaded=true)</td></tr>
<tr class="memdesc:a47e7b3c363d0d3a15b5859c4b06e9d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a sphere.  <a href="#a47e7b3c363d0d3a15b5859c4b06e9d8b">More...</a><br /></td></tr>
<tr class="separator:a47e7b3c363d0d3a15b5859c4b06e9d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c20722eb866a3eaece7be49d829c8d0"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a5c20722eb866a3eaece7be49d829c8d0"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a5c20722eb866a3eaece7be49d829c8d0">createLevelSetSphere</a> (float radius, const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">openvdb::Vec3f</a> &amp;center, float voxelSize, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), bool threaded=true)</td></tr>
<tr class="memdesc:a5c20722eb866a3eaece7be49d829c8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a sphere.  <a href="#a5c20722eb866a3eaece7be49d829c8d0">More...</a><br /></td></tr>
<tr class="separator:a5c20722eb866a3eaece7be49d829c8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad82d1b0039598209bc21cd9aa4511a0"><td class="memTemplParams" colspan="2">template&lt;class GridType &gt; </td></tr>
<tr class="memitem:aad82d1b0039598209bc21cd9aa4511a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aad82d1b0039598209bc21cd9aa4511a0">sdfToFogVolume</a> (GridType &amp;grid, typename GridType::ValueType cutoffDistance=lsutilGridMax&lt; GridType &gt;())</td></tr>
<tr class="memdesc:aad82d1b0039598209bc21cd9aa4511a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded method to convert a sparse level set/SDF into a sparse fog volume.  <a href="#aad82d1b0039598209bc21cd9aa4511a0">More...</a><br /></td></tr>
<tr class="separator:aad82d1b0039598209bc21cd9aa4511a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b83096927350f3324cba935be37717"><td class="memTemplParams" colspan="2">template&lt;class GridOrTreeType &gt; </td></tr>
<tr class="memitem:a59b83096927350f3324cba935be37717"><td class="memTemplItemLeft" align="right" valign="top">GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a59b83096927350f3324cba935be37717">sdfInteriorMask</a> (const GridOrTreeType &amp;volume, typename GridOrTreeType::ValueType isovalue=lsutilGridZero&lt; GridOrTreeType &gt;())</td></tr>
<tr class="memdesc:a59b83096927350f3324cba935be37717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded method to construct a boolean mask that represents interior regions in a signed distance field.  <a href="#a59b83096927350f3324cba935be37717">More...</a><br /></td></tr>
<tr class="separator:a59b83096927350f3324cba935be37717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3ef894d7a7eaf47a03d2508d2d95d3"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeType &gt; </td></tr>
<tr class="memitem:a1a3ef894d7a7eaf47a03d2508d2d95d3"><td class="memTemplItemLeft" align="right" valign="top">GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a1a3ef894d7a7eaf47a03d2508d2d95d3">extractEnclosedRegion</a> (const GridOrTreeType &amp;volume, typename GridOrTreeType::ValueType isovalue=lsutilGridZero&lt; GridOrTreeType &gt;(), const typename <a class="el" href="structopenvdb_1_1v8__0_1_1TreeAdapter.html">TreeAdapter</a>&lt; GridOrTreeType &gt;::TreeType::template ValueConverter&lt; bool &gt;::Type *fillMask=nullptr)</td></tr>
<tr class="memdesc:a1a3ef894d7a7eaf47a03d2508d2d95d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the interior regions of a signed distance field and topologically enclosed (watertight) regions of value greater than the <em>isovalue</em> (cavities) that can arise as the result of CSG union operations between different shapes where at least one of the shapes has a concavity that is capped.  <a href="#a1a3ef894d7a7eaf47a03d2508d2d95d3">More...</a><br /></td></tr>
<tr class="separator:a1a3ef894d7a7eaf47a03d2508d2d95d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bfe53eeb50b4ffdc96c90af7e1de1b"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeType &gt; </td></tr>
<tr class="memitem:a39bfe53eeb50b4ffdc96c90af7e1de1b"><td class="memTemplItemLeft" align="right" valign="top">GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a39bfe53eeb50b4ffdc96c90af7e1de1b">extractIsosurfaceMask</a> (const GridOrTreeType &amp;volume, typename GridOrTreeType::ValueType isovalue)</td></tr>
<tr class="memdesc:a39bfe53eeb50b4ffdc96c90af7e1de1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mask of the voxels that intersect the implicit surface with the given <em>isovalue</em>.  <a href="#a39bfe53eeb50b4ffdc96c90af7e1de1b">More...</a><br /></td></tr>
<tr class="separator:a39bfe53eeb50b4ffdc96c90af7e1de1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b522dd56a467487d4b16d0f1d16c0d6"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeType &gt; </td></tr>
<tr class="memitem:a3b522dd56a467487d4b16d0f1d16c0d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a3b522dd56a467487d4b16d0f1d16c0d6">extractActiveVoxelSegmentMasks</a> (const GridOrTreeType &amp;volume, std::vector&lt; typename GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr &gt; &amp;masks)</td></tr>
<tr class="memdesc:a3b522dd56a467487d4b16d0f1d16c0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mask for each connected component of the given grid's active voxels.  <a href="#a3b522dd56a467487d4b16d0f1d16c0d6">More...</a><br /></td></tr>
<tr class="separator:a3b522dd56a467487d4b16d0f1d16c0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc2d4f60d561afd2fb248e386ca67d8"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeType &gt; </td></tr>
<tr class="memitem:a1cc2d4f60d561afd2fb248e386ca67d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a1cc2d4f60d561afd2fb248e386ca67d8">segmentActiveVoxels</a> (const GridOrTreeType &amp;volume, std::vector&lt; typename GridOrTreeType::Ptr &gt; &amp;segments)</td></tr>
<tr class="memdesc:a1cc2d4f60d561afd2fb248e386ca67d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates disjoint active topology components into distinct grids or trees.  <a href="#a1cc2d4f60d561afd2fb248e386ca67d8">More...</a><br /></td></tr>
<tr class="separator:a1cc2d4f60d561afd2fb248e386ca67d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f4df82ed92eb746d439ce4721ea8a5"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeType &gt; </td></tr>
<tr class="memitem:ac9f4df82ed92eb746d439ce4721ea8a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac9f4df82ed92eb746d439ce4721ea8a5">segmentSDF</a> (const GridOrTreeType &amp;volume, std::vector&lt; typename GridOrTreeType::Ptr &gt; &amp;segments)</td></tr>
<tr class="memdesc:ac9f4df82ed92eb746d439ce4721ea8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates disjoint SDF surfaces into distinct grids or trees.  <a href="#ac9f4df82ed92eb746d439ce4721ea8a5">More...</a><br /></td></tr>
<tr class="separator:ac9f4df82ed92eb746d439ce4721ea8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5182249f0ff2cd4584ec24b09300a0"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a5d5182249f0ff2cd4584ec24b09300a0"><td class="memTemplItemLeft" align="right" valign="top">GridType::template ValueConverter&lt; bool &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a5d5182249f0ff2cd4584ec24b09300a0">interiorMask</a> (const GridType &amp;grid, const double isovalue=0.0)</td></tr>
<tr class="memdesc:a5d5182249f0ff2cd4584ec24b09300a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input grid of any type, return a new, boolean grid whose active voxel topology matches the input grid's or, if the input grid is a level set, matches the input grid's interior.  <a href="#a5d5182249f0ff2cd4584ec24b09300a0">More...</a><br /></td></tr>
<tr class="separator:a5d5182249f0ff2cd4584ec24b09300a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12727083ecf3b9561ff954517144d7a8"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MeshDataAdapter &gt; </td></tr>
<tr class="memitem:a12727083ecf3b9561ff954517144d7a8"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a12727083ecf3b9561ff954517144d7a8">meshToVolume</a> (const <a class="el" href="interfaceMeshDataAdapter.html">MeshDataAdapter</a> &amp;mesh, const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">math::Transform</a> &amp;transform, float exteriorBandWidth=3.0f, float interiorBandWidth=3.0f, int flags=0, typename GridType::template ValueConverter&lt; Int32 &gt;::Type *polygonIndexGrid=nullptr)</td></tr>
<tr class="separator:a12727083ecf3b9561ff954517144d7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc876198b66dd8a91b21835f1f25342"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename MeshDataAdapter , typename Interrupter &gt; </td></tr>
<tr class="memitem:afdc876198b66dd8a91b21835f1f25342"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#afdc876198b66dd8a91b21835f1f25342">meshToVolume</a> (Interrupter &amp;interrupter, const <a class="el" href="interfaceMeshDataAdapter.html">MeshDataAdapter</a> &amp;mesh, const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">math::Transform</a> &amp;transform, float exteriorBandWidth=3.0f, float interiorBandWidth=3.0f, int flags=0, typename GridType::template ValueConverter&lt; Int32 &gt;::Type *polygonIndexGrid=nullptr)</td></tr>
<tr class="memdesc:afdc876198b66dd8a91b21835f1f25342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert polygonal meshes that consist of quads and/or triangles into signed or unsigned distance field volumes.  <a href="#afdc876198b66dd8a91b21835f1f25342">More...</a><br /></td></tr>
<tr class="separator:afdc876198b66dd8a91b21835f1f25342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d6517666da8e1ec1175651ebf12f32"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a49d6517666da8e1ec1175651ebf12f32"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a49d6517666da8e1ec1175651ebf12f32">meshToLevelSet</a> (const openvdb::math::Transform &amp;xform, const std::vector&lt; Vec3s &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a49d6517666da8e1ec1175651ebf12f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a triangle mesh to a level set volume.  <a href="#a49d6517666da8e1ec1175651ebf12f32">More...</a><br /></td></tr>
<tr class="separator:a49d6517666da8e1ec1175651ebf12f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564d13cfab9796e72f62f51f991d05af"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename Interrupter &gt; </td></tr>
<tr class="memitem:a564d13cfab9796e72f62f51f991d05af"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a564d13cfab9796e72f62f51f991d05af">meshToLevelSet</a> (Interrupter &amp;interrupter, const openvdb::math::Transform &amp;xform, const std::vector&lt; Vec3s &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a564d13cfab9796e72f62f51f991d05af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds support for a <em>interrupter</em> callback used to cancel the conversion.  <a href="#a564d13cfab9796e72f62f51f991d05af">More...</a><br /></td></tr>
<tr class="separator:a564d13cfab9796e72f62f51f991d05af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb69abc32d73ce0e3cd67b569bed65b8"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:afb69abc32d73ce0e3cd67b569bed65b8"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#afb69abc32d73ce0e3cd67b569bed65b8">meshToLevelSet</a> (const openvdb::math::Transform &amp;xform, const std::vector&lt; Vec3s &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:afb69abc32d73ce0e3cd67b569bed65b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a quad mesh to a level set volume.  <a href="#afb69abc32d73ce0e3cd67b569bed65b8">More...</a><br /></td></tr>
<tr class="separator:afb69abc32d73ce0e3cd67b569bed65b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb7e6e46e2f3d080031f499863d3ba9"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename Interrupter &gt; </td></tr>
<tr class="memitem:a6eb7e6e46e2f3d080031f499863d3ba9"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a6eb7e6e46e2f3d080031f499863d3ba9">meshToLevelSet</a> (Interrupter &amp;interrupter, const openvdb::math::Transform &amp;xform, const std::vector&lt; Vec3s &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a6eb7e6e46e2f3d080031f499863d3ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds support for a <em>interrupter</em> callback used to cancel the conversion.  <a href="#a6eb7e6e46e2f3d080031f499863d3ba9">More...</a><br /></td></tr>
<tr class="separator:a6eb7e6e46e2f3d080031f499863d3ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88550f83eda208f6a4efd332735bb215"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a88550f83eda208f6a4efd332735bb215"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a88550f83eda208f6a4efd332735bb215">meshToLevelSet</a> (const openvdb::math::Transform &amp;xform, const std::vector&lt; Vec3s &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a88550f83eda208f6a4efd332735bb215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a triangle and quad mesh to a level set volume.  <a href="#a88550f83eda208f6a4efd332735bb215">More...</a><br /></td></tr>
<tr class="separator:a88550f83eda208f6a4efd332735bb215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63becdf83d644c0cbc00213390201f97"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename Interrupter &gt; </td></tr>
<tr class="memitem:a63becdf83d644c0cbc00213390201f97"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a63becdf83d644c0cbc00213390201f97">meshToLevelSet</a> (Interrupter &amp;interrupter, const openvdb::math::Transform &amp;xform, const std::vector&lt; Vec3s &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a63becdf83d644c0cbc00213390201f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds support for a <em>interrupter</em> callback used to cancel the conversion.  <a href="#a63becdf83d644c0cbc00213390201f97">More...</a><br /></td></tr>
<tr class="separator:a63becdf83d644c0cbc00213390201f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab994dead75e3d110e11eb64dce6ca65a"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:ab994dead75e3d110e11eb64dce6ca65a"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ab994dead75e3d110e11eb64dce6ca65a">meshToSignedDistanceField</a> (const openvdb::math::Transform &amp;xform, const std::vector&lt; Vec3s &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float exBandWidth, float inBandWidth)</td></tr>
<tr class="memdesc:ab994dead75e3d110e11eb64dce6ca65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a triangle and quad mesh to a signed distance field with an asymmetrical narrow band.  <a href="#ab994dead75e3d110e11eb64dce6ca65a">More...</a><br /></td></tr>
<tr class="separator:ab994dead75e3d110e11eb64dce6ca65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8b90b4bf51a0a1d6f02a769787b415"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename Interrupter &gt; </td></tr>
<tr class="memitem:aee8b90b4bf51a0a1d6f02a769787b415"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aee8b90b4bf51a0a1d6f02a769787b415">meshToSignedDistanceField</a> (Interrupter &amp;interrupter, const openvdb::math::Transform &amp;xform, const std::vector&lt; Vec3s &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float exBandWidth, float inBandWidth)</td></tr>
<tr class="memdesc:aee8b90b4bf51a0a1d6f02a769787b415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds support for a <em>interrupter</em> callback used to cancel the conversion.  <a href="#aee8b90b4bf51a0a1d6f02a769787b415">More...</a><br /></td></tr>
<tr class="separator:aee8b90b4bf51a0a1d6f02a769787b415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a77a75ddf87809699a67916ea172add"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a7a77a75ddf87809699a67916ea172add"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a7a77a75ddf87809699a67916ea172add">meshToUnsignedDistanceField</a> (const openvdb::math::Transform &amp;xform, const std::vector&lt; Vec3s &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float bandWidth)</td></tr>
<tr class="memdesc:a7a77a75ddf87809699a67916ea172add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a triangle and quad mesh to an unsigned distance field.  <a href="#a7a77a75ddf87809699a67916ea172add">More...</a><br /></td></tr>
<tr class="separator:a7a77a75ddf87809699a67916ea172add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc72d314893ef0b6ad5cda65ded5255"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename Interrupter &gt; </td></tr>
<tr class="memitem:aacc72d314893ef0b6ad5cda65ded5255"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aacc72d314893ef0b6ad5cda65ded5255">meshToUnsignedDistanceField</a> (Interrupter &amp;interrupter, const openvdb::math::Transform &amp;xform, const std::vector&lt; Vec3s &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float bandWidth)</td></tr>
<tr class="memdesc:aacc72d314893ef0b6ad5cda65ded5255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds support for a <em>interrupter</em> callback used to cancel the conversion.  <a href="#aacc72d314893ef0b6ad5cda65ded5255">More...</a><br /></td></tr>
<tr class="separator:aacc72d314893ef0b6ad5cda65ded5255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a314c42b9d506bd60c1acdd6f41aac7"><td class="memTemplParams" colspan="2">template&lt;typename GridType , typename VecType &gt; </td></tr>
<tr class="memitem:a9a314c42b9d506bd60c1acdd6f41aac7"><td class="memTemplItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a9a314c42b9d506bd60c1acdd6f41aac7">createLevelSetBox</a> (const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1BBox.html">math::BBox</a>&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ae93f92d10730a52ed3b207d5811f6a6e">VecType</a> &gt; &amp;bbox, const openvdb::math::Transform &amp;xform, typename VecType::ValueType halfWidth=<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</td></tr>
<tr class="memdesc:a9a314c42b9d506bd60c1acdd6f41aac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a box.  <a href="#a9a314c42b9d506bd60c1acdd6f41aac7">More...</a><br /></td></tr>
<tr class="separator:a9a314c42b9d506bd60c1acdd6f41aac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c971c289dca66c2e8500e01aac41bdf"><td class="memTemplParams" colspan="2">template&lt;typename FloatTreeT &gt; </td></tr>
<tr class="memitem:a5c971c289dca66c2e8500e01aac41bdf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a5c971c289dca66c2e8500e01aac41bdf">traceExteriorBoundaries</a> (FloatTreeT &amp;tree)</td></tr>
<tr class="memdesc:a5c971c289dca66c2e8500e01aac41bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traces the exterior voxel boundary of closed objects in the input volume <em>tree</em>. Exterior voxels are marked with a negative sign, voxels with a value below <code>0.75</code> are left unchanged and act as the boundary layer.  <a href="#a5c971c289dca66c2e8500e01aac41bdf">More...</a><br /></td></tr>
<tr class="separator:a5c971c289dca66c2e8500e01aac41bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46c2f5d3a3755b61c266cb3383bb4dd"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#af46c2f5d3a3755b61c266cb3383bb4dd">operator&lt;&lt;</a> (std::ostream &amp;ostr, const <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1MeshToVoxelEdgeData_1_1EdgeData.html">MeshToVoxelEdgeData::EdgeData</a> &amp;rhs)</td></tr>
<tr class="separator:af46c2f5d3a3755b61c266cb3383bb4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf89ceee42ffedc364378fd9fe5da1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1MeshToVoxelEdgeData_1_1EdgeData.html">MeshToVoxelEdgeData::EdgeData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#afaf89ceee42ffedc364378fd9fe5da1b">Abs</a> (const <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1MeshToVoxelEdgeData_1_1EdgeData.html">MeshToVoxelEdgeData::EdgeData</a> &amp;x)</td></tr>
<tr class="separator:afaf89ceee42ffedc364378fd9fe5da1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465a5aa8e8ee17ea4b9f68bcd481a372"><td class="memTemplParams" colspan="2">template&lt;typename TreeType &gt; </td></tr>
<tr class="memitem:a465a5aa8e8ee17ea4b9f68bcd481a372"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a465a5aa8e8ee17ea4b9f68bcd481a372">dilateActiveValues</a> (TreeType &amp;tree, int iterations=1, <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a> nn=<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a>, <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac7a17ca003c7f18f411cab4e8b4f6e74">TilePolicy</a> mode=<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac7a17ca003c7f18f411cab4e8b4f6e74ab963e977b12771992aceaf779527c26f">PRESERVE_TILES</a>)</td></tr>
<tr class="memdesc:a465a5aa8e8ee17ea4b9f68bcd481a372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topologically dilate all active values (i.e. both voxels and tiles) in a tree using one of three nearest neighbor connectivity patterns.  <a href="#a465a5aa8e8ee17ea4b9f68bcd481a372">More...</a><br /></td></tr>
<tr class="separator:a465a5aa8e8ee17ea4b9f68bcd481a372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4642829a0bcc9ee4a021cb8b96fe72"><td class="memTemplParams" colspan="2">template&lt;typename TreeType &gt; </td></tr>
<tr class="memitem:afd4642829a0bcc9ee4a021cb8b96fe72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#afd4642829a0bcc9ee4a021cb8b96fe72">dilateActiveValues</a> (<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html">tree::LeafManager</a>&lt; TreeType &gt; &amp;manager, int iterations=1, <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a> nn=<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a>, <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac7a17ca003c7f18f411cab4e8b4f6e74">TilePolicy</a> mode=<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac7a17ca003c7f18f411cab4e8b4f6e74ab963e977b12771992aceaf779527c26f">PRESERVE_TILES</a>)</td></tr>
<tr class="memdesc:afd4642829a0bcc9ee4a021cb8b96fe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topologically dilate all active values (i.e. both voxels and tiles) in a tree using one of three nearest neighbor connectivity patterns.  <a href="#afd4642829a0bcc9ee4a021cb8b96fe72">More...</a><br /></td></tr>
<tr class="separator:afd4642829a0bcc9ee4a021cb8b96fe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e34b5d2c9f6d491cada2461ce9413a"><td class="memTemplParams" colspan="2">template&lt;typename TreeType &gt; </td></tr>
<tr class="memitem:aa7e34b5d2c9f6d491cada2461ce9413a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aa7e34b5d2c9f6d491cada2461ce9413a">dilateVoxels</a> (TreeType &amp;tree, int iterations=1, <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a> nn=<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a>)</td></tr>
<tr class="memdesc:aa7e34b5d2c9f6d491cada2461ce9413a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topologically dilate all leaf-level active voxels in a tree using one of three nearest neighbor connectivity patterns.  <a href="#aa7e34b5d2c9f6d491cada2461ce9413a">More...</a><br /></td></tr>
<tr class="separator:aa7e34b5d2c9f6d491cada2461ce9413a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb648a3a1452b9640f099d3a3359990b"><td class="memTemplParams" colspan="2">template&lt;typename TreeType &gt; </td></tr>
<tr class="memitem:aeb648a3a1452b9640f099d3a3359990b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aeb648a3a1452b9640f099d3a3359990b">dilateVoxels</a> (<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html">tree::LeafManager</a>&lt; TreeType &gt; &amp;manager, int iterations=1, <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a> nn=<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a>)</td></tr>
<tr class="memdesc:aeb648a3a1452b9640f099d3a3359990b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topologically dilate all leaf-level active voxels in a tree using one of three nearest neighbor connectivity patterns.  <a href="#aeb648a3a1452b9640f099d3a3359990b">More...</a><br /></td></tr>
<tr class="separator:aeb648a3a1452b9640f099d3a3359990b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa99ba23890494cdfe09a6d6abdd380"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTree &gt; </td></tr>
<tr class="memitem:a9fa99ba23890494cdfe09a6d6abdd380"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a9fa99ba23890494cdfe09a6d6abdd380">activate</a> (GridOrTree &amp;, const typename GridOrTree::ValueType &amp;value, const typename GridOrTree::ValueType &amp;tolerance=<a class="el" href="namespaceopenvdb_1_1v8__0.html#afacc9da89954ca2831b932a917506991">zeroVal</a>&lt; typename GridOrTree::ValueType &gt;())</td></tr>
<tr class="memdesc:a9fa99ba23890494cdfe09a6d6abdd380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark as active any inactive tiles or voxels in the given grid or tree whose values are equal to <em>value</em> (optionally to within the given <em>tolerance</em>).  <a href="#a9fa99ba23890494cdfe09a6d6abdd380">More...</a><br /></td></tr>
<tr class="separator:a9fa99ba23890494cdfe09a6d6abdd380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc78330c21bf8fc7b0840d7ab6f0675d"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTree &gt; </td></tr>
<tr class="memitem:abc78330c21bf8fc7b0840d7ab6f0675d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#abc78330c21bf8fc7b0840d7ab6f0675d">deactivate</a> (GridOrTree &amp;, const typename GridOrTree::ValueType &amp;value, const typename GridOrTree::ValueType &amp;tolerance=<a class="el" href="namespaceopenvdb_1_1v8__0.html#afacc9da89954ca2831b932a917506991">zeroVal</a>&lt; typename GridOrTree::ValueType &gt;())</td></tr>
<tr class="memdesc:abc78330c21bf8fc7b0840d7ab6f0675d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark as inactive any active tiles or voxels in the given grid or tree whose values are equal to <em>value</em> (optionally to within the given <em>tolerance</em>).  <a href="#abc78330c21bf8fc7b0840d7ab6f0675d">More...</a><br /></td></tr>
<tr class="separator:abc78330c21bf8fc7b0840d7ab6f0675d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29bb93f486d96bd91cad919e623dab0"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename ParticleListT , typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ae29bb93f486d96bd91cad919e623dab0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ae29bb93f486d96bd91cad919e623dab0">particlesToSdf</a> (const ParticleListT &amp;, GridT &amp;, InterrupterT *=nullptr)</td></tr>
<tr class="memdesc:ae29bb93f486d96bd91cad919e623dab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a scalar, floating-point grid with CSG-unioned level set spheres described by the given particle positions and radii.  <a href="#ae29bb93f486d96bd91cad919e623dab0">More...</a><br /></td></tr>
<tr class="separator:ae29bb93f486d96bd91cad919e623dab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad924a8ad2838440370b1c80a599794d8"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename ParticleListT , typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ad924a8ad2838440370b1c80a599794d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ad924a8ad2838440370b1c80a599794d8">particlesToSdf</a> (const ParticleListT &amp;, GridT &amp;, <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> radius, InterrupterT *=nullptr)</td></tr>
<tr class="memdesc:ad924a8ad2838440370b1c80a599794d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a scalar, floating-point grid with fixed-size, CSG-unioned level set spheres described by the given particle positions and the specified radius.  <a href="#ad924a8ad2838440370b1c80a599794d8">More...</a><br /></td></tr>
<tr class="separator:ad924a8ad2838440370b1c80a599794d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcddfc57ef94f93ff3806a45c26ca7d0"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename ParticleListT , typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:adcddfc57ef94f93ff3806a45c26ca7d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#adcddfc57ef94f93ff3806a45c26ca7d0">particleTrailsToSdf</a> (const ParticleListT &amp;, GridT &amp;, <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> delta=1, InterrupterT *=nullptr)</td></tr>
<tr class="memdesc:adcddfc57ef94f93ff3806a45c26ca7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a scalar, floating-point grid with CSG-unioned trails of level set spheres with decreasing radius, where the starting position and radius and the direction of each trail is given by particle attributes.  <a href="#adcddfc57ef94f93ff3806a45c26ca7d0">More...</a><br /></td></tr>
<tr class="separator:adcddfc57ef94f93ff3806a45c26ca7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9feb86e4311db3ba962b9d19eb5569be"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename ParticleListT , typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a9feb86e4311db3ba962b9d19eb5569be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a9feb86e4311db3ba962b9d19eb5569be">particlesToMask</a> (const ParticleListT &amp;, GridT &amp;, InterrupterT *=nullptr)</td></tr>
<tr class="memdesc:a9feb86e4311db3ba962b9d19eb5569be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a boolean grid wherever it intersects the spheres described by the given particle positions and radii.  <a href="#a9feb86e4311db3ba962b9d19eb5569be">More...</a><br /></td></tr>
<tr class="separator:a9feb86e4311db3ba962b9d19eb5569be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6227a77a20fcc91e570b959710b930d2"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename ParticleListT , typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a6227a77a20fcc91e570b959710b930d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a6227a77a20fcc91e570b959710b930d2">particlesToMask</a> (const ParticleListT &amp;, GridT &amp;, <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> radius, InterrupterT *=nullptr)</td></tr>
<tr class="memdesc:a6227a77a20fcc91e570b959710b930d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a boolean grid wherever it intersects the fixed-size spheres described by the given particle positions and the specified radius.  <a href="#a6227a77a20fcc91e570b959710b930d2">More...</a><br /></td></tr>
<tr class="separator:a6227a77a20fcc91e570b959710b930d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4039b2222a88a7e4ed8e3f47490eecb"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename ParticleListT , typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:af4039b2222a88a7e4ed8e3f47490eecb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#af4039b2222a88a7e4ed8e3f47490eecb">particleTrailsToMask</a> (const ParticleListT &amp;, GridT &amp;, <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> delta=1, InterrupterT *=nullptr)</td></tr>
<tr class="memdesc:af4039b2222a88a7e4ed8e3f47490eecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a boolean grid wherever it intersects trails of spheres with decreasing radius, where the starting position and radius and the direction of each trail is given by particle attributes.  <a href="#af4039b2222a88a7e4ed8e3f47490eecb">More...</a><br /></td></tr>
<tr class="separator:af4039b2222a88a7e4ed8e3f47490eecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6960746cc5165cf6ac1252ad7bc5d4"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename PointArrayT &gt; </td></tr>
<tr class="memitem:aec6960746cc5165cf6ac1252ad7bc5d4"><td class="memTemplItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aec6960746cc5165cf6ac1252ad7bc5d4">createPointIndexGrid</a> (const PointArrayT &amp;points, double voxelSize)</td></tr>
<tr class="memdesc:aec6960746cc5165cf6ac1252ad7bc5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition points into a point index grid to accelerate range and nearest-neighbor searches.  <a href="#aec6960746cc5165cf6ac1252ad7bc5d4">More...</a><br /></td></tr>
<tr class="separator:aec6960746cc5165cf6ac1252ad7bc5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271fec55592c87ddf1f04a02207cfb34"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename PointArrayT &gt; </td></tr>
<tr class="memitem:a271fec55592c87ddf1f04a02207cfb34"><td class="memTemplItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a271fec55592c87ddf1f04a02207cfb34">createPointIndexGrid</a> (const PointArrayT &amp;points, const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">math::Transform</a> &amp;xform)</td></tr>
<tr class="memdesc:a271fec55592c87ddf1f04a02207cfb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition points into a point index grid to accelerate range and nearest-neighbor searches.  <a href="#a271fec55592c87ddf1f04a02207cfb34">More...</a><br /></td></tr>
<tr class="separator:a271fec55592c87ddf1f04a02207cfb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c25ce7b65fe2e22209dce0b5eae646"><td class="memTemplParams" colspan="2">template&lt;typename PointArrayT , typename GridT &gt; </td></tr>
<tr class="memitem:af2c25ce7b65fe2e22209dce0b5eae646"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#af2c25ce7b65fe2e22209dce0b5eae646">isValidPartition</a> (const PointArrayT &amp;points, const GridT &amp;grid)</td></tr>
<tr class="memdesc:af2c25ce7b65fe2e22209dce0b5eae646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given point index grid represents a valid partitioning of the given point array.  <a href="#af2c25ce7b65fe2e22209dce0b5eae646">More...</a><br /></td></tr>
<tr class="separator:af2c25ce7b65fe2e22209dce0b5eae646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2dc20cbb018eddb5d26c53bf8cf83ab"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename PointArrayT &gt; </td></tr>
<tr class="memitem:ab2dc20cbb018eddb5d26c53bf8cf83ab"><td class="memTemplItemLeft" align="right" valign="top">GridT::ConstPtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ab2dc20cbb018eddb5d26c53bf8cf83ab">getValidPointIndexGrid</a> (const PointArrayT &amp;points, const typename GridT::ConstPtr &amp;grid)</td></tr>
<tr class="memdesc:ab2dc20cbb018eddb5d26c53bf8cf83ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repartition the <em>points</em> if needed, otherwise return the input <em>grid</em>.  <a href="#ab2dc20cbb018eddb5d26c53bf8cf83ab">More...</a><br /></td></tr>
<tr class="separator:ab2dc20cbb018eddb5d26c53bf8cf83ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb27ad923a88ee58220750ffc3914c03"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename PointArrayT &gt; </td></tr>
<tr class="memitem:afb27ad923a88ee58220750ffc3914c03"><td class="memTemplItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#afb27ad923a88ee58220750ffc3914c03">getValidPointIndexGrid</a> (const PointArrayT &amp;points, const typename GridT::Ptr &amp;grid)</td></tr>
<tr class="memdesc:afb27ad923a88ee58220750ffc3914c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repartition the <em>points</em> if needed, otherwise return the input <em>grid</em>.  <a href="#afb27ad923a88ee58220750ffc3914c03">More...</a><br /></td></tr>
<tr class="separator:afb27ad923a88ee58220750ffc3914c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1164227196b14538c20d8cb234fdec6"><td class="memTemplParams" colspan="2">template&lt;typename PointListT , typename GridT &gt; </td></tr>
<tr class="memitem:aa1164227196b14538c20d8cb234fdec6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aa1164227196b14538c20d8cb234fdec6">maskPoints</a> (const PointListT &amp;points, GridT &amp;grid)</td></tr>
<tr class="memdesc:aa1164227196b14538c20d8cb234fdec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes every voxel of the <code>grid</code> active if it contains a point.  <a href="#aa1164227196b14538c20d8cb234fdec6">More...</a><br /></td></tr>
<tr class="separator:aa1164227196b14538c20d8cb234fdec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449cba1012dfb9c03702b8ce9164b346"><td class="memTemplParams" colspan="2">template&lt;typename PointListT &gt; </td></tr>
<tr class="memitem:a449cba1012dfb9c03702b8ce9164b346"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">MaskGrid::Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a449cba1012dfb9c03702b8ce9164b346">createPointMask</a> (const PointListT &amp;points, const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">math::Transform</a> &amp;xform)</td></tr>
<tr class="memdesc:a449cba1012dfb9c03702b8ce9164b346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MaskGrid where each binary voxel value is on if the voxel contains one (or more) points (i.e. the 3D position of a point is closer to this voxel than any other voxels).  <a href="#a449cba1012dfb9c03702b8ce9164b346">More...</a><br /></td></tr>
<tr class="separator:a449cba1012dfb9c03702b8ce9164b346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f99dbe0666280f607a4473ddf15d891"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename MaskT  = typename GridT::template ValueConverter&lt;ValueMask&gt;::Type&gt; </td></tr>
<tr class="memitem:a1f99dbe0666280f607a4473ddf15d891"><td class="memTemplItemLeft" align="right" valign="top">MaskT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a1f99dbe0666280f607a4473ddf15d891">createPotentialFlowMask</a> (const GridT &amp;grid, int dilation=5)</td></tr>
<tr class="memdesc:a1f99dbe0666280f607a4473ddf15d891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mask for the Potential Flow domain.  <a href="#a1f99dbe0666280f607a4473ddf15d891">More...</a><br /></td></tr>
<tr class="separator:a1f99dbe0666280f607a4473ddf15d891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc4a744d5c9f2fd9c0e2a0d176861c4"><td class="memTemplParams" colspan="2">template&lt;typename Vec3T , typename GridT , typename MaskT &gt; </td></tr>
<tr class="memitem:a1cc4a744d5c9f2fd9c0e2a0d176861c4"><td class="memTemplItemLeft" align="right" valign="top">GridT::template ValueConverter&lt; Vec3T &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a1cc4a744d5c9f2fd9c0e2a0d176861c4">createPotentialFlowNeumannVelocities</a> (const GridT &amp;collider, const MaskT &amp;domain, const typename GridT::template ValueConverter&lt; Vec3T &gt;::Type::ConstPtr boundaryVelocity, const Vec3T &amp;backgroundVelocity)</td></tr>
<tr class="memdesc:a1cc4a744d5c9f2fd9c0e2a0d176861c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Potential Flow velocities grid for the Neumann boundary.  <a href="#a1cc4a744d5c9f2fd9c0e2a0d176861c4">More...</a><br /></td></tr>
<tr class="separator:a1cc4a744d5c9f2fd9c0e2a0d176861c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248e7393549aaba7fcb758f85d6c4e0d"><td class="memTemplParams" colspan="2">template&lt;typename Vec3GridT , typename MaskT , typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a248e7393549aaba7fcb758f85d6c4e0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarGrid.html">VectorToScalarGrid</a>&lt; Vec3GridT &gt;::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a248e7393549aaba7fcb758f85d6c4e0d">computeScalarPotential</a> (const MaskT &amp;domain, const Vec3GridT &amp;neumann, <a class="el" href="structopenvdb_1_1v8__0_1_1math_1_1pcg_1_1State.html">math::pcg::State</a> &amp;state, InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a248e7393549aaba7fcb758f85d6c4e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Potential on the domain using the Neumann boundary conditions on solid boundaries.  <a href="#a248e7393549aaba7fcb758f85d6c4e0d">More...</a><br /></td></tr>
<tr class="separator:a248e7393549aaba7fcb758f85d6c4e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec6a2371219a981e94291a793ba0685"><td class="memTemplParams" colspan="2">template&lt;typename Vec3GridT &gt; </td></tr>
<tr class="memitem:acec6a2371219a981e94291a793ba0685"><td class="memTemplItemLeft" align="right" valign="top">Vec3GridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#acec6a2371219a981e94291a793ba0685">computePotentialFlow</a> (const typename <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarGrid.html">VectorToScalarGrid</a>&lt; Vec3GridT &gt;::Type &amp;potential, const Vec3GridT &amp;neumann, const typename Vec3GridT::ValueType backgroundVelocity=<a class="el" href="namespaceopenvdb_1_1v8__0.html#afacc9da89954ca2831b932a917506991">zeroVal</a>&lt; typename Vec3GridT::TreeType::ValueType &gt;())</td></tr>
<tr class="memdesc:acec6a2371219a981e94291a793ba0685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a vector Flow Field comprising the gradient of the potential with Neumann boundary conditions applied.  <a href="#acec6a2371219a981e94291a793ba0685">More...</a><br /></td></tr>
<tr class="separator:acec6a2371219a981e94291a793ba0685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8057e1165c928a37703f90eb9496083c"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:a8057e1165c928a37703f90eb9496083c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8057e1165c928a37703f90eb9496083c">prune</a> (TreeT &amp;tree, typename TreeT::ValueType tolerance=<a class="el" href="namespaceopenvdb_1_1v8__0.html#afacc9da89954ca2831b932a917506991">zeroVal</a>&lt; typename TreeT::ValueType &gt;(), bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:a8057e1165c928a37703f90eb9496083c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of a <em>tree</em> by replacing with tiles any nodes whose values are all the same (optionally to within a tolerance) and have the same active state.  <a href="#a8057e1165c928a37703f90eb9496083c">More...</a><br /></td></tr>
<tr class="separator:a8057e1165c928a37703f90eb9496083c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ffdc3cdd984ae9e4c0742406cfdaee"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:ab8ffdc3cdd984ae9e4c0742406cfdaee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ab8ffdc3cdd984ae9e4c0742406cfdaee">pruneTiles</a> (TreeT &amp;tree, typename TreeT::ValueType tolerance=<a class="el" href="namespaceopenvdb_1_1v8__0.html#afacc9da89954ca2831b932a917506991">zeroVal</a>&lt; typename TreeT::ValueType &gt;(), bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:ab8ffdc3cdd984ae9e4c0742406cfdaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of a <em>tree</em> by replacing with tiles any non-leaf nodes whose values are all the same (optionally to within a tolerance) and have the same active state.  <a href="#ab8ffdc3cdd984ae9e4c0742406cfdaee">More...</a><br /></td></tr>
<tr class="separator:ab8ffdc3cdd984ae9e4c0742406cfdaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81e76930df0c635a4e175887352257e"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:ae81e76930df0c635a4e175887352257e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ae81e76930df0c635a4e175887352257e">pruneInactive</a> (TreeT &amp;tree, bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:ae81e76930df0c635a4e175887352257e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of a <em>tree</em> by replacing with background tiles any nodes whose values are all inactive.  <a href="#ae81e76930df0c635a4e175887352257e">More...</a><br /></td></tr>
<tr class="separator:ae81e76930df0c635a4e175887352257e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68447719ca38904491830b5c1caefa8"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:ad68447719ca38904491830b5c1caefa8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ad68447719ca38904491830b5c1caefa8">pruneInactiveWithValue</a> (TreeT &amp;tree, const typename TreeT::ValueType &amp;value, bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:ad68447719ca38904491830b5c1caefa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of a <em>tree</em> by replacing any nodes whose values are all inactive with tiles of the given <em>value</em>.  <a href="#ad68447719ca38904491830b5c1caefa8">More...</a><br /></td></tr>
<tr class="separator:ad68447719ca38904491830b5c1caefa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467d50f8a53357977d5720498a88d72c"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:a467d50f8a53357977d5720498a88d72c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a467d50f8a53357977d5720498a88d72c">pruneLevelSet</a> (TreeT &amp;tree, bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:a467d50f8a53357977d5720498a88d72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of a <em>tree</em> by replacing nodes whose values are all inactive with inactive tiles having a value equal to the first value encountered in the (inactive) child.  <a href="#a467d50f8a53357977d5720498a88d72c">More...</a><br /></td></tr>
<tr class="separator:a467d50f8a53357977d5720498a88d72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57eaa5cdb5f7180a68b88901e9421ad"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:ac57eaa5cdb5f7180a68b88901e9421ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac57eaa5cdb5f7180a68b88901e9421ad">pruneLevelSet</a> (TreeT &amp;tree, const typename TreeT::ValueType &amp;outsideWidth, const typename TreeT::ValueType &amp;insideWidth, bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:ac57eaa5cdb5f7180a68b88901e9421ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of a <em>tree</em> by replacing nodes whose voxel values are all inactive with inactive tiles having the value -| <em>insideWidth</em> | if the voxel values are negative and | <em>outsideWidth</em> | otherwise.  <a href="#ac57eaa5cdb5f7180a68b88901e9421ad">More...</a><br /></td></tr>
<tr class="separator:ac57eaa5cdb5f7180a68b88901e9421ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8642ecf09da68f9d3d16f606be7ae301"><td class="memTemplParams" colspan="2">template&lt;typename GridT &gt; </td></tr>
<tr class="memitem:a8642ecf09da68f9d3d16f606be7ae301"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8642ecf09da68f9d3d16f606be7ae301">rayTrace</a> (const GridT &amp;, const <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1BaseShader.html">BaseShader</a> &amp;, <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1BaseCamera.html">BaseCamera</a> &amp;, size_t pixelSamples=1, unsigned int seed=0, bool threaded=true)</td></tr>
<tr class="memdesc:a8642ecf09da68f9d3d16f606be7ae301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ray-trace a volume.  <a href="#a8642ecf09da68f9d3d16f606be7ae301">More...</a><br /></td></tr>
<tr class="separator:a8642ecf09da68f9d3d16f606be7ae301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02be13fa85c9edfa183b39d1255ff6c4"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename IntersectorT &gt; </td></tr>
<tr class="memitem:a02be13fa85c9edfa183b39d1255ff6c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a02be13fa85c9edfa183b39d1255ff6c4">rayTrace</a> (const GridT &amp;, const IntersectorT &amp;, const <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1BaseShader.html">BaseShader</a> &amp;, <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1BaseCamera.html">BaseCamera</a> &amp;, size_t pixelSamples=1, unsigned int seed=0, bool threaded=true)</td></tr>
<tr class="memdesc:a02be13fa85c9edfa183b39d1255ff6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ray-trace a volume using a given ray intersector.  <a href="#a02be13fa85c9edfa183b39d1255ff6c4">More...</a><br /></td></tr>
<tr class="separator:a02be13fa85c9edfa183b39d1255ff6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c1921d688e3c65c71aac5405f155a9"><td class="memTemplParams" colspan="2">template&lt;typename TreeOrLeafManagerT &gt; </td></tr>
<tr class="memitem:ab8c1921d688e3c65c71aac5405f155a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ab8c1921d688e3c65c71aac5405f155a9">signedFloodFill</a> (TreeOrLeafManagerT &amp;tree, bool threaded=true, size_t grainSize=1, <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> minLevel=0)</td></tr>
<tr class="memdesc:ab8c1921d688e3c65c71aac5405f155a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the values of all inactive voxels and tiles of a narrow-band level set from the signs of the active voxels, setting outside values to +background and inside values to -background.  <a href="#ab8c1921d688e3c65c71aac5405f155a9">More...</a><br /></td></tr>
<tr class="separator:ab8c1921d688e3c65c71aac5405f155a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059130a68dd01092e7db04afa0f2580e"><td class="memTemplParams" colspan="2">template&lt;typename TreeOrLeafManagerT &gt; </td></tr>
<tr class="memitem:a059130a68dd01092e7db04afa0f2580e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a059130a68dd01092e7db04afa0f2580e">signedFloodFillWithValues</a> (TreeOrLeafManagerT &amp;tree, const typename TreeOrLeafManagerT::ValueType &amp;outsideWidth, const typename TreeOrLeafManagerT::ValueType &amp;insideWidth, bool threaded=true, size_t grainSize=1, <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> minLevel=0)</td></tr>
<tr class="memdesc:a059130a68dd01092e7db04afa0f2580e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the values of all inactive voxels and tiles of a narrow-band level set from the signs of the active voxels, setting exterior values to <em>outsideWidth</em> and interior values to <em>insideWidth</em>. Set the background value of this tree to <em>outsideWidth</em>.  <a href="#a059130a68dd01092e7db04afa0f2580e">More...</a><br /></td></tr>
<tr class="separator:a059130a68dd01092e7db04afa0f2580e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705b035d27c69d566009424697c36a65"><td class="memTemplParams" colspan="2">template&lt;typename IterT &gt; </td></tr>
<tr class="memitem:a705b035d27c69d566009424697c36a65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Histogram.html">math::Histogram</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a705b035d27c69d566009424697c36a65">histogram</a> (const IterT &amp;iter, double minVal, double maxVal, size_t numBins=10, bool threaded=true)</td></tr>
<tr class="memdesc:a705b035d27c69d566009424697c36a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a scalar grid and compute a histogram of the values of the voxels that are visited, or iterate over a vector-valued grid and compute a histogram of the magnitudes of the vectors.  <a href="#a705b035d27c69d566009424697c36a65">More...</a><br /></td></tr>
<tr class="separator:a705b035d27c69d566009424697c36a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6aea86a2df380225a3b3c8553efe4e3"><td class="memTemplParams" colspan="2">template&lt;typename IterT &gt; </td></tr>
<tr class="memitem:ac6aea86a2df380225a3b3c8553efe4e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Extrema.html">math::Extrema</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac6aea86a2df380225a3b3c8553efe4e3">extrema</a> (const IterT &amp;iter, bool threaded=true)</td></tr>
<tr class="memdesc:ac6aea86a2df380225a3b3c8553efe4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a scalar grid and compute extrema (min/max) of the values of the voxels that are visited, or iterate over a vector-valued grid and compute extrema of the magnitudes of the vectors.  <a href="#ac6aea86a2df380225a3b3c8553efe4e3">More...</a><br /></td></tr>
<tr class="separator:ac6aea86a2df380225a3b3c8553efe4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0298e9e5b5b3a443d321bd24825f1d5a"><td class="memTemplParams" colspan="2">template&lt;typename IterT &gt; </td></tr>
<tr class="memitem:a0298e9e5b5b3a443d321bd24825f1d5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Stats.html">math::Stats</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a0298e9e5b5b3a443d321bd24825f1d5a">statistics</a> (const IterT &amp;iter, bool threaded=true)</td></tr>
<tr class="memdesc:a0298e9e5b5b3a443d321bd24825f1d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a scalar grid and compute statistics (mean, variance, etc.) of the values of the voxels that are visited, or iterate over a vector-valued grid and compute statistics of the magnitudes of the vectors.  <a href="#a0298e9e5b5b3a443d321bd24825f1d5a">More...</a><br /></td></tr>
<tr class="separator:a0298e9e5b5b3a443d321bd24825f1d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcd95f6d9da81e339aab75465ee4e22"><td class="memTemplParams" colspan="2">template&lt;typename IterT , typename ValueOp &gt; </td></tr>
<tr class="memitem:aafcd95f6d9da81e339aab75465ee4e22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Extrema.html">math::Extrema</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aafcd95f6d9da81e339aab75465ee4e22">extrema</a> (const IterT &amp;iter, const ValueOp &amp;op, bool threaded)</td></tr>
<tr class="memdesc:aafcd95f6d9da81e339aab75465ee4e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a grid and compute extrema (min/max) of the values produced by applying the given functor at each voxel that is visited.  <a href="#aafcd95f6d9da81e339aab75465ee4e22">More...</a><br /></td></tr>
<tr class="separator:aafcd95f6d9da81e339aab75465ee4e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada341f0cb3d7e02cb30f563ae58d77b8"><td class="memTemplParams" colspan="2">template&lt;typename IterT , typename ValueOp &gt; </td></tr>
<tr class="memitem:ada341f0cb3d7e02cb30f563ae58d77b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Stats.html">math::Stats</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ada341f0cb3d7e02cb30f563ae58d77b8">statistics</a> (const IterT &amp;iter, const ValueOp &amp;op, bool threaded)</td></tr>
<tr class="memdesc:ada341f0cb3d7e02cb30f563ae58d77b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a grid and compute statistics (mean, variance, etc.) of the values produced by applying the given functor at each voxel that is visited.  <a href="#ada341f0cb3d7e02cb30f563ae58d77b8">More...</a><br /></td></tr>
<tr class="separator:ada341f0cb3d7e02cb30f563ae58d77b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35876c2d474f3ed28fc6a6aa4b4f5678"><td class="memTemplParams" colspan="2">template&lt;typename OperatorT , typename IterT &gt; </td></tr>
<tr class="memitem:a35876c2d474f3ed28fc6a6aa4b4f5678"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Stats.html">math::Stats</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a35876c2d474f3ed28fc6a6aa4b4f5678">opStatistics</a> (const IterT &amp;iter, const OperatorT &amp;op=OperatorT(), bool threaded=true)</td></tr>
<tr class="memdesc:a35876c2d474f3ed28fc6a6aa4b4f5678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a grid and compute statistics (mean, variance, etc.) of the values produced by applying a given operator (see <a class="el" href="Operators_8h.html">math/Operators.h</a>) at each voxel that is visited.  <a href="#a35876c2d474f3ed28fc6a6aa4b4f5678">More...</a><br /></td></tr>
<tr class="separator:a35876c2d474f3ed28fc6a6aa4b4f5678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a308e2e6c2d283bfafb3bd80c8ca43"><td class="memTemplParams" colspan="2">template&lt;typename OperatorT , typename IterT &gt; </td></tr>
<tr class="memitem:ab4a308e2e6c2d283bfafb3bd80c8ca43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Extrema.html">math::Extrema</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ab4a308e2e6c2d283bfafb3bd80c8ca43">opExtrema</a> (const IterT &amp;iter, const OperatorT &amp;op=OperatorT(), bool threaded=true)</td></tr>
<tr class="memdesc:ab4a308e2e6c2d283bfafb3bd80c8ca43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as opStatistics except it returns a <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Extrema.html" title="This class computes the minimum and maximum values of a population of floating-point values...">math::Extrema</a> vs a <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Stats.html" title="This class computes statistics (minimum value, maximum value, mean, variance and standard deviation) ...">math::Stats</a>.  <a href="#ab4a308e2e6c2d283bfafb3bd80c8ca43">More...</a><br /></td></tr>
<tr class="separator:ab4a308e2e6c2d283bfafb3bd80c8ca43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbae85c9cdcbfc824ca7222995f16ca"><td class="memTemplParams" colspan="2">template&lt;typename GridT &gt; </td></tr>
<tr class="memitem:aabbae85c9cdcbfc824ca7222995f16ca"><td class="memTemplItemLeft" align="right" valign="top">GridT::template ValueConverter&lt; float &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aabbae85c9cdcbfc824ca7222995f16ca">topologyToLevelSet</a> (const GridT &amp;grid, int halfWidth=3, int closingSteps=1, int dilation=0, int smoothingSteps=0)</td></tr>
<tr class="memdesc:aabbae85c9cdcbfc824ca7222995f16ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the narrow-band signed distance to the interface between active and inactive voxels in the input grid.  <a href="#aabbae85c9cdcbfc824ca7222995f16ca">More...</a><br /></td></tr>
<tr class="separator:aabbae85c9cdcbfc824ca7222995f16ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e2f42e7a8c6243963b70dece2f8113"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename InterrupterT &gt; </td></tr>
<tr class="memitem:a07e2f42e7a8c6243963b70dece2f8113"><td class="memTemplItemLeft" align="right" valign="top">GridT::template ValueConverter&lt; float &gt;::Type::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a07e2f42e7a8c6243963b70dece2f8113">topologyToLevelSet</a> (const GridT &amp;grid, int halfWidth=3, int closingSteps=1, int dilation=0, int smoothingSteps=0, InterrupterT *interrupt=nullptr)</td></tr>
<tr class="memdesc:a07e2f42e7a8c6243963b70dece2f8113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the narrow-band signed distance to the interface between active and inactive voxels in the input grid.  <a href="#a07e2f42e7a8c6243963b70dece2f8113">More...</a><br /></td></tr>
<tr class="separator:a07e2f42e7a8c6243963b70dece2f8113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1c7e219f36d148510ce22d7599171b"><td class="memTemplParams" colspan="2">template&lt;typename IterT , typename XformOp &gt; </td></tr>
<tr class="memitem:ada1c7e219f36d148510ce22d7599171b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ada1c7e219f36d148510ce22d7599171b">foreach</a> (const IterT &amp;iter, XformOp &amp;op, bool threaded=true, bool shareOp=true)</td></tr>
<tr class="separator:ada1c7e219f36d148510ce22d7599171b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1dd9695ed106fdc71856355b0bfc1b6"><td class="memTemplParams" colspan="2">template&lt;typename IterT , typename XformOp &gt; </td></tr>
<tr class="memitem:aa1dd9695ed106fdc71856355b0bfc1b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aa1dd9695ed106fdc71856355b0bfc1b6">foreach</a> (const IterT &amp;iter, const XformOp &amp;op, bool threaded=true, bool shareOp=true)</td></tr>
<tr class="separator:aa1dd9695ed106fdc71856355b0bfc1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae870e81ce652b9c057d92dbe4b4b9811"><td class="memTemplParams" colspan="2">template&lt;typename InIterT , typename OutGridT , typename XformOp &gt; </td></tr>
<tr class="memitem:ae870e81ce652b9c057d92dbe4b4b9811"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ae870e81ce652b9c057d92dbe4b4b9811">transformValues</a> (const InIterT &amp;inIter, OutGridT &amp;outGrid, XformOp &amp;op, bool threaded=true, bool shareOp=true, <a class="el" href="namespaceopenvdb_1_1v8__0.html#ade9c95ac55c647839e6f3e9b462c0575">MergePolicy</a> merge=<a class="el" href="namespaceopenvdb_1_1v8__0.html#ade9c95ac55c647839e6f3e9b462c0575a89c44945b26534bc1d5ede51c342400e">MERGE_ACTIVE_STATES</a>)</td></tr>
<tr class="separator:ae870e81ce652b9c057d92dbe4b4b9811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a43dc2e67d32098ee0f0b77e6b4aca"><td class="memTemplParams" colspan="2">template&lt;typename InIterT , typename OutGridT , typename XformOp &gt; </td></tr>
<tr class="memitem:a21a43dc2e67d32098ee0f0b77e6b4aca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a21a43dc2e67d32098ee0f0b77e6b4aca">transformValues</a> (const InIterT &amp;inIter, OutGridT &amp;outGrid, const XformOp &amp;op, bool threaded=true, bool shareOp=true, <a class="el" href="namespaceopenvdb_1_1v8__0.html#ade9c95ac55c647839e6f3e9b462c0575">MergePolicy</a> merge=<a class="el" href="namespaceopenvdb_1_1v8__0.html#ade9c95ac55c647839e6f3e9b462c0575a89c44945b26534bc1d5ede51c342400e">MERGE_ACTIVE_STATES</a>)</td></tr>
<tr class="separator:a21a43dc2e67d32098ee0f0b77e6b4aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e31fdabdae973490731a7be4f31d9ad"><td class="memTemplParams" colspan="2">template&lt;typename IterT , typename XformOp &gt; </td></tr>
<tr class="memitem:a8e31fdabdae973490731a7be4f31d9ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8e31fdabdae973490731a7be4f31d9ad">accumulate</a> (const IterT &amp;iter, XformOp &amp;op, bool threaded=true)</td></tr>
<tr class="separator:a8e31fdabdae973490731a7be4f31d9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdcf782cb40fcb514524737e2f8e070"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:adbdcf782cb40fcb514524737e2f8e070"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#adbdcf782cb40fcb514524737e2f8e070">setValueOnMin</a> (TreeT &amp;tree, const Coord &amp;xyz, const typename TreeT::ValueType &amp;value)</td></tr>
<tr class="memdesc:adbdcf782cb40fcb514524737e2f8e070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates in <em>tree</em> to the minimum of its current value and <em>value</em>, and mark the voxel as active.  <a href="#adbdcf782cb40fcb514524737e2f8e070">More...</a><br /></td></tr>
<tr class="separator:adbdcf782cb40fcb514524737e2f8e070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c76dc587d3f1735c0113f04ace2f257"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:a7c76dc587d3f1735c0113f04ace2f257"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a7c76dc587d3f1735c0113f04ace2f257">setValueOnMax</a> (TreeT &amp;tree, const Coord &amp;xyz, const typename TreeT::ValueType &amp;value)</td></tr>
<tr class="memdesc:a7c76dc587d3f1735c0113f04ace2f257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates in <em>tree</em> to the maximum of its current value and <em>value</em>, and mark the voxel as active.  <a href="#a7c76dc587d3f1735c0113f04ace2f257">More...</a><br /></td></tr>
<tr class="separator:a7c76dc587d3f1735c0113f04ace2f257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d1e43e1896e1a7fa9548c4fd4a2988"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:a92d1e43e1896e1a7fa9548c4fd4a2988"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a92d1e43e1896e1a7fa9548c4fd4a2988">setValueOnSum</a> (TreeT &amp;tree, const Coord &amp;xyz, const typename TreeT::ValueType &amp;value)</td></tr>
<tr class="memdesc:a92d1e43e1896e1a7fa9548c4fd4a2988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates in <em>tree</em> to the sum of its current value and <em>value</em>, and mark the voxel as active.  <a href="#a92d1e43e1896e1a7fa9548c4fd4a2988">More...</a><br /></td></tr>
<tr class="separator:a92d1e43e1896e1a7fa9548c4fd4a2988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa019501d9dddd1891421935c31efba"><td class="memTemplParams" colspan="2">template&lt;typename TreeT &gt; </td></tr>
<tr class="memitem:a2fa019501d9dddd1891421935c31efba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2fa019501d9dddd1891421935c31efba">setValueOnMult</a> (TreeT &amp;tree, const Coord &amp;xyz, const typename TreeT::ValueType &amp;value)</td></tr>
<tr class="memdesc:a2fa019501d9dddd1891421935c31efba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates in <em>tree</em> to the product of its current value and <em>value</em>, and mark the voxel as active.  <a href="#a2fa019501d9dddd1891421935c31efba">More...</a><br /></td></tr>
<tr class="separator:a2fa019501d9dddd1891421935c31efba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642190ccc3febe94d8b07ac37f892349"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a642190ccc3febe94d8b07ac37f892349"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a642190ccc3febe94d8b07ac37f892349">transformVectors</a> (GridType &amp;, const Mat4d &amp;)</td></tr>
<tr class="memdesc:a642190ccc3febe94d8b07ac37f892349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an affine transform to the voxel values of a vector-valued grid in accordance with the grid's vector type (covariant, contravariant, etc.).  <a href="#a642190ccc3febe94d8b07ac37f892349">More...</a><br /></td></tr>
<tr class="separator:a642190ccc3febe94d8b07ac37f892349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2641c8c08ca3ed3bf4cea4d9b52434b5"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a2641c8c08ca3ed3bf4cea4d9b52434b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2641c8c08ca3ed3bf4cea4d9b52434b5">volumeToMesh</a> (const GridType &amp;grid, std::vector&lt; Vec3s &gt; &amp;points, std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, double isovalue=0.0)</td></tr>
<tr class="memdesc:a2641c8c08ca3ed3bf4cea4d9b52434b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniformly mesh any scalar grid that has a continuous isosurface.  <a href="#a2641c8c08ca3ed3bf4cea4d9b52434b5">More...</a><br /></td></tr>
<tr class="separator:a2641c8c08ca3ed3bf4cea4d9b52434b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576ce1469c40253573f9c3ad65369806"><td class="memTemplParams" colspan="2">template&lt;typename GridType &gt; </td></tr>
<tr class="memitem:a576ce1469c40253573f9c3ad65369806"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a576ce1469c40253573f9c3ad65369806">volumeToMesh</a> (const GridType &amp;grid, std::vector&lt; Vec3s &gt; &amp;points, std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, double isovalue=0.0, double adaptivity=0.0, bool relaxDisorientedTriangles=true)</td></tr>
<tr class="memdesc:a576ce1469c40253573f9c3ad65369806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptively mesh any scalar grid that has a continuous isosurface.  <a href="#a576ce1469c40253573f9c3ad65369806">More...</a><br /></td></tr>
<tr class="separator:a576ce1469c40253573f9c3ad65369806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47969b0a41353bc67f7e3af1be7ce0e"><td class="memItemLeft" align="right" valign="top">Vec3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac47969b0a41353bc67f7e3af1be7ce0e">findFeaturePoint</a> (const std::vector&lt; Vec3d &gt; &amp;points, const std::vector&lt; Vec3d &gt; &amp;normals)</td></tr>
<tr class="memdesc:ac47969b0a41353bc67f7e3af1be7ce0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of tangent elements, <code>points</code> with corresponding <code>normals</code>, this method returns the intersection point of all tangent elements.  <a href="#ac47969b0a41353bc67f7e3af1be7ce0e">More...</a><br /></td></tr>
<tr class="separator:ac47969b0a41353bc67f7e3af1be7ce0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f0e9f42ab322b7dd0f54dfb5b28556"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:af3f0e9f42ab322b7dd0f54dfb5b28556"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#af3f0e9f42ab322b7dd0f54dfb5b28556">fillWithSpheres</a> (const GridT &amp;grid, std::vector&lt; openvdb::Vec4s &gt; &amp;spheres, const Vec2i &amp;sphereCount=Vec2i(1, 50), bool overlapping=false, float minRadius=1.0, float maxRadius=std::numeric_limits&lt; float &gt;::max(), float isovalue=0.0, int instanceCount=10000, InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:af3f0e9f42ab322b7dd0f54dfb5b28556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a closed level set or fog volume with adaptively-sized spheres.  <a href="#af3f0e9f42ab322b7dd0f54dfb5b28556">More...</a><br /></td></tr>
<tr class="separator:af3f0e9f42ab322b7dd0f54dfb5b28556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aec7b415f8b2e1ef32d6d832e87ac2e8e"><td class="memTemplParams" colspan="2">template&lt;typename TreeType &gt; </td></tr>
<tr class="memitem:aec7b415f8b2e1ef32d6d832e87ac2e8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aec7b415f8b2e1ef32d6d832e87ac2e8e">erodeVoxels</a> (TreeType &amp;tree, int iterations=1, <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a> nn=<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a>)</td></tr>
<tr class="memdesc:aec7b415f8b2e1ef32d6d832e87ac2e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topologically erode all leaf-level active voxels in the given tree.  <a href="#aec7b415f8b2e1ef32d6d832e87ac2e8e">More...</a><br /></td></tr>
<tr class="separator:aec7b415f8b2e1ef32d6d832e87ac2e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad103855494b0317d1dbc12139a07b926"><td class="memTemplParams" colspan="2">template&lt;typename TreeType &gt; </td></tr>
<tr class="memitem:ad103855494b0317d1dbc12139a07b926"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ad103855494b0317d1dbc12139a07b926">erodeVoxels</a> (<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html">tree::LeafManager</a>&lt; TreeType &gt; &amp;manager, int iterations=1, <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a> nn=<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a>)</td></tr>
<tr class="memdesc:ad103855494b0317d1dbc12139a07b926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topologically erode all leaf-level active voxels in the given tree.  <a href="#ad103855494b0317d1dbc12139a07b926">More...</a><br /></td></tr>
<tr class="separator:ad103855494b0317d1dbc12139a07b926"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a15acb14744ad597506ab2c876df1e3c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a15acb14744ad597506ab2c876df1e3c0">CsgIntersectionOp</a> =  <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CsgUnionOrIntersectionOp.html">CsgUnionOrIntersectionOp</a>&lt;TreeT, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa2bd678647ee7c097628900599ecd911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aa2bd678647ee7c097628900599ecd911">CsgUnionOp</a> =  <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1CsgUnionOrIntersectionOp.html">CsgUnionOrIntersectionOp</a>&lt;TreeT, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae0b5eb564884170a157dd5ea34c183f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ae0b5eb564884170a157dd5ea34c183f5">ParticleIndexAtlas</a> =  <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ParticleAtlas.html">ParticleAtlas</a>&lt;<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#acfb828103bf471f9c51ea65d156e4498">PointIndexGrid</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acfb828103bf471f9c51ea65d156e4498"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#acfb828103bf471f9c51ea65d156e4498">PointIndexGrid</a> =  <a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html">Grid</a>&lt;<a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#af59b06fbf7e8c0f817695e92b0a86db1">PointIndexTree</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Point index grid. </p>

</div>
</div>
<a class="anchor" id="af59b06fbf7e8c0f817695e92b0a86db1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#af59b06fbf7e8c0f817695e92b0a86db1">PointIndexTree</a> =  <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1Tree.html">tree::Tree</a>&lt;<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1RootNode.html">tree::RootNode</a>&lt;<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1InternalNode.html">tree::InternalNode</a>&lt;<a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1InternalNode.html">tree::InternalNode</a> &lt;<a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1PointIndexLeafNode.html">PointIndexLeafNode</a>&lt;<a class="el" href="namespaceopenvdb_1_1v8__0.html#a58d2265df00dc40b96bfbdc675052994">PointIndex32</a>, 3&gt;, 4&gt;, 5&gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Point index tree configured to match the default OpenVDB tree configuration. </p>

</div>
</div>
<a class="anchor" id="a48d92c3835e9c28ed5fd3c9a416d3585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a48d92c3835e9c28ed5fd3c9a416d3585">PointList</a> =  std::unique_ptr&lt;openvdb::Vec3s[]&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Point and primitive list types. </p>

</div>
</div>
<a class="anchor" id="aa4c6e4a427196ef80116eb8fd76a62b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#aa4c6e4a427196ef80116eb8fd76a62b6">PolygonPoolList</a> =  std::unique_ptr&lt;<a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1PolygonPool.html">PolygonPool</a>[]&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Point and primitive list types. </p>

</div>
</div>
<a class="anchor" id="a52bc789f19484fd8102225765173f548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a52bc789f19484fd8102225765173f548">UInt32PointPartitioner</a> =  <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1PointPartitioner.html">PointPartitioner</a>&lt;uint32_t, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a2215bf270a4991ca057bb6efb294846b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polygon flags, used for reference based meshing. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a2215bf270a4991ca057bb6efb294846baa911a2c909b228a84da11c9e7ec8d6f4"></a>POLYFLAG_EXTERIOR&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2215bf270a4991ca057bb6efb294846ba6162751648b85f251927667c2b51ca67"></a>POLYFLAG_FRACTURE_SEAM&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2215bf270a4991ca057bb6efb294846bacbee21124fa14157f6c0c992c4728c7b"></a>POLYFLAG_SUBDIVIDED&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a4af148611e5ef140a0121ee996fb8321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a4af148611e5ef140a0121ee996fb8321">DSCompositeOp</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We currrently support the following operations when compositing sparse data into a dense grid. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a4af148611e5ef140a0121ee996fb8321a812485f135c6cee2586b34b814cddc6a"></a>DS_OVER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4af148611e5ef140a0121ee996fb8321a8d4beb09c71b751771158b53d1cf99c3"></a>DS_ADD&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4af148611e5ef140a0121ee996fb8321afa18e1086c47d6d467d2ca6e708f739b"></a>DS_SUB&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4af148611e5ef140a0121ee996fb8321a85f583b7144fce0c85930f1a01c25a72"></a>DS_MIN&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4af148611e5ef140a0121ee996fb8321abab98682392bb93a93278797f8db5d75"></a>DS_MAX&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4af148611e5ef140a0121ee996fb8321a697b1fa695bcb46b82bc1f22ff61855a"></a>DS_MULT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4af148611e5ef140a0121ee996fb8321ab5356cf273f92049213e30c3444f149b"></a>DS_SET&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a8206a04f26f57965d9cb369acafa33d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8206a04f26f57965d9cb369acafa33d7">MemoryLayout</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We currently support the following two 3D memory layouts for dense volumes: XYZ, i.e. x is the fastest moving index, and ZYX, i.e. z is the fastest moving index. The ZYX memory layout leads to nested for-loops of the order x, y, z, which we find to be the most intuitive. Hence, ZYX is the layout used throughout VDB. However, other data structures, e.g. Houdini and Maya, employ the XYZ layout. Clearly a dense volume with the ZYX layout converts more efficiently to a VDB, but we support both for convenience. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8206a04f26f57965d9cb369acafa33d7a696de54548c230cf353790fc1f73117f"></a>LayoutXYZ&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8206a04f26f57965d9cb369acafa33d7ac4b2238a60f4ee86d9ed5a72a13fe814"></a>LayoutZYX&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a2623bf4797b966b29fbe45c87e60481c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2623bf4797b966b29fbe45c87e60481c">MeshToVolumeFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mesh to volume conversion flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a2623bf4797b966b29fbe45c87e60481ca99d80e217668e63e75cbd0591f034f70"></a>UNSIGNED_DISTANCE_FIELD&#160;</td><td class="fielddoc">
<p>Switch from the default signed distance field conversion that classifies regions as either inside or outside the mesh boundary to a unsigned distance field conversion that only computes distance values. This conversion type does not require a closed watertight mesh. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2623bf4797b966b29fbe45c87e60481ca145012afd1cbb669fe4c8c94b041abc4"></a>DISABLE_INTERSECTING_VOXEL_REMOVAL&#160;</td><td class="fielddoc">
<p>Disable the cleanup step that removes voxels created by self intersecting portions of the mesh. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2623bf4797b966b29fbe45c87e60481ca414a054233ec27d0ec60800ea7e73332"></a>DISABLE_RENORMALIZATION&#160;</td><td class="fielddoc">
<p>Disable the distance renormalization step that smooths out bumps caused by self intersecting or overlapping portions of the mesh </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2623bf4797b966b29fbe45c87e60481ca4d48077f5cf6edf9cb34cf66d4d88505"></a>DISABLE_NARROW_BAND_TRIMMING&#160;</td><td class="fielddoc">
<p>Disable the cleanup step that removes active voxels that exceed the narrow band limits. (Only relevant for small limits) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a31d3cd59d1264144ae21e5250166cfc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Voxel topology of nearest neighbors. </p>
<dl>
<dt><b>NN_FACE</b> </dt>
<dd><p class="startdd">face adjacency (6 nearest neighbors, defined as all neighbor voxels connected along one of the primary axes)</p>
<p class="enddd"></p>
</dd>
<dt><b>NN_FACE_EDGE</b> </dt>
<dd><p class="startdd">face and edge adjacency (18 nearest neighbors, defined as all neighbor voxels connected along either one or two of the primary axes)</p>
<p class="enddd"></p>
</dd>
<dt><b>NN_FACE_EDGE_VERTEX</b> </dt>
<dd>face, edge and vertex adjacency (26 nearest neighbors, defined as all neighbor voxels connected along either one, two or all three of the primary axes) </dd>
</dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59"></a>NN_FACE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a31d3cd59d1264144ae21e5250166cfc2a6d84698cb77f59ae061433cbb1313bbf"></a>NN_FACE_EDGE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a31d3cd59d1264144ae21e5250166cfc2a2cbda8f22b738858b06cb668117278ee"></a>NN_FACE_EDGE_VERTEX&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ac7a17ca003c7f18f411cab4e8b4f6e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac7a17ca003c7f18f411cab4e8b4f6e74">TilePolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different policies when dilating trees with active tiles. </p>
<dl>
<dt><b>IGNORE_TILES</b> </dt>
<dd><p class="startdd">Active tiles are ignores, i.e. only active voxels are dilates.</p>
<p class="enddd"></p>
</dd>
<dt><b>EXPAND_TILES</b> </dt>
<dd><p class="startdd">Active tiles are expanded into active voxels and then dilated.</p>
<p class="enddd"></p>
</dd>
<dt><b>PRESERVE_TILES</b> </dt>
<dd>Active tiles remain unchanged but they still contribute to the dilation as if they were active voxels. </dd>
</dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac7a17ca003c7f18f411cab4e8b4f6e74ab6e5cc3f7167ba290c413016ae105d99"></a>IGNORE_TILES&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac7a17ca003c7f18f411cab4e8b4f6e74ab3c4d64060dcfe7f0949fb11f8ad789c"></a>EXPAND_TILES&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac7a17ca003c7f18f411cab4e8b4f6e74ab963e977b12771992aceaf779527c26f"></a>PRESERVE_TILES&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="afaf89ceee42ffedc364378fd9fe5da1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1MeshToVoxelEdgeData_1_1EdgeData.html">MeshToVoxelEdgeData::EdgeData</a> openvdb::v8_0::tools::Abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1MeshToVoxelEdgeData_1_1EdgeData.html">MeshToVoxelEdgeData::EdgeData</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e31fdabdae973490731a7be4f31d9ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void accumulate </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XformOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterate over a grid and at each step call <code>op(iter)</code>. If threading is enabled, call <code>op.join(otherOp)</code> to accumulate intermediate results from pairs of threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over a grid or its tree (<code><a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::NodeIter</code>, etc.) </td></tr>
    <tr><td class="paramname">op</td><td>a functor with a join method of the form <code>void join(XformOp&amp;)</code> and a call method of the form <code>void op(const IterT&amp;)</code>, where <code>IterT</code> is the type of <em>iter</em> </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, transform multiple values of the grid in parallel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <em>threaded</em> is true, each thread gets its own copy of the <em>original</em> functor. The order in which threads are joined is unspecified. </dd>
<dd>
If <em>threaded</em> is false, the join method is never called.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Compute the average of the active values of a scalar, floating-point grid using the <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Stats.html" title="This class computes statistics (minimum value, maximum value, mean, variance and standard deviation) ...">math::Stats</a> class. <div class="fragment"><div class="line"><span class="keyword">namespace </span>{</div><div class="line">    <span class="keyword">struct </span>Average {</div><div class="line">        math::Stats stats;</div><div class="line"></div><div class="line">        <span class="comment">// Accumulate voxel and tile values into this functor&#39;s Stats object.</span></div><div class="line">        <span class="keyword">inline</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v8__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">FloatGrid::ValueOnCIter</a>&amp; iter) {</div><div class="line">            <span class="keywordflow">if</span> (iter.isVoxelValue()) stats.add(*iter);</div><div class="line">            <span class="keywordflow">else</span> stats.add(*iter, iter.getVoxelCount());</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Accumulate another functor&#39;s Stats object into this functor&#39;s.</span></div><div class="line">        <span class="keyword">inline</span> <span class="keywordtype">void</span> join(Average&amp; other) { stats.add(other.stats); }</div><div class="line"></div><div class="line">        <span class="comment">// Return the cumulative result.</span></div><div class="line">        <span class="keyword">inline</span> <span class="keywordtype">double</span> average()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> stats.mean(); }</div><div class="line">    };</div><div class="line">}</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> grid = ...;</div><div class="line">    Average op;</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8e31fdabdae973490731a7be4f31d9ad">tools::accumulate</a>(grid.cbeginValueOn(), op);</div><div class="line">    <span class="keywordtype">double</span> average = op.average();</div><div class="line">}</div></div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>For more complex operations that require finer control over threading, consider using <code>tbb::parallel_for()</code> or <code>tbb::parallel_reduce()</code> in conjunction with a <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1IteratorRange.html">tree::IteratorRange</a> that wraps a grid or tree iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fa99ba23890494cdfe09a6d6abdd380"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void activate </td>
          <td>(</td>
          <td class="paramtype">GridOrTree &amp;&#160;</td>
          <td class="paramname"><em>gridOrTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridOrTree::ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridOrTree::ValueType &amp;&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#afacc9da89954ca2831b932a917506991">zeroVal</a>&lt;typename&#160;GridOrTree::ValueType&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark as active any inactive tiles or voxels in the given grid or tree whose values are equal to <em>value</em> (optionally to within the given <em>tolerance</em>). </p>

</div>
</div>
<a class="anchor" id="a5662e54e5608edc934c09c8bac2ec3ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1TileData.html">TileData</a>&lt; typename TreeT::ValueType &gt; &gt; activeTiles </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector with bounding boxes that represents all the intersections between active tiles in the tree and the specified bounding box. </p>
<dl class="section warning"><dt>Warning</dt><dd>For repeated calls to this method consider instead creating an instance of <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1FindActiveValues.html" title="Finds the active values in a tree which intersects a bounding box. ">FindActiveValues</a> and then repeatedly call count(). This assumes the tree to be constant between calls but is slightly faster.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>const tree to be tested for active tiles. </td></tr>
    <tr><td class="paramname">bbox</td><td>index bounding box which is intersected against the active tiles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b0a2e1f38b296a8dd5f1494efb51bed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool anyActiveTiles </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the bounding box intersects any of the active tiles in a tree, i.e. ignores active leaf values. </p>
<dl class="section warning"><dt>Warning</dt><dd>For repeated calls to this method consider instead creating an instance of <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1FindActiveValues.html" title="Finds the active values in a tree which intersects a bounding box. ">FindActiveValues</a> and then repeatedly call <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a7b0a2e1f38b296a8dd5f1494efb51bed" title="Returns true if the bounding box intersects any of the active tiles in a tree, i.e. ignores active leaf values. ">anyActiveTiles()</a>. This assumes the tree to be constant between calls but is slightly faster.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>const tree to be tested for active tiles. </td></tr>
    <tr><td class="paramname">bbox</td><td>index bounding box which is intersected against the active tiles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1562d5f6c1e6d39636666756be0234a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool anyActiveValues </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the bounding box intersects any of the active values in a tree, i.e. either active voxels or active tiles. </p>
<dl class="section warning"><dt>Warning</dt><dd>For repeated calls to this method consider instead creating an instance of <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1FindActiveValues.html" title="Finds the active values in a tree which intersects a bounding box. ">FindActiveValues</a> and then repeatedly call <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a1562d5f6c1e6d39636666756be0234a3" title="Returns true if the bounding box intersects any of the active values in a tree, i.e. either active voxels or active tiles. ">anyActiveValues()</a>. This assumes the tree to be constant between calls but is slightly faster.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>const tree to be tested for active values. </td></tr>
    <tr><td class="paramname">bbox</td><td>index bounding box which is intersected against the active values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ddfbc3ca506b15623bcffd355f2e749"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool anyActiveVoxels </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the bounding box intersects any of the active voxels in a tree, i.e. ignores active tile values. </p>
<dl class="section note"><dt>Note</dt><dd>In VDB voxels by definition reside in the leaf nodes ONLY. So this method ignores active tile values that reside higher up in the VDB tree structure.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For repeated calls to this method consider instead creating an instance of <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1FindActiveValues.html" title="Finds the active values in a tree which intersects a bounding box. ">FindActiveValues</a> and then repeatedly call <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8ddfbc3ca506b15623bcffd355f2e749" title="Returns true if the bounding box intersects any of the active voxels in a tree, i.e. ignores active tile values. ">anyActiveVoxels()</a>. This assumes the tree to be constant between calls but is slightly faster.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>const tree to be tested for active voxels. </td></tr>
    <tr><td class="paramname">bbox</td><td>index bounding box which is intersected against the active voxels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7573006df5786ba9cd6c564e4bd589ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void changeAsymmetricLevelSetBackground </td>
          <td>(</td>
          <td class="paramtype">TreeOrLeafManagerT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeOrLeafManagerT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>outsideWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeOrLeafManagerT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>insideWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainSize</em> = <code>32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the background values in all the nodes of a floating-point tree containing a possibly asymmetric narrow-band level set. </p>
<p>All inactive values will be set to +| <em>outsideWidth</em> | if outside and -| <em>insideWidth</em> | if inside, where <em>outsideWidth</em> is the outside width of the narrow band and <em>insideWidth</em> is its inside width.</p>
<dl class="section note"><dt>Note</dt><dd>This method is faster than changeBackground since it does not perform tests to see if inactive values are equal to the old background value. </dd>
<dd>
If a LeafManager is used the cached leaf nodes are reused, resulting in slightly better overall performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree (or LeafManager) that will have its background value changed </td></tr>
    <tr><td class="paramname">outsideWidth</td><td>The width of the outside of the narrow band </td></tr>
    <tr><td class="paramname">insideWidth</td><td>The width of the inside of the narrow band </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1ValueError.html">ValueError</a></td><td>if <em>outsideWidth</em> is negative or <em>insideWidth</em> is not negative (as defined by <a class="el" href="namespaceopenvdb_1_1v8__0_1_1math.html#a9226689ce35d680be36e27bc90670d93" title="Return true if x is less than zero. ">math::isNegative</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad795f2f3910144753a5e03d12f4703de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void changeBackground </td>
          <td>(</td>
          <td class="paramtype">TreeOrLeafManagerT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeOrLeafManagerT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>background</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainSize</em> = <code>32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the background value in all the nodes of a tree. </p>
<p>The sign of the background value is preserved, and only inactive values equal to the old background value are replaced.</p>
<dl class="section note"><dt>Note</dt><dd>If a LeafManager is used the cached leaf nodes are reused, resulting in slightly better overall performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree (or LeafManager) that will have its background value changed </td></tr>
    <tr><td class="paramname">background</td><td>the new background value </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 32) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9b9e9c02f534160f2571613f2d67ef5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void changeLevelSetBackground </td>
          <td>(</td>
          <td class="paramtype">TreeOrLeafManagerT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeOrLeafManagerT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>halfWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainSize</em> = <code>32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the background value in all the nodes of a floating-point tree containing a symmetric narrow-band level set. </p>
<p>All inactive values will be set to +| <em>halfWidth</em> | if outside and -| <em>halfWidth</em> | if inside, where <em>halfWidth</em> is half the width of the symmetric narrow band.</p>
<dl class="section note"><dt>Note</dt><dd>This method is faster than changeBackground since it does not perform tests to see if inactive values are equal to the old background value. </dd>
<dd>
If a LeafManager is used the cached leaf nodes are reused, resulting in slightly better overall performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree (or LeafManager) that will have its background value changed </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half of the width of the symmetric narrow band </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1ValueError.html">ValueError</a></td><td>if <em>halfWidth</em> is negative (as defined by <a class="el" href="namespaceopenvdb_1_1v8__0_1_1math.html#a9226689ce35d680be36e27bc90670d93" title="Return true if x is less than zero. ">math::isNegative</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab03bd92afef729f144e63f37f417c96d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string checkFogVolume </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number</em> = <code>6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform checks on a grid to see if it is a valid fog volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td><a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a> to be checked </td></tr>
    <tr><td class="paramname">number</td><td>Number of the checks to be performed (see below) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string with a message indicating the nature of the issue. If no issue is detected the return string is empty.</dd></dl>
<p><em>number</em> refers to the following ordered list of checks - always starting from the top. Fast checks 1: value type is floating point 2: has FOG volume class type 3: background value is zero</p>
<p>Slower checks 4: all the values are finite, i.e not NaN or infinite 5: inactive values are zero 6: active values are in the range [0,1] </p>

</div>
</div>
<a class="anchor" id="ae07091e4e6f1cfb869111d233da6d9b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string checkLevelSet </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number</em> = <code>9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform checks on a grid to see if it is a valid symmetric, narrow-band level set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td><a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a> to be checked </td></tr>
    <tr><td class="paramname">number</td><td>Number of the checks to be performed (see below) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string with a message indicating the nature of the issue. If no issue is detected the return string is empty.</dd></dl>
<p><em>number</em> refers to the following ordered list of checks - always starting from the top. Fast checks 1: value type is floating point 2: has level set class type 3: has uniform scale 4: background value is positive and n*dx</p>
<p>Slower checks 5: no active tiles 6: all the values are finite, i.e not NaN or infinite 7: active values in range between +-background 8: abs of inactive values = background, i.e. assuming a symmetric narrow band!</p>
<p>Relatively slow check (however multithreaded) 9: norm gradient is close to one, i.e. satisfied the Eikonal equation. </p>

</div>
</div>
<a class="anchor" id="a9a2667c6fe1ab087fded41b3b3f1fa4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr clip </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#aa7e17f708810f66dc1d195abaf1e9dbf">BBoxd</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepInterior</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clip the given grid against a world-space bounding box and return a new grid containing the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the grid to be clipped </td></tr>
    <tr><td class="paramname">bbox</td><td>a world-space bounding box </td></tr>
    <tr><td class="paramname">keepInterior</td><td>if true, discard voxels that lie outside the bounding box; if false, discard voxels that lie inside the bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Clipping a level set will likely produce a grid that is no longer a valid level set. </dd></dl>

</div>
</div>
<a class="anchor" id="a92b28ca7a4cb9e950e833fac3988a28b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr clip </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1NonlinearFrustumMap.html">math::NonlinearFrustumMap</a> &amp;&#160;</td>
          <td class="paramname"><em>frustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepInterior</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clip the given grid against a frustum and return a new grid containing the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the grid to be clipped </td></tr>
    <tr><td class="paramname">frustum</td><td>a frustum map </td></tr>
    <tr><td class="paramname">keepInterior</td><td>if true, discard voxels that lie outside the frustum; if false, discard voxels that lie inside the frustum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Clipping a level set will likely produce a grid that is no longer a valid level set. </dd></dl>

</div>
</div>
<a class="anchor" id="a97505ce1787d419b22343fe78600db06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::clip </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html">Grid</a>&lt; MaskTreeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepInterior</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clip a grid against the active voxels of another grid and return a new grid containing the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the grid to be clipped </td></tr>
    <tr><td class="paramname">mask</td><td>a grid whose active voxels form a boolean clipping mask </td></tr>
    <tr><td class="paramname">keepInterior</td><td>if true, discard voxels that do not intersect the mask; if false, discard voxels that intersect the mask</td></tr>
  </table>
  </dd>
</dl>
<p>The mask grid need not have the same transform as the source grid. Also, if the mask grid is a level set, consider using <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a59b83096927350f3324cba935be37717" title="Threaded method to construct a boolean mask that represents interior regions in a signed distance fie...">tools::sdfInteriorMask</a> to construct a new mask comprising the interior (rather than the narrow band) of the level set. </p><dl class="section warning"><dt>Warning</dt><dd>Clipping a level set will likely produce a grid that is no longer a valid level set. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e2b7fa45d550d8a5349495d0d37090f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v8_0::tools::compActiveLeafVoxels </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;&#160;</td>
          <td class="paramname"><em>srcTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeT &amp;&#160;</td>
          <td class="paramname"><em>dstTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OpT&#160;</td>
          <td class="paramname"><em>op</em> = <code>composite::CopyOp&lt;TreeT&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composite the active values in leaf nodes, i.e. active voxels, of a source tree into a destination tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcTree</td><td>source tree from which active voxels are composited.</td></tr>
    <tr><td class="paramname">dstTree</td><td>destination tree into which active voxels are composited.</td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <code>void op(T&amp; dst, const T&amp; src)</code>, where <code>T</code> is the <code>ValueType</code> of the tree, that composites a source value into a destination value. By default it copies the value from src to dst.</td></tr>
  </table>
  </dd>
</dl>
<p>All active voxels in the source tree will be active in the destination tree, and their value is determined by a use-defined functor (OpT op) that operates on the source and destination values. The only exception is when the tree type is MaskTree, in which case no functor is needed since by defintion a MaskTree has no values (only topology).</p>
<dl class="section warning"><dt>Warning</dt><dd>This function only operated on leaf node values, i.e. tile values are ignored. </dd></dl>

</div>
</div>
<a class="anchor" id="a001d3e901a369bb50ed1b4e78e57b303"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compDiv </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given grids A and B, compute a / b per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty. </p>

</div>
</div>
<a class="anchor" id="ab89a5ef4e61074f401e72aef834afda1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compMax </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given grids A and B, compute max(a, b) per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty. </p>

</div>
</div>
<a class="anchor" id="ad0f06ce463a63898a09fea378ac6912e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compMin </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given grids A and B, compute min(a, b) per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty. </p>

</div>
</div>
<a class="anchor" id="abdd7d6918702cd795e831789812c9ac1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compMul </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given grids A and B, compute a * b per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty. </p>

</div>
</div>
<a class="anchor" id="ac53b377981f3baf29cef347335e3588b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compositeToDense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Dense.html">Dense</a>&lt; typename TreeT::ValueType, <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8206a04f26f57965d9cb369acafa33d7ac4b2238a60f4ee86d9ed5a72a13fe814">LayoutZYX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TreeT &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TreeT &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType&#160;</td>
          <td class="paramname"><em>strength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composite data from a sparse tree into a dense array of the same value type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dense</td><td><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Dense.html" title="Dense is a simple dense grid API used by the CopyToDense and CopyFromDense classes defined below...">Dense</a> grid to be altered by the operation </td></tr>
    <tr><td class="paramname">source</td><td>Sparse data to composite into <code>dense</code> </td></tr>
    <tr><td class="paramname">alpha</td><td>Sparse Alpha mask used in compositing operations. </td></tr>
    <tr><td class="paramname">beta</td><td>Constant multiplier on src </td></tr>
    <tr><td class="paramname">strength</td><td>Constant multiplier on alpha </td></tr>
    <tr><td class="paramname">threaded</td><td>Enable threading for this operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a7784bcd2c95e7b015e6fc2c3c9d5d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compReplace </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the active voxels of B into A. </p>

</div>
</div>
<a class="anchor" id="ab3e57293906eddd0c42c4df3e64cc800"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compSum </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given grids A and B, compute a + b per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty. </p>

</div>
</div>
<a class="anchor" id="acec6a2371219a981e94291a793ba0685"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vec3GridT::Ptr computePotentialFlow </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarGrid.html">VectorToScalarGrid</a>&lt; Vec3GridT &gt;::Type &amp;&#160;</td>
          <td class="paramname"><em>potential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec3GridT &amp;&#160;</td>
          <td class="paramname"><em>neumann</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Vec3GridT::ValueType&#160;</td>
          <td class="paramname"><em>backgroundVelocity</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#afacc9da89954ca2831b932a917506991">zeroVal</a>&lt;typename&#160;Vec3GridT::TreeType::ValueType&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a vector Flow Field comprising the gradient of the potential with Neumann boundary conditions applied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">potential</td><td>scalar potential, typically computed from <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a248e7393549aaba7fcb758f85d6c4e0d" title="Compute the Potential on the domain using the Neumann boundary conditions on solid boundaries...">computeScalarPotential()</a> </td></tr>
    <tr><td class="paramname">neumann</td><td>the topology of this grid defines where the solid boundaries are and grid values give the Neumann boundaries that should be applied there </td></tr>
    <tr><td class="paramname">backgroundVelocity</td><td>a background velocity value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a248e7393549aaba7fcb758f85d6c4e0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarGrid.html">VectorToScalarGrid</a>&lt; Vec3GridT &gt;::Ptr computeScalarPotential </td>
          <td>(</td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec3GridT &amp;&#160;</td>
          <td class="paramname"><em>neumann</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v8__0_1_1math_1_1pcg_1_1State.html">math::pcg::State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Potential on the domain using the Neumann boundary conditions on solid boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>a mask to represent the domain in which to perform the solve </td></tr>
    <tr><td class="paramname">neumann</td><td>the topology of this grid defines where the solid boundaries are and grid values give the Neumann boundaries that should be applied there </td></tr>
    <tr><td class="paramname">state</td><td>the solver parameters for computing the solution </td></tr>
    <tr><td class="paramname">interrupter</td><td>pointer to an optional interrupter adhering to the <a class="el" href="structopenvdb_1_1v8__0_1_1util_1_1NullInterrupter.html" title="Dummy NOOP interrupter class defining interface. ">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<p>On input, the State object should specify convergence criteria (minimum error and maximum number of iterations); on output, it gives the actual termination conditions. </p>

</div>
</div>
<a class="anchor" id="a718fc3e33310680728f4fbf04db240c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copyFromDense </td>
          <td>(</td>
          <td class="paramtype">const DenseT &amp;&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>sparse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridOrTreeT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate a sparse grid with the values of all of the voxels of a dense grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dense</td><td>the dense grid from which to copy values </td></tr>
    <tr><td class="paramname">sparse</td><td>an OpenVDB grid or tree into which to copy values </td></tr>
    <tr><td class="paramname">tolerance</td><td>values in the dense grid that are within this tolerance of the sparse grid's background value become inactive background voxels or tiles in the sparse grid </td></tr>
    <tr><td class="paramname">serial</td><td>if false, process voxels in parallel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbd41a08ed8ea7c1a7d33146b8d17ce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copyToDense </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>sparse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseT &amp;&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate a dense grid with the values of voxels from a sparse grid, where the sparse grid intersects the dense grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sparse</td><td>an OpenVDB grid or tree from which to copy values </td></tr>
    <tr><td class="paramname">dense</td><td>the dense grid into which to copy values </td></tr>
    <tr><td class="paramname">serial</td><td>if false, process voxels in parallel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d05f8d7abe330825f886373991c52e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> countActiveValues </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of active values that intersects a bounding box intersects, i.e. the count includes both active voxels and virtual voxels in active tiles. </p>
<dl class="section warning"><dt>Warning</dt><dd>For repeated calls to this method consider instead creating an instance of <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1FindActiveValues.html" title="Finds the active values in a tree which intersects a bounding box. ">FindActiveValues</a> and then repeatedly call count(). This assumes the tree to be constant between calls but is slightly faster.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>const tree to be tested for active values. </td></tr>
    <tr><td class="paramname">bbox</td><td>index bounding box which is intersected against the active values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea23457a3376d6fb611bd3f46fdffd61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr cpt </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Closest-Point Transform (CPT) from a distance field. </p>
<dl class="section return"><dt>Returns</dt><dd>a new vector-valued grid with the same numerical precision as the input grid (for example, if the input grid is a DoubleGrid, the output grid will be a Vec3DGrid)</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a class="anchor" id="a0a4a7dc00308e20a77a2dfd6cb598fb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr cpt </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acc7dc67879556a352c2236a0ea414af2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt;GridType&gt;::Type::Ptr openvdb::v8_0::tools::cpt </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aae66f8ee5791c6d49fffc3bf7e3b5bbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt;GridType&gt;::Type::Ptr openvdb::v8_0::tools::cpt </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a314c42b9d506bd60c1acdd6f41aac7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1BBox.html">math::BBox</a>&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ae93f92d10730a52ed3b207d5811f6a6e">VecType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename VecType::ValueType&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>a bounding box in world units </td></tr>
    <tr><td class="paramname">xform</td><td>world-to-index-space transform </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4647d0e8bc878c1795a0510d7222a0b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::createLevelSetCube </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelSize</em> = <code>0.1f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a cube. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">interrupt</td><td>a pointer adhering to the <a class="el" href="structopenvdb_1_1v8__0_1_1util_1_1NullInterrupter.html" title="Dummy NOOP interrupter class defining interface. ">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a class="anchor" id="af61101c3365a960b7ebb627f46bdbe43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::createLevelSetCube </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelSize</em> = <code>0.1f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a cube. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a class="anchor" id="a327bb0281010fd9a5cb2bee6e1e85ddd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::createLevelSetDodecahedron </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelSize</em> = <code>0.1f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a dodecahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">interrupt</td><td>a pointer adhering to the <a class="el" href="structopenvdb_1_1v8__0_1_1util_1_1NullInterrupter.html" title="Dummy NOOP interrupter class defining interface. ">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a class="anchor" id="a653823e30ee298adfb1bd07bdb1d57d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::createLevelSetDodecahedron </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelSize</em> = <code>0.1f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a dodecahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a class="anchor" id="a74dc176d9b993ff0f4658dcbd37904bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::createLevelSetIcosahedron </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelSize</em> = <code>0.1f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an icosahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">interrupt</td><td>a pointer adhering to the <a class="el" href="structopenvdb_1_1v8__0_1_1util_1_1NullInterrupter.html" title="Dummy NOOP interrupter class defining interface. ">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a class="anchor" id="a584442a160cdf1a28af335046732487f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::createLevelSetIcosahedron </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelSize</em> = <code>0.1f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an icosahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d0ac6470c087f2f96b8efef46bc190c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::createLevelSetOctahedron </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelSize</em> = <code>0.1f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an octahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">interrupt</td><td>a pointer adhering to the <a class="el" href="structopenvdb_1_1v8__0_1_1util_1_1NullInterrupter.html" title="Dummy NOOP interrupter class defining interface. ">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a class="anchor" id="a6985a9cbbaddaf2f11d3adf2ed90cbd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::createLevelSetOctahedron </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelSize</em> = <code>0.1f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an octahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a class="anchor" id="a55629b59f05b1a45ea3edf5f4303b7d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetPlatonic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>faceCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelSize</em> = <code>0.1f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a platonic solid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faceCount</td><td>number of faces of the platonic solid, i.e. 4, 6, 8, 12 or 20 </td></tr>
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">interrupt</td><td>a pointer adhering to the <a class="el" href="structopenvdb_1_1v8__0_1_1util_1_1NullInterrupter.html" title="Dummy NOOP interrupter class defining interface. ">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<p>Faces: TETRAHEDRON=4, CUBE=6, OCTAHEDRON=8, DODECAHEDRON=12, ICOSAHEDRON=20</p>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a class="anchor" id="a5daf496fca49e34b4a7a47a366409641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::createLevelSetPlatonic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>faceCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelSize</em> = <code>0.1f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a platonic solid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faceCount</td><td>number of faces of the platonic solid, i.e. 4, 6, 8, 12 or 20 </td></tr>
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units</td></tr>
  </table>
  </dd>
</dl>
<p>Faces: TETRAHEDRON=4, CUBE=6, OCTAHEDRON=8, DODECAHEDRON=12, ICOSAHEDRON=20</p>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a class="anchor" id="a47e7b3c363d0d3a15b5859c4b06e9d8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetSphere </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">openvdb::Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a sphere. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>radius of the sphere in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the sphere in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">interrupt</td><td>a pointer adhering to the <a class="el" href="structopenvdb_1_1v8__0_1_1util_1_1NullInterrupter.html" title="Dummy NOOP interrupter class defining interface. ">util::NullInterrupter</a> interface </td></tr>
    <tr><td class="paramname">threaded</td><td>if true multi-threading is enabled (true by default)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd>
<dd>
The leapfrog algorithm employed in this method is best suited for a single large sphere. For multiple small spheres consider using the faster algorithm in <a class="el" href="ParticlesToLevelSet_8h.html" title="Rasterize particles with position, radius and velocity into either a boolean mask grid or a narrow-ba...">ParticlesToLevelSet.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5c20722eb866a3eaece7be49d829c8d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::createLevelSetSphere </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">openvdb::Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a sphere. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>radius of the sphere in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the sphere in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">threaded</td><td>if true multi-threading is enabled (true by default)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd>
<dd>
The leapfrog algorithm employed in this method is best suited for a single large sphere. For multiple small spheres consider using the faster algorithm in <a class="el" href="ParticlesToLevelSet_8h.html" title="Rasterize particles with position, radius and velocity into either a boolean mask grid or a narrow-ba...">ParticlesToLevelSet.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9ba062fce46a33580873b119f2725b97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::createLevelSetTetrahedron </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelSize</em> = <code>0.1f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tetrahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">interrupt</td><td>a pointer adhering to the <a class="el" href="structopenvdb_1_1v8__0_1_1util_1_1NullInterrupter.html" title="Dummy NOOP interrupter class defining interface. ">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a class="anchor" id="ad68b863f0eab591d85b4d3b0123196bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::createLevelSetTetrahedron </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voxelSize</em> = <code>0.1f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tetrahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a class="anchor" id="aec6960746cc5165cf6ac1252ad7bc5d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr createPointIndexGrid </td>
          <td>(</td>
          <td class="paramtype">const PointArrayT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>voxelSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition points into a point index grid to accelerate range and nearest-neighbor searches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>world-space point array conforming to the <a class="el" href="interfacePointArray.html" title="Partitions points into BucketLog2Dim aligned buckets using a parallel radix-based sorting algorithm...">PointArray</a> interface </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a271fec55592c87ddf1f04a02207cfb34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr createPointIndexGrid </td>
          <td>(</td>
          <td class="paramtype">const PointArrayT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">math::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition points into a point index grid to accelerate range and nearest-neighbor searches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>world-space point array conforming to the <a class="el" href="interfacePointArray.html" title="Partitions points into BucketLog2Dim aligned buckets using a parallel radix-based sorting algorithm...">PointArray</a> interface </td></tr>
    <tr><td class="paramname">xform</td><td>world-to-index-space transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a449cba1012dfb9c03702b8ce9164b346"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">MaskGrid::Ptr</a> openvdb::v8_0::tools::createPointMask </td>
          <td>(</td>
          <td class="paramtype">const PointListT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">math::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a MaskGrid where each binary voxel value is on if the voxel contains one (or more) points (i.e. the 3D position of a point is closer to this voxel than any other voxels). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>points that active the voxels in the returned grid. </td></tr>
    <tr><td class="paramname">xform</td><td>transform from world space to voxels in grid space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f99dbe0666280f607a4473ddf15d891"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MaskT::Ptr createPotentialFlowMask </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dilation</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a mask for the Potential Flow domain. </p>
<p>For a level set, this represents a rebuilt exterior narrow band. For any other grid it is a new region that surrounds the active voxels. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>source grid to use for computing the mask </td></tr>
    <tr><td class="paramname">dilation</td><td>dilation in voxels of the source grid to form the new potential flow mask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1cc4a744d5c9f2fd9c0e2a0d176861c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::template ValueConverter&lt; Vec3T &gt;::Type::Ptr createPotentialFlowNeumannVelocities </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>collider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridT::template ValueConverter&lt; Vec3T &gt;::Type::ConstPtr&#160;</td>
          <td class="paramname"><em>boundaryVelocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec3T &amp;&#160;</td>
          <td class="paramname"><em>backgroundVelocity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a Potential Flow velocities grid for the Neumann boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collider</td><td>a level set that represents the boundary </td></tr>
    <tr><td class="paramname">domain</td><td>a mask to represent the potential flow domain </td></tr>
    <tr><td class="paramname">boundaryVelocity</td><td>an optional grid pointer to stores the velocities of the boundary </td></tr>
    <tr><td class="paramname">backgroundVelocity</td><td>a background velocity value</td></tr>
  </table>
  </dd>
</dl>
<p>Typically this method involves supplying a velocity grid for the collider boundary, however it can also be used for a global wind field around the collider by supplying an empty boundary Velocity and a non-zero background velocity. </p>

</div>
</div>
<a class="anchor" id="a1e2d62ce38b1969798cdc45baf2c9df3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csgDifference </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prune</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given two level set grids, replace the A grid with the difference A / B. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1ValueError.html">ValueError</a></td><td>if the background value of either grid is not greater than zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation always leaves the B grid empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a7029f32f9814fd95e23d202c37b8da5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridOrTreeT::Ptr csgDifferenceCopy </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threaded CSG difference operation that produces a new grid or tree from immutable inputs. </p>
<dl class="section return"><dt>Returns</dt><dd>The CSG difference of the <em>and</em> <b>level</b> set inputs. </dd></dl>

</div>
</div>
<a class="anchor" id="a7de3e11a37615c24f9c5e50bdc2a06e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csgIntersection </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prune</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given two level set grids, replace the A grid with the intersection of A and B. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1ValueError.html">ValueError</a></td><td>if the background value of either grid is not greater than zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation always leaves the B grid empty. </dd></dl>

</div>
</div>
<a class="anchor" id="add41b6c432f26145649e640fa76dc25d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridOrTreeT::Ptr csgIntersectionCopy </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threaded CSG intersection operation that produces a new grid or tree from immutable inputs. </p>
<dl class="section return"><dt>Returns</dt><dd>The CSG intersection of the <em>and</em> <b>level</b> set inputs. </dd></dl>

</div>
</div>
<a class="anchor" id="a003db10da0696d7e120eff0477bc782c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void csgUnion </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prune</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given two level set grids, replace the A grid with the union of A and B. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1ValueError.html">ValueError</a></td><td>if the background value of either grid is not greater than zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation always leaves the B grid empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a99a3bda1cab85509556b73d1467a004f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridOrTreeT::Ptr csgUnionCopy </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridOrTreeT &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threaded CSG union operation that produces a new grid or tree from immutable inputs. </p>
<dl class="section return"><dt>Returns</dt><dd>The CSG union of the <em>and</em> <b>level</b> set inputs. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d7270767850c4f3241bce09b730d84a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr curl </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the curl of the given vector-valued grid. </p>
<dl class="section return"><dt>Returns</dt><dd>a new vector-valued grid</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a class="anchor" id="a8b2279de4cd703914497d7733aefbb6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr curl </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae356c0a65b83cc69595672c59c63655a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::curl </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adce39fc3fd3d9396e5de29e9a97d77d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::curl </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abc78330c21bf8fc7b0840d7ab6f0675d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deactivate </td>
          <td>(</td>
          <td class="paramtype">GridOrTree &amp;&#160;</td>
          <td class="paramname"><em>gridOrTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridOrTree::ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridOrTree::ValueType &amp;&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#afacc9da89954ca2831b932a917506991">zeroVal</a>&lt;typename&#160;GridOrTree::ValueType&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark as inactive any active tiles or voxels in the given grid or tree whose values are equal to <em>value</em> (optionally to within the given <em>tolerance</em>). </p>

</div>
</div>
<a class="anchor" id="a465a5aa8e8ee17ea4b9f68bcd481a372"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dilateActiveValues </td>
          <td>(</td>
          <td class="paramtype">TreeType &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a>&#160;</td>
          <td class="paramname"><em>nn</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac7a17ca003c7f18f411cab4e8b4f6e74">TilePolicy</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac7a17ca003c7f18f411cab4e8b4f6e74ab963e977b12771992aceaf779527c26f">PRESERVE_TILES</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Topologically dilate all active values (i.e. both voxels and tiles) in a tree using one of three nearest neighbor connectivity patterns. </p>
<dl class="section note"><dt>Note</dt><dd>This method is fully multi-threaded and support active tiles!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>tree to be dilated </td></tr>
    <tr><td class="paramname">iterations</td><td>number of iterations to apply the dilation </td></tr>
    <tr><td class="paramname">nn</td><td>connectivity pattern of the dilation: either face-adjacent (6 nearest neighbors), face- and edge-adjacent (18 nearest neighbors) or face-, edge- and vertex-adjacent (26 nearest neighbors). </td></tr>
    <tr><td class="paramname">mode</td><td>Defined the policy for handling active tiles (see above for details)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The values of any voxels are unchanged. </dd></dl>

</div>
</div>
<a class="anchor" id="afd4642829a0bcc9ee4a021cb8b96fe72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dilateActiveValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html">tree::LeafManager</a>&lt; TreeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a>&#160;</td>
          <td class="paramname"><em>nn</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac7a17ca003c7f18f411cab4e8b4f6e74">TilePolicy</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac7a17ca003c7f18f411cab4e8b4f6e74ab963e977b12771992aceaf779527c26f">PRESERVE_TILES</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Topologically dilate all active values (i.e. both voxels and tiles) in a tree using one of three nearest neighbor connectivity patterns. </p>
<dl class="section warning"><dt>Warning</dt><dd>Unlike the method above this one takes a LeafManger, however (unlike dilateVoxels method below) it offers no performance advantage over the one that takes a tree. Its merely included for API compatability. The leaf nodes in the manger are updated after the dilation, which incurres a (very small) overhead.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is fully multi-threaded and support active tiles!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>Leaf node manager for the tree to be dilated. On exit it is updated to include all the leaf nodes of the dilated tree. </td></tr>
    <tr><td class="paramname">iterations</td><td>number of iterations to apply the dilation </td></tr>
    <tr><td class="paramname">nn</td><td>connectivity pattern of the dilation: either face-adjacent (6 nearest neighbors), face- and edge-adjacent (18 nearest neighbors) or face-, edge- and vertex-adjacent (26 nearest neighbors). </td></tr>
    <tr><td class="paramname">mode</td><td>Defined the policy for handling active tiles (see above for details)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The values of any voxels are unchanged. </dd></dl>

</div>
</div>
<a class="anchor" id="a697de92ff0bec5d6b6ada6fdb3966af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr dilateSdf </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>sdfGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dilation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a>&#160;</td>
          <td class="paramname"><em>nn</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIter</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dilates an existing signed distance filed by a specified number of voxels. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the dilated signed distance field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdfGrid</td><td>Input signed distance field to be dilated.</td></tr>
    <tr><td class="paramname">dilation</td><td>Numer of voxels that the input SDF will be dilated.</td></tr>
    <tr><td class="paramname">nn</td><td>Stencil-pattern used for dilation</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
  </table>
  </dd>
</dl>
<p>Topology will change as a result of this dilation. E.g. if sdfGrid has a width of 3 and <em>dilation</em> = 6 then the grid returned by this method is a narrow band signed distance field with a total vidth of 9 units. </p>

</div>
</div>
<a class="anchor" id="aa7e34b5d2c9f6d491cada2461ce9413a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dilateVoxels </td>
          <td>(</td>
          <td class="paramtype">TreeType &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a>&#160;</td>
          <td class="paramname"><em>nn</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Topologically dilate all leaf-level active voxels in a tree using one of three nearest neighbor connectivity patterns. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is NOT multi-threaded and ignores active tiles!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>tree to be dilated </td></tr>
    <tr><td class="paramname">iterations</td><td>number of iterations to apply the dilation </td></tr>
    <tr><td class="paramname">nn</td><td>connectivity pattern of the dilation: either face-adjacent (6 nearest neighbors), face- and edge-adjacent (18 nearest neighbors) or face-, edge- and vertex-adjacent (26 nearest neighbors).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The values of any voxels are unchanged. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb648a3a1452b9640f099d3a3359990b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dilateVoxels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html">tree::LeafManager</a>&lt; TreeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a>&#160;</td>
          <td class="paramname"><em>nn</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Topologically dilate all leaf-level active voxels in a tree using one of three nearest neighbor connectivity patterns. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is NOT multi-threaded and ignores active tiles!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>LeafManager containing the tree to be dilated. On exit it is updated to include all the leaf nodes of the dilated tree. </td></tr>
    <tr><td class="paramname">iterations</td><td>number of iterations to apply the dilation </td></tr>
    <tr><td class="paramname">nn</td><td>connectivity pattern of the dilation: either face-adjacent (6 nearest neighbors), face- and edge-adjacent (18 nearest neighbors) or face-, edge- and vertex-adjacent (26 nearest neighbors).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The values of any voxels are unchanged. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9d4adc505e30de4684d20efdcb66512"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr divergence </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the divergence of the given vector-valued grid. </p>
<dl class="section return"><dt>Returns</dt><dd>a new scalar-valued grid with the same numerical precision as the input grid (for example, if the input grid is a Vec3DGrid, the output grid will be a DoubleGrid)</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a class="anchor" id="ab4342922999466ca1d2481c6c0d083b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr divergence </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a32740877aa270bb22ecb4762b2d64951"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt;GridType&gt;::Type::Ptr openvdb::v8_0::tools::divergence </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afc5d7a9409e1d987c8f9f17e4a8d9eac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt;GridType&gt;::Type::Ptr openvdb::v8_0::tools::divergence </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad04cb644cc1e7f5d3135977bbd2b2c9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v8_0::tools::doResampleToMatch </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>inGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridType &amp;&#160;</td>
          <td class="paramname"><em>outGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Interrupter &amp;&#160;</td>
          <td class="paramname"><em>interrupter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The normal entry points for resampling are the <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ae190c2befe2b252b8d930bd632964ab7" title="Resample an input grid into an output grid of the same type such that, after resampling, the input and output grids coincide (apart from sampling artifacts), but the output grid&#39;s transform is unchanged. ">resampleToMatch()</a> functions, which correctly handle level set grids under scaling and shearing. <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ad04cb644cc1e7f5d3135977bbd2b2c9e">doResampleToMatch()</a> is mainly for internal use but is typically faster for level sets, and correct provided that no scaling or shearing is needed.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not use this function to scale or shear a level set grid. </dd></dl>

</div>
</div>
<a class="anchor" id="aec7b415f8b2e1ef32d6d832e87ac2e8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void erodeVoxels </td>
          <td>(</td>
          <td class="paramtype">TreeType &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a>&#160;</td>
          <td class="paramname"><em>nn</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Topologically erode all leaf-level active voxels in the given tree. </p>
<p>That is, shrink the set of active voxels by <em>iterations</em> voxels in the +x, -x, +y, -y, +z and -z directions, but don't change the values of any voxels, only their active states.  </p>

</div>
</div>
<a class="anchor" id="ad103855494b0317d1dbc12139a07b926"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void erodeVoxels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html">tree::LeafManager</a>&lt; TreeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a>&#160;</td>
          <td class="paramname"><em>nn</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Topologically erode all leaf-level active voxels in the given tree. </p>
<p>That is, shrink the set of active voxels by <em>iterations</em> voxels in the +x, -x, +y, -y, +z and -z directions, but don't change the values of any voxels, only their active states.  </p>

</div>
</div>
<a class="anchor" id="a3b522dd56a467487d4b16d0f1d16c0d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void extractActiveVoxelSegmentMasks </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeType &amp;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr &gt; &amp;&#160;</td>
          <td class="paramname"><em>masks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a mask for each connected component of the given grid's active voxels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>Input grid or tree </td></tr>
    <tr><td class="paramname">masks</td><td>Output set of disjoint active topology masks sorted in descending order based on the active voxel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a3ef894d7a7eaf47a03d2508d2d95d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr extractEnclosedRegion </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeType &amp;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridOrTreeType::ValueType&#160;</td>
          <td class="paramname"><em>isovalue</em> = <code>lsutilGridZero&lt;GridOrTreeType&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structopenvdb_1_1v8__0_1_1TreeAdapter.html">TreeAdapter</a>&lt; GridOrTreeType &gt;::TreeType::template ValueConverter&lt; bool &gt;::Type *&#160;</td>
          <td class="paramname"><em>fillMask</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the interior regions of a signed distance field and topologically enclosed (watertight) regions of value greater than the <em>isovalue</em> (cavities) that can arise as the result of CSG union operations between different shapes where at least one of the shapes has a concavity that is capped. </p>
<p>For example the enclosed region of a capped bottle would include the walls and the interior cavity.</p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to either a boolean grid or tree with the same tree configuration and potentially transform as the input <code>volume</code> and whose active and <code>true</code> values correspond to the interior and enclosed regions in the input signed distance field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>Signed distance field / level set volume. </td></tr>
    <tr><td class="paramname">isovalue</td><td>Threshold below which values are considered part of the interior region. </td></tr>
    <tr><td class="paramname">fillMask</td><td>Optional boolean tree, when provided enclosed cavity regions that are not completely filled by this mask are ignored.</td></tr>
  </table>
  </dd>
</dl>
<p>For instance if the fill mask does not completely fill the bottle in the previous example only the walls and cap are returned and the interior cavity will be ignored. </p>

</div>
</div>
<a class="anchor" id="a39bfe53eeb50b4ffdc96c90af7e1de1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr extractIsosurfaceMask </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeType &amp;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridOrTreeType::ValueType&#160;</td>
          <td class="paramname"><em>isovalue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a mask of the voxels that intersect the implicit surface with the given <em>isovalue</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>Signed distance field / level set volume. </td></tr>
    <tr><td class="paramname">isovalue</td><td>The crossing point that is considered the surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a586a786ed67c81b31e7bcc11c70df047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpType::ResultTreeType::Ptr extractSparseTree </td>
          <td>(</td>
          <td class="paramtype">const DenseType &amp;&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OpType &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename OpType::ResultValueType &amp;&#160;</td>
          <td class="paramname"><em>background</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selectively extract and transform data from a dense grid, producing a sparse tree with leaf nodes only (e.g. create a tree from the square of values greater than a cutoff.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dense</td><td>A dense grid that acts as a data source </td></tr>
    <tr><td class="paramname">functor</td><td>A functor that selects and transforms data for output </td></tr>
    <tr><td class="paramname">background</td><td>The background value of the resulting sparse grid </td></tr>
    <tr><td class="paramname">threaded</td><td>Option to use threaded or serial code path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>Ptr</code> to tree with the valuetype and configuration defined by typedefs in the <code>functor</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>To achieve optimal sparsity consider calling the <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a8057e1165c928a37703f90eb9496083c" title="Reduce the memory footprint of a tree by replacing with tiles any nodes whose values are all the same...">prune()</a> method on the result. </dd>
<dd>
To simply copy the all the data from a <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Dense.html" title="Dense is a simple dense grid API used by the CopyToDense and CopyFromDense classes defined below...">Dense</a> grid to a OpenVDB <a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a>, use <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a718fc3e33310680728f4fbf04db240c0" title="Populate a sparse grid with the values of all of the voxels of a dense grid. ">tools::copyFromDense()</a> for better performance.</dd></dl>
<p>The type of the sparse tree is determined by the specified OtpType functor by means of the typedef OptType::ResultTreeType</p>
<p>The OptType function is responsible for the the transformation of dense grid data to sparse grid data on a per-voxel basis.</p>
<p>Only leaf nodes with active values will be added to the sparse grid.</p>
<p>The OpType must struct that defines a the minimal form </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ExampleOp</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> ResultTreeType = DesiredTreeType;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> IndexOrCoord&gt;</div><div class="line">     <span class="keywordtype">void</span> OpType::operator() (<span class="keyword">const</span> DenseValueType a, <span class="keyword">const</span> IndexOrCoord&amp; ijk,</div><div class="line">                   ResultTreeType::LeafNodeType* leaf);</div><div class="line">};</div></div><!-- fragment --><p>For example, to generate a &lt;ValueType, 5, 4, 3&gt; tree with valuesOn at locations greater than a given maskvalue </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</div><div class="line"><span class="keyword">class </span>Rule</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Standard tree type (e.g. MaskTree or FloatTree in openvdb.h)</span></div><div class="line">    <span class="keyword">using</span> ResultTreeType = <span class="keyword">typename</span> openvdb::tree::Tree4&lt;ValueType, 5, 4, 3&gt;::Type;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ResultLeafNodeType = <span class="keyword">typename</span> ResultTreeType::LeafNodeType;</div><div class="line">    <span class="keyword">using</span> ResultValueType = <span class="keyword">typename</span> ResultTreeType::ValueType;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> DenseValueType = float;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> <a class="code" href="namespaceopenvdb_1_1v8__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> = vdbmath::Coord::ValueType;</div><div class="line"></div><div class="line">    Rule(<span class="keyword">const</span> DenseValueType&amp; value): mMaskValue(value){};</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> IndexOrCoord&gt;</div><div class="line">    <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> DenseValueType&amp; a, <span class="keyword">const</span> IndexOrCoord&amp; offset,</div><div class="line">                ResultLeafNodeType* leaf)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">            <span class="keywordflow">if</span> (a &gt; mMaskValue) {</div><div class="line">                leaf-&gt;setValueOn(offset, a);</div><div class="line">            }</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> DenseValueType mMaskValue;</div><div class="line">};</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae1e62f3b18a1d40b3195c83b4d76c1e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1DSConverter.html">DSConverter</a>&lt; DenseType, MaskTreeType &gt;::Type::Ptr extractSparseTreeWithMask </td>
          <td>(</td>
          <td class="paramtype">const DenseType &amp;&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskTreeType &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DenseType::ValueType &amp;&#160;</td>
          <td class="paramname"><em>background</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from the intersection of a sparse tree and a dense input grid. The resulting tree has the same configuration as the sparse tree, but holds the data type specified by the dense input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dense</td><td>A dense grid that acts as a data source </td></tr>
    <tr><td class="paramname">mask</td><td>The active voxels and tiles intersected with dense define iteration mask </td></tr>
    <tr><td class="paramname">background</td><td>The background value of the resulting sparse grid </td></tr>
    <tr><td class="paramname">threaded</td><td>Option to use threaded or serial code path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>Ptr</code> to tree with the same configuration as <code>mask</code> but of value type defined by <code>dense</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6aea86a2df380225a3b3c8553efe4e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Extrema.html">math::Extrema</a> extrema </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over a scalar grid and compute extrema (min/max) of the values of the voxels that are visited, or iterate over a vector-valued grid and compute extrema of the magnitudes of the vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over the values of a grid or its tree (<code><a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::ValueOffIter</code>, etc.) </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, iterate over the grid in parallel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafcd95f6d9da81e339aab75465ee4e22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Extrema.html">math::Extrema</a> extrema </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over a grid and compute extrema (min/max) of the values produced by applying the given functor at each voxel that is visited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over the values of a grid or its tree (<code><a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::ValueOffIter</code>, etc.) </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <code>void op(const IterT&amp;, math::Stats&amp;)</code>, where <code>IterT</code> is the type of <em>iter</em>, that inserts zero or more floating-point values into the provided <code><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Stats.html" title="This class computes statistics (minimum value, maximum value, mean, variance and standard deviation) ...">math::Stats</a></code> object </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, iterate over the grid in parallel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When <em>threaded</em> is true, each thread gets its own copy of the functor.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Compute statistics of just the active and positive-valued voxels of a scalar, floating-point grid. <div class="fragment"><div class="line"><span class="keyword">struct </span>Local {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span></div><div class="line">    <span class="keywordtype">void</span> addIfPositive(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v8__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">FloatGrid::ValueOnCIter</a>&amp; iter, math::Extrema&amp; ex)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> f = *iter;</div><div class="line">        <span class="keywordflow">if</span> (f &gt; 0.0) {</div><div class="line">            <span class="keywordflow">if</span> (iter.isVoxelValue()) ex.add(f);</div><div class="line">            <span class="keywordflow">else</span> ex.add(f, iter.getVoxelCount());</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> grid = ...;</div><div class="line">math::Extrema stats =</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ac6aea86a2df380225a3b3c8553efe4e3">tools::extrema</a>(grid.cbeginValueOn(), Local::addIfPositive, <span class="comment">/*threaded=*/</span><span class="keyword">true</span>);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="af3f0e9f42ab322b7dd0f54dfb5b28556"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fillWithSpheres </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; openvdb::Vec4s &gt; &amp;&#160;</td>
          <td class="paramname"><em>spheres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec2i &amp;&#160;</td>
          <td class="paramname"><em>sphereCount</em> = <code>Vec2i(1,&#160;50)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overlapping</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minRadius</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxRadius</em> = <code>std::numeric_limits&lt;float&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>isovalue</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instanceCount</em> = <code>10000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a closed level set or fog volume with adaptively-sized spheres. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar grid that defines the surface to be filled with spheres </td></tr>
    <tr><td class="paramname">spheres</td><td>an output array of 4-tuples representing the fitted spheres<br />
 The first three components of each tuple specify the sphere center, and the fourth specifies the radius. The spheres are ordered by radius, from largest to smallest. </td></tr>
    <tr><td class="paramname">sphereCount</td><td>lower and upper bounds on the number of spheres to be generated<br />
 The actual number will be somewhere within the bounds. </td></tr>
    <tr><td class="paramname">overlapping</td><td>toggle to allow spheres to overlap/intersect </td></tr>
    <tr><td class="paramname">minRadius</td><td>the smallest allowable sphere size, in voxel units<br />
 </td></tr>
    <tr><td class="paramname">maxRadius</td><td>the largest allowable sphere size, in voxel units </td></tr>
    <tr><td class="paramname">isovalue</td><td>the voxel value that determines the surface of the volume<br />
 The default value of zero works for signed distance fields, while fog volumes require a larger positive value (0.5 is a good initial guess). </td></tr>
    <tr><td class="paramname">instanceCount</td><td>the number of interior points to consider for the sphere placement<br />
 Increasing this count increases the chances of finding optimal sphere sizes. </td></tr>
    <tr><td class="paramname">interrupter</td><td>pointer to an object adhering to the <a class="el" href="structopenvdb_1_1v8__0_1_1util_1_1NullInterrupter.html" title="Dummy NOOP interrupter class defining interface. ">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The minimum sphere count takes precedence over the minimum radius. </dd></dl>

</div>
</div>
<a class="anchor" id="ac47969b0a41353bc67f7e3af1be7ce0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vec3d openvdb::v8_0::tools::findFeaturePoint </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Vec3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vec3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a set of tangent elements, <code>points</code> with corresponding <code>normals</code>, this method returns the intersection point of all tangent elements. </p>
<dl class="section note"><dt>Note</dt><dd>Used to extract surfaces with sharp edges and corners from volume data, see the following paper for details: "Feature Sensitive Surface
        Extraction from Volume Data, Kobbelt et al. 2001". </dd></dl>

</div>
</div>
<a class="anchor" id="ad3a364ccf87a335cf241e6d90f026744"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FogGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr fogToExt </td>
          <td>(</td>
          <td class="paramtype">const FogGridT &amp;&#160;</td>
          <td class="paramname"><em>fogGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtOpT &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtValueT &amp;&#160;</td>
          <td class="paramname"><em>background</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename FogGridT::ValueType&#160;</td>
          <td class="paramname"><em>isoValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIter</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the extension of a field, defined by the specified functor, off an iso-surface from an input FOG volume. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the extension field defined from the active values in the input fog volume.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fogGrid</td><td>Scalar (floating-point) volume from which an iso-surface can be defined.</td></tr>
    <tr><td class="paramname">op</td><td>Functor with signature [](const Vec3R &amp;xyz)-&gt;ExtValueT that defines the Dirichlet boundary condition, on the iso-surface, of the field to be extended.</td></tr>
    <tr><td class="paramname">background</td><td>Background value of return grid with the extension field.</td></tr>
    <tr><td class="paramname">isoValue</td><td>A value which defines a smooth iso-surface that intersects active voxels in <em>fogGrid</em>.</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Strictly speaking a fog volume is normalized to the range [0,1] but this method accepts a scalar volume with an arbitary range, as long as the it includes the <em>isoValue</em>.</dd></dl>
<p>Topology of output grid is identical to that of the input grid, except active tiles in the input grid will be converted to active voxels in the output grid!</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em>isoValue</em> does not intersect any active values in <em>fogGrid</em> then the returned grid has all its active values set to <em>background</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a09b0661a0aaa5a3b5badaf557459dcc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr fogToSdf </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>fogGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridT::ValueType&#160;</td>
          <td class="paramname"><em>isoValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIter</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a scalar fog volume into a signed distance function. Active input voxels with scalar values above the given isoValue will have NEGATIVE distance values on output, i.e. they are assumed to be INSIDE the iso-surface. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a signed-distance field defined on the active values of the input fog volume.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fogGrid</td><td>Scalar (floating-point) volume from which an iso-surface can be defined.</td></tr>
    <tr><td class="paramname">isoValue</td><td>A value which defines a smooth iso-surface that intersects active voxels in <em>fogGrid</em>.</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Strictly speaking a fog volume is normalized to the range [0,1] but this method accepts a scalar volume with an arbitary range, as long as the it includes the <em>isoValue</em>.</dd></dl>
<p>Topology of output grid is identical to that of the input grid, except active tiles in the input grid will be converted to active voxels in the output grid!</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em>isoValue</em> does not intersect any active values in <em>fogGrid</em> then the returned grid has all its active values set to plus or minus infinity, depending on if the input values are larger or smaller than <em>isoValue</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3fa3d058b61aff63b0ce92fd718da48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename FogGridT::Ptr, typename FogGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr &gt; fogToSdfAndExt </td>
          <td>(</td>
          <td class="paramtype">const FogGridT &amp;&#160;</td>
          <td class="paramname"><em>fogGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtOpT &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtValueT &amp;&#160;</td>
          <td class="paramname"><em>background</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename FogGridT::ValueType&#160;</td>
          <td class="paramname"><em>isoValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIter</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the signed distance field and the extension of a scalar field, defined by the specified functor, off an iso-surface from an input FOG volume. </p>
<dl class="section return"><dt>Returns</dt><dd>An pair of two shared pointers to respectively the SDF and extension field</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fogGrid</td><td>Scalar (floating-point) volume from which an iso-surface can be defined.</td></tr>
    <tr><td class="paramname">op</td><td>Functor with signature [](const Vec3R &amp;xyz)-&gt;float that defines the Dirichlet boundary condition, on the iso-surface, of the field to be extended.</td></tr>
    <tr><td class="paramname">background</td><td>Background value of return grid with the extension field.</td></tr>
    <tr><td class="paramname">isoValue</td><td>A value which defines a smooth iso-surface that intersects active voxels in <em>fogGrid</em>.</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Strictly speaking a fog volume is normalized to the range [0,1] but this method accepts a scalar volume with an arbitary range, as long as the it includes the <em>isoValue</em>.</dd></dl>
<p>Topology of output grids are identical to that of the input grid, except active tiles in the input grid will be converted to active voxels in the output grids!</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em>isoValue</em> does not intersect any active values in <em>fogGrid</em> then a pair of the following grids is returned: The first is a signed distance grid with its active values set to plus or minus infinity depending of whether its input values are above or below <em>isoValue</em>. The second grid, which represents the extension field, has all its active values set to <em>background</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ada1c7e219f36d148510ce22d7599171b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void foreach </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XformOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shareOp</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterate over a grid and at each step call <code>op(iter)</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over a grid or its tree (<code><a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::NodeIter</code>, etc.) </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <code>void op(const IterT&amp;)</code>, where <code>IterT</code> is the type of <em>iter</em> </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, transform multiple values of the grid in parallel </td></tr>
    <tr><td class="paramname">shareOp</td><td>if true and <em>threaded</em> is true, all threads use the same functor; otherwise, each thread gets its own copy of the <em>original</em> functor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd>Multiply all values (both set and unset) of a scalar, floating-point grid by two. <div class="fragment"><div class="line"><span class="keyword">struct </span>Local {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> op(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v8__0_1_1Grid.html#ae60f7ec90327837088fbe58242f78745">FloatGrid::ValueAllIter</a>&amp; iter) {</div><div class="line">        iter.setValue(*iter * 2);</div><div class="line">    }</div><div class="line">};</div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> grid = ...;</div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ada1c7e219f36d148510ce22d7599171b">tools::foreach</a>(grid.beginValueAll(), Local::op);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Rotate all active vectors of a vector grid by 45 degrees about the y axis. <div class="fragment"><div class="line"><span class="keyword">namespace </span>{</div><div class="line">    <span class="keyword">struct </span>MatMul {</div><div class="line">        <a class="code" href="namespaceopenvdb_1_1v8__0_1_1math.html#a85b140686e0a81e6b7e47e021428005e">math::Mat3s</a> M;</div><div class="line">        <a class="code" href="structopenvdb_1_1v8__0_1_1tools_1_1MatMul.html#a59cf6c732ef2e69040ccffa439bc0409">MatMul</a>(<span class="keyword">const</span> <a class="code" href="namespaceopenvdb_1_1v8__0_1_1math.html#a85b140686e0a81e6b7e47e021428005e">math::Mat3s</a>&amp; <a class="code" href="structopenvdb_1_1v8__0_1_1tools_1_1MatMul.html#a5c83e050fc2b2e0f06288f74cde5d715">mat</a>): M(mat) {}</div><div class="line">        <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="structopenvdb_1_1v8__0_1_1tools_1_1MatMul.html#acaceb3fad0005e8130a71b2e54af7e43">operator()</a>(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v8__0_1_1Grid.html#aa20792587df8cc92cff821e68e70ace7">VectorGrid::ValueOnIter</a>&amp; iter)<span class="keyword"> const </span>{</div><div class="line">            iter.setValue(M.transform(*iter));</div><div class="line">        }</div><div class="line">    };</div><div class="line">}</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__0.html#a34f04b5087af8e271f07c3665c9593b7">VectorGrid</a> grid = ...;</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ada1c7e219f36d148510ce22d7599171b">tools::foreach</a>(grid.beginValueOn(),</div><div class="line">        <a class="code" href="structopenvdb_1_1v8__0_1_1tools_1_1MatMul.html#a59cf6c732ef2e69040ccffa439bc0409">MatMul</a>(math::rotation&lt;math::Mat3s&gt;(math::Y, M_PI_4)));</div><div class="line">}</div></div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>For more complex operations that require finer control over threading, consider using <code>tbb::parallel_for()</code> or <code>tbb::parallel_reduce()</code> in conjunction with a <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1IteratorRange.html">tree::IteratorRange</a> that wraps a grid or tree iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1dd9695ed106fdc71856355b0bfc1b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void foreach </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XformOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shareOp</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab2dc20cbb018eddb5d26c53bf8cf83ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::ConstPtr getValidPointIndexGrid </td>
          <td>(</td>
          <td class="paramtype">const PointArrayT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridT::ConstPtr &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repartition the <em>points</em> if needed, otherwise return the input <em>grid</em>. </p>

</div>
</div>
<a class="anchor" id="afb27ad923a88ee58220750ffc3914c03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr getValidPointIndexGrid </td>
          <td>(</td>
          <td class="paramtype">const PointArrayT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridT::Ptr &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repartition the <em>points</em> if needed, otherwise return the input <em>grid</em>. </p>

</div>
</div>
<a class="anchor" id="a61d4d89cd34db1794e9a615dec11dc0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr gradient </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the gradient of the given scalar grid. </p>
<dl class="section return"><dt>Returns</dt><dd>a new vector-valued grid with the same numerical precision as the input grid (for example, if the input grid is a DoubleGrid, the output grid will be a Vec3DGrid)</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a class="anchor" id="a8cad07124b4f4d6a7b15021ee86b2c2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr gradient </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac52272e8e0845e2d3c0dbd195c00a2b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt;GridType&gt;::Type::Ptr openvdb::v8_0::tools::gradient </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4a940c5624461c9ba8a59ab1870f85a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt;GridType&gt;::Type::Ptr openvdb::v8_0::tools::gradient </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a705b035d27c69d566009424697c36a65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Histogram.html">math::Histogram</a> histogram </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over a scalar grid and compute a histogram of the values of the voxels that are visited, or iterate over a vector-valued grid and compute a histogram of the magnitudes of the vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over the values of a grid or its tree (<code><a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::ValueOffIter</code>, etc.) </td></tr>
    <tr><td class="paramname">minVal</td><td>the smallest value that can be added to the histogram </td></tr>
    <tr><td class="paramname">maxVal</td><td>the largest value that can be added to the histogram </td></tr>
    <tr><td class="paramname">numBins</td><td>the number of histogram bins </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, iterate over the grid in parallel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d5182249f0ff2cd4584ec24b09300a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::template ValueConverter&lt; bool &gt;::Type::Ptr interiorMask </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>isovalue</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input grid of any type, return a new, boolean grid whose active voxel topology matches the input grid's or, if the input grid is a level set, matches the input grid's interior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the grid from which to construct a mask </td></tr>
    <tr><td class="paramname">isovalue</td><td>for a level set grid, the isovalue that defines the grid's interior </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a59b83096927350f3324cba935be37717" title="Threaded method to construct a boolean mask that represents interior regions in a signed distance fie...">tools::sdfInteriorMask()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af2c25ce7b65fe2e22209dce0b5eae646"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValidPartition </td>
          <td>(</td>
          <td class="paramtype">const PointArrayT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given point index grid represents a valid partitioning of the given point array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>world-space point array conforming to the <a class="el" href="interfacePointArray.html" title="Partitions points into BucketLog2Dim aligned buckets using a parallel radix-based sorting algorithm...">PointArray</a> interface </td></tr>
    <tr><td class="paramname">grid</td><td>point index grid to validate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af55f3361b55d27809c1da5bf33db393a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr laplacian </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Laplacian.html">Laplacian</a> of the given scalar grid. </p>
<dl class="section return"><dt>Returns</dt><dd>a new scalar grid</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a class="anchor" id="a2c8b10bc1b3daa909a50c4b1a68c1c79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr laplacian </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab078dffd97b0801b1575dfe0592e3c5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::laplacian </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9596e04716318ee74de2e07f47c69910"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::laplacian </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a21904c4bdeb53424433206487628a32f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> openvdb::v8_0::tools::levelSetArea </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useWorldSpace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the surface area of a narrow-band level set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar, floating-point grid with one or more disjoint, closed level set surfaces </td></tr>
    <tr><td class="paramname">useWorldSpace</td><td>if true the area is computed in world space units, else in voxel units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if <em>grid</em> is not scalar or not floating-point or not a level set or empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace2b53898f455d8e5963c5de67c71c34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> openvdb::v8_0::tools::levelSetArea </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useWorldUnits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f1d5d4e92ad027e268d355a6c20fddb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int openvdb::v8_0::tools::levelSetEulerCharacteristic </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Euler Characteristics of a narrow-band level set surface (possibly disconnected). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar, floating-point grid with one or more disjoint, closed level set surfaces</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if <em>grid</em> is not scalar or not floating-point or not a level set or empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19f3f620c49f508bbfe2cddda18c66d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int openvdb::v8_0::tools::levelSetEulerCharacteristic </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5e8497642e2adea02d80cd84003e8626"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int openvdb::v8_0::tools::levelSetGenus </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the genus of a narrow-band level set surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar, floating-point grid with one or more disjoint, closed level set surfaces </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The genus is only well defined for a single connected surface</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if <em>grid</em> is not scalar or not floating-point or not a level set or empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5f57ec0f6bb9d933e6532c58aeb0918"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int openvdb::v8_0::tools::levelSetGenus </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af574939742ed86a148731292520c8e30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr levelSetRebuild </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>isovalue</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">math::Transform</a> *&#160;</td>
          <td class="paramname"><em>xform</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a new grid of type <code>GridType</code> that contains a narrow-band level set representation of an isosurface of a given grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar, floating-point grid with one or more disjoint, closed isosurfaces at the given <em>isovalue</em> </td></tr>
    <tr><td class="paramname">isovalue</td><td>the isovalue that defines the implicit surface (defaults to zero, which is typical if the input grid is already a level set or a SDF). </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units (defaults to 3 voxels, which is required for some level set operations) </td></tr>
    <tr><td class="paramname">xform</td><td>optional transform for the output grid (if not provided, the transform of the input <em>grid</em> will be matched)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if <em>grid</em> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the input grid contains overlapping isosurfaces, interior edges will be lost. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ce3a230f06d4e222727e1046bc6ae3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr levelSetRebuild </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>exBandWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inBandWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">math::Transform</a> *&#160;</td>
          <td class="paramname"><em>xform</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a new grid of type <code>GridType</code> that contains a narrow-band level set representation of an isosurface of a given grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar, floating-point grid with one or more disjoint, closed isosurfaces at the given <em>isovalue</em> </td></tr>
    <tr><td class="paramname">isovalue</td><td>the isovalue that defines the implicit surface </td></tr>
    <tr><td class="paramname">exBandWidth</td><td>the exterior narrow-band width in voxel units </td></tr>
    <tr><td class="paramname">inBandWidth</td><td>the interior narrow-band width in voxel units </td></tr>
    <tr><td class="paramname">xform</td><td>optional transform for the output grid (if not provided, the transform of the input <em>grid</em> will be matched)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if <em>grid</em> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the input grid contains overlapping isosurfaces, interior edges will be lost. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b42eee5e13c85a68dfad82c21d510a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr levelSetRebuild </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>exBandWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inBandWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">math::Transform</a> *&#160;</td>
          <td class="paramname"><em>xform</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a new grid of type <code>GridType</code> that contains a narrow-band level set representation of an isosurface of a given grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar, floating-point grid with one or more disjoint, closed isosurfaces at the given <em>isovalue</em> </td></tr>
    <tr><td class="paramname">isovalue</td><td>the isovalue that defines the implicit surface </td></tr>
    <tr><td class="paramname">exBandWidth</td><td>the exterior narrow-band width in voxel units </td></tr>
    <tr><td class="paramname">inBandWidth</td><td>the interior narrow-band width in voxel units </td></tr>
    <tr><td class="paramname">xform</td><td>optional transform for the output grid (if not provided, the transform of the input <em>grid</em> will be matched) </td></tr>
    <tr><td class="paramname">interrupter</td><td>optional interrupter object</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if <em>grid</em> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the input grid contains overlapping isosurfaces, interior edges will be lost. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a4a922db530a6e630c3215bec543805"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> openvdb::v8_0::tools::levelSetVolume </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useWorldSpace</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the volume of a narrow-band level set surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar, floating-point grid with one or more disjoint, closed level set surfaces </td></tr>
    <tr><td class="paramname">useWorldSpace</td><td>if true the volume is computed in world space units, else in voxel units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if <em>grid</em> is not scalar or not floating-point or not a level set or empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e985b678d35b43dfd0b2bcb0d1d01d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> openvdb::v8_0::tools::levelSetVolume </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useWorldUnits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9370eee6dbb6de354a68a54b9cdd1dba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr magnitude </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the magnitudes of the vectors of the given vector-valued grid. </p>
<dl class="section return"><dt>Returns</dt><dd>a new scalar-valued grid with the same numerical precision as the input grid (for example, if the input grid is a Vec3DGrid, the output grid will be a DoubleGrid)</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a class="anchor" id="a06fe38fb2a95969530d664ef92f7dcae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr magnitude </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4c05f5bd0fd548da639aa5cfd1dd05bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt;GridType&gt;::Type::Ptr openvdb::v8_0::tools::magnitude </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a15bae762c6ce7763de58417791f9af0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt;GridType&gt;::Type::Ptr openvdb::v8_0::tools::magnitude </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1164227196b14538c20d8cb234fdec6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v8_0::tools::maskPoints </td>
          <td>(</td>
          <td class="paramtype">const PointListT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes every voxel of the <code>grid</code> active if it contains a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>points that active the voxels of <code>grid</code> </td></tr>
    <tr><td class="paramname">grid</td><td>on out its voxels with points are active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa310f2f224f5b386b70dd8645b39b133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr maskSdf </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>sdfGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html">Grid</a>&lt; MaskTreeT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreActiveTiles</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIter</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills mask by extending an existing signed distance field into the active values of this input ree of arbitrary value type. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the masked signed distance field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdfGrid</td><td>Input signed distance field to be extended into the mask.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask used to idetify the topology of the output SDF. Note this mask is assume to overlap with the sdfGrid.</td></tr>
    <tr><td class="paramname">ignoreActiveTiles</td><td>If false, active tiles in the mask are treated as active voxels. Else they are ignored.</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
  </table>
  </dd>
</dl>
<p>Topology of the output SDF is determined by the union of the active voxels (or optionally values) in <em>sdfGrid</em> and <em>mask</em>. </p>

</div>
</div>
<a class="anchor" id="a5ad8501c4e8a1e0f613d880f3431d6ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meanCurvature </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the mean curvature of the given grid. </p>
<dl class="section return"><dt>Returns</dt><dd>a new grid</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a class="anchor" id="a85e0a1a825212802a6a672420f1be648"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meanCurvature </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae4a0ea5918b4710b87cf20d0af0991e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::meanCurvature </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a202d03198722a082c8d5aae0afbe2da0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::meanCurvature </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a49d6517666da8e1ec1175651ebf12f32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToLevelSet </td>
          <td>(</td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vec3s &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a triangle mesh to a level set volume. </p>
<dl class="section return"><dt>Returns</dt><dd>a grid of type <code>GridType</code> containing a narrow-band level set representation of the input mesh.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if <code>GridType</code> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Requires a closed surface but not necessarily a manifold surface. Supports surfaces with self intersections and degenerate faces and is independent of mesh surface normals.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xform</td><td>transform for the output grid </td></tr>
    <tr><td class="paramname">points</td><td>list of world space point positions </td></tr>
    <tr><td class="paramname">triangles</td><td>triangle index list </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a564d13cfab9796e72f62f51f991d05af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToLevelSet </td>
          <td>(</td>
          <td class="paramtype">Interrupter &amp;&#160;</td>
          <td class="paramname"><em>interrupter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vec3s &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds support for a <em>interrupter</em> callback used to cancel the conversion. </p>

</div>
</div>
<a class="anchor" id="afb69abc32d73ce0e3cd67b569bed65b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToLevelSet </td>
          <td>(</td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vec3s &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a quad mesh to a level set volume. </p>
<dl class="section return"><dt>Returns</dt><dd>a grid of type <code>GridType</code> containing a narrow-band level set representation of the input mesh.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if <code>GridType</code> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Requires a closed surface but not necessarily a manifold surface. Supports surfaces with self intersections and degenerate faces and is independent of mesh surface normals.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xform</td><td>transform for the output grid </td></tr>
    <tr><td class="paramname">points</td><td>list of world space point positions </td></tr>
    <tr><td class="paramname">quads</td><td>quad index list </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6eb7e6e46e2f3d080031f499863d3ba9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToLevelSet </td>
          <td>(</td>
          <td class="paramtype">Interrupter &amp;&#160;</td>
          <td class="paramname"><em>interrupter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vec3s &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds support for a <em>interrupter</em> callback used to cancel the conversion. </p>

</div>
</div>
<a class="anchor" id="a88550f83eda208f6a4efd332735bb215"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToLevelSet </td>
          <td>(</td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vec3s &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a triangle and quad mesh to a level set volume. </p>
<dl class="section return"><dt>Returns</dt><dd>a grid of type <code>GridType</code> containing a narrow-band level set representation of the input mesh.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if <code>GridType</code> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Requires a closed surface but not necessarily a manifold surface. Supports surfaces with self intersections and degenerate faces and is independent of mesh surface normals.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xform</td><td>transform for the output grid </td></tr>
    <tr><td class="paramname">points</td><td>list of world space point positions </td></tr>
    <tr><td class="paramname">triangles</td><td>triangle index list </td></tr>
    <tr><td class="paramname">quads</td><td>quad index list </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63becdf83d644c0cbc00213390201f97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToLevelSet </td>
          <td>(</td>
          <td class="paramtype">Interrupter &amp;&#160;</td>
          <td class="paramname"><em>interrupter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vec3s &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>float(<a class="el" href="namespaceopenvdb_1_1v8__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds support for a <em>interrupter</em> callback used to cancel the conversion. </p>

</div>
</div>
<a class="anchor" id="ab994dead75e3d110e11eb64dce6ca65a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToSignedDistanceField </td>
          <td>(</td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vec3s &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>exBandWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inBandWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a triangle and quad mesh to a signed distance field with an asymmetrical narrow band. </p>
<dl class="section return"><dt>Returns</dt><dd>a grid of type <code>GridType</code> containing a narrow-band signed distance field representation of the input mesh.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if <code>GridType</code> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Requires a closed surface but not necessarily a manifold surface. Supports surfaces with self intersections and degenerate faces and is independent of mesh surface normals.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xform</td><td>transform for the output grid </td></tr>
    <tr><td class="paramname">points</td><td>list of world space point positions </td></tr>
    <tr><td class="paramname">triangles</td><td>triangle index list </td></tr>
    <tr><td class="paramname">quads</td><td>quad index list </td></tr>
    <tr><td class="paramname">exBandWidth</td><td>the exterior narrow-band width in voxel units </td></tr>
    <tr><td class="paramname">inBandWidth</td><td>the interior narrow-band width in voxel units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee8b90b4bf51a0a1d6f02a769787b415"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToSignedDistanceField </td>
          <td>(</td>
          <td class="paramtype">Interrupter &amp;&#160;</td>
          <td class="paramname"><em>interrupter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vec3s &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>exBandWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inBandWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds support for a <em>interrupter</em> callback used to cancel the conversion. </p>

</div>
</div>
<a class="anchor" id="a7a77a75ddf87809699a67916ea172add"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToUnsignedDistanceField </td>
          <td>(</td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vec3s &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bandWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a triangle and quad mesh to an unsigned distance field. </p>
<dl class="section return"><dt>Returns</dt><dd>a grid of type <code>GridType</code> containing a narrow-band unsigned distance field representation of the input mesh.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if <code>GridType</code> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does not requires a closed surface.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xform</td><td>transform for the output grid </td></tr>
    <tr><td class="paramname">points</td><td>list of world space point positions </td></tr>
    <tr><td class="paramname">triangles</td><td>triangle index list </td></tr>
    <tr><td class="paramname">quads</td><td>quad index list </td></tr>
    <tr><td class="paramname">bandWidth</td><td>the width of the narrow band, in voxel units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacc72d314893ef0b6ad5cda65ded5255"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToUnsignedDistanceField </td>
          <td>(</td>
          <td class="paramtype">Interrupter &amp;&#160;</td>
          <td class="paramname"><em>interrupter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Vec3s &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bandWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds support for a <em>interrupter</em> callback used to cancel the conversion. </p>

</div>
</div>
<a class="anchor" id="a12727083ecf3b9561ff954517144d7a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="interfaceMeshDataAdapter.html">MeshDataAdapter</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">math::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>exteriorBandWidth</em> = <code>3.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interiorBandWidth</em> = <code>3.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridType::template ValueConverter&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ac524bdfeb5d781872485d9321c881920">Int32</a> &gt;::Type *&#160;</td>
          <td class="paramname"><em>polygonIndexGrid</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afdc876198b66dd8a91b21835f1f25342"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToVolume </td>
          <td>(</td>
          <td class="paramtype">Interrupter &amp;&#160;</td>
          <td class="paramname"><em>interrupter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="interfaceMeshDataAdapter.html">MeshDataAdapter</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">math::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>exteriorBandWidth</em> = <code>3.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interiorBandWidth</em> = <code>3.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridType::template ValueConverter&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ac524bdfeb5d781872485d9321c881920">Int32</a> &gt;::Type *&#160;</td>
          <td class="paramname"><em>polygonIndexGrid</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert polygonal meshes that consist of quads and/or triangles into signed or unsigned distance field volumes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interrupter</td><td>a callback to interrupt the conversion process that conforms to the <a class="el" href="structopenvdb_1_1v8__0_1_1util_1_1NullInterrupter.html" title="Dummy NOOP interrupter class defining interface. ">util::NullInterrupter</a> interface </td></tr>
    <tr><td class="paramname">mesh</td><td>mesh data access class that conforms to the <a class="el" href="interfaceMeshDataAdapter.html" title="Convert polygonal meshes that consist of quads and/or triangles into signed or unsigned distance fiel...">MeshDataAdapter</a> interface </td></tr>
    <tr><td class="paramname">transform</td><td>world-to-index-space transform </td></tr>
    <tr><td class="paramname">exteriorBandWidth</td><td>exterior narrow band width in voxel units </td></tr>
    <tr><td class="paramname">interiorBandWidth</td><td>interior narrow band width in voxel units (set this value to <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools_1_1composite.html#aef3b101928da7fcb2c4f05adccace8a9">std::numeric_limits&lt;float&gt;::max()</a> to fill interior regions with distance values) </td></tr>
    <tr><td class="paramname">flags</td><td>optional conversion flags defined in <code>MeshToVolumeFlags</code> </td></tr>
    <tr><td class="paramname">polygonIndexGrid</td><td>optional grid output that will contain the closest-polygon index for each voxel in the active narrow band region </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add8ca0caf60c323917088490510fa8e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool noActiveValues </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the bounding box intersects none of the active values in a tree, i.e. neither active voxels or active tiles. </p>
<dl class="section warning"><dt>Warning</dt><dd>For repeated calls to this method consider instead creating an instance of <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1FindActiveValues.html" title="Finds the active values in a tree which intersects a bounding box. ">FindActiveValues</a> and then repeatedly call <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#add8ca0caf60c323917088490510fa8e8" title="Returns true if the bounding box intersects none of the active values in a tree, i.e. neither active voxels or active tiles. ">noActiveValues()</a>. This assumes the tree to be constant between calls but is slightly faster.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>const tree to be tested for active values. </td></tr>
    <tr><td class="paramname">bbox</td><td>index bounding box which is intersected against the active values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5c0227e6c84797a06542df58c2b564d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr normalize </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Normalize.html">Normalize</a> the vectors of the given vector-valued grid. </p>
<dl class="section return"><dt>Returns</dt><dd>a new vector-valued grid</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a class="anchor" id="ac1b083e3b964ba0f08ff56bf2d50981e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr normalize </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *&#160;</td>
          <td class="paramname"><em>interrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a154fe714133a26d9e3e1e6785f7f90b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::normalize </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3f9b68b9b87c65865b48deac6efa79c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr openvdb::v8_0::tools::normalize </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af46c2f5d3a3755b61c266cb3383bb4dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; openvdb::v8_0::tools::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1MeshToVoxelEdgeData_1_1EdgeData.html">MeshToVoxelEdgeData::EdgeData</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4a308e2e6c2d283bfafb3bd80c8ca43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Extrema.html">math::Extrema</a> opExtrema </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OperatorT &amp;&#160;</td>
          <td class="paramname"><em>op</em> = <code>OperatorT()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as opStatistics except it returns a <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Extrema.html" title="This class computes the minimum and maximum values of a population of floating-point values...">math::Extrema</a> vs a <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Stats.html" title="This class computes statistics (minimum value, maximum value, mean, variance and standard deviation) ...">math::Stats</a>. </p>

</div>
</div>
<a class="anchor" id="a35876c2d474f3ed28fc6a6aa4b4f5678"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Stats.html">math::Stats</a> opStatistics </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OperatorT &amp;&#160;</td>
          <td class="paramname"><em>op</em> = <code>OperatorT()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over a grid and compute statistics (mean, variance, etc.) of the values produced by applying a given operator (see <a class="el" href="Operators_8h.html">math/Operators.h</a>) at each voxel that is visited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over the values of a grid or its tree (<code><a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::ValueOffIter</code>, etc.) </td></tr>
    <tr><td class="paramname">op</td><td>an operator object with a method of the form <code>double result(Accessor&amp;, const Coord&amp;)</code> </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, iterate over the grid in parallel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>World-space operators, whose <code>result()</code> methods are of the form <code>double result(const Map&amp;, Accessor&amp;, const Coord&amp;)</code>, must be wrapped in a <a class="el" href="structopenvdb_1_1v8__0_1_1math_1_1MapAdapter.html" title="Adapter to associate a map with a world-space operator, giving it the same call signature as an index...">math::MapAdapter</a>. </dd>
<dd>
Vector-valued operators like <a class="el" href="structopenvdb_1_1v8__0_1_1math_1_1Gradient.html" title="Center difference gradient operators, defined with respect to the range-space of the map...">math::Gradient</a> must be wrapped in an adapter such as <a class="el" href="structopenvdb_1_1v8__0_1_1math_1_1OpMagnitude.html" title="Adapter for vector-valued world-space operators to return the vector magnitude. ">math::OpMagnitude</a>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Compute statistics of the magnitude of the gradient at the active voxels of a scalar, floating-point grid. (Note the use of the <a class="el" href="structopenvdb_1_1v8__0_1_1math_1_1MapAdapter.html" title="Adapter to associate a map with a world-space operator, giving it the same call signature as an index...">math::MapAdapter</a> and <a class="el" href="structopenvdb_1_1v8__0_1_1math_1_1OpMagnitude.html" title="Adapter for vector-valued world-space operators to return the vector magnitude. ">math::OpMagnitude</a> adapters.) <div class="fragment"><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> grid = ...;</div><div class="line"></div><div class="line"><span class="comment">// Assume that we know that the grid has a uniform scale map.</span></div><div class="line"><span class="keyword">using</span> MapType = math::UniformScaleMap;</div><div class="line"><span class="comment">// Specify a world-space gradient operator that uses first-order differencing.</span></div><div class="line"><span class="keyword">using</span> GradientOp = math::Gradient&lt;MapType, math::FD_1ST&gt;;</div><div class="line"><span class="comment">// Wrap the operator with an adapter that computes the magnitude of the gradient.</span></div><div class="line"><span class="keyword">using</span> MagnitudeOp = math::OpMagnitude&lt;GradientOp, MapType&gt;;</div><div class="line"><span class="comment">// Wrap the operator with an adapter that associates a map with it.</span></div><div class="line"><span class="keyword">using</span> CompoundOp = math::MapAdapter&lt;MapType, GradientOp, double&gt;;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (MapType::Ptr map = grid.constTransform().constMap&lt;MapType&gt;()) {</div><div class="line">    math::Stats stats = <a class="code" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a35876c2d474f3ed28fc6a6aa4b4f5678">tools::opStatistics</a>(grid.cbeginValueOn(), CompoundOp(*map));</div><div class="line">}</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Compute statistics of the divergence at the active voxels of a vector-valued grid. <div class="fragment"><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__0.html#a77ff1a3a38ec99a56b4d99a15a2970bf">Vec3SGrid</a> grid = ...;</div><div class="line"></div><div class="line"><span class="comment">// Assume that we know that the grid has a uniform scale map.</span></div><div class="line"><span class="keyword">using</span> MapType = math::UniformScaleMap;</div><div class="line"><span class="comment">// Specify a world-space divergence operator that uses first-order differencing.</span></div><div class="line"><span class="keyword">using</span> DivergenceOp = math::Divergence&lt;MapType, math::FD_1ST&gt;;</div><div class="line"><span class="comment">// Wrap the operator with an adapter that associates a map with it.</span></div><div class="line"><span class="keyword">using</span> CompoundOp = math::MapAdapter&lt;MapType, DivergenceOp, double&gt;;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (MapType::Ptr map = grid.constTransform().constMap&lt;MapType&gt;()) {</div><div class="line">    math::Stats stats = <a class="code" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a35876c2d474f3ed28fc6a6aa4b4f5678">tools::opStatistics</a>(grid.cbeginValueOn(), CompoundOp(*map));</div><div class="line">}</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example:</dt><dd>As above, but computing the divergence in index space. <div class="fragment"><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__0.html#a77ff1a3a38ec99a56b4d99a15a2970bf">Vec3SGrid</a> grid = ...;</div><div class="line"></div><div class="line"><span class="comment">// Specify an index-space divergence operator that uses first-order differencing.</span></div><div class="line"><span class="keyword">using</span> DivergenceOp = math::ISDivergence&lt;math::FD_1ST&gt;;</div><div class="line"></div><div class="line">math::Stats stats = <a class="code" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a35876c2d474f3ed28fc6a6aa4b4f5678">tools::opStatistics</a>(grid.cbeginValueOn(), DivergenceOp());</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a9feb86e4311db3ba962b9d19eb5569be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void particlesToMask </td>
          <td>(</td>
          <td class="paramtype">const ParticleListT &amp;&#160;</td>
          <td class="paramname"><em>plist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activate a boolean grid wherever it intersects the spheres described by the given particle positions and radii. </p>
<p>For more control over the output, including attribute transfer, use the <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ParticlesToLevelSet.html">ParticlesToLevelSet</a> class directly. </p>

</div>
</div>
<a class="anchor" id="a6227a77a20fcc91e570b959710b930d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void particlesToMask </td>
          <td>(</td>
          <td class="paramtype">const ParticleListT &amp;&#160;</td>
          <td class="paramname"><em>plist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activate a boolean grid wherever it intersects the fixed-size spheres described by the given particle positions and the specified radius. </p>
<p>For more control over the output, including attribute transfer, use the <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ParticlesToLevelSet.html">ParticlesToLevelSet</a> class directly. </p>

</div>
</div>
<a class="anchor" id="ae29bb93f486d96bd91cad919e623dab0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void particlesToSdf </td>
          <td>(</td>
          <td class="paramtype">const ParticleListT &amp;&#160;</td>
          <td class="paramname"><em>plist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a scalar, floating-point grid with CSG-unioned level set spheres described by the given particle positions and radii. </p>
<p>For more control over the output, including attribute transfer, use the <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ParticlesToLevelSet.html">ParticlesToLevelSet</a> class directly. </p>

</div>
</div>
<a class="anchor" id="ad924a8ad2838440370b1c80a599794d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void particlesToSdf </td>
          <td>(</td>
          <td class="paramtype">const ParticleListT &amp;&#160;</td>
          <td class="paramname"><em>plist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a scalar, floating-point grid with fixed-size, CSG-unioned level set spheres described by the given particle positions and the specified radius. </p>
<p>For more control over the output, including attribute transfer, use the <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ParticlesToLevelSet.html">ParticlesToLevelSet</a> class directly. </p>

</div>
</div>
<a class="anchor" id="af4039b2222a88a7e4ed8e3f47490eecb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void particleTrailsToMask </td>
          <td>(</td>
          <td class="paramtype">const ParticleListT &amp;&#160;</td>
          <td class="paramname"><em>plist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activate a boolean grid wherever it intersects trails of spheres with decreasing radius, where the starting position and radius and the direction of each trail is given by particle attributes. </p>
<p>For more control over the output, including attribute transfer, use the <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ParticlesToLevelSet.html">ParticlesToLevelSet</a> class directly. </p><dl class="section note"><dt>Note</dt><dd>The <em>delta</em> parameter controls the distance between spheres in a trail. Be careful not to use too small a value. </dd></dl>

</div>
</div>
<a class="anchor" id="adcddfc57ef94f93ff3806a45c26ca7d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void particleTrailsToSdf </td>
          <td>(</td>
          <td class="paramtype">const ParticleListT &amp;&#160;</td>
          <td class="paramname"><em>plist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a scalar, floating-point grid with CSG-unioned trails of level set spheres with decreasing radius, where the starting position and radius and the direction of each trail is given by particle attributes. </p>
<p>For more control over the output, including attribute transfer, use the <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1ParticlesToLevelSet.html">ParticlesToLevelSet</a> class directly. </p><dl class="section note"><dt>Note</dt><dd>The <em>delta</em> parameter controls the distance between spheres in a trail. Be careful not to use too small a value. </dd></dl>

</div>
</div>
<a class="anchor" id="a8057e1165c928a37703f90eb9496083c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void prune </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename TreeT::ValueType&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#afacc9da89954ca2831b932a917506991">zeroVal</a>&lt;typename&#160;TreeT::ValueType&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce the memory footprint of a <em>tree</em> by replacing with tiles any nodes whose values are all the same (optionally to within a tolerance) and have the same active state. </p>
<dl class="section note"><dt>Note</dt><dd>For trees with non-boolean values a child node with (approximately) constant values are replaced with a tile value corresponding to the median of the values in said child node.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree to be pruned </td></tr>
    <tr><td class="paramname">tolerance</td><td>tolerance within which values are considered to be equal </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae81e76930df0c635a4e175887352257e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pruneInactive </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce the memory footprint of a <em>tree</em> by replacing with background tiles any nodes whose values are all inactive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree to be pruned </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad68447719ca38904491830b5c1caefa8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pruneInactiveWithValue </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce the memory footprint of a <em>tree</em> by replacing any nodes whose values are all inactive with tiles of the given <em>value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree to be pruned </td></tr>
    <tr><td class="paramname">value</td><td>value assigned to inactive tiles created during pruning </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a467d50f8a53357977d5720498a88d72c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pruneLevelSet </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce the memory footprint of a <em>tree</em> by replacing nodes whose values are all inactive with inactive tiles having a value equal to the first value encountered in the (inactive) child. </p>
<p>This method is faster than tolerance-based prune and useful for narrow-band level set applications where inactive values are limited to either an inside or an outside value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree to be pruned </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1ValueError.html">ValueError</a></td><td>if the background of the <em>tree</em> is negative (as defined by <a class="el" href="namespaceopenvdb_1_1v8__0_1_1math.html#a9226689ce35d680be36e27bc90670d93" title="Return true if x is less than zero. ">math::isNegative</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac57eaa5cdb5f7180a68b88901e9421ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pruneLevelSet </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>outsideWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>insideWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce the memory footprint of a <em>tree</em> by replacing nodes whose voxel values are all inactive with inactive tiles having the value -| <em>insideWidth</em> | if the voxel values are negative and | <em>outsideWidth</em> | otherwise. </p>
<p>This method is faster than tolerance-based prune and useful for narrow-band level set applications where inactive values are limited to either an inside or an outside value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree to be pruned </td></tr>
    <tr><td class="paramname">outsideWidth</td><td>the width of the outside of the narrow band </td></tr>
    <tr><td class="paramname">insideWidth</td><td>the width of the inside of the narrow band </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1ValueError.html">ValueError</a></td><td>if <em>outsideWidth</em> is negative or <em>insideWidth</em> is not negative (as defined by <a class="el" href="namespaceopenvdb_1_1v8__0_1_1math.html#a9226689ce35d680be36e27bc90670d93" title="Return true if x is less than zero. ">math::isNegative</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8ffdc3cdd984ae9e4c0742406cfdaee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pruneTiles </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename TreeT::ValueType&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#afacc9da89954ca2831b932a917506991">zeroVal</a>&lt;typename&#160;TreeT::ValueType&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainSize</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce the memory footprint of a <em>tree</em> by replacing with tiles any non-leaf nodes whose values are all the same (optionally to within a tolerance) and have the same active state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree to be pruned </td></tr>
    <tr><td class="paramname">tolerance</td><td>tolerance within which values are considered to be equal </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8642ecf09da68f9d3d16f606be7ae301"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rayTrace </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1BaseShader.html">BaseShader</a> &amp;&#160;</td>
          <td class="paramname"><em>shader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1BaseCamera.html">BaseCamera</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pixelSamples</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ray-trace a volume. </p>

</div>
</div>
<a class="anchor" id="a02be13fa85c9edfa183b39d1255ff6c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rayTrace </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntersectorT &amp;&#160;</td>
          <td class="paramname"><em>inter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1BaseShader.html">BaseShader</a> &amp;&#160;</td>
          <td class="paramname"><em>shader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1BaseCamera.html">BaseCamera</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pixelSamples</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ray-trace a volume using a given ray intersector. </p>

</div>
</div>
<a class="anchor" id="ae190c2befe2b252b8d930bd632964ab7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resampleToMatch </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>inGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridType &amp;&#160;</td>
          <td class="paramname"><em>outGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Interrupter &amp;&#160;</td>
          <td class="paramname"><em>interrupter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resample an input grid into an output grid of the same type such that, after resampling, the input and output grids coincide (apart from sampling artifacts), but the output grid's transform is unchanged. </p>
<p>Specifically, this function resamples the input grid into the output grid's index space, using a sampling kernel like <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1PointSampler.html">PointSampler</a>, <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1BoxSampler.html">BoxSampler</a>, or <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1QuadraticSampler.html">QuadraticSampler</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inGrid</td><td>the grid to be resampled </td></tr>
    <tr><td class="paramname">outGrid</td><td>the grid into which to write the resampled voxel data </td></tr>
    <tr><td class="paramname">interrupter</td><td>an object adhering to the <a class="el" href="structopenvdb_1_1v8__0_1_1util_1_1NullInterrupter.html" title="Dummy NOOP interrupter class defining interface. ">util::NullInterrupter</a> interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="comment">// Create an input grid with the default identity transform</span></div><div class="line"><span class="comment">// and populate it with a level-set sphere.</span></div><div class="line"><a class="code" href="classopenvdb_1_1v8__0_1_1Grid.html#a84f71739738652d0987c7456128389be">FloatGrid::ConstPtr</a> src = tools::makeSphere(...);</div><div class="line"><span class="comment">// Create an output grid and give it a uniform-scale transform.</span></div><div class="line"><a class="code" href="classopenvdb_1_1v8__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">FloatGrid::Ptr</a> dest = <a class="code" href="classopenvdb_1_1v8__0_1_1Grid.html#afed9748b2280ee9155aa1033cc583bc7">FloatGrid::create</a>();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> voxelSize = 0.5;</div><div class="line">dest-&gt;setTransform(<a class="code" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html#ae35abe5d5592d24a97725f90eb3ce3f1">math::Transform::createLinearTransform</a>(voxelSize));</div><div class="line"><span class="comment">// Resample the input grid into the output grid, reproducing</span></div><div class="line"><span class="comment">// the level-set sphere at a smaller voxel size.</span></div><div class="line">MyInterrupter interrupter = ...;</div><div class="line">tools::resampleToMatch&lt;tools::QuadraticSampler&gt;(*src, *dest, interrupter);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="af4c63aac5d546c4e73dd5f2e8bf734ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resampleToMatch </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>inGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridType &amp;&#160;</td>
          <td class="paramname"><em>outGrid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resample an input grid into an output grid of the same type such that, after resampling, the input and output grids coincide (apart from sampling artifacts), but the output grid's transform is unchanged. </p>
<p>Specifically, this function resamples the input grid into the output grid's index space, using a sampling kernel like <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1PointSampler.html">PointSampler</a>, <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1BoxSampler.html">BoxSampler</a>, or <a class="el" href="structopenvdb_1_1v8__0_1_1tools_1_1QuadraticSampler.html">QuadraticSampler</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inGrid</td><td>the grid to be resampled </td></tr>
    <tr><td class="paramname">outGrid</td><td>the grid into which to write the resampled voxel data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="comment">// Create an input grid with the default identity transform</span></div><div class="line"><span class="comment">// and populate it with a level-set sphere.</span></div><div class="line"><a class="code" href="classopenvdb_1_1v8__0_1_1Grid.html#a84f71739738652d0987c7456128389be">FloatGrid::ConstPtr</a> src = tools::makeSphere(...);</div><div class="line"><span class="comment">// Create an output grid and give it a uniform-scale transform.</span></div><div class="line"><a class="code" href="classopenvdb_1_1v8__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">FloatGrid::Ptr</a> dest = <a class="code" href="classopenvdb_1_1v8__0_1_1Grid.html#afed9748b2280ee9155aa1033cc583bc7">FloatGrid::create</a>();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> voxelSize = 0.5;</div><div class="line">dest-&gt;setTransform(<a class="code" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html#ae35abe5d5592d24a97725f90eb3ce3f1">math::Transform::createLinearTransform</a>(voxelSize));</div><div class="line"><span class="comment">// Resample the input grid into the output grid, reproducing</span></div><div class="line"><span class="comment">// the level-set sphere at a smaller voxel size.</span></div><div class="line">tools::resampleToMatch&lt;tools::QuadraticSampler&gt;(*src, *dest);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a59b83096927350f3324cba935be37717"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr sdfInteriorMask </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeType &amp;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridOrTreeType::ValueType&#160;</td>
          <td class="paramname"><em>isovalue</em> = <code>lsutilGridZero&lt;GridOrTreeType&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threaded method to construct a boolean mask that represents interior regions in a signed distance field. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to either a boolean grid or tree with the same tree configuration and potentially transform as the input <code>volume</code> and whose active and <code>true</code> values correspond to the interior of the input signed distance field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>Signed distance field / level set volume. </td></tr>
    <tr><td class="paramname">isovalue</td><td>Threshold below which values are considered part of the interior region. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6f5c23566a92043e7c3099699a86492"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SdfGridT::template ValueConverter&lt;ExtValueT&gt;::Type::Ptr openvdb::v8_0::tools::sdfToExt </td>
          <td>(</td>
          <td class="paramtype">const SdfGridT &amp;&#160;</td>
          <td class="paramname"><em>sdfGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtOpT &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtValueT &amp;&#160;</td>
          <td class="paramname"><em>background</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename SdfGridT::ValueType&#160;</td>
          <td class="paramname"><em>isoValue</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIter</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the extension of a scalar field, defined by the specified functor, off an iso-surface from an input SDF volume. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the extension field defined on the active values in the input signed distance field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdfGrid</td><td>An approximate signed distance field to the specified iso-surface.</td></tr>
    <tr><td class="paramname">op</td><td>Functor with signature [](const Vec3R &amp;xyz)-&gt;float that defines the Dirichlet boundary condition, on the iso-surface, of the field to be extended.</td></tr>
    <tr><td class="paramname">background</td><td>Background value of return grid with the extension field.</td></tr>
    <tr><td class="paramname">isoValue</td><td>A value which defines a smooth iso-surface that intersects active voxels in <em>sdfGrid</em>.</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The only difference between this method and fogToEXT, defined above, is the convention of the sign of the signed distance field.</dd></dl>
<p>Topology of output grid is identical to that of the input grid, except active tiles in the input grid will be converted to active voxels in the output grid!</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em>isoValue</em> does not intersect any active values in <em>sdfGrid</em> then the returned grid has all its active values set to <em>background</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1651975d1f7c66871d5e18c45fae099a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SdfGridT::template ValueConverter&lt;ExtValueT&gt;::Type::Ptr openvdb::v8_0::tools::sdfToExt </td>
          <td>(</td>
          <td class="paramtype">const SdfGridT &amp;&#160;</td>
          <td class="paramname"><em>sdfGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OpT &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtValueT &amp;&#160;</td>
          <td class="paramname"><em>background</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename SdfGridT::ValueType&#160;</td>
          <td class="paramname"><em>isoValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aad82d1b0039598209bc21cd9aa4511a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sdfToFogVolume </td>
          <td>(</td>
          <td class="paramtype">GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridType::ValueType&#160;</td>
          <td class="paramname"><em>cutoffDistance</em> = <code>lsutilGridMax&lt;GridType&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Threaded method to convert a sparse level set/SDF into a sparse fog volume. </p>
<p>For a level set, the active and negative-valued interior half of the narrow band becomes a linear ramp from 0 to 1; the inactive interior becomes active with a constant value of 1; and the exterior, including the background and the active exterior half of the narrow band, becomes inactive with a constant value of 0. The interior, though active, remains sparse.</p>
<p>For a generic SDF, a specified cutoff distance determines the width of the ramp, but otherwise the result is the same as for a level set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>level set/SDF grid to transform </td></tr>
    <tr><td class="paramname">cutoffDistance</td><td>optional world space cutoff distance for the ramp (automatically clamped if greater than the interior narrow band width) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ec6859a45f6b4fa6c0beb9687eabacd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr sdfToSdf </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>sdfGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridT::ValueType&#160;</td>
          <td class="paramname"><em>isoValue</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIter</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an existing approximate SDF it solves the Eikonal equation for all its active voxels. Active input voxels with a signed distance value above the given isoValue will have POSITIVE distance values on output, i.e. they are assumed to be OUTSIDE the iso-surface. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a signed-distance field defined on the active values of the input sdf volume.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdfGrid</td><td>An approximate signed distance field to the specified iso-surface.</td></tr>
    <tr><td class="paramname">isoValue</td><td>A value which defines a smooth iso-surface that intersects active voxels in <em>sdfGrid</em>.</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The only difference between this method and fogToSdf, defined above, is the convention of the sign of the output distance field.</dd></dl>
<p>Topology of output grid is identical to that of the input grid, except active tiles in the input grid will be converted to active voxels in the output grid!</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em>isoValue</em> does not intersect any active values in <em>sdfGrid</em> then the returned grid has all its active values set to plus or minus infinity, depending on if the input values are larger or smaller than <em>isoValue</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b430d0d5e79eaa7c822b7ec72d45fb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename SdfGridT::Ptr, typename SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr &gt; sdfToSdfAndExt </td>
          <td>(</td>
          <td class="paramtype">const SdfGridT &amp;&#160;</td>
          <td class="paramname"><em>sdfGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtOpT &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtValueT &amp;&#160;</td>
          <td class="paramname"><em>background</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename SdfGridT::ValueType&#160;</td>
          <td class="paramname"><em>isoValue</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIter</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the signed distance field and the extension of a scalar field, defined by the specified functor, off an iso-surface from an input SDF volume. </p>
<dl class="section return"><dt>Returns</dt><dd>A pair of two shared pointers to respectively the SDF and extension field</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdfGrid</td><td>Scalar (floating-point) volume from which an iso-surface can be defined.</td></tr>
    <tr><td class="paramname">op</td><td>Functor with signature [](const Vec3R &amp;xyz)-&gt;float that defines the Dirichlet boundary condition, on the iso-surface, of the field to be extended.</td></tr>
    <tr><td class="paramname">background</td><td>Background value of return grid with the extension field.</td></tr>
    <tr><td class="paramname">isoValue</td><td>A value which defines a smooth iso-surface that intersects active voxels in <em>sdfGrid</em>.</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Strictly speaking a fog volume is normalized to the range [0,1] but this method accepts a scalar volume with an arbitary range, as long as the it includes the <em>isoValue</em>.</dd></dl>
<p>Topology of output grids are identical to that of the input grid, except active tiles in the input grid will be converted to active voxels in the output grids!</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em>isoValue</em> does not intersect any active values in <em>sdfGrid</em> then a pair of the following grids is returned: The first is a signed distance grid with its active values set to plus or minus infinity depending of whether its input values are above or below <em>isoValue</em>. The second grid, which represents the extension field, has all its active values set to <em>background</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cc2d4f60d561afd2fb248e386ca67d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void segmentActiveVoxels </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeType &amp;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename GridOrTreeType::Ptr &gt; &amp;&#160;</td>
          <td class="paramname"><em>segments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Separates disjoint active topology components into distinct grids or trees. </p>
<p>Supports volumes with active tiles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>Input grid or tree </td></tr>
    <tr><td class="paramname">segments</td><td>Output set of disjoint active topology components sorted in descending order based on the active voxel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9f4df82ed92eb746d439ce4721ea8a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void segmentSDF </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeType &amp;&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename GridOrTreeType::Ptr &gt; &amp;&#160;</td>
          <td class="paramname"><em>segments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Separates disjoint SDF surfaces into distinct grids or trees. </p>
<p>Supports asymmetric interior / exterior narrowband widths and SDF volumes with dense interior regions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>Input signed distance field / level set volume </td></tr>
    <tr><td class="paramname">segments</td><td>Output set of disjoint SDF surfaces found in <em>volume</em> sorted in descending order based on the surface intersecting voxel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c76dc587d3f1735c0113f04ace2f257"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnMax </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates in <em>tree</em> to the maximum of its current value and <em>value</em>, and mark the voxel as active. </p>
<p>This is typically significantly faster than calling getValue() followed by setValueOn(). </p><dl class="section note"><dt>Note</dt><dd><em>TreeT</em> can be either a Tree or a ValueAccessor. </dd></dl>

</div>
</div>
<a class="anchor" id="adbdcf782cb40fcb514524737e2f8e070"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnMin </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates in <em>tree</em> to the minimum of its current value and <em>value</em>, and mark the voxel as active. </p>
<p>This is typically significantly faster than calling getValue() followed by setValueOn(). </p><dl class="section note"><dt>Note</dt><dd><em>TreeT</em> can be either a Tree or a ValueAccessor. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fa019501d9dddd1891421935c31efba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnMult </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates in <em>tree</em> to the product of its current value and <em>value</em>, and mark the voxel as active. </p>
<p>This is typically significantly faster than calling getValue() followed by setValueOn(). </p><dl class="section note"><dt>Note</dt><dd><em>TreeT</em> can be either a Tree or a ValueAccessor. </dd></dl>

</div>
</div>
<a class="anchor" id="a92d1e43e1896e1a7fa9548c4fd4a2988"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnSum </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates in <em>tree</em> to the sum of its current value and <em>value</em>, and mark the voxel as active. </p>
<p>This is typically significantly faster than calling getValue() followed by setValueOn(). </p><dl class="section note"><dt>Note</dt><dd><em>TreeT</em> can be either a Tree or a ValueAccessor. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8c1921d688e3c65c71aac5405f155a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void signedFloodFill </td>
          <td>(</td>
          <td class="paramtype">TreeOrLeafManagerT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainSize</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>minLevel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the values of all inactive voxels and tiles of a narrow-band level set from the signs of the active voxels, setting outside values to +background and inside values to -background. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method should only be used on closed, symmetric narrow-band level sets.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If a LeafManager is used the cached leaf nodes are reused, resulting in slightly better overall performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree or LeafManager that will be flood filled. </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1) </td></tr>
    <tr><td class="paramname">minLevel</td><td>Specify the lowest tree level to process (leafnode level = 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if the ValueType of <em>tree</em> is not floating-point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a059130a68dd01092e7db04afa0f2580e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void signedFloodFillWithValues </td>
          <td>(</td>
          <td class="paramtype">TreeOrLeafManagerT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeOrLeafManagerT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>outsideWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeOrLeafManagerT::ValueType &amp;&#160;</td>
          <td class="paramname"><em>insideWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainSize</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>minLevel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the values of all inactive voxels and tiles of a narrow-band level set from the signs of the active voxels, setting exterior values to <em>outsideWidth</em> and interior values to <em>insideWidth</em>. Set the background value of this tree to <em>outsideWidth</em>. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method should only be used on closed, narrow-band level sets.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If a LeafManager is used the cached leaf nodes are reused resulting in slightly better overall performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree or LeafManager that will be flood filled </td></tr>
    <tr><td class="paramname">outsideWidth</td><td>the width of the outside of the narrow band </td></tr>
    <tr><td class="paramname">insideWidth</td><td>the width of the inside of the narrow band </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1) </td></tr>
    <tr><td class="paramname">minLevel</td><td>Specify the lowest tree level to process (leafnode level = 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if the ValueType of <em>tree</em> is not floating-point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0298e9e5b5b3a443d321bd24825f1d5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Stats.html">math::Stats</a> statistics </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over a scalar grid and compute statistics (mean, variance, etc.) of the values of the voxels that are visited, or iterate over a vector-valued grid and compute statistics of the magnitudes of the vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over the values of a grid or its tree (<code><a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::ValueOffIter</code>, etc.) </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, iterate over the grid in parallel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada341f0cb3d7e02cb30f563ae58d77b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Stats.html">math::Stats</a> statistics </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over a grid and compute statistics (mean, variance, etc.) of the values produced by applying the given functor at each voxel that is visited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over the values of a grid or its tree (<code><a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::ValueOffIter</code>, etc.) </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <code>void op(const IterT&amp;, math::Stats&amp;)</code>, where <code>IterT</code> is the type of <em>iter</em>, that inserts zero or more floating-point values into the provided <code><a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Stats.html" title="This class computes statistics (minimum value, maximum value, mean, variance and standard deviation) ...">math::Stats</a></code> object </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, iterate over the grid in parallel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When <em>threaded</em> is true, each thread gets its own copy of the functor.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Compute statistics of just the active and positive-valued voxels of a scalar, floating-point grid. <div class="fragment"><div class="line"><span class="keyword">struct </span>Local {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span></div><div class="line">    <span class="keywordtype">void</span> addIfPositive(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v8__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">FloatGrid::ValueOnCIter</a>&amp; iter, math::Stats&amp; stats)</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> f = *iter;</div><div class="line">        <span class="keywordflow">if</span> (f &gt; 0.0) {</div><div class="line">            <span class="keywordflow">if</span> (iter.isVoxelValue()) stats.add(f);</div><div class="line">            <span class="keywordflow">else</span> stats.add(f, iter.getVoxelCount());</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> grid = ...;</div><div class="line">math::Stats stats =</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a0298e9e5b5b3a443d321bd24825f1d5a">tools::statistics</a>(grid.cbeginValueOn(), Local::addIfPositive, <span class="comment">/*threaded=*/</span><span class="keyword">true</span>);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="aabbae85c9cdcbfc824ca7222995f16ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::template ValueConverter&lt; float &gt;::Type::Ptr topologyToLevelSet </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>closingSteps</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dilation</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smoothingSteps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the narrow-band signed distance to the interface between active and inactive voxels in the input grid. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new sdf / level set grid of type <code>float</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>Input grid of arbitrary type whose active voxels are used in constructing the level set. </td></tr>
    <tr><td class="paramname">halfWidth</td><td>Half the width of the narrow band in voxel units. </td></tr>
    <tr><td class="paramname">closingSteps</td><td>Number of morphological closing steps used to fill gaps in the active voxel region. </td></tr>
    <tr><td class="paramname">dilation</td><td>Number of voxels to expand the active voxel region. </td></tr>
    <tr><td class="paramname">smoothingSteps</td><td>Number of smoothing interations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07e2f42e7a8c6243963b70dece2f8113"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::template ValueConverter&lt; float &gt;::Type::Ptr topologyToLevelSet </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>halfWidth</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>closingSteps</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dilation</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smoothingSteps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the narrow-band signed distance to the interface between active and inactive voxels in the input grid. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new sdf / level set grid of type <code>float</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>Input grid of arbitrary type whose active voxels are used in constructing the level set. </td></tr>
    <tr><td class="paramname">halfWidth</td><td>Half the width of the narrow band in voxel units. </td></tr>
    <tr><td class="paramname">closingSteps</td><td>Number of morphological closing steps used to fill gaps in the active voxel region. </td></tr>
    <tr><td class="paramname">dilation</td><td>Number of voxels to expand the active voxel region. </td></tr>
    <tr><td class="paramname">smoothingSteps</td><td>Number of smoothing interations. </td></tr>
    <tr><td class="paramname">interrupt</td><td>Optional object adhering to the <a class="el" href="structopenvdb_1_1v8__0_1_1util_1_1NullInterrupter.html" title="Dummy NOOP interrupter class defining interface. ">util::NullInterrupter</a> interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c971c289dca66c2e8500e01aac41bdf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void traceExteriorBoundaries </td>
          <td>(</td>
          <td class="paramtype">FloatTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traces the exterior voxel boundary of closed objects in the input volume <em>tree</em>. Exterior voxels are marked with a negative sign, voxels with a value below <code>0.75</code> are left unchanged and act as the boundary layer. </p>
<dl class="section note"><dt>Note</dt><dd>Does not propagate sign information into tile regions. </dd></dl>

</div>
</div>
<a class="anchor" id="a8fcc7df3409df7357565d418f7fb6e3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v8_0::tools::transformDense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Dense.html">Dense</a>&lt; ValueT, openvdb::tools::LayoutZYX &gt; &amp;&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OpType &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a point-wise functor to the intersection of a dense grid and a given bounding box </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dense</td><td>A dense grid to be transformed </td></tr>
    <tr><td class="paramname">bbox</td><td>Index space bounding box, define region where the transformation is applied </td></tr>
    <tr><td class="paramname">op</td><td>A functor that acts on the dense grid value type </td></tr>
    <tr><td class="paramname">parallel</td><td>Used to select multithreaded or single threaded Minimally, the <code>op</code> class has to support a <code>operator()</code> method, <div class="fragment"><div class="line"><span class="comment">// Square values in a grid</span></div><div class="line"><span class="keyword">struct </span>Op</div><div class="line">{</div><div class="line">    ValueT operator()(<span class="keyword">const</span> ValueT&amp; in)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="comment">// do work</span></div><div class="line">      ValueT result = in * in;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> result;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> NB: only <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Dense.html" title="Dense is a simple dense grid API used by the CopyToDense and CopyFromDense classes defined below...">Dense</a> grids with memory layout zxy are supported </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ac976d1526021421d99c73e70d726fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v8_0::tools::transformDense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1Dense.html">Dense</a>&lt; ValueT, openvdb::tools::LayoutZYX &gt; &amp;&#160;</td>
          <td class="paramname"><em>dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointwiseOpT &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a point-wise functor to the intersection of a dense grid and a given bounding box. </p>

</div>
</div>
<a class="anchor" id="ae870e81ce652b9c057d92dbe4b4b9811"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void transformValues </td>
          <td>(</td>
          <td class="paramtype">const InIterT &amp;&#160;</td>
          <td class="paramname"><em>inIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutGridT &amp;&#160;</td>
          <td class="paramname"><em>outGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XformOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shareOp</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0.html#ade9c95ac55c647839e6f3e9b462c0575">MergePolicy</a>&#160;</td>
          <td class="paramname"><em>merge</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#ade9c95ac55c647839e6f3e9b462c0575a89c44945b26534bc1d5ede51c342400e">MERGE_ACTIVE_STATES</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterate over a grid and at each step call <code>op(iter, accessor)</code> to populate (via the accessor) the given output grid, whose <code>ValueType</code> need not be the same as the input grid's. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inIter</td><td>a non-<code>const</code> or (preferably) <code>const</code> iterator over an input grid or its tree (<code><a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::NodeIter</code>, etc.) </td></tr>
    <tr><td class="paramname">outGrid</td><td>an empty grid to be populated </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <code>void op(const InIterT&amp;, OutGridT::ValueAccessor&amp;)</code>, where <code>InIterT</code> is the type of <em>inIter</em> </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, transform multiple values of the input grid in parallel </td></tr>
    <tr><td class="paramname">shareOp</td><td>if true and <em>threaded</em> is true, all threads use the same functor; otherwise, each thread gets its own copy of the <em>original</em> functor </td></tr>
    <tr><td class="paramname">merge</td><td>how to merge intermediate results from multiple threads (see Types.h)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd>Populate a scalar floating-point grid with the lengths of the vectors from all active voxels of a vector-valued input grid. <div class="fragment"><div class="line"><span class="keyword">struct </span>Local {</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> op(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v8__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Vec3fGrid::ValueOnCIter</a>&amp; iter,</div><div class="line">        FloatGrid::ValueAccessor&amp; accessor)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (iter.isVoxelValue()) { <span class="comment">// set a single voxel</span></div><div class="line">            accessor.setValue(iter.getCoord(), iter-&gt;length());</div><div class="line">        } <span class="keywordflow">else</span> { <span class="comment">// fill an entire tile</span></div><div class="line">            CoordBBox bbox;</div><div class="line">            iter.getBoundingBox(bbox);</div><div class="line">            accessor.getTree()-&gt;fill(bbox, iter-&gt;length());</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__0.html#a58332e5bdbbdb5a926507027db318e5b">Vec3fGrid</a> inGrid = ...;</div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> outGrid;</div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ae870e81ce652b9c057d92dbe4b4b9811">tools::transformValues</a>(inGrid.cbeginValueOn(), outGrid, Local::op);</div></div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>For more complex operations that require finer control over threading, consider using <code>tbb::parallel_for()</code> or <code>tbb::parallel_reduce()</code> in conjunction with a <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1IteratorRange.html">tree::IteratorRange</a> that wraps a grid or tree iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a21a43dc2e67d32098ee0f0b77e6b4aca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void transformValues </td>
          <td>(</td>
          <td class="paramtype">const InIterT &amp;&#160;</td>
          <td class="paramname"><em>inIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutGridT &amp;&#160;</td>
          <td class="paramname"><em>outGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XformOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shareOp</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__0.html#ade9c95ac55c647839e6f3e9b462c0575">MergePolicy</a>&#160;</td>
          <td class="paramname"><em>merge</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__0.html#ade9c95ac55c647839e6f3e9b462c0575a89c44945b26534bc1d5ede51c342400e">MERGE_ACTIVE_STATES</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a642190ccc3febe94d8b07ac37f892349"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void transformVectors </td>
          <td>(</td>
          <td class="paramtype">GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat4d &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply an affine transform to the voxel values of a vector-valued grid in accordance with the grid's vector type (covariant, contravariant, etc.). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if the grid is not vector-valued </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a136006bbdda1e616071dba827c34be79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uniqueInactiveValues </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename GridType::ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Threaded method to find unique inactive values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>A VDB volume. </td></tr>
    <tr><td class="paramname">values</td><td>List of unique inactive values, returned by this method. </td></tr>
    <tr><td class="paramname">numValues</td><td>Number of values to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the <em>grid</em> has more than <em>numValues</em> inactive values. </dd></dl>

</div>
</div>
<a class="anchor" id="a2641c8c08ca3ed3bf4cea4d9b52434b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void volumeToMesh </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Vec3s &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>isovalue</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uniformly mesh any scalar grid that has a continuous isosurface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar grid to mesh </td></tr>
    <tr><td class="paramname">points</td><td>output list of world space points </td></tr>
    <tr><td class="paramname">quads</td><td>output quad index list </td></tr>
    <tr><td class="paramname">isovalue</td><td>determines which isosurface to mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if <em>grid</em> does not have a scalar value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a576ce1469c40253573f9c3ad65369806"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void volumeToMesh </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Vec3s &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>isovalue</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>adaptivity</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>relaxDisorientedTriangles</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adaptively mesh any scalar grid that has a continuous isosurface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar grid to mesh </td></tr>
    <tr><td class="paramname">points</td><td>output list of world space points </td></tr>
    <tr><td class="paramname">triangles</td><td>output triangle index list </td></tr>
    <tr><td class="paramname">quads</td><td>output quad index list </td></tr>
    <tr><td class="paramname">isovalue</td><td>determines which isosurface to mesh </td></tr>
    <tr><td class="paramname">adaptivity</td><td>surface adaptivity threshold [0 to 1] </td></tr>
    <tr><td class="paramname">relaxDisorientedTriangles</td><td>toggle relaxing disoriented triangles during adaptive meshing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__0_1_1TypeError.html">TypeError</a></td><td>if <em>grid</em> does not have a scalar value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
