<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: OpenVDB Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenVDB</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">OpenVDB Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Contents"></a>
Contents</h1>
<ul>
<li><a class="el" href="overview.html#secOverview">Introduction</a></li>
<li><a class="el" href="overview.html#secTree">The Tree</a><ul>
<li><a class="el" href="overview.html#subsecTreeConfig">Tree Configuration</a></li>
</ul>
</li>
<li><a class="el" href="overview.html#secSparsity">Sparse Values and Voxels</a><ul>
<li><a class="el" href="overview.html#subsecValues">Tile, Voxel, and Background Values</a></li>
<li><a class="el" href="overview.html#subsecInactive">Active and Inactive Voxels</a></li>
</ul>
</li>
<li><a class="el" href="overview.html#secSpaceAndTrans">Coordinate Systems and Transforms</a><ul>
<li><a class="el" href="overview.html#subsecVoxSpace">Index Space</a></li>
<li><a class="el" href="overview.html#subsecWorSpace">World Space</a></li>
<li><a class="el" href="overview.html#subsecTrans">Transforms and Maps</a></li>
</ul>
</li>
<li><a class="el" href="overview.html#secGrid">The Grid</a></li>
<li><a class="el" href="overview.html#secToolUtils">Utilities and Tools</a></li>
<li><a class="el" href="overview.html#secIterator">Iterators</a><ul>
<li><a class="el" href="overview.html#subsecTreeIter">Tree Iterators</a></li>
<li><a class="el" href="overview.html#subsecNodeIter">Node Iterators</a></li>
<li><a class="el" href="overview.html#subsecValueAccessor">Value Accessor</a></li>
<li><a class="el" href="overview.html#subsecTraversal">Tree Traversal</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="secOverview"></a>
Introduction</h1>
<p>This document is a high-level summary of the terminology and basic components of the OpenVDB library and is organized around two key motivating concepts. First, OpenVDB is designed specifically to work efficiently with sparse volumetric data locally sampled at a high spatial frequency, although it will function well for dense volumetric data. From this follows the need for a memory efficient representation of this sparsity and the need for fast iterators (and other tools) that respect sparsity. Second, data storage is separated from data interpretation. OpenVDB uses unit-less three-dimensional integer coordinates to address the sparse data, but introduces a unit-less continuous index space for interpolation, along with a transform to place the data in physical space.</p>
<p>When manipulating data in OpenVDB, the three essential objects are (1)&#160;the <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1Tree.html">Tree</a>, a B-tree-like three-dimensional data structure; (2)&#160;the <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">Transform</a>, which relates voxel indices (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) to physical locations (<em>x</em>,&amp;nbsp <em>y</em>,&amp;nbsp <em>z</em>) in <a class="el" href="overview.html#subsecWorSpace">World Space</a> &ldquo;world&rdquo; space; and (3)&#160;the <a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html">Grid</a>, a container that associates a <b>Tree</b> with a <b>Transform</b> and additional metadata. For instancing purposes (i.e., placing copies of the same volume in multiple locations), the same tree may be referenced (via smart pointers) by several different <b>Grid</b>s, each having a unique transform.</p>
<p>We now proceed to discuss the <b>Tree</b> and ideas of sparsity in some detail, followed by a briefer description of the different spaces and transforms as well as some of the tools that act on the sparse data.</p>
<h1><a class="anchor" id="secTree"></a>
The Tree</h1>
<p>In OpenVDB the <b>Tree</b> data structure exists to answer the question <em>What value is stored at location (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) in three-dimensional index space?</em> Here <em>i</em>, <em>j</em> and <em>k</em> are arbitrary signed 32-bit integers, and the data type of the associated value (<code>float</code>, <code>bool</code>, vector, etc.) is the same for all (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>). While the <b>Tree</b> serves the same purpose as a large three-dimensional array, it is a specially designed data structure that, given sparse unique values, minimizes the overall memory footprint while retaining fast access times. This is accomplished, as the name suggests, via a tree-based acceleration structure comprising a <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1RootNode.html">RootNode</a>, <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafNode.html">LeafNode</a><b></b>s and usually one or more levels of <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1InternalNode.html">InternalNode</a><b></b>s with prescribed branching factors.</p>
<h2><a class="anchor" id="subsecTreeConfig"></a>
Tree Configuration</h2>
<p>The tree-based acceleration structure can be configured in various ways, but with the restriction that for a given tree all the <b>LeafNode</b>s are at the same depth. Conceptually, the <b>RootNode</b> and <b>InternalNode</b>s increasingly subdivide the three-dimensional index space, and the <b>LeafNode</b>s hold the actual unique voxels.</p>
<p>The type of a <b>Tree</b> encodes both the type of the data to be stored in the tree (<code>float</code>, <code>bool</code>, etc.) and the tree&rsquo;s node configuration. In practice a four-level (root, internal, internal, leaf) configuration is standard, and several common tree types are defined in <a class="el" href="openvdb_8h.html">openvdb.h</a>. For example, </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespaceopenvdb_1_1v8__0.html#a79a0127ad333d2a6201f025a0d9944f4">FloatTree</a> = tree::Tree4&lt;float, 5, 4, 3&gt;::Type;</div><div class="line"><span class="keyword">using</span> <a class="code" href="namespaceopenvdb_1_1v8__0.html#ac12ade07e19df3d551f17c429d7b4f10">BoolTree</a> = tree::Tree4&lt;bool, 5, 4, 3&gt;::Type;</div></div><!-- fragment --><p> These predefined tree types share the same branching factors, which dictate the number of children of a given node. The branching factors (5,&#160;4,&#160;3) are specified as base two logarithms and should be read backwards from the leaf nodes up the tree.</p>
<p>In the default tree configuration, each <b>LeafNode</b> holds a three-dimensional grid of 2<sup>3</sup> voxels on a side (i.e., an 8&times;8&times;8 voxel grid). Internally, the <b>LeafNode</b> is said to be at &ldquo;level&#160;0&rdquo; of the tree. At &ldquo;level&#160;1&rdquo; of this tree is the first <b>InternalNode</b>, and it indexes a 2<sup>4</sup>&times;2<sup>4</sup>&times;2<sup>4</sup> = 16&times;16&times;16 grid, each entry of which is either a <b>LeafNode</b> or a constant value that represents an 8&times;8&times;8 block of voxels. At &ldquo;level&#160;2&rdquo; is the second <b>InternalNode</b> in this configuration; it in turn indexes a 2<sup>5</sup>&times;2<sup>5</sup>&times;2<sup>5</sup> = 32&times;32&times;32 grid of level-1 <b>InternalNode</b>s and/or values, and so the <b>InternalNode</b> at level&#160;2 subsumes a three-dimensional block of voxels of size 32&times;16&times;8 = 4096 on a side. Unlike the <b>InternalNode</b>s and <b>LeafNode</b>s, the <b>RootNode</b> (&ldquo;level&#160;3&rdquo; for the default configuration) is not explicitly restricted in the number of children it may have, so the overall index space is limited only by the range of the integer indices, which are 32-bit by default.</p>
<h1><a class="anchor" id="secSparsity"></a>
Sparse Values and Voxels</h1>
<p>Like a tree&rsquo;s node configuration, the type of data held by a tree is determined at compile time. Conceptually the tree itself employs two different notions of data sparsity to reduce the memory footprint and at the same time accelerate access to its contents. The first is largely hidden from the user and concerns ways in which large regions of uniform values are compactly represented, and the second allows for fast sequential iteration, skipping user-specified &ldquo;uninteresting&rdquo; regions (that may or may not have uniform values).</p>
<h2><a class="anchor" id="subsecValues"></a>
Tile, Voxel, and Background Values</h2>
<p>Although the data in a tree is accessed and set on a per-voxel level (i.e., the value at (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>)) it need not be internally stored in that way. To reduce the memory footprint and accelerate data access, data values are stored in three distinct forms internal to the tree: <b>voxel values</b>, <b>tile values</b>, and a <b>background value</b>. A voxel value is a unique value indexed by the location of a voxel and is stored in the <b>LeafNode</b> responsible for that voxel. A tile value is a uniform value assigned to all voxels subsumed by a given node. (For example, a tile Value belonging to an <b>InternalNode</b> at level&#160;1 is equivalent to a constant-value cube of voxels of the same size, 8&times;8&times;8, as a <b>LeafNode</b>.) The tile value is returned when a request is made for the data associated with any (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) location within the uniform tile. The background value is a unique value (stored at the root level) that is returned when accessing any (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) location that does not resolve to either a tile or a <b>LeafNode</b>.</p>
<h2><a class="anchor" id="subsecInactive"></a>
Active and Inactive Voxels</h2>
<p>Any voxel or tile can be classified as either <b>active</b> or <b>inactive</b>. The interpretation of this state is application-specific, but generally active voxels are &ldquo;interesting&rdquo; and inactive somehow less so. The locations of active values may be sparse in the overall voxel topology, and OpenVDB provides <a class="el" href="overview.html#secIterator">iterators</a> that access active values only (as well as iterators over inactive values, all values, and general topology). An example of active vs. inactive: the voxels used to store the distance values of a narrow-band level set (i.e., close to a given surface) will be marked as active while the other (&ldquo;far&rdquo;) voxel locations will be marked as inactive and will generally represent regions of space with constant distance values (e.g., two constant distance values of opposite sign to distinguish the enclosed inside region from the infinite outside or background embedding).</p>
<p>The <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1Tree.html#a462c7056adc55d8da2cc5828934ff859">prune</a> method replaces with tile values any nodes that subsume voxels with the same values and active states. The resulting tree represents the same volume, but more sparsely.</p>
<h1><a class="anchor" id="secSpaceAndTrans"></a>
Coordinate Systems and Transforms</h1>
<p>The sampled data in the tree is accessed using signed <b>index coordinates</b> (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>), but associating each indicial coordinate with a specific physical location is the job of a <b>Transform</b>. A simple linear transform assumes a lattice-like structure with a fixed physical distance&#160;&Delta; between indices, so that (<em>x</em>,&amp;nbsp <em>y</em>,&amp;nbsp <em>z</em>) = (&Delta;<em>i</em>,&#160;&Delta;<em>j</em>,&#160;&Delta;<em>k</em>).</p>
<h2><a class="anchor" id="subsecVoxSpace"></a>
Index Space</h2>
<p>To simplify transformations between physical space and lattice index coordinates, a continuous generalization of the index lattice points called <b>index space</b> is used. For example, index space coordinate (1.0, 1.0, 1.0) corresponds to the same point as (1,1,1) in the index lattice, but (1.5,1.0,1.0) also has meaning as halfway between the index coordinates (1,1,1) and (2,1,1). Index space can be used in constructing interpolated data values: given an arbitrary location in physical space, one can use a transform to compute the point in index space (which need not fall on an exact integer index) that maps to that location and locally interpolate from values with neighboring index coordinates.</p>
<h2><a class="anchor" id="subsecWorSpace"></a>
World Space</h2>
<p>The interpretation of the data in a tree takes place in <b>world space</b>. For example, the tree might hold data sampled at discrete physical locations in world space. <b>Transform</b> methods such as <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html#a9b0e6d022b2571d4b0551704406ac4ba">indexToWorld</a> and its inverse <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html#a917d728a21347bc8528cfdcd0cbada38">worldToIndex</a> may be used to relate coordinates in the two continuous spaces. In addition, methods such as <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html#a63423207db89c360676357577e25175d">worldToIndexCellCentered</a> actually return lattice points.</p>
<h2><a class="anchor" id="subsecTrans"></a>
Transforms and Maps</h2>
<p>A <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">Transform </a> provides a context for interpreting the information held in a tree by associating a location in world space with each entry in the tree. The actual implementation of the <b>Transform</b> is managed by a <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1MapBase.html">Map</a> object, which is an encapsulation of a continuous, mostly invertible function of three variables. A <b>Map</b> is required to provide <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1MapBase.html#ab73d501388bb6b4da00a3604a1f1d907">applyMap</a> and <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1MapBase.html#a23e1a30c6ff6d75a23ed489b157e8ffe">applyInverseMap</a> methods to relate locations in its domain to its range and vice versa. A <b>Map</b> is also required to provide information about its local derivatives. For more on these classes, see the <a class="el" href="transformsAndMaps.html">Transforms and Maps</a> page.</p>
<h1><a class="anchor" id="secGrid"></a>
The Grid</h1>
<p>For many applications, it might not be necessary ever to operate directly on trees, though there are often significant performance improvements to be gained by exploiting the tree structure. The <a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html">Grid</a>, however, is the preferred interface through which to manage voxel data, in part because a grid associates with a tree additional and often necessary information that is not accessible through the tree itself.</p>
<p>A <a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html">Grid</a> contains smart pointers to a <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1Tree.html">Tree</a> object and a <a class="el" href="classopenvdb_1_1v8__0_1_1math_1_1Transform.html">Transform</a> object, either or both of which might be shared with other grids. As mentioned above, the transform provides for the interpretation of voxel locations. Other grid metadata, notably the <b>grid class</b>, the <b>vector type</b> and the world&#160;space/local space toggle, affect the interpretation of voxel values.</p>
<p>OpenVDB is particularly well-suited (though by no means exclusively so) to the representation of <b>narrow-band level sets</b> and <b>fog volumes</b>. A narrow-band level set is represented by three distinct regions of voxels: an <b>outside</b> (or background) region of inactive voxels having a constant, positive distance from the level set surface; an <b>inside</b> region of inactive voxels having a constant, negative distance; and a thin band of active voxels (normally three voxels wide on either side of the surface) whose values are signed distances. Similarly, a fog volume is represented by an outside region of inactive voxels with value zero, an inside region of active voxels with value one, and a thin band of active voxels, with values typically varying linearly between zero and one, that separates the inside from the outside. Identifying a grid as a level set or a fog volume, by setting its <a class="el" href="namespaceopenvdb_1_1v8__0.html#a511a7f5bd868162ec06bcc20b98e160e">grid class</a> with <a class="el" href="classopenvdb_1_1v8__0_1_1GridBase.html#a60f870194239aba95a3a0a01597d391a">setGridClass</a>, allows tools to invoke alternative implementations that are better-suited or better-optimized for those classes. For example, resampling (in particular, scaling) a level set should normally not be done without updating its signed distance values. The <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ae190c2befe2b252b8d930bd632964ab7">resampleToMatch</a> tool automatically recomputes signed distances for grids that are identified as level sets. (The lower-level <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1GridResampler.html">GridResampler</a> does not, but it is optimized for level set grids in that it transforms only voxels in the narrow band and relies on <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ab8c1921d688e3c65c71aac5405f155a9">signed flood fill</a> to reconstruct the inside and outside regions.) Other tools whose behavior is affected by the grid class include the <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#ad9d4adc505e30de4684d20efdcb66512">divergence</a> operator (which has an alternative implementation for <a class="el" href="transformsAndMaps.html#sStaggered">staggered velocity</a> grids), the <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a2641c8c08ca3ed3bf4cea4d9b52434b5">volume to mesh</a> converter, and the <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#af3f0e9f42ab322b7dd0f54dfb5b28556">sphere packing</a> tool. In addition, a number of level-set-specific tools, such as the <a class="el" href="classopenvdb_1_1v8__0_1_1tools_1_1LevelSetTracker.html">level set tracker</a>, throw exceptions when invoked on grids that are not identified as level sets. It is important, therefore, to set a grid&rsquo;s class appropriately.</p>
<p>When a vector-valued grid is transformed or resampled, it is often necessary for the transform to be applied not just to voxel locations but also to voxel values. By default, grids are identified as &ldquo;world-space&rdquo;, meaning that if the grid is vector-valued, its voxel values should be transformed. Alternatively, voxel values of grids identified as &ldquo;local-space&rdquo;, via <a class="el" href="classopenvdb_1_1v8__0_1_1GridBase.html#af7d08f61e709400a7ecf2c8da101f52f">setIsInWorldSpace</a>, do not undergo transformation. A world-space grid&rsquo;s <a class="el" href="namespaceopenvdb_1_1v8__0.html#ae93f92d10730a52ed3b207d5811f6a6e">vector type</a>, specified with <a class="el" href="classopenvdb_1_1v8__0_1_1GridBase.html#a84dcd39f42e4f0558516c040e576fe03">setVectorType</a>, may be invariant, covariant or contravariant, which determines how transforms are applied to the grid&rsquo;s voxel values (for details see, for example, <a href="http://en.wikipedia.org/wiki/Covariance_and_contravariance_of_vectors"><em>Covariance and contravariance of vectors</em></a>&#160;[Wikipedia]). The <a class="el" href="namespaceopenvdb_1_1v8__0_1_1tools.html#a642190ccc3febe94d8b07ac37f892349">transformVectors</a> tool can be used to apply a transform to a grid&rsquo;s voxel values, and it handles all of the supported vector types.</p>
<p>A grid can optionally be assigned <a class="el" href="classopenvdb_1_1v8__0_1_1GridBase.html#a36c59a26f0317be12cea01f8dea24ec7">name</a> and <a class="el" href="classopenvdb_1_1v8__0_1_1GridBase.html#ab8ca1d751197a95b14a8b1f9cadbe81e">creator</a> strings. These are purely informational, though it might be desirable to name grids so as to easily select which ones to read from files that contain multiple grids. In the absence of grid names, or at least of unique names, OpenVDB&rsquo;s file I/O routines recognize an ordinal suffix: &ldquo;<code>[0]</code>&rdquo; refers to the first unnamed grid, &ldquo;<code>[1]</code>&rdquo; refers to the second, and so on, and &ldquo;<code>density[0]</code>&rdquo; and &ldquo;<code>density[1]</code>&rdquo; refer to the first and second grids named &ldquo;density&rdquo;. Also of interest for file I/O is a grid&rsquo;s &ldquo;<a class="el" href="classopenvdb_1_1v8__0_1_1GridBase.html#a2718ae098c784d28d4c13868e0aab0da">save float as half</a>&rdquo; setting, which allows it to be written more compactly using 16-bit floating point values rather than full-precision values. Finally, during file output certain statistics are computed and stored as per-grid metadata. These include the grid&rsquo;s index-space active voxel bounding box, its active voxel count and its memory usage in bytes. This information can also be <a class="el" href="classopenvdb_1_1v8__0_1_1io_1_1File.html#abf37aaa82022716eede54e8d58b94c20">retrieved</a> efficiently from a file.</p>
<h1><a class="anchor" id="secToolUtils"></a>
Utilities and Tools</h1>
<p>OpenVDB provides utility functions and classes for the manipulation of grids and the data they hold. Tools such as those found in <a class="el" href="GridOperators_8h.html" title="Apply an operator to an input grid to produce an output grid with the same active voxel topology but ...">GridOperators.h</a> compute vector quantities from scalar data or vice-versa. Other tools perform filtering (<a class="el" href="Filter_8h.html" title="Filtering of VDB volumes. Note that only the values in the grid are changed, not its topology! All op...">Filter.h</a> and <a class="el" href="LevelSetFilter_8h.html" title="Performs various types of level set deformations with interface tracking. These unrestricted deformat...">LevelSetFilter.h</a>) and interpolation (<a class="el" href="Interpolation_8h.html">Interpolation.h</a>) as well as sampling (<a class="el" href="GridTransformer_8h.html">GridTransformer.h</a>), compositing and constructive solid geometry (<a class="el" href="Composite_8h.html" title="Functions to efficiently perform various compositing operations on grids. ">Composite.h</a>), and other transformations (<a class="el" href="ValueTransformer_8h.html">ValueTransformer.h</a>). OpenVDB also supports advanced finite difference computations through a variety of local support stencils (<a class="el" href="Stencils_8h.html" title="Defines various finite difference stencils by means of the &quot;curiously recurring template pattern&quot; on ...">Stencils.h</a>).</p>
<h1><a class="anchor" id="secIterator"></a>
Iterators</h1>
<p>OpenVDB provides efficient, often multithreaded, implementations of a large variety of morphological, filtering and other algorithms that address common data manipulation tasks on three-dimensional grids. For more specialized tasks, OpenVDB provides lower-level data accessors that enable fast iteration over all or selected voxels and over the elements of a <b>Tree</b>. These take several forms: iterator classes of various types, functor-based <b>visitor</b> methods, and the <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>, an accelerator for indexed (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) voxel lookups.</p>
<p>Iterator classes follow a fairly consistent naming scheme. First, the <b>CIter</b> and <b>Iter</b> suffixes denote <code>const</code> and non-<code>const</code> iterators, i.e., iterators that offer, respectively, read-only and read/write access to the underlying tree or node. Second, iterators over tile and voxel values are denoted either <b>On</b>, <b>Off</b> or <b>All</b>, indicating that they visit only active values, only inactive values, or both active and inactive values. So, for example, <b>Tree::ValueOnCIter</b> is a read-only iterator over all active values (both tile and voxel) of a tree, whereas <b>LeafNode::ValueAllIter</b> is a read/write iterator over all values, both active and inactive, of a single leaf node.</p>
<p>OpenVDB iterators are not STL-compatible in that one can always request an iterator that points to the beginning of a collection of elements (nodes, voxels, etc.), but one usually cannot request an iterator that points to the end of the collection. (This is because finding the end might require a full tree traversal.) Instead, all OpenVDB iterators implement a <b>test</b> method that returns <code>true</code> as long as the iterator is not exhausted and <code>false</code> as soon as it is. Typical usage is as follows: </p><div class="fragment"><div class="line"><span class="keyword">using</span> GridType = <a class="code" href="namespaceopenvdb_1_1v8__0.html#a2ae45d4df056c7d0d936a496fec925ee">openvdb::FloatGrid</a>;</div><div class="line">GridType grid = ...;</div><div class="line"><span class="keywordflow">for</span> (GridType::ValueOnCIter iter = grid.cbeginValueOn(); iter.test(); ++iter) ...</div></div><!-- fragment --><p> or more compactly </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> iter = grid.cbeginValueOn(); iter; ++iter) ...</div></div><!-- fragment --><p> Note that the naming scheme for methods that return &ldquo;begin&rdquo; iterators closely mirrors that of the iterators themselves. That is, <b>Grid::cbeginValueOn</b> returns a <code>const</code> iterator to the first of a grid&rsquo;s active values, whereas <b>LeafNode::beginValueAll</b> returns a non-<code>const</code> iterator to the first of a leaf node&rsquo;s values, both active and inactive. (<code>const</code> overloads of <b>begin</b>* methods are usually provided, so that if the <b>Grid</b> is itself <code>const</code>, <b>Grid::begin</b>* will actually return a <code>const</code> iterator. This makes it more convenient to use these methods in templated code.)</p>
<p>Finally, note that modifying the tree or node over which one is iterating typically does not invalidate the iterator, though it might first need to be incremented to point to the next existing element (for example, if one deletes a child node to which the iterator is currently pointing).</p>
<h2><a class="anchor" id="subsecTreeIter"></a>
Tree Iterators</h2>
<p><a class="anchor" id="treeValueIterRef"></a></p><dl class="section user"><dt>Tree::ValueIter</dt><dd>Tree-level value iterators traverse an entire tree, visiting each value (tile or voxel) exactly once. (It is also possible to restrict the traversal to minimum and maximum levels of the tree.) In addition to the methods common to all OpenVDB iterators, such as <b>test</b> and <b>next</b>, a <b>Tree::ValueIter</b> provides methods that return the depth in the tree of the node within which the iterator is pointing (the root node has depth&#160;0) and the (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) axis-aligned bounding box of the tile or voxel to which it is pointing, and methods to get and set both the value and the active state of the tile or voxel. See the <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1TreeValueIteratorBase.html">TreeValueIteratorBase </a> class for the complete list.</dd></dl>
<p><a class="anchor" id="treeLeafIterRef"></a></p><dl class="section user"><dt>Tree::LeafIter</dt><dd>By convention in OpenVDB, voxels in the narrow band of a narrow-band level set are stored only at the leaf level of a tree, so to facilitate the implementation of level set algorithms that operate on narrow-band voxels, OpenVDB provides an iterator that visits each <b>LeafNode</b> in a tree exactly once. See the <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafIteratorBase.html">LeafIteratorBase</a> class for details, and also the related <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1LeafManager.html">LeafManager</a> acceleration structure.</dd></dl>
<p><a class="anchor" id="treeNodeIterRef"></a></p><dl class="section user"><dt>Tree::NodeIter</dt><dd>A node iterator traverses a tree in depth-first order, starting from its root, and visits each node exactly once. (It is also possible to restrict the traversal to minimum and maximum node depths&mdash;see the <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1NodeIteratorBase.html">NodeIteratorBase </a> class for details.) Like the tree-level value iterator, the node iterator provides methods that return the depth in the tree of the node to which the iterator is pointing (the root node has depth&#160;0) and the (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) axis-aligned bounding box of the voxels subsumed by the node and all of its children. </dd></dl>
<dl class="section user"><dt></dt><dd>Naturally, a node iterator also provides access to the node to which it is pointing, but this is complicated somewhat by the fact that nodes of the various types (<b>RootNode</b>, <b>InternalNode</b> and <b>LeafNode</b>) do not inherit from a common base class. For efficiency, OpenVDB generally avoids class inheritance and virtual functions in favor of templates, allowing the compiler to optimize away function calls. In particular, each node type is templated on the type of its children, so even two <b>InternalNode</b>s at different levels of a tree have distinct types. As a result, it is necessary to know the type of the node to which a node iterator is pointing in order to request access to that node. See the <a class="el" href="codeExamples.html#sNodeIterator">Cookbook</a> for an example of how to do this.</dd></dl>
<h2><a class="anchor" id="subsecNodeIter"></a>
Node Iterators</h2>
<p>Less commonly used than tree-level iterators (but found in the implementations of some of the narrow-band level set algorithms referred to <a class="el" href="overview.html#treeLeafIterRef">above</a>) are node-level iterators. A node <b>value iterator</b> visits the values (active, inactive or both) stored in a single <b>RootNode</b>, <b>InternalNode</b> or <b>LeafNode</b>, whereas a node <b>child iterator</b> visits the children of a single root or internal node. (Recall that non-leaf nodes store either a tile value or a child node at each grid position.)</p>
<h2><a class="anchor" id="subsecValueAccessor"></a>
Value Accessor</h2>
<p>When traversing a grid by (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) index in a spatially coherent pattern, such as when iterating over neighboring voxels, request a <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1ValueAccessor.html">ValueAccessor</a> from the grid (with <a class="el" href="classopenvdb_1_1v8__0_1_1Grid.html#afd9327e5a015e2e860017765f0eb372c">Grid::getAccessor</a>) and use the accessor&rsquo;s <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1ValueAccessor.html#aa0cec1da633233009e933bb56b1ec345">getValue</a> and <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1ValueAccessor.html#a83302a39df403b0b10ffcadac5856916">setValue</a> methods, since these will usually be significantly faster (a factor of three is typical) than accessing voxels directly in the grid&rsquo;s tree. The accessor records the sequence of nodes visited during the most recent access; on the next access, rather than traversing the tree from the root node down, it performs an inverted traversal from the deepest recorded node up. For neighboring voxels, the traversal need only proceed as far as the voxels&rsquo; common ancestor node, which more often than not is the first node in the sequence.</p>
<p>Multiple accessors may be associated with a single grid. In fact, for multithreaded, read-only access to a grid, it is recommended that each thread be assigned its own accessor. A thread-safe, mutex-locked accessor is provided (see <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1ValueAccessorRW.html">ValueAccessorRW</a>), but the locking negates much of the performance benefit of inverted traversal; and because it is the accessor object that is thread-safe, not the grid, concurrent reads and writes are not safe unless all threads share a single accessor.</p>
<p>All accessors associated with a grid must be cleared after any operation that removes nodes from the grid&rsquo;s tree, such as pruning, CSG or compositing. For those and other built-in operations, this is done automatically via a callback mechanism, but developers must be careful to call <a class="el" href="classopenvdb_1_1v8__0_1_1tree_1_1Tree.html#a24a9fa1c5dbac50f2d5f406f8842e368">Tree::clearAllAccessors</a> whenever deleting nodes directly.</p>
<h2><a class="anchor" id="subsecTraversal"></a>
Tree Traversal</h2>
<p><em>To be written</em> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
