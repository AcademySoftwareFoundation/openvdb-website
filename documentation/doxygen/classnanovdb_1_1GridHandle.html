<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: GridHandle&lt; BufferT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classnanovdb_1_1GridHandle.html','','classnanovdb_1_1GridHandle-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">GridHandle&lt; BufferT &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class serves to manage a buffer containing one or more NanoVDB Grids.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="GridHandle_8h_source.html">nanovdb/GridHandle.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab9394c0860a72744306b73a0f9cfe87c" id="r_ab9394c0860a72744306b73a0f9cfe87c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9394c0860a72744306b73a0f9cfe87c">BufferType</a> = BufferT</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc14689d7fc4a9b9432b899211a309ec" id="r_adc14689d7fc4a9b9432b899211a309ec"><td class="memTemplParams" colspan="2">template&lt;typename T = BufferT, typename <a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; T &gt;::hasDeviceDual, int &gt;::type = 0&gt; </td></tr>
<tr class="memitem:adc14689d7fc4a9b9432b899211a309ec template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc14689d7fc4a9b9432b899211a309ec">GridHandle</a> (T &amp;&amp;<a class="el" href="#a27d8a3674328a33d9e2c43b1fd3f0166">buffer</a>)</td></tr>
<tr class="memdesc:adc14689d7fc4a9b9432b899211a309ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor from a dual host-device buffer.  <br /></td></tr>
<tr class="memitem:adc14689d7fc4a9b9432b899211a309ec" id="r_adc14689d7fc4a9b9432b899211a309ec"><td class="memTemplParams" colspan="2">template&lt;typename T = BufferT, typename <a class="el" href="structnanovdb_1_1util_1_1disable__if.html">util::disable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; T &gt;::hasDeviceDual, int &gt;::type = 0&gt; </td></tr>
<tr class="memitem:adc14689d7fc4a9b9432b899211a309ec template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc14689d7fc4a9b9432b899211a309ec">GridHandle</a> (T &amp;&amp;<a class="el" href="#a27d8a3674328a33d9e2c43b1fd3f0166">buffer</a>)</td></tr>
<tr class="memdesc:adc14689d7fc4a9b9432b899211a309ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor from a host buffer.  <br /></td></tr>
<tr class="memitem:afaae13e5113d0e32d6f758ca748652f9" id="r_afaae13e5113d0e32d6f758ca748652f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaae13e5113d0e32d6f758ca748652f9">GridHandle</a> ()=default</td></tr>
<tr class="memdesc:afaae13e5113d0e32d6f758ca748652f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a>.  <br /></td></tr>
<tr class="memitem:a3bc536fa3086174cdac78304c0df0130" id="r_a3bc536fa3086174cdac78304c0df0130"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bc536fa3086174cdac78304c0df0130">GridHandle</a> (const <a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a> &amp;)=delete</td></tr>
<tr class="memdesc:a3bc536fa3086174cdac78304c0df0130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow copy-construction.  <br /></td></tr>
<tr class="memitem:a838e184a2851ad71ee5b238b776016ab" id="r_a838e184a2851ad71ee5b238b776016ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a838e184a2851ad71ee5b238b776016ab">GridHandle</a> (<a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a838e184a2851ad71ee5b238b776016ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move copy-constructor.  <br /></td></tr>
<tr class="memitem:ad20897c5c8bd47f5d4005989bead0e55" id="r_ad20897c5c8bd47f5d4005989bead0e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad20897c5c8bd47f5d4005989bead0e55">reset</a> ()</td></tr>
<tr class="memdesc:ad20897c5c8bd47f5d4005989bead0e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> to an empty handle  <br /></td></tr>
<tr class="memitem:a0fde638bdd0e584fd3491afc93bb28b4" id="r_a0fde638bdd0e584fd3491afc93bb28b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fde638bdd0e584fd3491afc93bb28b4">operator=</a> (const <a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a> &amp;)=delete</td></tr>
<tr class="memdesc:a0fde638bdd0e584fd3491afc93bb28b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow copy assignment operation.  <br /></td></tr>
<tr class="memitem:a467f69248588aaa9b3fed08129892451" id="r_a467f69248588aaa9b3fed08129892451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a467f69248588aaa9b3fed08129892451">operator=</a> (<a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a467f69248588aaa9b3fed08129892451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move copy assignment operation.  <br /></td></tr>
<tr class="memitem:ac3b4f299904b94b8e644605cfbbd36c8" id="r_ac3b4f299904b94b8e644605cfbbd36c8"><td class="memTemplParams" colspan="2">template&lt;typename OtherBufferT = HostBuffer&gt; </td></tr>
<tr class="memitem:ac3b4f299904b94b8e644605cfbbd36c8 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a>&lt; OtherBufferT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3b4f299904b94b8e644605cfbbd36c8">copy</a> (const OtherBufferT &amp;<a class="el" href="#a27d8a3674328a33d9e2c43b1fd3f0166">buffer</a>=OtherBufferT()) const</td></tr>
<tr class="memdesc:ac3b4f299904b94b8e644605cfbbd36c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep copy of the <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a>, possibly templated on a different buffer type.  <br /></td></tr>
<tr class="memitem:a27d8a3674328a33d9e2c43b1fd3f0166" id="r_a27d8a3674328a33d9e2c43b1fd3f0166"><td class="memItemLeft" align="right" valign="top">BufferT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27d8a3674328a33d9e2c43b1fd3f0166">buffer</a> ()</td></tr>
<tr class="memdesc:a27d8a3674328a33d9e2c43b1fd3f0166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the buffer.  <br /></td></tr>
<tr class="memitem:a81689bd02e9e6a7e1f14d5613a3ec176" id="r_a81689bd02e9e6a7e1f14d5613a3ec176"><td class="memItemLeft" align="right" valign="top">const BufferT &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81689bd02e9e6a7e1f14d5613a3ec176">buffer</a> () const</td></tr>
<tr class="memdesc:a81689bd02e9e6a7e1f14d5613a3ec176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the buffer.  <br /></td></tr>
<tr class="memitem:a0189be0971a32a0171c51b90a1ab1020" id="r_a0189be0971a32a0171c51b90a1ab1020"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0189be0971a32a0171c51b90a1ab1020">data</a> ()</td></tr>
<tr class="memdesc:a0189be0971a32a0171c51b90a1ab1020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-const pointer to the data.  <br /></td></tr>
<tr class="memitem:a332a750ed35277f0bc297fbfecce598f" id="r_a332a750ed35277f0bc297fbfecce598f"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a332a750ed35277f0bc297fbfecce598f">data</a> () const</td></tr>
<tr class="memdesc:a332a750ed35277f0bc297fbfecce598f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the data.  <br /></td></tr>
<tr class="memitem:a853c922c68fa1ec667d7ff1af5404138" id="r_a853c922c68fa1ec667d7ff1af5404138"><td class="memTemplParams" colspan="2">template&lt;typename U = BufferT&gt; </td></tr>
<tr class="memitem:a853c922c68fa1ec667d7ff1af5404138 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, constvoid * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a853c922c68fa1ec667d7ff1af5404138">deviceData</a> () const</td></tr>
<tr class="memitem:a1901a89dc8b4b440bf47de580d428228" id="r_a1901a89dc8b4b440bf47de580d428228"><td class="memTemplParams" colspan="2">template&lt;typename U = BufferT&gt; </td></tr>
<tr class="memitem:a1901a89dc8b4b440bf47de580d428228 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, constvoid * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1901a89dc8b4b440bf47de580d428228">deviceData</a> (int device) const</td></tr>
<tr class="memitem:ae18dc8faaa706f35dca39e7f601b53e7" id="r_ae18dc8faaa706f35dca39e7f601b53e7"><td class="memTemplParams" colspan="2">template&lt;typename U = BufferT&gt; </td></tr>
<tr class="memitem:ae18dc8faaa706f35dca39e7f601b53e7 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, void * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae18dc8faaa706f35dca39e7f601b53e7">deviceData</a> ()</td></tr>
<tr class="memitem:a8b64bc6c8fb05bd0d8ee5db740f69197" id="r_a8b64bc6c8fb05bd0d8ee5db740f69197"><td class="memTemplParams" colspan="2">template&lt;typename U = BufferT&gt; </td></tr>
<tr class="memitem:a8b64bc6c8fb05bd0d8ee5db740f69197 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, void * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b64bc6c8fb05bd0d8ee5db740f69197">deviceData</a> (int device)</td></tr>
<tr class="memitem:a762969d9fb827c7c4e4df778152838fe" id="r_a762969d9fb827c7c4e4df778152838fe"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a762969d9fb827c7c4e4df778152838fe">size</a> () const</td></tr>
<tr class="memdesc:a762969d9fb827c7c4e4df778152838fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the raw memory buffer managed by this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a>.  <br /></td></tr>
<tr class="memitem:a5d08927fb422019423a54acbf1cf24b0" id="r_a5d08927fb422019423a54acbf1cf24b0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d08927fb422019423a54acbf1cf24b0">bufferSize</a> () const</td></tr>
<tr class="memitem:a644718bb2fb240de962dc3c9a1fdf0dc" id="r_a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a644718bb2fb240de962dc3c9a1fdf0dc">empty</a> () const</td></tr>
<tr class="memdesc:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this handle is empty, i.e. has no allocated memory.  <br /></td></tr>
<tr class="memitem:acf82f9b2937375c7b1cf3dccb3df3312" id="r_acf82f9b2937375c7b1cf3dccb3df3312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf82f9b2937375c7b1cf3dccb3df3312">isEmpty</a> () const</td></tr>
<tr class="memitem:a67b76affb3b5d35fa419ac234144038b" id="r_a67b76affb3b5d35fa419ac234144038b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67b76affb3b5d35fa419ac234144038b">operator bool</a> () const</td></tr>
<tr class="memdesc:a67b76affb3b5d35fa419ac234144038b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this handle is not empty, i.e. contains at least one grid.  <br /></td></tr>
<tr class="memitem:a55830727b5cd6cd25e014c68b1ab2eb2" id="r_a55830727b5cd6cd25e014c68b1ab2eb2"><td class="memTemplParams" colspan="2">template&lt;typename ValueT&gt; </td></tr>
<tr class="memitem:a55830727b5cd6cd25e014c68b1ab2eb2 template"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacenanovdb.html#a1eba1ecdc176671d534794bcd6604e8a">NanoGrid</a>&lt; ValueT &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55830727b5cd6cd25e014c68b1ab2eb2">grid</a> (uint32_t n=0) const</td></tr>
<tr class="memdesc:a55830727b5cd6cd25e014c68b1ab2eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const host pointer to the <em class="arg">n'th</em> NanoVDB grid encoded in this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a>.  <br /></td></tr>
<tr class="memitem:a1be47bd78d73d079e0acabb3885b6f10" id="r_a1be47bd78d73d079e0acabb3885b6f10"><td class="memTemplParams" colspan="2">template&lt;typename ValueT&gt; </td></tr>
<tr class="memitem:a1be47bd78d73d079e0acabb3885b6f10 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenanovdb.html#a1eba1ecdc176671d534794bcd6604e8a">NanoGrid</a>&lt; ValueT &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1be47bd78d73d079e0acabb3885b6f10">grid</a> (uint32_t n=0)</td></tr>
<tr class="memdesc:a1be47bd78d73d079e0acabb3885b6f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a host pointer to the <em class="arg">n'th</em> NanoVDB grid encoded in this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a>.  <br /></td></tr>
<tr class="memitem:a658d5cd49f70b4b493a55830507fe2ec" id="r_a658d5cd49f70b4b493a55830507fe2ec"><td class="memTemplParams" colspan="2">template&lt;typename ValueT, typename U = BufferT&gt; </td></tr>
<tr class="memitem:a658d5cd49f70b4b493a55830507fe2ec template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, constNanoGrid&lt; ValueT &gt; * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a658d5cd49f70b4b493a55830507fe2ec">deviceGrid</a> (uint32_t n=0) const</td></tr>
<tr class="memdesc:a658d5cd49f70b4b493a55830507fe2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the <em class="arg">n'th</em> grid encoded in this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> on the device, e.g. GPU.  <br /></td></tr>
<tr class="memitem:a7aeb091775430c25ccfae8fcab10e9ee" id="r_a7aeb091775430c25ccfae8fcab10e9ee"><td class="memTemplParams" colspan="2">template&lt;typename ValueT, typename U = BufferT&gt; </td></tr>
<tr class="memitem:a7aeb091775430c25ccfae8fcab10e9ee template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, <a class="el" href="namespacenanovdb.html#a1eba1ecdc176671d534794bcd6604e8a">NanoGrid</a>&lt; ValueT &gt; * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aeb091775430c25ccfae8fcab10e9ee">deviceGrid</a> (uint32_t n=0)</td></tr>
<tr class="memdesc:a7aeb091775430c25ccfae8fcab10e9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the <em class="arg">n'th</em> grid encoded in this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> on the device, e.g. GPU.  <br /></td></tr>
<tr class="memitem:a1d957d3ecb8baca7710f79bf8bab08f4" id="r_a1d957d3ecb8baca7710f79bf8bab08f4"><td class="memTemplParams" colspan="2">template&lt;typename U = BufferT&gt; </td></tr>
<tr class="memitem:a1d957d3ecb8baca7710f79bf8bab08f4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d957d3ecb8baca7710f79bf8bab08f4">deviceUpload</a> (void *stream, bool sync=true)</td></tr>
<tr class="memdesc:a1d957d3ecb8baca7710f79bf8bab08f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload the grid to the device, e.g. from CPU to GPU.  <br /></td></tr>
<tr class="memitem:ae715b77e8f4a0a5cf54a1b50fbe28940" id="r_ae715b77e8f4a0a5cf54a1b50fbe28940"><td class="memTemplParams" colspan="2">template&lt;typename U = BufferT&gt; </td></tr>
<tr class="memitem:ae715b77e8f4a0a5cf54a1b50fbe28940 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae715b77e8f4a0a5cf54a1b50fbe28940">deviceUpload</a> (int device=0, void *stream=nullptr, bool sync=true)</td></tr>
<tr class="memdesc:ae715b77e8f4a0a5cf54a1b50fbe28940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload the host buffer to a specific device buffer. It device buffer doesn't exist it's created first.  <br /></td></tr>
<tr class="memitem:afbe7c6dac0f42f118894d79a5eceb078" id="r_afbe7c6dac0f42f118894d79a5eceb078"><td class="memTemplParams" colspan="2">template&lt;typename U = BufferT&gt; </td></tr>
<tr class="memitem:afbe7c6dac0f42f118894d79a5eceb078 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbe7c6dac0f42f118894d79a5eceb078">deviceDownload</a> (void *stream, bool sync=true)</td></tr>
<tr class="memdesc:afbe7c6dac0f42f118894d79a5eceb078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download the grid to from the device, e.g. from GPU to CPU.  <br /></td></tr>
<tr class="memitem:a17136a1e9a8f4a047dd59a84d8215eb4" id="r_a17136a1e9a8f4a047dd59a84d8215eb4"><td class="memTemplParams" colspan="2">template&lt;typename U = BufferT&gt; </td></tr>
<tr class="memitem:a17136a1e9a8f4a047dd59a84d8215eb4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17136a1e9a8f4a047dd59a84d8215eb4">deviceDownload</a> (int device=0, void *stream=nullptr, bool sync=true)</td></tr>
<tr class="memitem:a9baa231ef13afcdc1ef69c91848e6bb0" id="r_a9baa231ef13afcdc1ef69c91848e6bb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9baa231ef13afcdc1ef69c91848e6bb0">isPadded</a> () const</td></tr>
<tr class="memdesc:a9baa231ef13afcdc1ef69c91848e6bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer is this handle has any padding, i.e. if the buffer is larger than the combined size of all its grids.  <br /></td></tr>
<tr class="memitem:acadb14428c60ff024255246dbda917ea" id="r_acadb14428c60ff024255246dbda917ea"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acadb14428c60ff024255246dbda917ea">gridCount</a> () const</td></tr>
<tr class="memdesc:acadb14428c60ff024255246dbda917ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of grids contained in this buffer.  <br /></td></tr>
<tr class="memitem:a86cf773d742fa49b4efba258dd1b6734" id="r_a86cf773d742fa49b4efba258dd1b6734"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86cf773d742fa49b4efba258dd1b6734">gridSize</a> (uint32_t n=0) const</td></tr>
<tr class="memdesc:a86cf773d742fa49b4efba258dd1b6734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the grid size of the <em class="arg">n'th</em> grid in this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a>.  <br /></td></tr>
<tr class="memitem:a15758b4e61d161dfc656a8bdf7d261fd" id="r_a15758b4e61d161dfc656a8bdf7d261fd"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15758b4e61d161dfc656a8bdf7d261fd">totalGridSize</a> () const</td></tr>
<tr class="memdesc:a15758b4e61d161dfc656a8bdf7d261fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the total sum of memory footprints of all the grids in this buffer  <br /></td></tr>
<tr class="memitem:a07d3824a4a68998aefeca6820b8c3b26" id="r_a07d3824a4a68998aefeca6820b8c3b26"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07d3824a4a68998aefeca6820b8c3b26">freeSize</a> () const</td></tr>
<tr class="memdesc:a07d3824a4a68998aefeca6820b8c3b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the size of unused storage in this buffer  <br /></td></tr>
<tr class="memitem:ad753310e7ebeac80873cea6766ad1e60" id="r_ad753310e7ebeac80873cea6766ad1e60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad753310e7ebeac80873cea6766ad1e60">isFull</a> () const</td></tr>
<tr class="memdesc:ad753310e7ebeac80873cea6766ad1e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this buffer has any unused storage left, i.e. memory not occupied by grids.  <br /></td></tr>
<tr class="memitem:a87e4f9a158c81013eddfa01661b20835" id="r_a87e4f9a158c81013eddfa01661b20835"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenanovdb.html#a4c0dc82510efc445233bd15b340bfeb0">GridType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87e4f9a158c81013eddfa01661b20835">gridType</a> (uint32_t n=0) const</td></tr>
<tr class="memdesc:a87e4f9a158c81013eddfa01661b20835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="namespacenanovdb.html#a4c0dc82510efc445233bd15b340bfeb0" title="List of types that are currently supported by NanoVDB.">GridType</a> of the <em class="arg">n'th</em> grid in this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a>.  <br /></td></tr>
<tr class="memitem:a2add1fa08c513d9afef0297f6d5e4bf5" id="r_a2add1fa08c513d9afef0297f6d5e4bf5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structnanovdb_1_1GridData.html">GridData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2add1fa08c513d9afef0297f6d5e4bf5">gridData</a> (uint32_t n=0) const</td></tr>
<tr class="memdesc:a2add1fa08c513d9afef0297f6d5e4bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the <a class="el" href="structnanovdb_1_1GridData.html" title="Struct with all the member data of the Grid (useful during serialization of an openvdb grid)">GridData</a> of the n'th grid in the current handle.  <br /></td></tr>
<tr class="memitem:a8672f5065e66dfb4f19e58b3d044e59f" id="r_a8672f5065e66dfb4f19e58b3d044e59f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnanovdb_1_1GridMetaData.html">GridMetaData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8672f5065e66dfb4f19e58b3d044e59f">gridMetaData</a> (uint32_t n=0) const</td></tr>
<tr class="memdesc:a8672f5065e66dfb4f19e58b3d044e59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const point to the <em class="arg">n'th</em> grid meta data.  <br /></td></tr>
<tr class="memitem:af3a59e5a0477939c842dd312f5cb918d" id="r_af3a59e5a0477939c842dd312f5cb918d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3a59e5a0477939c842dd312f5cb918d">write</a> (std::ostream &amp;os, uint32_t n) const</td></tr>
<tr class="memdesc:af3a59e5a0477939c842dd312f5cb918d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a specific grid in this buffer to an output stream.  <br /></td></tr>
<tr class="memitem:a352bb124b2f1609c8d6a0fa0e62d91d0" id="r_a352bb124b2f1609c8d6a0fa0e62d91d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a352bb124b2f1609c8d6a0fa0e62d91d0">write</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a352bb124b2f1609c8d6a0fa0e62d91d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the entire grid buffer to an output stream.  <br /></td></tr>
<tr class="memitem:a98a57200bc719f763e7652280f9d589f" id="r_a98a57200bc719f763e7652280f9d589f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98a57200bc719f763e7652280f9d589f">write</a> (const std::string &amp;fileName) const</td></tr>
<tr class="memdesc:a98a57200bc719f763e7652280f9d589f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write this entire grid buffer to a file.  <br /></td></tr>
<tr class="memitem:aec7c41fa0197653a54b4765dba7be4e1" id="r_aec7c41fa0197653a54b4765dba7be4e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec7c41fa0197653a54b4765dba7be4e1">write</a> (const std::string &amp;fileName, uint32_t n) const</td></tr>
<tr class="memdesc:aec7c41fa0197653a54b4765dba7be4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a specific grid to file.  <br /></td></tr>
<tr class="memitem:aede7b9718f389e31ce50690ff788fc12" id="r_aede7b9718f389e31ce50690ff788fc12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aede7b9718f389e31ce50690ff788fc12">read</a> (std::istream &amp;is, const BufferT &amp;pool=BufferT())</td></tr>
<tr class="memdesc:aede7b9718f389e31ce50690ff788fc12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an entire raw grid buffer from an input stream.  <br /></td></tr>
<tr class="memitem:a42628edd9bde1b4cfac23e4d247d1561" id="r_a42628edd9bde1b4cfac23e4d247d1561"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42628edd9bde1b4cfac23e4d247d1561">read</a> (std::istream &amp;is, uint32_t n, const BufferT &amp;pool=BufferT())</td></tr>
<tr class="memdesc:a42628edd9bde1b4cfac23e4d247d1561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a specific grid from an input stream containing a raw grid buffer.  <br /></td></tr>
<tr class="memitem:a3c1c725da9c29c96d194a120447980ec" id="r_a3c1c725da9c29c96d194a120447980ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c1c725da9c29c96d194a120447980ec">read</a> (std::istream &amp;is, const std::string &amp;gridName, const BufferT &amp;pool=BufferT())</td></tr>
<tr class="memdesc:a3c1c725da9c29c96d194a120447980ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a specific grid from an input stream containing a raw grid buffer.  <br /></td></tr>
<tr class="memitem:ae612cbaf45aeba8b76288065804c9dbb" id="r_ae612cbaf45aeba8b76288065804c9dbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae612cbaf45aeba8b76288065804c9dbb">read</a> (const std::string &amp;fileName, const BufferT &amp;pool=BufferT())</td></tr>
<tr class="memdesc:ae612cbaf45aeba8b76288065804c9dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a raw grid buffer from a file.  <br /></td></tr>
<tr class="memitem:a8dfafffae26e0026d92725c765469b85" id="r_a8dfafffae26e0026d92725c765469b85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dfafffae26e0026d92725c765469b85">read</a> (const std::string &amp;fileName, uint32_t n, const BufferT &amp;pool=BufferT())</td></tr>
<tr class="memdesc:a8dfafffae26e0026d92725c765469b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a specific grid from a file containing a raw grid buffer.  <br /></td></tr>
<tr class="memitem:a5f9dee3c050dab4072da9f4671cca88a" id="r_a5f9dee3c050dab4072da9f4671cca88a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f9dee3c050dab4072da9f4671cca88a">read</a> (const std::string &amp;fileName, const std::string &amp;gridName, const BufferT &amp;pool=BufferT())</td></tr>
<tr class="memdesc:a5f9dee3c050dab4072da9f4671cca88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a specific grid from a file containing a raw grid buffer.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename BufferT = HostBuffer&gt;<br />
class nanovdb::GridHandle&lt; BufferT &gt;</div><p>This class serves to manage a buffer containing one or more NanoVDB Grids. </p>
<dl class="section note"><dt>Note</dt><dd>It is important to note that this class does NOT depend on OpenVDB. </dd></dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="ab9394c0860a72744306b73a0f9cfe87c" name="ab9394c0860a72744306b73a0f9cfe87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9394c0860a72744306b73a0f9cfe87c">&#9670;&#160;</a></span>BufferType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab9394c0860a72744306b73a0f9cfe87c">BufferType</a> = BufferT</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adc14689d7fc4a9b9432b899211a309ec" name="adc14689d7fc4a9b9432b899211a309ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc14689d7fc4a9b9432b899211a309ec">&#9670;&#160;</a></span>GridHandle() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT&gt; </div>
<div class="memtemplate">
template&lt;typename T, typename <a class="el" href="structnanovdb_1_1util_1_1disable__if.html">util::disable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; T &gt;::hasDeviceDual, int &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a> </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor from a dual host-device buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer containing one or more NanoGrids that will be moved into this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Will</td><td>throw and error with the buffer does not contain a valid NanoGrid! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation of this template specialization is in nanovdb/cuda/GridHandle.cuh since it requires CUDA </dd></dl>

</div>
</div>
<a id="adc14689d7fc4a9b9432b899211a309ec" name="adc14689d7fc4a9b9432b899211a309ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc14689d7fc4a9b9432b899211a309ec">&#9670;&#160;</a></span>GridHandle() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<div class="memtemplate">
template&lt;typename T = BufferT, typename <a class="el" href="structnanovdb_1_1util_1_1disable__if.html">util::disable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; T &gt;::hasDeviceDual, int &gt;::type = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a> </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor from a host buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer containing one or more NanoGrids that will be moved into this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Will</td><td>throw and error with the buffer does not contain a valid NanoGrid! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaae13e5113d0e32d6f758ca748652f9" name="afaae13e5113d0e32d6f758ca748652f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaae13e5113d0e32d6f758ca748652f9">&#9670;&#160;</a></span>GridHandle() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a>. </p>

</div>
</div>
<a id="a3bc536fa3086174cdac78304c0df0130" name="a3bc536fa3086174cdac78304c0df0130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc536fa3086174cdac78304c0df0130">&#9670;&#160;</a></span>GridHandle() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a>&lt; BufferT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallow copy-construction. </p>

</div>
</div>
<a id="a838e184a2851ad71ee5b238b776016ab" name="a838e184a2851ad71ee5b238b776016ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838e184a2851ad71ee5b238b776016ab">&#9670;&#160;</a></span>GridHandle() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a>&lt; BufferT &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move copy-constructor. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a27d8a3674328a33d9e2c43b1fd3f0166" name="a27d8a3674328a33d9e2c43b1fd3f0166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d8a3674328a33d9e2c43b1fd3f0166">&#9670;&#160;</a></span>buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BufferT &amp; buffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the buffer. </p>

</div>
</div>
<a id="a81689bd02e9e6a7e1f14d5613a3ec176" name="a81689bd02e9e6a7e1f14d5613a3ec176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81689bd02e9e6a7e1f14d5613a3ec176">&#9670;&#160;</a></span>buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const BufferT &amp; buffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the buffer. </p>

</div>
</div>
<a id="a5d08927fb422019423a54acbf1cf24b0" name="a5d08927fb422019423a54acbf1cf24b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d08927fb422019423a54acbf1cf24b0">&#9670;&#160;</a></span>bufferSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bufferSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3b4f299904b94b8e644605cfbbd36c8" name="ac3b4f299904b94b8e644605cfbbd36c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b4f299904b94b8e644605cfbbd36c8">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT&gt; </div>
<div class="memtemplate">
template&lt;typename OtherBufferT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a>&lt; OtherBufferT &gt; copy </td>
          <td>(</td>
          <td class="paramtype">const OtherBufferT &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span><span class="paramdefsep"> = </span><span class="paramdefval">OtherBufferT()</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a deep copy of the <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a>, possibly templated on a different buffer type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherBufferT</td><td>Buffer type of the deep copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>optional buffer used for allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new handle of the specified buffer type that contains a deep copy of the current handle </dd></dl>

</div>
</div>
<a id="a0189be0971a32a0171c51b90a1ab1020" name="a0189be0971a32a0171c51b90a1ab1020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0189be0971a32a0171c51b90a1ab1020">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a non-const pointer to the data. </p>
<dl class="section warning"><dt>Warning</dt><dd>Note that the return pointer can be NULL if the <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> was not initialized </dd></dl>

</div>
</div>
<a id="a332a750ed35277f0bc297fbfecce598f" name="a332a750ed35277f0bc297fbfecce598f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332a750ed35277f0bc297fbfecce598f">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const pointer to the data. </p>
<dl class="section warning"><dt>Warning</dt><dd>Note that the return pointer can be NULL if the <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> was not initialized </dd></dl>

</div>
</div>
<a id="ae18dc8faaa706f35dca39e7f601b53e7" name="ae18dc8faaa706f35dca39e7f601b53e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18dc8faaa706f35dca39e7f601b53e7">&#9670;&#160;</a></span>deviceData() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<div class="memtemplate">
template&lt;typename U = BufferT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, void * &gt;::type deviceData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a853c922c68fa1ec667d7ff1af5404138" name="a853c922c68fa1ec667d7ff1af5404138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853c922c68fa1ec667d7ff1af5404138">&#9670;&#160;</a></span>deviceData() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<div class="memtemplate">
template&lt;typename U = BufferT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, constvoid * &gt;::type deviceData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b64bc6c8fb05bd0d8ee5db740f69197" name="a8b64bc6c8fb05bd0d8ee5db740f69197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b64bc6c8fb05bd0d8ee5db740f69197">&#9670;&#160;</a></span>deviceData() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<div class="memtemplate">
template&lt;typename U = BufferT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, void * &gt;::type deviceData </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>device</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1901a89dc8b4b440bf47de580d428228" name="a1901a89dc8b4b440bf47de580d428228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1901a89dc8b4b440bf47de580d428228">&#9670;&#160;</a></span>deviceData() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<div class="memtemplate">
template&lt;typename U = BufferT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, constvoid * &gt;::type deviceData </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>device</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17136a1e9a8f4a047dd59a84d8215eb4" name="a17136a1e9a8f4a047dd59a84d8215eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17136a1e9a8f4a047dd59a84d8215eb4">&#9670;&#160;</a></span>deviceDownload() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<div class="memtemplate">
template&lt;typename U = BufferT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, void &gt;::type deviceDownload </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>device</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>stream</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>sync</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afbe7c6dac0f42f118894d79a5eceb078" name="afbe7c6dac0f42f118894d79a5eceb078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe7c6dac0f42f118894d79a5eceb078">&#9670;&#160;</a></span>deviceDownload() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<div class="memtemplate">
template&lt;typename U = BufferT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, void &gt;::type deviceDownload </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>sync</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Download the grid to from the device, e.g. from GPU to CPU. </p>
<dl class="section note"><dt>Note</dt><dd>This method is only available if the buffer supports devices </dd></dl>

</div>
</div>
<a id="a7aeb091775430c25ccfae8fcab10e9ee" name="a7aeb091775430c25ccfae8fcab10e9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aeb091775430c25ccfae8fcab10e9ee">&#9670;&#160;</a></span>deviceGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<div class="memtemplate">
template&lt;typename ValueT, typename U = BufferT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, <a class="el" href="namespacenanovdb.html#a1eba1ecdc176671d534794bcd6604e8a">NanoGrid</a>&lt; ValueT &gt; * &gt;::type deviceGrid </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the <em class="arg">n'th</em> grid encoded in this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> on the device, e.g. GPU. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueT</td><td>Value type of the grid point to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Index of the grid pointer to be returned </td></tr>
    <tr><td class="paramname">verbose</td><td>if non-zero error messages will be printed in case something failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Note that the return pointer can be NULL if the <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> was not initialized, <em class="arg">n</em> is invalid, or if the template parameter does not match the specified grid. </dd></dl>

</div>
</div>
<a id="a658d5cd49f70b4b493a55830507fe2ec" name="a658d5cd49f70b4b493a55830507fe2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658d5cd49f70b4b493a55830507fe2ec">&#9670;&#160;</a></span>deviceGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT&gt; </div>
<div class="memtemplate">
template&lt;typename ValueT, typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, constNanoGrid&lt; ValueT &gt; * &gt;::type deviceGrid </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the <em class="arg">n'th</em> grid encoded in this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> on the device, e.g. GPU. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueT</td><td>Value type of the grid point to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Index of the (device) grid pointer to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Note that the return pointer can be NULL if the <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> has no device grid, <em class="arg">n</em> is invalid, or if the template parameter does not match the specified grid. </dd></dl>

</div>
</div>
<a id="ae715b77e8f4a0a5cf54a1b50fbe28940" name="ae715b77e8f4a0a5cf54a1b50fbe28940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae715b77e8f4a0a5cf54a1b50fbe28940">&#9670;&#160;</a></span>deviceUpload() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<div class="memtemplate">
template&lt;typename U = BufferT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, void &gt;::type deviceUpload </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>device</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>stream</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>sync</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Upload the host buffer to a specific device buffer. It device buffer doesn't exist it's created first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Device to upload host data to </td></tr>
    <tr><td class="paramname">stream</td><td>cuda stream </td></tr>
    <tr><td class="paramname">sync</td><td>if false the memory copy is asynchronous </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d957d3ecb8baca7710f79bf8bab08f4" name="a1d957d3ecb8baca7710f79bf8bab08f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d957d3ecb8baca7710f79bf8bab08f4">&#9670;&#160;</a></span>deviceUpload() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<div class="memtemplate">
template&lt;typename U = BufferT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnanovdb_1_1util_1_1enable__if.html">util::enable_if</a>&lt; <a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits</a>&lt; U &gt;::hasDeviceDual, void &gt;::type deviceUpload </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>sync</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Upload the grid to the device, e.g. from CPU to GPU. </p>
<dl class="section note"><dt>Note</dt><dd>This method is only available if the buffer supports devices </dd></dl>

</div>
</div>
<a id="a644718bb2fb240de962dc3c9a1fdf0dc" name="a644718bb2fb240de962dc3c9a1fdf0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644718bb2fb240de962dc3c9a1fdf0dc">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this handle is empty, i.e. has no allocated memory. </p>

</div>
</div>
<a id="a07d3824a4a68998aefeca6820b8c3b26" name="a07d3824a4a68998aefeca6820b8c3b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d3824a4a68998aefeca6820b8c3b26">&#9670;&#160;</a></span>freeSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t freeSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the size of unused storage in this buffer </p>
<dl class="section return"><dt>Returns</dt><dd>the number of unused bytes in this buffer. </dd></dl>

</div>
</div>
<a id="a1be47bd78d73d079e0acabb3885b6f10" name="a1be47bd78d73d079e0acabb3885b6f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be47bd78d73d079e0acabb3885b6f10">&#9670;&#160;</a></span>grid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<div class="memtemplate">
template&lt;typename ValueT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenanovdb.html#a1eba1ecdc176671d534794bcd6604e8a">NanoGrid</a>&lt; ValueT &gt; * grid </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a host pointer to the <em class="arg">n'th</em> NanoVDB grid encoded in this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueT</td><td>Value type of the grid point to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Index of the (host) grid pointer to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Note that the return pointer can be NULL if the <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> no host grid, <em class="arg">n</em> is invalid or if the template parameter does not match the specified grid! </dd></dl>

</div>
</div>
<a id="a55830727b5cd6cd25e014c68b1ab2eb2" name="a55830727b5cd6cd25e014c68b1ab2eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55830727b5cd6cd25e014c68b1ab2eb2">&#9670;&#160;</a></span>grid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT&gt; </div>
<div class="memtemplate">
template&lt;typename ValueT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacenanovdb.html#a1eba1ecdc176671d534794bcd6604e8a">NanoGrid</a>&lt; ValueT &gt; * grid </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const host pointer to the <em class="arg">n'th</em> NanoVDB grid encoded in this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueT</td><td>Value type of the grid point to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Index of the (host) grid pointer to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Note that the return pointer can be NULL if the <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> no host grid, <em class="arg">n</em> is invalid or if the template parameter does not match the specified grid! </dd></dl>

</div>
</div>
<a id="acadb14428c60ff024255246dbda917ea" name="acadb14428c60ff024255246dbda917ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acadb14428c60ff024255246dbda917ea">&#9670;&#160;</a></span>gridCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t gridCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number of grids contained in this buffer. </p>

</div>
</div>
<a id="a2add1fa08c513d9afef0297f6d5e4bf5" name="a2add1fa08c513d9afef0297f6d5e4bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2add1fa08c513d9afef0297f6d5e4bf5">&#9670;&#160;</a></span>gridData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structnanovdb_1_1GridData.html">GridData</a> * gridData </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the <a class="el" href="structnanovdb_1_1GridData.html" title="Struct with all the member data of the Grid (useful during serialization of an openvdb grid)">GridData</a> of the n'th grid in the current handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>zero-based ID of the grid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const pointer to the n'th <a class="el" href="structnanovdb_1_1GridData.html" title="Struct with all the member data of the Grid (useful during serialization of an openvdb grid)">GridData</a> in the current handle </dd></dl>

</div>
</div>
<a id="a8672f5065e66dfb4f19e58b3d044e59f" name="a8672f5065e66dfb4f19e58b3d044e59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8672f5065e66dfb4f19e58b3d044e59f">&#9670;&#160;</a></span>gridMetaData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnanovdb_1_1GridMetaData.html">GridMetaData</a> * gridMetaData </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const point to the <em class="arg">n'th</em> grid meta data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>zero-based ID of the grid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Note that the return pointer can be NULL if the <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> was not initialized </dd></dl>

</div>
</div>
<a id="a86cf773d742fa49b4efba258dd1b6734" name="a86cf773d742fa49b4efba258dd1b6734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cf773d742fa49b4efba258dd1b6734">&#9670;&#160;</a></span>gridSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t gridSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the grid size of the <em class="arg">n'th</em> grid in this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>index of the grid (assumed to be less than <a class="el" href="#acadb14428c60ff024255246dbda917ea" title="Return the total number of grids contained in this buffer.">gridCount()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the byte size of the specified grid </dd></dl>

</div>
</div>
<a id="a87e4f9a158c81013eddfa01661b20835" name="a87e4f9a158c81013eddfa01661b20835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e4f9a158c81013eddfa01661b20835">&#9670;&#160;</a></span>gridType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenanovdb.html#a4c0dc82510efc445233bd15b340bfeb0">GridType</a> gridType </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="namespacenanovdb.html#a4c0dc82510efc445233bd15b340bfeb0" title="List of types that are currently supported by NanoVDB.">GridType</a> of the <em class="arg">n'th</em> grid in this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>index of the grid (assumed to be less than <a class="el" href="#acadb14428c60ff024255246dbda917ea" title="Return the total number of grids contained in this buffer.">gridCount()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the <a class="el" href="namespacenanovdb.html#a4c0dc82510efc445233bd15b340bfeb0" title="List of types that are currently supported by NanoVDB.">GridType</a> of the specified grid </dd></dl>

</div>
</div>
<a id="acf82f9b2937375c7b1cf3dccb3df3312" name="acf82f9b2937375c7b1cf3dccb3df3312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf82f9b2937375c7b1cf3dccb3df3312">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad753310e7ebeac80873cea6766ad1e60" name="ad753310e7ebeac80873cea6766ad1e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad753310e7ebeac80873cea6766ad1e60">&#9670;&#160;</a></span>isFull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isFull </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if this buffer has any unused storage left, i.e. memory not occupied by grids. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there is no extra storage left in this buffer, i.e. empty or fully occupied with grids </dd></dl>

</div>
</div>
<a id="a9baa231ef13afcdc1ef69c91848e6bb0" name="a9baa231ef13afcdc1ef69c91848e6bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baa231ef13afcdc1ef69c91848e6bb0">&#9670;&#160;</a></span>isPadded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isPadded </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the buffer is this handle has any padding, i.e. if the buffer is larger than the combined size of all its grids. </p>
<dl class="section return"><dt>Returns</dt><dd>true is the combined size of all grid is smaller than the buffer size </dd></dl>

</div>
</div>
<a id="a67b76affb3b5d35fa419ac234144038b" name="a67b76affb3b5d35fa419ac234144038b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b76affb3b5d35fa419ac234144038b">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operator bool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this handle is not empty, i.e. contains at least one grid. </p>

</div>
</div>
<a id="a0fde638bdd0e584fd3491afc93bb28b4" name="a0fde638bdd0e584fd3491afc93bb28b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fde638bdd0e584fd3491afc93bb28b4">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a>&lt; BufferT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disallow copy assignment operation. </p>

</div>
</div>
<a id="a467f69248588aaa9b3fed08129892451" name="a467f69248588aaa9b3fed08129892451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467f69248588aaa9b3fed08129892451">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnanovdb_1_1GridHandle.html">GridHandle</a>&lt; BufferT &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move copy assignment operation. </p>

</div>
</div>
<a id="ae612cbaf45aeba8b76288065804c9dbb" name="ae612cbaf45aeba8b76288065804c9dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae612cbaf45aeba8b76288065804c9dbb">&#9670;&#160;</a></span>read() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferT &amp;</td>          <td class="paramname"><span class="paramname"><em>pool</em></span><span class="paramdefsep"> = </span><span class="paramdefval">BufferT()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a raw grid buffer from a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>string name of the input file containing a raw grid buffer </td></tr>
    <tr><td class="paramname">pool</td><td>optional pool from which to allocate the new grid buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f9dee3c050dab4072da9f4671cca88a" name="a5f9dee3c050dab4072da9f4671cca88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9dee3c050dab4072da9f4671cca88a">&#9670;&#160;</a></span>read() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>gridName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferT &amp;</td>          <td class="paramname"><span class="paramname"><em>pool</em></span><span class="paramdefsep"> = </span><span class="paramdefval">BufferT()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a specific grid from a file containing a raw grid buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>string name of the input file containing a raw grid buffer </td></tr>
    <tr><td class="paramname">gridName</td><td>string name of the grid to be read </td></tr>
    <tr><td class="paramname">pool</td><td>optional pool from which to allocate the new grid buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Will</td><td>throw a std::ios_base::failure if the file does not exist and a std::logic_error if the files does not contain a valid raw grid withe the specified name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dfafffae26e0026d92725c765469b85" name="a8dfafffae26e0026d92725c765469b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfafffae26e0026d92725c765469b85">&#9670;&#160;</a></span>read() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferT &amp;</td>          <td class="paramname"><span class="paramname"><em>pool</em></span><span class="paramdefsep"> = </span><span class="paramdefval">BufferT()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a specific grid from a file containing a raw grid buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>string name of the input file containing a raw grid buffer </td></tr>
    <tr><td class="paramname">n</td><td>zero-based index of the grid to be read </td></tr>
    <tr><td class="paramname">pool</td><td>optional pool from which to allocate the new grid buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Will</td><td>throw a std::ios_base::failure if the file does not exist and a std::logic_error if the files does not contain a valid raw grid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aede7b9718f389e31ce50690ff788fc12" name="aede7b9718f389e31ce50690ff788fc12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede7b9718f389e31ce50690ff788fc12">&#9670;&#160;</a></span>read() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferT &amp;</td>          <td class="paramname"><span class="paramname"><em>pool</em></span><span class="paramdefsep"> = </span><span class="paramdefval">BufferT()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an entire raw grid buffer from an input stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream containing a raw grid buffer </td></tr>
    <tr><td class="paramname">pool</td><td>optional pool from which to allocate the new grid buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Will</td><td>throw a std::logic_error if the stream does not contain a valid raw grid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c1c725da9c29c96d194a120447980ec" name="a3c1c725da9c29c96d194a120447980ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1c725da9c29c96d194a120447980ec">&#9670;&#160;</a></span>read() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>gridName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferT &amp;</td>          <td class="paramname"><span class="paramname"><em>pool</em></span><span class="paramdefsep"> = </span><span class="paramdefval">BufferT()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a specific grid from an input stream containing a raw grid buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream containing a raw grid buffer </td></tr>
    <tr><td class="paramname">gridName</td><td>string name of the grid to be read </td></tr>
    <tr><td class="paramname">pool</td><td>optional pool from which to allocate the new grid buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Will</td><td>throw a std::logic_error if the stream does not contain a valid raw grid with the specified name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42628edd9bde1b4cfac23e4d247d1561" name="a42628edd9bde1b4cfac23e4d247d1561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42628edd9bde1b4cfac23e4d247d1561">&#9670;&#160;</a></span>read() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferT &amp;</td>          <td class="paramname"><span class="paramname"><em>pool</em></span><span class="paramdefsep"> = </span><span class="paramdefval">BufferT()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a specific grid from an input stream containing a raw grid buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream containing a raw grid buffer </td></tr>
    <tr><td class="paramname">n</td><td>zero-based index of the grid to be read </td></tr>
    <tr><td class="paramname">pool</td><td>optional pool from which to allocate the new grid buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Will</td><td>throw a std::logic_error if the stream does not contain a valid raw grid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad20897c5c8bd47f5d4005989bead0e55" name="ad20897c5c8bd47f5d4005989bead0e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20897c5c8bd47f5d4005989bead0e55">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clear this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a> to an empty handle </p>

</div>
</div>
<a id="a762969d9fb827c7c4e4df778152838fe" name="a762969d9fb827c7c4e4df778152838fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762969d9fb827c7c4e4df778152838fe">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size in bytes of the raw memory buffer managed by this <a class="el" href="classnanovdb_1_1GridHandle.html" title="This class serves to manage a buffer containing one or more NanoVDB Grids.">GridHandle</a>. </p>

</div>
</div>
<a id="a15758b4e61d161dfc656a8bdf7d261fd" name="a15758b4e61d161dfc656a8bdf7d261fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15758b4e61d161dfc656a8bdf7d261fd">&#9670;&#160;</a></span>totalGridSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t totalGridSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the total sum of memory footprints of all the grids in this buffer </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes occupied by all grids associated with this buffer </dd></dl>

</div>
</div>
<a id="a98a57200bc719f763e7652280f9d589f" name="a98a57200bc719f763e7652280f9d589f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a57200bc719f763e7652280f9d589f">&#9670;&#160;</a></span>write() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void write </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write this entire grid buffer to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>string name of the output file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec7c41fa0197653a54b4765dba7be4e1" name="aec7c41fa0197653a54b4765dba7be4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7c41fa0197653a54b4765dba7be4e1">&#9670;&#160;</a></span>write() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void write </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a specific grid to file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>string name of the output file </td></tr>
    <tr><td class="paramname">n</td><td>zero-based index of the grid to be written to file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a352bb124b2f1609c8d6a0fa0e62d91d0" name="a352bb124b2f1609c8d6a0fa0e62d91d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352bb124b2f1609c8d6a0fa0e62d91d0">&#9670;&#160;</a></span>write() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the entire grid buffer to an output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream that the buffer will be written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3a59e5a0477939c842dd312f5cb918d" name="af3a59e5a0477939c842dd312f5cb918d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a59e5a0477939c842dd312f5cb918d">&#9670;&#160;</a></span>write() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferT = HostBuffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a specific grid in this buffer to an output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream that the buffer will be written to </td></tr>
    <tr><td class="paramname">n</td><td>zero-based index of the grid to be written to stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacenanovdb.html">nanovdb</a></li><li class="navelem"><a href="classnanovdb_1_1GridHandle.html">GridHandle</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
