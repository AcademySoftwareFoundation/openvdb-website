<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: openvdb::v10_0::points Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">10.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v10__0.html">v10_0</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html">points</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">openvdb::v10_0::points Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceopenvdb_1_1v10__0_1_1points_1_1attribute__traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points_1_1attribute__traits.html">attribute_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v10__0_1_1points_1_1future"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points_1_1future.html">future</a></td></tr>
<tr class="memdesc:namespaceopenvdb_1_1v10__0_1_1points_1_1future"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for ABI=5 to help ease introduction of upcoming features. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v10__0_1_1points_1_1index"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points_1_1index.html">index</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v10__0_1_1points_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v10__0_1_1points_1_1point__attribute__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points_1_1point__attribute__internal.html">point_attribute_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v10__0_1_1points_1_1point__move__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points_1_1point__move__internal.html">point_move_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v10__0_1_1points_1_1point__rasterize__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points_1_1point__rasterize__internal.html">point_rasterize_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v10__0_1_1points_1_1statistics__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points_1_1statistics__internal.html">statistics_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v10__0_1_1points_1_1transfer__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points_1_1transfer__internal.html">transfer_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1AccessorEval.html">AccessorEval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to call unsafe get and set methods based on templated Codec and Value.  <a href="structopenvdb_1_1v10__0_1_1points_1_1AccessorEval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1AccessorEval_3_01UnknownCodec_00_01ValueType_01_4.html">AccessorEval&lt; UnknownCodec, ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization when Codec is not known at compile-time to use the supplied functor instead.  <a href="structopenvdb_1_1v10__0_1_1points_1_1AccessorEval_3_01UnknownCodec_00_01ValueType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeArray.html">AttributeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for storing attribute data.  <a href="classopenvdb_1_1v10__0_1_1points_1_1AttributeArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeHandle.html">AttributeHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeHashFilter.html">AttributeHashFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeSet.html">AttributeSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered collection of uniquely-named attribute arrays.  <a href="classopenvdb_1_1v10__0_1_1points_1_1AttributeSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeWriteHandle.html">AttributeWriteHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write-able version of <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeHandle.html">AttributeHandle</a>.  <a href="classopenvdb_1_1v10__0_1_1points_1_1AttributeWriteHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1BBoxFilter.html">BBoxFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1BinaryFilter.html">BinaryFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1CachedDeformer.html">CachedDeformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Deformer that caches the resulting positions from evaluating another Deformer.  <a href="classopenvdb_1_1v10__0_1_1points_1_1CachedDeformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1DeformerTraits.html">DeformerTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deformer Traits for optionally configuring deformers to be applied in index-space. The default is world-space.  <a href="structopenvdb_1_1v10__0_1_1points_1_1DeformerTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1DummySampleType.html">DummySampleType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1FilterTraits.html">FilterTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1FilterTraits_3_01BBoxFilter_01_4.html">FilterTraits&lt; BBoxFilter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1FilterTraits_3_01BinaryFilter_3_01T0_00_01T1_00_01And_01_4_01_4.html">FilterTraits&lt; BinaryFilter&lt; T0, T1, And &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1FilterTraits_3_01LevelSetFilter_3_01T_01_4_01_4.html">FilterTraits&lt; LevelSetFilter&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1FixedPointCodec.html">FixedPointCodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1FrustumRasterizer.html">FrustumRasterizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient rasterization of one or more VDB Points grids into a linear or frustum volume with the option to bake in camera or geometry motion blur.  <a href="classopenvdb_1_1v10__0_1_1points_1_1FrustumRasterizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1FrustumRasterizerMask.html">FrustumRasterizerMask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1FrustumRasterizerSettings.html">FrustumRasterizerSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A group of shared settings to be used in the Volume Rasterizer.  <a href="structopenvdb_1_1v10__0_1_1points_1_1FrustumRasterizerSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1GroupCodec.html">GroupCodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1GroupFilter.html">GroupFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index filtering on group membership.  <a href="classopenvdb_1_1v10__0_1_1points_1_1GroupFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1GroupHandle.html">GroupHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1GroupWriteHandle.html">GroupWriteHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1IndexIter.html">IndexIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator over array indices with filtering IteratorT can be either <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1IndexIter.html" title="A forward iterator over array indices with filtering IteratorT can be either IndexIter or ValueIndexI...">IndexIter</a> or <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1IndexIter_1_1ValueIndexIter.html" title="A forward iterator over array indices from a value iterator (such as ValueOnCIter) ...">ValueIndexIter</a> (or some custom index iterator) FilterT should be a struct or class with a valid() method than can be evaluated per index Here's a simple filter example that only accepts even indices:  <a href="classopenvdb_1_1v10__0_1_1points_1_1IndexIter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1LevelSetFilter.html">LevelSetFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1MultiGroupFilter.html">MultiGroupFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1NullCodec.html">NullCodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1NullDeformer.html">NullDeformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op deformer (adheres to the deformer interface documented in <a class="el" href="PointMove_8h.html" title="Ability to move VDB Points using a custom deformer. ">PointMove.h</a>)  <a href="structopenvdb_1_1v10__0_1_1points_1_1NullDeformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-op filter that can be used when iterating over all indices.  <a href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1PointAttributeVector.html">PointAttributeVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-partitioner compatible STL vector attribute wrapper for convenience.  <a href="classopenvdb_1_1v10__0_1_1points_1_1PointAttributeVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1PointDataLeafNode.html">PointDataLeafNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1PositionRange.html">PositionRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1RandomLeafFilter.html">RandomLeafFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1RasterCamera.html">RasterCamera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A camera class that provides an interface for camera motion blur when rasterizing.  <a href="classopenvdb_1_1v10__0_1_1points_1_1RasterCamera.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1RasterGroups.html">RasterGroups</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that stores all include/exclude attribute names as strings and is internally converted into the resolved <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1MultiGroupFilter.html">MultiGroupFilter</a>.  <a href="structopenvdb_1_1v10__0_1_1points_1_1RasterGroups.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1SampleWithRounding.html">SampleWithRounding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1StringAttributeHandle.html">StringAttributeHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1StringAttributeWriteHandle.html">StringAttributeWriteHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1StringCodec.html">StringCodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1StringMetaCache.html">StringMetaCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to compute a string-&gt;index map from all string:N metadata.  <a href="classopenvdb_1_1v10__0_1_1points_1_1StringMetaCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1StringMetaInserter.html">StringMetaInserter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to help with insertion of keyed string values into metadata.  <a href="classopenvdb_1_1v10__0_1_1points_1_1StringMetaInserter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1TransformTransfer.html">TransformTransfer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1TransformTransfer.html" title="The TransformTransfer module should be used if the source transform of the input points and the targe...">TransformTransfer</a> module should be used if the source transform of the input points and the target transforms of the destination volumes differ. The default rasterizer will skip index to world (and vice versa) transformations unless a transfer scheme derives from a <a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1TransformTransfer.html" title="The TransformTransfer module should be used if the source transform of the input points and the targe...">TransformTransfer</a>.  <a href="structopenvdb_1_1v10__0_1_1points_1_1TransformTransfer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1TreeConverter.html">TreeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similiar to ValueConverter, but allows for tree configuration conversion to a PointDataTree. ValueConverter&lt;PointDataIndex32&gt; cannot be used as a <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1PointDataLeafNode.html">PointDataLeafNode</a> is not a specialization of LeafNode.  <a href="structopenvdb_1_1v10__0_1_1points_1_1TreeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1TrilinearTraits.html">TrilinearTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1TrilinearTraits_3_01ValueT_00_01false_01_4.html">TrilinearTraits&lt; ValueT, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1TruncateCodec.html">TruncateCodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typed class for storing attribute data.  <a href="classopenvdb_1_1v10__0_1_1points_1_1TypedAttributeArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1UnitRange.html">UnitRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1UnitVecCodec.html">UnitVecCodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1UnknownCodec.html">UnknownCodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index filtering on active / inactive state of host voxel.  <a href="classopenvdb_1_1v10__0_1_1points_1_1ValueMaskFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1ValueVoxelCIter.html">ValueVoxelCIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator over array indices in a single voxel.  <a href="classopenvdb_1_1v10__0_1_1points_1_1ValueVoxelCIter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1VolumeTransfer.html">VolumeTransfer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1VolumeTransfer.html" title="The VolumeTransfer module provides methods to automatically setup and access destination buffers for ...">VolumeTransfer</a> module provides methods to automatically setup and access destination buffers for multiple target volumes of arbitrary types. Deriving from a <a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1VolumeTransfer.html" title="The VolumeTransfer module provides methods to automatically setup and access destination buffers for ...">VolumeTransfer</a> ensures that the available buffers correlate to the order of the provided tree arguments.  <a href="structopenvdb_1_1v10__0_1_1points_1_1VolumeTransfer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1VolumeTransfer_3_01TreeT_01_4.html">VolumeTransfer&lt; TreeT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1VolumeTransfer.html" title="The VolumeTransfer module provides methods to automatically setup and access destination buffers for ...">VolumeTransfer</a> specialization for a single target volume.  <a href="structopenvdb_1_1v10__0_1_1points_1_1VolumeTransfer_3_01TreeT_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af44fac5036c56999ca811116b73eca72"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#af44fac5036c56999ca811116b73eca72">StringAttributeArray</a> = <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a>&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>, <a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1StringCodec.html">StringCodec</a>&lt; false &gt;&gt;</td></tr>
<tr class="separator:af44fac5036c56999ca811116b73eca72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc95058fb208e9baa08dab77d98c5fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a9bc95058fb208e9baa08dab77d98c5fa">GroupAttributeArray</a> = <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a>&lt; <a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a714bfd681b0e82019a95174ecdb6a889">GroupType</a>, <a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1GroupCodec.html">GroupCodec</a> &gt;</td></tr>
<tr class="separator:a9bc95058fb208e9baa08dab77d98c5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714bfd681b0e82019a95174ecdb6a889"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a714bfd681b0e82019a95174ecdb6a889">GroupType</a> = uint8_t</td></tr>
<tr class="separator:a714bfd681b0e82019a95174ecdb6a889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8954944cf980f1f874a6510497568338"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a8954944cf980f1f874a6510497568338">ActiveFilter</a> = <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a>&lt; true &gt;</td></tr>
<tr class="separator:a8954944cf980f1f874a6510497568338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8273cc7bb48dded419013b35a6491bc0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a8273cc7bb48dded419013b35a6491bc0">InactiveFilter</a> = <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a>&lt; false &gt;</td></tr>
<tr class="separator:a8273cc7bb48dded419013b35a6491bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fec47b2a3d864d85c53f69c3655fdbf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a7fec47b2a3d864d85c53f69c3655fdbf">PointDataTree</a> = <a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1Tree.html">tree::Tree</a>&lt; <a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1RootNode.html">tree::RootNode</a>&lt; <a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1InternalNode.html">tree::InternalNode</a>&lt; <a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1InternalNode.html">tree::InternalNode</a>&lt; <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1PointDataLeafNode.html">PointDataLeafNode</a>&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#afcdd46e3c391ea8febd5fa6017b9f19b">PointDataIndex32</a>, 3 &gt;, 4 &gt;, 5 &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a7fec47b2a3d864d85c53f69c3655fdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point index tree configured to match the default VDB configurations.  <a href="#a7fec47b2a3d864d85c53f69c3655fdbf">More...</a><br /></td></tr>
<tr class="separator:a7fec47b2a3d864d85c53f69c3655fdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf438a63a8a41ec38b6d7ceae6467678"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#acf438a63a8a41ec38b6d7ceae6467678">PointDataGrid</a> = <a class="el" href="classopenvdb_1_1v10__0_1_1Grid.html">Grid</a>&lt; <a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a7fec47b2a3d864d85c53f69c3655fdbf">PointDataTree</a> &gt;</td></tr>
<tr class="memdesc:acf438a63a8a41ec38b6d7ceae6467678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point data grid.  <a href="#acf438a63a8a41ec38b6d7ceae6467678">More...</a><br /></td></tr>
<tr class="separator:acf438a63a8a41ec38b6d7ceae6467678"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae71b1a4d4abc6a321046036c37ae645e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ae71b1a4d4abc6a321046036c37ae645e">RasterMode</a> { <a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ae71b1a4d4abc6a321046036c37ae645eac5d2a98a2112d89452e04fe14de91b91">ACCUMULATE</a> = 0, 
<a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ae71b1a4d4abc6a321046036c37ae645ea115f17a28532bbd6f0f5ec83ed20692a">MAXIMUM</a>, 
<a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ae71b1a4d4abc6a321046036c37ae645ea16de38737a9f8366e9b2042b4e9b6290">AVERAGE</a>
 }<tr class="memdesc:ae71b1a4d4abc6a321046036c37ae645e"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to composite points into a volume.  <a href="namespaceopenvdb_1_1v10__0_1_1points.html#ae71b1a4d4abc6a321046036c37ae645e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae71b1a4d4abc6a321046036c37ae645e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a62158f26e5900828b1dc3c574ef3e268"><td class="memTemplParams" colspan="2">template&lt;typename IntegerT , typename FloatT &gt; </td></tr>
<tr class="memitem:a62158f26e5900828b1dc3c574ef3e268"><td class="memTemplItemLeft" align="right" valign="top">IntegerT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a62158f26e5900828b1dc3c574ef3e268">floatingPointToFixedPoint</a> (const FloatT s)</td></tr>
<tr class="separator:a62158f26e5900828b1dc3c574ef3e268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c3dd120bd13cfeddaa95377e674471"><td class="memTemplParams" colspan="2">template&lt;typename FloatT , typename IntegerT &gt; </td></tr>
<tr class="memitem:a85c3dd120bd13cfeddaa95377e674471"><td class="memTemplItemLeft" align="right" valign="top">FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a85c3dd120bd13cfeddaa95377e674471">fixedPointToFloatingPoint</a> (const IntegerT s)</td></tr>
<tr class="separator:a85c3dd120bd13cfeddaa95377e674471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbf4bd9ecbb55dc2107708fbff0def2"><td class="memTemplParams" colspan="2">template&lt;typename IntegerVectorT , typename FloatT &gt; </td></tr>
<tr class="memitem:a6dbf4bd9ecbb55dc2107708fbff0def2"><td class="memTemplItemLeft" align="right" valign="top">IntegerVectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a6dbf4bd9ecbb55dc2107708fbff0def2">floatingPointToFixedPoint</a> (const <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; FloatT &gt; &amp;v)</td></tr>
<tr class="separator:a6dbf4bd9ecbb55dc2107708fbff0def2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7038f079a6df66adf5fc413c687029"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT , typename IntegerT &gt; </td></tr>
<tr class="memitem:abb7038f079a6df66adf5fc413c687029"><td class="memTemplItemLeft" align="right" valign="top">FloatVectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#abb7038f079a6df66adf5fc413c687029">fixedPointToFloatingPoint</a> (const <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; IntegerT &gt; &amp;v)</td></tr>
<tr class="separator:abb7038f079a6df66adf5fc413c687029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a7e9c443da80e78e308df87ba38846"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a95a7e9c443da80e78e308df87ba38846">isString</a> (const <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeArray.html">AttributeArray</a> &amp;array)</td></tr>
<tr class="separator:a95a7e9c443da80e78e308df87ba38846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afb2350c490943a40eb6eaeec006ff2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a2afb2350c490943a40eb6eaeec006ff2">isGroup</a> (const <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeArray.html">AttributeArray</a> &amp;array)</td></tr>
<tr class="separator:a2afb2350c490943a40eb6eaeec006ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb5e64392fdf29bc3462e5a60713158"><td class="memTemplParams" colspan="2">template&lt;typename IterT &gt; </td></tr>
<tr class="memitem:adfb5e64392fdf29bc3462e5a60713158"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#adfb5e64392fdf29bc3462e5a60713158">iterCount</a> (const IterT &amp;iter)</td></tr>
<tr class="memdesc:adfb5e64392fdf29bc3462e5a60713158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count up the number of times the iterator can iterate.  <a href="#adfb5e64392fdf29bc3462e5a60713158">More...</a><br /></td></tr>
<tr class="separator:adfb5e64392fdf29bc3462e5a60713158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79ffb24dc5aee12a75d1507966164bc"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename VelGridT , typename AdvectFilterT  = NullFilter, typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:ab79ffb24dc5aee12a75d1507966164bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ab79ffb24dc5aee12a75d1507966164bc">advectPoints</a> (PointDataGridT &amp;points, const VelGridT &amp;velocity, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> integrationOrder, const double dt, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> timeSteps, const AdvectFilterT &amp;advectFilter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool cached=true)</td></tr>
<tr class="memdesc:ab79ffb24dc5aee12a75d1507966164bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advect points in a PointDataGrid through a velocity grid.  <a href="#ab79ffb24dc5aee12a75d1507966164bc">More...</a><br /></td></tr>
<tr class="separator:ab79ffb24dc5aee12a75d1507966164bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8216e14812f6a9c9aaf1af5b2ad36b"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a9f8216e14812f6a9c9aaf1af5b2ad36b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a9f8216e14812f6a9c9aaf1af5b2ad36b">appendAttribute</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;name, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a3907786c2430dbab9f198bfd5b31ff7c">NamePair</a> &amp;type, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> strideOrTotalSize=1, const bool constantStride=true, const <a class="el" href="classopenvdb_1_1v10__0_1_1Metadata.html">Metadata</a> *defaultValue=nullptr, const bool hidden=false, const bool transient=false)</td></tr>
<tr class="memdesc:a9f8216e14812f6a9c9aaf1af5b2ad36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new attribute to the VDB tree (this method does not require a templated AttributeType)  <a href="#a9f8216e14812f6a9c9aaf1af5b2ad36b">More...</a><br /></td></tr>
<tr class="separator:a9f8216e14812f6a9c9aaf1af5b2ad36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12af91f538ab5256ce2db4afe3b9dd31"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CodecType  = NullCodec, typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a12af91f538ab5256ce2db4afe3b9dd31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a12af91f538ab5256ce2db4afe3b9dd31">appendAttribute</a> (PointDataTreeT &amp;tree, const std::string &amp;name, const ValueType &amp;uniformValue=<a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1point__attribute__internal_1_1Default.html">point_attribute_internal::Default</a>&lt; ValueType &gt;::<a class="el" href="GridBuilder_8h.html#a0bd8e8b76a16eb8c0d32d42313755c8e">value</a>(), const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> strideOrTotalSize=1, const bool constantStride=true, const <a class="el" href="classopenvdb_1_1v10__0_1_1TypedMetadata.html">TypedMetadata</a>&lt; ValueType &gt; *defaultValue=nullptr, const bool hidden=false, const bool transient=false)</td></tr>
<tr class="memdesc:a12af91f538ab5256ce2db4afe3b9dd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new attribute to the VDB tree.  <a href="#a12af91f538ab5256ce2db4afe3b9dd31">More...</a><br /></td></tr>
<tr class="separator:a12af91f538ab5256ce2db4afe3b9dd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b46b75155cc394f4ad4b540f167523a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a6b46b75155cc394f4ad4b540f167523a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a6b46b75155cc394f4ad4b540f167523a">collapseAttribute</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;name, const ValueType &amp;uniformValue=<a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1point__attribute__internal_1_1Default.html">point_attribute_internal::Default</a>&lt; ValueType &gt;::<a class="el" href="GridBuilder_8h.html#a0bd8e8b76a16eb8c0d32d42313755c8e">value</a>())</td></tr>
<tr class="memdesc:a6b46b75155cc394f4ad4b540f167523a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse the attribute into a uniform value.  <a href="#a6b46b75155cc394f4ad4b540f167523a">More...</a><br /></td></tr>
<tr class="separator:a6b46b75155cc394f4ad4b540f167523a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa22577ec29a353a700c9a3fa03906f"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:aaaa22577ec29a353a700c9a3fa03906f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#aaaa22577ec29a353a700c9a3fa03906f">dropAttributes</a> (PointDataTreeT &amp;tree, const std::vector&lt; size_t &gt; &amp;indices)</td></tr>
<tr class="memdesc:aaaa22577ec29a353a700c9a3fa03906f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops attributes from the VDB tree.  <a href="#aaaa22577ec29a353a700c9a3fa03906f">More...</a><br /></td></tr>
<tr class="separator:aaaa22577ec29a353a700c9a3fa03906f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8ee0b505384ce90253b77516cedce4"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:aaa8ee0b505384ce90253b77516cedce4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#aaa8ee0b505384ce90253b77516cedce4">dropAttributes</a> (PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;names)</td></tr>
<tr class="memdesc:aaa8ee0b505384ce90253b77516cedce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops attributes from the VDB tree.  <a href="#aaa8ee0b505384ce90253b77516cedce4">More...</a><br /></td></tr>
<tr class="separator:aaa8ee0b505384ce90253b77516cedce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630071eb13957e9c9683fafb845ec9ce"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a630071eb13957e9c9683fafb845ec9ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a630071eb13957e9c9683fafb845ec9ce">dropAttribute</a> (PointDataTreeT &amp;tree, const size_t &amp;index)</td></tr>
<tr class="memdesc:a630071eb13957e9c9683fafb845ec9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop one attribute from the VDB tree (convenience method).  <a href="#a630071eb13957e9c9683fafb845ec9ce">More...</a><br /></td></tr>
<tr class="separator:a630071eb13957e9c9683fafb845ec9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd25e23091c52fb8da4fcb50369ad45b"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:acd25e23091c52fb8da4fcb50369ad45b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#acd25e23091c52fb8da4fcb50369ad45b">dropAttribute</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;name)</td></tr>
<tr class="memdesc:acd25e23091c52fb8da4fcb50369ad45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop one attribute from the VDB tree (convenience method).  <a href="#acd25e23091c52fb8da4fcb50369ad45b">More...</a><br /></td></tr>
<tr class="separator:acd25e23091c52fb8da4fcb50369ad45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb82e6282deeaa12012efbe386ce564"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:aceb82e6282deeaa12012efbe386ce564"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#aceb82e6282deeaa12012efbe386ce564">renameAttributes</a> (PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;oldNames, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;newNames)</td></tr>
<tr class="memdesc:aceb82e6282deeaa12012efbe386ce564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename attributes in a VDB tree.  <a href="#aceb82e6282deeaa12012efbe386ce564">More...</a><br /></td></tr>
<tr class="separator:aceb82e6282deeaa12012efbe386ce564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb60e92fdbb25ad5822945cc30b3e8b2"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:aeb60e92fdbb25ad5822945cc30b3e8b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#aeb60e92fdbb25ad5822945cc30b3e8b2">renameAttribute</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;oldName, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;newName)</td></tr>
<tr class="memdesc:aeb60e92fdbb25ad5822945cc30b3e8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename an attribute in a VDB tree.  <a href="#aeb60e92fdbb25ad5822945cc30b3e8b2">More...</a><br /></td></tr>
<tr class="separator:aeb60e92fdbb25ad5822945cc30b3e8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467b8eefb87ca02fa0f017c40c08d674"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a467b8eefb87ca02fa0f017c40c08d674"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a467b8eefb87ca02fa0f017c40c08d674">compactAttributes</a> (PointDataTreeT &amp;tree)</td></tr>
<tr class="memdesc:a467b8eefb87ca02fa0f017c40c08d674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact attributes in a VDB tree (if possible).  <a href="#a467b8eefb87ca02fa0f017c40c08d674">More...</a><br /></td></tr>
<tr class="separator:a467b8eefb87ca02fa0f017c40c08d674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15a1ee82d506999536458071ba44299"><td class="memTemplParams" colspan="2">template&lt;typename CompressionT , typename PointDataGridT , typename PositionArrayT , typename PointIndexGridT &gt; </td></tr>
<tr class="memitem:ab15a1ee82d506999536458071ba44299"><td class="memTemplItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ab15a1ee82d506999536458071ba44299">createPointDataGrid</a> (const PointIndexGridT &amp;pointIndexGrid, const PositionArrayT &amp;positions, const <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html">math::Transform</a> &amp;xform, const <a class="el" href="classopenvdb_1_1v10__0_1_1Metadata.html">Metadata</a> *positionDefaultValue=nullptr)</td></tr>
<tr class="memdesc:ab15a1ee82d506999536458071ba44299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Localises points with position into a <code>PointDataGrid</code> into two stages: allocation of the leaf attribute data and population of the positions.  <a href="#ab15a1ee82d506999536458071ba44299">More...</a><br /></td></tr>
<tr class="separator:ab15a1ee82d506999536458071ba44299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c2da02df6fb329b2684f56617c39b9"><td class="memTemplParams" colspan="2">template&lt;typename CompressionT , typename PointDataGridT , typename ValueT &gt; </td></tr>
<tr class="memitem:a07c2da02df6fb329b2684f56617c39b9"><td class="memTemplItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a07c2da02df6fb329b2684f56617c39b9">createPointDataGrid</a> (const std::vector&lt; ValueT &gt; &amp;positions, const <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html">math::Transform</a> &amp;xform, const <a class="el" href="classopenvdb_1_1v10__0_1_1Metadata.html">Metadata</a> *positionDefaultValue=nullptr)</td></tr>
<tr class="memdesc:a07c2da02df6fb329b2684f56617c39b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to create a <code>PointDataGrid</code> from a std::vector of point positions.  <a href="#a07c2da02df6fb329b2684f56617c39b9">More...</a><br /></td></tr>
<tr class="separator:a07c2da02df6fb329b2684f56617c39b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7557b731e5392e4448f933a84139950"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT , typename PointIndexTreeT , typename PointArrayT &gt; </td></tr>
<tr class="memitem:ad7557b731e5392e4448f933a84139950"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ad7557b731e5392e4448f933a84139950">populateAttribute</a> (PointDataTreeT &amp;tree, const PointIndexTreeT &amp;pointIndexTree, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">openvdb::Name</a> &amp;attributeName, const PointArrayT &amp;data, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> stride=1, const bool insertMetadata=true)</td></tr>
<tr class="memdesc:ad7557b731e5392e4448f933a84139950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores point attribute data in an existing <code>PointDataGrid</code> attribute.  <a href="#ad7557b731e5392e4448f933a84139950">More...</a><br /></td></tr>
<tr class="separator:ad7557b731e5392e4448f933a84139950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf905ca86b725954bf900e3caf6b431a"><td class="memTemplParams" colspan="2">template&lt;typename PositionAttribute , typename PointDataGridT , typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:acf905ca86b725954bf900e3caf6b431a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#acf905ca86b725954bf900e3caf6b431a">convertPointDataGridPosition</a> (PositionAttribute &amp;positionAttribute, const PointDataGridT &amp;grid, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;<a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a639be5922b4acf36c519e88f9ea8ff7d">pointOffsets</a>, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> startOffset, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false)</td></tr>
<tr class="memdesc:acf905ca86b725954bf900e3caf6b431a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the position attribute from a Point Data <a class="el" href="classopenvdb_1_1v10__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a>.  <a href="#acf905ca86b725954bf900e3caf6b431a">More...</a><br /></td></tr>
<tr class="separator:acf905ca86b725954bf900e3caf6b431a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91e520838e75f17a4e0a3505c128931"><td class="memTemplParams" colspan="2">template&lt;typename TypedAttribute , typename PointDataTreeT , typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:ac91e520838e75f17a4e0a3505c128931"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ac91e520838e75f17a4e0a3505c128931">convertPointDataGridAttribute</a> (TypedAttribute &amp;attribute, const PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;<a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a639be5922b4acf36c519e88f9ea8ff7d">pointOffsets</a>, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> startOffset, const unsigned arrayIndex, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> stride=1, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false)</td></tr>
<tr class="memdesc:ac91e520838e75f17a4e0a3505c128931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the attribute from a PointDataGrid.  <a href="#ac91e520838e75f17a4e0a3505c128931">More...</a><br /></td></tr>
<tr class="separator:ac91e520838e75f17a4e0a3505c128931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4875034852344d7f676c955bb764d9c1"><td class="memTemplParams" colspan="2">template&lt;typename Group , typename PointDataTreeT , typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a4875034852344d7f676c955bb764d9c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a4875034852344d7f676c955bb764d9c1">convertPointDataGridGroup</a> (Group &amp;group, const PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;<a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a639be5922b4acf36c519e88f9ea8ff7d">pointOffsets</a>, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> startOffset, const AttributeSet::Descriptor::GroupIndex index, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false)</td></tr>
<tr class="memdesc:a4875034852344d7f676c955bb764d9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the group from a PointDataGrid.  <a href="#a4875034852344d7f676c955bb764d9c1">More...</a><br /></td></tr>
<tr class="separator:a4875034852344d7f676c955bb764d9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85baad70404957c0b435068440ae1c0f"><td class="memTemplParams" colspan="2">template&lt;typename PositionWrapper , typename InterrupterT  = openvdb::util::NullInterrupter, typename VecT  = typename internal::ValueTypeTraits&lt;PositionWrapper&gt;::Type&gt; </td></tr>
<tr class="memitem:a85baad70404957c0b435068440ae1c0f"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a85baad70404957c0b435068440ae1c0f">computeVoxelSize</a> (const PositionWrapper &amp;positions, const uint32_t pointsPerVoxel, const <a class="el" href="namespaceopenvdb_1_1v10__0_1_1math.html#abaf7f913bf1752b9157259ffa32704ca">math::Mat4d</a> transform=<a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Mat4.html#a71890348d53084982694f39988f4b286">math::Mat4d::identity</a>(), const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> decimalPlaces=5, InterrupterT *const interrupter=nullptr)</td></tr>
<tr class="separator:a85baad70404957c0b435068440ae1c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbfd50108bbe665a6e1a0607335a5df"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT , typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a8dbfd50108bbe665a6e1a0607335a5df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a8dbfd50108bbe665a6e1a0607335a5df">pointCount</a> (const PointDataTreeT &amp;tree, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false, const bool threaded=true)</td></tr>
<tr class="memdesc:a8dbfd50108bbe665a6e1a0607335a5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the total number of points in a PointDataTree.  <a href="#a8dbfd50108bbe665a6e1a0607335a5df">More...</a><br /></td></tr>
<tr class="separator:a8dbfd50108bbe665a6e1a0607335a5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639be5922b4acf36c519e88f9ea8ff7d"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT , typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a639be5922b4acf36c519e88f9ea8ff7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a639be5922b4acf36c519e88f9ea8ff7d">pointOffsets</a> (std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;pointOffsets, const PointDataTreeT &amp;tree, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false, const bool threaded=true)</td></tr>
<tr class="memdesc:a639be5922b4acf36c519e88f9ea8ff7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate an array of cumulative point offsets per leaf node.  <a href="#a639be5922b4acf36c519e88f9ea8ff7d">More...</a><br /></td></tr>
<tr class="separator:a639be5922b4acf36c519e88f9ea8ff7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90464075cf4382ab74a75288eebfce02"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename GridT  = typename PointDataGridT::template ValueConverter&lt;Int32&gt;::Type, typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a90464075cf4382ab74a75288eebfce02"><td class="memTemplItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a90464075cf4382ab74a75288eebfce02">pointCountGrid</a> (const PointDataGridT &amp;grid, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>())</td></tr>
<tr class="memdesc:a90464075cf4382ab74a75288eebfce02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a new grid with voxel values to store the number of points per voxel.  <a href="#a90464075cf4382ab74a75288eebfce02">More...</a><br /></td></tr>
<tr class="separator:a90464075cf4382ab74a75288eebfce02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2159bcf1fea38531ec493459f3b37857"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename GridT  = typename PointDataGridT::template ValueConverter&lt;Int32&gt;::Type, typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a2159bcf1fea38531ec493459f3b37857"><td class="memTemplItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a2159bcf1fea38531ec493459f3b37857">pointCountGrid</a> (const PointDataGridT &amp;grid, const openvdb::math::Transform &amp;transform, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>())</td></tr>
<tr class="memdesc:a2159bcf1fea38531ec493459f3b37857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a new grid that uses the supplied transform with voxel values to store the number of points per voxel.  <a href="#a2159bcf1fea38531ec493459f3b37857">More...</a><br /></td></tr>
<tr class="separator:a2159bcf1fea38531ec493459f3b37857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af351ce8e812595d5fede2fd73ce96420"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:af351ce8e812595d5fede2fd73ce96420"><td class="memTemplItemLeft" align="right" valign="top">AttributeSet::Descriptor::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#af351ce8e812595d5fede2fd73ce96420">makeDescriptorUnique</a> (PointDataTreeT &amp;tree)</td></tr>
<tr class="memdesc:af351ce8e812595d5fede2fd73ce96420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy the descriptor across all leaf nodes.  <a href="#af351ce8e812595d5fede2fd73ce96420">More...</a><br /></td></tr>
<tr class="separator:af351ce8e812595d5fede2fd73ce96420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d85a4b1b93c26f69ecf71e75017275b"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a0d85a4b1b93c26f69ecf71e75017275b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a0d85a4b1b93c26f69ecf71e75017275b">setStreamingMode</a> (PointDataTreeT &amp;tree, bool on=true)</td></tr>
<tr class="memdesc:a0d85a4b1b93c26f69ecf71e75017275b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the streaming mode on all attributes in the tree to collapse the attributes after deconstructing a bound <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeHandle.html">AttributeHandle</a> to each array. This results in better memory efficiency when the data is streamed into another data structure (typically for rendering).  <a href="#a0d85a4b1b93c26f69ecf71e75017275b">More...</a><br /></td></tr>
<tr class="separator:a0d85a4b1b93c26f69ecf71e75017275b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2205d8c5a7c5fd2e24145a9df5ad6485"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a2205d8c5a7c5fd2e24145a9df5ad6485"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a2205d8c5a7c5fd2e24145a9df5ad6485">prefetch</a> (PointDataTreeT &amp;tree, bool position=true, bool otherAttributes=true)</td></tr>
<tr class="memdesc:a2205d8c5a7c5fd2e24145a9df5ad6485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequentially pre-fetch all delayed-load voxel and attribute data from disk in order to accelerate subsequent random access.  <a href="#a2205d8c5a7c5fd2e24145a9df5ad6485">More...</a><br /></td></tr>
<tr class="separator:a2205d8c5a7c5fd2e24145a9df5ad6485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9d921b422e929c3786e77c8d4c811f"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a6b9d921b422e929c3786e77c8d4c811f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a6b9d921b422e929c3786e77c8d4c811f">deleteFromGroups</a> (PointDataTreeT &amp;pointTree, const std::vector&lt; std::string &gt; &amp;groups, bool invert=false, bool drop=true)</td></tr>
<tr class="memdesc:a6b9d921b422e929c3786e77c8d4c811f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete points that are members of specific groups.  <a href="#a6b9d921b422e929c3786e77c8d4c811f">More...</a><br /></td></tr>
<tr class="separator:a6b9d921b422e929c3786e77c8d4c811f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbd30a3741affcd2b2434124a34149d"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:afdbd30a3741affcd2b2434124a34149d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#afdbd30a3741affcd2b2434124a34149d">deleteFromGroup</a> (PointDataTreeT &amp;pointTree, const std::string &amp;group, bool invert=false, bool drop=true)</td></tr>
<tr class="memdesc:afdbd30a3741affcd2b2434124a34149d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete points that are members of a group.  <a href="#afdbd30a3741affcd2b2434124a34149d">More...</a><br /></td></tr>
<tr class="separator:afdbd30a3741affcd2b2434124a34149d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e318d6bae7846125e0ac39c66024fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a5e318d6bae7846125e0ac39c66024fc2">deleteMissingPointGroups</a> (std::vector&lt; std::string &gt; &amp;groups, const <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeSet.html#abf4c4c63e6ef3b54e88cd0cab0be66c8">AttributeSet::Descriptor</a> &amp;descriptor)</td></tr>
<tr class="memdesc:a5e318d6bae7846125e0ac39c66024fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete any group that is not present in the Descriptor.  <a href="#a5e318d6bae7846125e0ac39c66024fc2">More...</a><br /></td></tr>
<tr class="separator:a5e318d6bae7846125e0ac39c66024fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df5f0462ae9d328e4987971cda4c7ee"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a6df5f0462ae9d328e4987971cda4c7ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a6df5f0462ae9d328e4987971cda4c7ee">appendGroup</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group)</td></tr>
<tr class="memdesc:a6df5f0462ae9d328e4987971cda4c7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new empty group to the VDB tree.  <a href="#a6df5f0462ae9d328e4987971cda4c7ee">More...</a><br /></td></tr>
<tr class="separator:a6df5f0462ae9d328e4987971cda4c7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2483abeddd3034b01b946caf10f84f"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:aad2483abeddd3034b01b946caf10f84f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#aad2483abeddd3034b01b946caf10f84f">appendGroups</a> (PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;groups)</td></tr>
<tr class="memdesc:aad2483abeddd3034b01b946caf10f84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends new empty groups to the VDB tree.  <a href="#aad2483abeddd3034b01b946caf10f84f">More...</a><br /></td></tr>
<tr class="separator:aad2483abeddd3034b01b946caf10f84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f0afec32f566e10a0a25fde4466dba"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:ac1f0afec32f566e10a0a25fde4466dba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ac1f0afec32f566e10a0a25fde4466dba">dropGroup</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const bool compact=true)</td></tr>
<tr class="memdesc:ac1f0afec32f566e10a0a25fde4466dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops an existing group from the VDB tree.  <a href="#ac1f0afec32f566e10a0a25fde4466dba">More...</a><br /></td></tr>
<tr class="separator:ac1f0afec32f566e10a0a25fde4466dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c87fccd745143ae4e42c5b1f4998508"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a0c87fccd745143ae4e42c5b1f4998508"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a0c87fccd745143ae4e42c5b1f4998508">dropGroups</a> (PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;groups)</td></tr>
<tr class="memdesc:a0c87fccd745143ae4e42c5b1f4998508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops existing groups from the VDB tree, the tree is compacted after dropping.  <a href="#a0c87fccd745143ae4e42c5b1f4998508">More...</a><br /></td></tr>
<tr class="separator:a0c87fccd745143ae4e42c5b1f4998508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7814ccafca96a095c60c6c6438b7eb2"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:ad7814ccafca96a095c60c6c6438b7eb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ad7814ccafca96a095c60c6c6438b7eb2">dropGroups</a> (PointDataTreeT &amp;tree)</td></tr>
<tr class="memdesc:ad7814ccafca96a095c60c6c6438b7eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops all existing groups from the VDB tree, the tree is compacted after dropping.  <a href="#ad7814ccafca96a095c60c6c6438b7eb2">More...</a><br /></td></tr>
<tr class="separator:ad7814ccafca96a095c60c6c6438b7eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6057529f97b428787a3e993ad12d3cf2"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a6057529f97b428787a3e993ad12d3cf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a6057529f97b428787a3e993ad12d3cf2">compactGroups</a> (PointDataTreeT &amp;tree)</td></tr>
<tr class="memdesc:a6057529f97b428787a3e993ad12d3cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compacts existing groups of a VDB Tree to use less memory if possible.  <a href="#a6057529f97b428787a3e993ad12d3cf2">More...</a><br /></td></tr>
<tr class="separator:a6057529f97b428787a3e993ad12d3cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1866ee320dd051901bb7f4f49e155cee"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT , typename PointIndexTreeT &gt; </td></tr>
<tr class="memitem:a1866ee320dd051901bb7f4f49e155cee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a1866ee320dd051901bb7f4f49e155cee">setGroup</a> (PointDataTreeT &amp;tree, const PointIndexTreeT &amp;indexTree, const std::vector&lt; short &gt; &amp;membership, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const bool remove=false)</td></tr>
<tr class="memdesc:a1866ee320dd051901bb7f4f49e155cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets group membership from a PointIndexTree-ordered vector.  <a href="#a1866ee320dd051901bb7f4f49e155cee">More...</a><br /></td></tr>
<tr class="separator:a1866ee320dd051901bb7f4f49e155cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522af44dcf8da3f9e6c7b747e075f155"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a522af44dcf8da3f9e6c7b747e075f155"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a522af44dcf8da3f9e6c7b747e075f155">setGroup</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const bool member=true)</td></tr>
<tr class="memdesc:a522af44dcf8da3f9e6c7b747e075f155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets membership for the specified group for all points (on/off).  <a href="#a522af44dcf8da3f9e6c7b747e075f155">More...</a><br /></td></tr>
<tr class="separator:a522af44dcf8da3f9e6c7b747e075f155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ce5ef333b529b92e4acb1bddeec93c"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT , typename FilterT &gt; </td></tr>
<tr class="memitem:ab5ce5ef333b529b92e4acb1bddeec93c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ab5ce5ef333b529b92e4acb1bddeec93c">setGroupByFilter</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const FilterT &amp;filter)</td></tr>
<tr class="memdesc:ab5ce5ef333b529b92e4acb1bddeec93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets group membership based on a provided filter.  <a href="#ab5ce5ef333b529b92e4acb1bddeec93c">More...</a><br /></td></tr>
<tr class="separator:ab5ce5ef333b529b92e4acb1bddeec93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630ad019fee99cc74bb048d047212218"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a630ad019fee99cc74bb048d047212218"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a630ad019fee99cc74bb048d047212218">setGroupByRandomTarget</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> targetPoints, const unsigned int seed=0)</td></tr>
<tr class="separator:a630ad019fee99cc74bb048d047212218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac775f2efb51fe765dc1e54e4f33f85cf"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:ac775f2efb51fe765dc1e54e4f33f85cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ac775f2efb51fe765dc1e54e4f33f85cf">setGroupByRandomPercentage</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const float percentage=10.0f, const unsigned int seed=0)</td></tr>
<tr class="separator:ac775f2efb51fe765dc1e54e4f33f85cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b55bc8e90ae04b25f2e09e5f88253e5"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT , typename MaskTreeT  = typename PointDataTreeT::template ValueConverter&lt;bool&gt;::Type, typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a2b55bc8e90ae04b25f2e09e5f88253e5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#acbcb5f84dd5976c2bb8d02c10017d060">TreeBase</a>, PointDataTreeT &gt;::<a class="el" href="GridBuilder_8h.html#a0bd8e8b76a16eb8c0d32d42313755c8e">value</a> &amp;&amp;std::is_same&lt; typename MaskTreeT::ValueType, bool &gt;::<a class="el" href="GridBuilder_8h.html#a0bd8e8b76a16eb8c0d32d42313755c8e">value</a>, typename MaskTreeT::Ptr &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a2b55bc8e90ae04b25f2e09e5f88253e5">convertPointsToMask</a> (const PointDataTreeT &amp;tree, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), bool threaded=true)</td></tr>
<tr class="memdesc:a2b55bc8e90ae04b25f2e09e5f88253e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a Mask Tree from a Point Data Tree.  <a href="#a2b55bc8e90ae04b25f2e09e5f88253e5">More...</a><br /></td></tr>
<tr class="separator:a2b55bc8e90ae04b25f2e09e5f88253e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba59ee8dd9f55d6922565f27f3921c3"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename MaskGridT  = typename PointDataGridT::template ValueConverter&lt;bool&gt;::Type, typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a4ba59ee8dd9f55d6922565f27f3921c3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classopenvdb_1_1v10__0_1_1GridBase.html">GridBase</a>, PointDataGridT &gt;::<a class="el" href="GridBuilder_8h.html#a0bd8e8b76a16eb8c0d32d42313755c8e">value</a> &amp;&amp;std::is_same&lt; typename MaskGridT::ValueType, bool &gt;::<a class="el" href="GridBuilder_8h.html#a0bd8e8b76a16eb8c0d32d42313755c8e">value</a>, typename MaskGridT::Ptr &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a4ba59ee8dd9f55d6922565f27f3921c3">convertPointsToMask</a> (const PointDataGridT &amp;grid, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), bool threaded=true)</td></tr>
<tr class="memdesc:a4ba59ee8dd9f55d6922565f27f3921c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a Mask <a class="el" href="classopenvdb_1_1v10__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a> from a Point Data <a class="el" href="classopenvdb_1_1v10__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a>.  <a href="#a4ba59ee8dd9f55d6922565f27f3921c3">More...</a><br /></td></tr>
<tr class="separator:a4ba59ee8dd9f55d6922565f27f3921c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdf43efd3cbc67e8d781bd3d06fb85f"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename MaskT  = typename PointDataGridT::template ValueConverter&lt;bool&gt;::Type, typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:adfdf43efd3cbc67e8d781bd3d06fb85f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename MaskT::ValueType, bool &gt;::<a class="el" href="GridBuilder_8h.html#a0bd8e8b76a16eb8c0d32d42313755c8e">value</a>, typename MaskT::Ptr &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#adfdf43efd3cbc67e8d781bd3d06fb85f">convertPointsToMask</a> (const PointDataGridT &amp;grid, const openvdb::math::Transform &amp;transform, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), bool threaded=true)</td></tr>
<tr class="memdesc:adfdf43efd3cbc67e8d781bd3d06fb85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a Mask <a class="el" href="classopenvdb_1_1v10__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a> from a Point Data <a class="el" href="classopenvdb_1_1v10__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a> using a new transform.  <a href="#adfdf43efd3cbc67e8d781bd3d06fb85f">More...</a><br /></td></tr>
<tr class="separator:adfdf43efd3cbc67e8d781bd3d06fb85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0082c20c402a864700014eae174838"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename DeformerT , typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a2d0082c20c402a864700014eae174838"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a2d0082c20c402a864700014eae174838">movePoints</a> (PointDataGridT &amp;points, DeformerT &amp;deformer, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), <a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1future_1_1Advect.html">future::Advect</a> *objectNotInUse=nullptr, bool threaded=true)</td></tr>
<tr class="memdesc:a2d0082c20c402a864700014eae174838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move points in a PointDataGrid using a custom deformer.  <a href="#a2d0082c20c402a864700014eae174838">More...</a><br /></td></tr>
<tr class="separator:a2d0082c20c402a864700014eae174838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d785b238fdbdf02b903fd9ddd453f3"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename DeformerT , typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:ad0d785b238fdbdf02b903fd9ddd453f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ad0d785b238fdbdf02b903fd9ddd453f3">movePoints</a> (PointDataGridT &amp;points, const <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html">math::Transform</a> &amp;transform, DeformerT &amp;deformer, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), <a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1future_1_1Advect.html">future::Advect</a> *objectNotInUse=nullptr, bool threaded=true)</td></tr>
<tr class="memdesc:ad0d785b238fdbdf02b903fd9ddd453f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move points in a PointDataGrid using a custom deformer and a new transform.  <a href="#ad0d785b238fdbdf02b903fd9ddd453f3">More...</a><br /></td></tr>
<tr class="separator:ad0d785b238fdbdf02b903fd9ddd453f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120917a417a08b222180816d267f0e50"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename SdfT  = typename PointDataGridT::template ValueConverter&lt;float&gt;::Type, typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a120917a417a08b222180816d267f0e50"><td class="memTemplItemLeft" align="right" valign="top">SdfT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a120917a417a08b222180816d267f0e50">rasterizeSpheres</a> (const PointDataGridT &amp;points, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> radius, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> halfband=<a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>, <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a> transform=nullptr, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a120917a417a08b222180816d267f0e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Narrow band sphere stamping with a uniform radius.  <a href="#a120917a417a08b222180816d267f0e50">More...</a><br /></td></tr>
<tr class="separator:a120917a417a08b222180816d267f0e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368f4fde28a7b92a670af70045a3c08c"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename RadiusT  = float, typename SdfT  = typename PointDataGridT::template ValueConverter&lt;float&gt;::Type, typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a368f4fde28a7b92a670af70045a3c08c"><td class="memTemplItemLeft" align="right" valign="top">SdfT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a368f4fde28a7b92a670af70045a3c08c">rasterizeSpheres</a> (const PointDataGridT &amp;points, const std::string &amp;radius, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> scale=1.0, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> halfband=<a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>, <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a> transform=nullptr, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a368f4fde28a7b92a670af70045a3c08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Narrow band sphere stamping with a varying radius.  <a href="#a368f4fde28a7b92a670af70045a3c08c">More...</a><br /></td></tr>
<tr class="separator:a368f4fde28a7b92a670af70045a3c08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7855e30f7a0d1526efa75cc1da5bd8"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename AttributeTypes , typename SdfT  = typename PointDataGridT::template ValueConverter&lt;float&gt;::Type, typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a5d7855e30f7a0d1526efa75cc1da5bd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v10__0.html#a0c9703e6ff5cc9deb6410c53412c22c3">GridPtrVec</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a5d7855e30f7a0d1526efa75cc1da5bd8">rasterizeSpheres</a> (const PointDataGridT &amp;points, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> radius, const std::vector&lt; std::string &gt; &amp;attributes, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> halfband=<a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>, <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a> transform=nullptr, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a5d7855e30f7a0d1526efa75cc1da5bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Narrow band sphere stamping with a uniform radius and closest point attribute transfer.  <a href="#a5d7855e30f7a0d1526efa75cc1da5bd8">More...</a><br /></td></tr>
<tr class="separator:a5d7855e30f7a0d1526efa75cc1da5bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc29e6ff518213c83a2868be36df2d58"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename AttributeTypes , typename RadiusT  = float, typename SdfT  = typename PointDataGridT::template ValueConverter&lt;float&gt;::Type, typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:abc29e6ff518213c83a2868be36df2d58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v10__0.html#a0c9703e6ff5cc9deb6410c53412c22c3">GridPtrVec</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#abc29e6ff518213c83a2868be36df2d58">rasterizeSpheres</a> (const PointDataGridT &amp;points, const std::string &amp;radius, const std::vector&lt; std::string &gt; &amp;attributes, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> scale=1.0, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> halfband=<a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>, <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a> transform=nullptr, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:abc29e6ff518213c83a2868be36df2d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Narrow band sphere stamping with a varying radius and closest point attribute transfer.  <a href="#abc29e6ff518213c83a2868be36df2d58">More...</a><br /></td></tr>
<tr class="separator:abc29e6ff518213c83a2868be36df2d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082f0d3ace2f284f821b49d68535c64b"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename SdfT  = typename PointDataGridT::template ValueConverter&lt;float&gt;::Type, typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a082f0d3ace2f284f821b49d68535c64b"><td class="memTemplItemLeft" align="right" valign="top">SdfT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a082f0d3ace2f284f821b49d68535c64b">rasterizeSmoothSpheres</a> (const PointDataGridT &amp;points, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> radius, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> searchRadius, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> halfband=<a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>, <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a> transform=nullptr, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a082f0d3ace2f284f821b49d68535c64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothed point distribution based sphere stamping with a uniform radius.  <a href="#a082f0d3ace2f284f821b49d68535c64b">More...</a><br /></td></tr>
<tr class="separator:a082f0d3ace2f284f821b49d68535c64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061f2cdb45d004922a317239e13437a9"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename RadiusT  = float, typename SdfT  = typename PointDataGridT::template ValueConverter&lt;float&gt;::Type, typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a061f2cdb45d004922a317239e13437a9"><td class="memTemplItemLeft" align="right" valign="top">SdfT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a061f2cdb45d004922a317239e13437a9">rasterizeSmoothSpheres</a> (const PointDataGridT &amp;points, const std::string &amp;radius, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> radiusScale, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> searchRadius, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> halfband=<a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>, <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a> transform=nullptr, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a061f2cdb45d004922a317239e13437a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothed point distribution based sphere stamping with a varying radius.  <a href="#a061f2cdb45d004922a317239e13437a9">More...</a><br /></td></tr>
<tr class="separator:a061f2cdb45d004922a317239e13437a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8effe83e84502ac0ba508d32f2e10a"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename AttributeTypes , typename SdfT  = typename PointDataGridT::template ValueConverter&lt;float&gt;::Type, typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a0a8effe83e84502ac0ba508d32f2e10a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v10__0.html#a0c9703e6ff5cc9deb6410c53412c22c3">GridPtrVec</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a0a8effe83e84502ac0ba508d32f2e10a">rasterizeSmoothSpheres</a> (const PointDataGridT &amp;points, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> radius, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> searchRadius, const std::vector&lt; std::string &gt; &amp;attributes, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> halfband=<a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>, <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a> transform=nullptr, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a0a8effe83e84502ac0ba508d32f2e10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothed point distribution based sphere stamping with a uniform radius and closest point attribute transfer.  <a href="#a0a8effe83e84502ac0ba508d32f2e10a">More...</a><br /></td></tr>
<tr class="separator:a0a8effe83e84502ac0ba508d32f2e10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3722592b607cb0eafbfa5c17ebdc3f"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename AttributeTypes , typename RadiusT  = float, typename SdfT  = typename PointDataGridT::template ValueConverter&lt;float&gt;::Type, typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a0f3722592b607cb0eafbfa5c17ebdc3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v10__0.html#a0c9703e6ff5cc9deb6410c53412c22c3">GridPtrVec</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a0f3722592b607cb0eafbfa5c17ebdc3f">rasterizeSmoothSpheres</a> (const PointDataGridT &amp;points, const std::string &amp;radius, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> radiusScale, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> searchRadius, const std::vector&lt; std::string &gt; &amp;attributes, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> halfband=<a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>, <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a> transform=nullptr, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a0f3722592b607cb0eafbfa5c17ebdc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothed point distribution based sphere stamping with a varying radius and closest point attribute transfer.  <a href="#a0f3722592b607cb0eafbfa5c17ebdc3f">More...</a><br /></td></tr>
<tr class="separator:a0f3722592b607cb0eafbfa5c17ebdc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f917f566a11a07b496f369adc7d6a4"><td class="memTemplParams" colspan="2">template&lt;bool Staggered, typename ValueT , typename FilterT  = NullFilter, typename PointDataTreeT  = PointDataTree&gt; </td></tr>
<tr class="memitem:a43f917f566a11a07b496f369adc7d6a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a43f917f566a11a07b496f369adc7d6a4">rasterizeTrilinear</a> (const PointDataTreeT &amp;points, const std::string &amp;attribute, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>())</td></tr>
<tr class="memdesc:a43f917f566a11a07b496f369adc7d6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform weighted trilinear rasterization of all points within a voxel. This method takes and returns a tree i.e. ignores grid transformations.  <a href="#a43f917f566a11a07b496f369adc7d6a4">More...</a><br /></td></tr>
<tr class="separator:a43f917f566a11a07b496f369adc7d6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b556e743b5d3b8b336c75252264d96"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename SourceGridT , typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ae7b556e743b5d3b8b336c75252264d96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ae7b556e743b5d3b8b336c75252264d96">pointSample</a> (PointDataGridT &amp;points, const SourceGridT &amp;sourceGrid, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;targetAttribute=&quot;&quot;, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *const interrupter=nullptr)</td></tr>
<tr class="memdesc:ae7b556e743b5d3b8b336c75252264d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs closest point sampling from a VDB grid onto a VDB Points attribute.  <a href="#ae7b556e743b5d3b8b336c75252264d96">More...</a><br /></td></tr>
<tr class="separator:ae7b556e743b5d3b8b336c75252264d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41bddc5c1099d146cee05b0dc3eb6ff"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename SourceGridT , typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:aa41bddc5c1099d146cee05b0dc3eb6ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#aa41bddc5c1099d146cee05b0dc3eb6ff">boxSample</a> (PointDataGridT &amp;points, const SourceGridT &amp;sourceGrid, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;targetAttribute=&quot;&quot;, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *const interrupter=nullptr)</td></tr>
<tr class="memdesc:aa41bddc5c1099d146cee05b0dc3eb6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tri-linear sampling from a VDB grid onto a VDB Points attribute.  <a href="#aa41bddc5c1099d146cee05b0dc3eb6ff">More...</a><br /></td></tr>
<tr class="separator:aa41bddc5c1099d146cee05b0dc3eb6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad694b6c2cdbcd760f327fe3fb36ae936"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename SourceGridT , typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ad694b6c2cdbcd760f327fe3fb36ae936"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ad694b6c2cdbcd760f327fe3fb36ae936">quadraticSample</a> (PointDataGridT &amp;points, const SourceGridT &amp;sourceGrid, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;targetAttribute=&quot;&quot;, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *const interrupter=nullptr)</td></tr>
<tr class="memdesc:ad694b6c2cdbcd760f327fe3fb36ae936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tri-quadratic sampling from a VDB grid onto a VDB Points attribute.  <a href="#ad694b6c2cdbcd760f327fe3fb36ae936">More...</a><br /></td></tr>
<tr class="separator:ad694b6c2cdbcd760f327fe3fb36ae936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff8951f375ddac4b685e72f486489d3"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename SourceGridT , typename TargetValueT  = DummySampleType, typename SamplerT  = SampleWithRounding, typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a5ff8951f375ddac4b685e72f486489d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a5ff8951f375ddac4b685e72f486489d3">sampleGrid</a> (size_t order, PointDataGridT &amp;points, const SourceGridT &amp;sourceGrid, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;targetAttribute, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const SamplerT &amp;sampler=<a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1SampleWithRounding.html">SampleWithRounding</a>(), InterrupterT *const interrupter=nullptr, const bool threaded=true)</td></tr>
<tr class="memdesc:a5ff8951f375ddac4b685e72f486489d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs sampling and conversion from a VDB grid onto a VDB Points attribute.  <a href="#a5ff8951f375ddac4b685e72f486489d3">More...</a><br /></td></tr>
<tr class="separator:a5ff8951f375ddac4b685e72f486489d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4c70eaf37048c67356fd7189b15d95"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename RandGenT  = std::mt19937, typename PositionArrayT  = TypedAttributeArray&lt;Vec3f, NullCodec&gt;, typename PointDataGridT  = Grid&lt;        typename points::TreeConverter&lt;typename GridT::TreeType&gt;::Type&gt;, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:abc4c70eaf37048c67356fd7189b15d95"><td class="memTemplItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#abc4c70eaf37048c67356fd7189b15d95">uniformPointScatter</a> (const GridT &amp;grid, const <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> count, const unsigned int seed=0, const float spread=1.0f, InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:abc4c70eaf37048c67356fd7189b15d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The free functions depend on the following class:  <a href="#abc4c70eaf37048c67356fd7189b15d95">More...</a><br /></td></tr>
<tr class="separator:abc4c70eaf37048c67356fd7189b15d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a35fc7cff4396e3c0fed48af7150c30"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename RandGenT  = std::mt19937, typename PositionArrayT  = TypedAttributeArray&lt;Vec3f, NullCodec&gt;, typename PointDataGridT  = Grid&lt;        typename points::TreeConverter&lt;typename GridT::TreeType&gt;::Type&gt;, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a2a35fc7cff4396e3c0fed48af7150c30"><td class="memTemplItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a2a35fc7cff4396e3c0fed48af7150c30">denseUniformPointScatter</a> (const GridT &amp;grid, const float pointsPerVoxel, const unsigned int seed=0, const float spread=1.0f, InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a2a35fc7cff4396e3c0fed48af7150c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniformly scatter a fixed number of points per active voxel. If the pointsPerVoxel value provided is a fractional value, each voxel calculates a delta value of how likely it is to contain an extra point.  <a href="#a2a35fc7cff4396e3c0fed48af7150c30">More...</a><br /></td></tr>
<tr class="separator:a2a35fc7cff4396e3c0fed48af7150c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea55ad121ac7274e8a5bb844253c695d"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename RandGenT  = std::mt19937, typename PositionArrayT  = TypedAttributeArray&lt;Vec3f, NullCodec&gt;, typename PointDataGridT  = Grid&lt;        typename points::TreeConverter&lt;typename GridT::TreeType&gt;::Type&gt;, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:aea55ad121ac7274e8a5bb844253c695d"><td class="memTemplItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#aea55ad121ac7274e8a5bb844253c695d">nonUniformPointScatter</a> (const GridT &amp;grid, const float pointsPerVoxel, const unsigned int seed=0, const float spread=1.0f, InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:aea55ad121ac7274e8a5bb844253c695d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non uniformly scatter points per active voxel. The pointsPerVoxel value is used to weight each grids cell value to compute a fixed number of points for every active voxel. If the computed result is a fractional value, each voxel calculates a delta value of how likely it is to contain an extra point.  <a href="#aea55ad121ac7274e8a5bb844253c695d">More...</a><br /></td></tr>
<tr class="separator:aea55ad121ac7274e8a5bb844253c695d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d93f4d68e2eb70dac85a685e9b9522e"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename CodecT  = UnknownCodec, typename FilterT  = NullFilter, typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a7d93f4d68e2eb70dac85a685e9b9522e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; ValueT, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a7d93f4d68e2eb70dac85a685e9b9522e">evalMinMax</a> (const PointDataTreeT &amp;points, const std::string &amp;attribute, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>())</td></tr>
<tr class="memdesc:a7d93f4d68e2eb70dac85a685e9b9522e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the minimum and maximum values of a point attribute.  <a href="#a7d93f4d68e2eb70dac85a685e9b9522e">More...</a><br /></td></tr>
<tr class="separator:a7d93f4d68e2eb70dac85a685e9b9522e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee94dbff950fd1421a1f324bc5b4b2b"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename CodecT  = UnknownCodec, typename FilterT  = NullFilter, typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:abee94dbff950fd1421a1f324bc5b4b2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v10__0_1_1ConvertElementType.html">ConvertElementType</a>&lt; ValueT, double &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#abee94dbff950fd1421a1f324bc5b4b2b">evalAverage</a> (const PointDataTreeT &amp;points, const std::string &amp;attribute, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>())</td></tr>
<tr class="memdesc:abee94dbff950fd1421a1f324bc5b4b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the average value of a point attribute.  <a href="#abee94dbff950fd1421a1f324bc5b4b2b">More...</a><br /></td></tr>
<tr class="separator:abee94dbff950fd1421a1f324bc5b4b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc9cf4453d1c8ee7aae58fe5efd4040"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename CodecT  = UnknownCodec, typename FilterT  = NullFilter, typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a4cc9cf4453d1c8ee7aae58fe5efd4040"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v10__0_1_1PromoteType.html">PromoteType</a>&lt; ValueT &gt;::Highest&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a4cc9cf4453d1c8ee7aae58fe5efd4040">accumulate</a> (const PointDataTreeT &amp;points, const std::string &amp;attribute, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>())</td></tr>
<tr class="memdesc:a4cc9cf4453d1c8ee7aae58fe5efd4040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the total value of a point attribute.  <a href="#a4cc9cf4453d1c8ee7aae58fe5efd4040">More...</a><br /></td></tr>
<tr class="separator:a4cc9cf4453d1c8ee7aae58fe5efd4040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44690998e9733ab3498205299864e4a4"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename CodecT  = UnknownCodec, typename FilterT  = NullFilter, typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a44690998e9733ab3498205299864e4a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a44690998e9733ab3498205299864e4a4">evalMinMax</a> (const PointDataTreeT &amp;points, const std::string &amp;attribute, ValueT &amp;min, ValueT &amp;max, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), typename PointDataTreeT::template ValueConverter&lt; ValueT &gt;::Type *minTree=nullptr, typename PointDataTreeT::template ValueConverter&lt; ValueT &gt;::Type *maxTree=nullptr)</td></tr>
<tr class="memdesc:a44690998e9733ab3498205299864e4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the minimum and maximum values of a point attribute and returns whether the values are valid. Optionally constructs localised min and max value trees.  <a href="#a44690998e9733ab3498205299864e4a4">More...</a><br /></td></tr>
<tr class="separator:a44690998e9733ab3498205299864e4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca703db5f875505c22c5d2c142441a2"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename CodecT  = UnknownCodec, typename FilterT  = NullFilter, typename PointDataTreeT , typename ResultTreeT  = typename ConvertElementType&lt;ValueT, double&gt;::Type&gt; </td></tr>
<tr class="memitem:a2ca703db5f875505c22c5d2c142441a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a2ca703db5f875505c22c5d2c142441a2">evalAverage</a> (const PointDataTreeT &amp;points, const std::string &amp;attribute, typename <a class="el" href="structopenvdb_1_1v10__0_1_1ConvertElementType.html">ConvertElementType</a>&lt; ValueT, double &gt;::Type &amp;average, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), typename PointDataTreeT::template ValueConverter&lt; ResultTreeT &gt;::Type *averageTree=nullptr)</td></tr>
<tr class="memdesc:a2ca703db5f875505c22c5d2c142441a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the average value of a point attribute and returns whether the value is valid. Optionally constructs localised average value trees.  <a href="#a2ca703db5f875505c22c5d2c142441a2">More...</a><br /></td></tr>
<tr class="separator:a2ca703db5f875505c22c5d2c142441a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a92590037c00b856a13e368400575c3"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename CodecT  = UnknownCodec, typename FilterT  = NullFilter, typename PointDataTreeT , typename ResultTreeT  = typename PromoteType&lt;ValueT&gt;::Highest&gt; </td></tr>
<tr class="memitem:a9a92590037c00b856a13e368400575c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a9a92590037c00b856a13e368400575c3">accumulate</a> (const PointDataTreeT &amp;points, const std::string &amp;attribute, typename <a class="el" href="structopenvdb_1_1v10__0_1_1PromoteType.html">PromoteType</a>&lt; ValueT &gt;::Highest &amp;total, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), typename PointDataTreeT::template ValueConverter&lt; ResultTreeT &gt;::Type *totalTree=nullptr)</td></tr>
<tr class="memdesc:a9a92590037c00b856a13e368400575c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the total value of a point attribute and returns whether the value is valid. Optionally constructs localised total value trees.  <a href="#a9a92590037c00b856a13e368400575c3">More...</a><br /></td></tr>
<tr class="separator:a9a92590037c00b856a13e368400575c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad115cf471d7feb23dec86b68073d54c9"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeOrGridT , typename TransferT , typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ad115cf471d7feb23dec86b68073d54c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ad115cf471d7feb23dec86b68073d54c9">rasterize</a> (const PointDataTreeOrGridT &amp;points, TransferT &amp;transfer, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:ad115cf471d7feb23dec86b68073d54c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform potentially complex rasterization from a user defined transfer scheme.  <a href="#ad115cf471d7feb23dec86b68073d54c9">More...</a><br /></td></tr>
<tr class="separator:ad115cf471d7feb23dec86b68073d54c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a8954944cf980f1f874a6510497568338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a8954944cf980f1f874a6510497568338">ActiveFilter</a> =  <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9bc95058fb208e9baa08dab77d98c5fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a9bc95058fb208e9baa08dab77d98c5fa">GroupAttributeArray</a> =  <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a>&lt;<a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a714bfd681b0e82019a95174ecdb6a889">GroupType</a>, <a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1GroupCodec.html">GroupCodec</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a714bfd681b0e82019a95174ecdb6a889"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a714bfd681b0e82019a95174ecdb6a889">GroupType</a> =  uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8273cc7bb48dded419013b35a6491bc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a8273cc7bb48dded419013b35a6491bc0">InactiveFilter</a> =  <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acf438a63a8a41ec38b6d7ceae6467678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#acf438a63a8a41ec38b6d7ceae6467678">PointDataGrid</a> =  <a class="el" href="classopenvdb_1_1v10__0_1_1Grid.html">Grid</a>&lt;<a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a7fec47b2a3d864d85c53f69c3655fdbf">PointDataTree</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Point data grid. </p>

</div>
</div>
<a class="anchor" id="a7fec47b2a3d864d85c53f69c3655fdbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#a7fec47b2a3d864d85c53f69c3655fdbf">PointDataTree</a> =  <a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1Tree.html">tree::Tree</a>&lt;<a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1RootNode.html">tree::RootNode</a>&lt;<a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1InternalNode.html">tree::InternalNode</a>&lt;<a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1InternalNode.html">tree::InternalNode</a> &lt;<a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1PointDataLeafNode.html">PointDataLeafNode</a>&lt;<a class="el" href="namespaceopenvdb_1_1v10__0.html#afcdd46e3c391ea8febd5fa6017b9f19b">PointDataIndex32</a>, 3&gt;, 4&gt;, 5&gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Point index tree configured to match the default VDB configurations. </p>

</div>
</div>
<a class="anchor" id="af44fac5036c56999ca811116b73eca72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#af44fac5036c56999ca811116b73eca72">StringAttributeArray</a> =  <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a>&lt;<a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>, <a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1StringCodec.html">StringCodec</a>&lt;false&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ae71b1a4d4abc6a321046036c37ae645e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopenvdb_1_1v10__0_1_1points.html#ae71b1a4d4abc6a321046036c37ae645e">RasterMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How to composite points into a volume. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae71b1a4d4abc6a321046036c37ae645eac5d2a98a2112d89452e04fe14de91b91"></a>ACCUMULATE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae71b1a4d4abc6a321046036c37ae645ea115f17a28532bbd6f0f5ec83ed20692a"></a>MAXIMUM&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae71b1a4d4abc6a321046036c37ae645ea16de38737a9f8366e9b2042b4e9b6290"></a>AVERAGE&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4cc9cf4453d1c8ee7aae58fe5efd4040"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v10__0_1_1PromoteType.html">PromoteType</a>&lt; ValueT &gt;::Highest accumulate </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the total value of a point attribute. </p>
<p>Performs parallel reduction by summing all values. The reduction arithmetic and return value precision evaluates to: <a class="el" href="structopenvdb_1_1v10__0_1_1PromoteType.html#af1df57fa72e33748fb29c44bbaefdffa">PromoteType&lt;ValueT&gt;::Highest</a> which, for POD and VDB math types, is ValueT at its highest bit precision. If the PointDataGrid is empty or the filter evalutes to empty, <a class="el" href="namespaceopenvdb_1_1v10__0.html#a579236d56cbb62895f34b2ae02c4d479" title="Return the value of type T that corresponds to zero. ">zeroVal&lt;ValueT&gt;()</a> is returned. </p><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structopenvdb_1_1v10__0_1_1PromoteType.html" title="Promotion classes which provide an interface for elevating and demoting a scalar or VDB type to a hig...">PromoteType</a> of the attribute must be copy constructible, support the same type + operator. This method will throw if ValueT does not match the given attribute. The function is deterministic. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if "P" is provided, the result is undefined. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point tree </td></tr>
    <tr><td class="paramname">attribute</td><td>the attribute to reduce </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total value </dd></dl>

</div>
</div>
<a class="anchor" id="a9a92590037c00b856a13e368400575c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool accumulate </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structopenvdb_1_1v10__0_1_1PromoteType.html">PromoteType</a>&lt; ValueT &gt;::Highest &amp;&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PointDataTreeT::template ValueConverter&lt; ResultTreeT &gt;::Type *&#160;</td>
          <td class="paramname"><em>totalTree</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the total value of a point attribute and returns whether the value is valid. Optionally constructs localised total value trees. </p>
<p>Performs parallel reduction by summing all values. The reduction arithmetic and return value precision evaluates to: <a class="el" href="structopenvdb_1_1v10__0_1_1PromoteType.html#af1df57fa72e33748fb29c44bbaefdffa">PromoteType&lt;ValueT&gt;::Highest</a> which, for POD and VDB math types, is ValueT at its highest bit precision. This method will return true total has been set, false otherwise (when no points existed or a filter evaluated to empty). </p><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structopenvdb_1_1v10__0_1_1PromoteType.html" title="Promotion classes which provide an interface for elevating and demoting a scalar or VDB type to a hig...">PromoteType</a> of the attribute must be copy constructible, support the same type + operator. This method will throw if ValueT does not match the given attribute. The function is deterministic. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if "P" is provided, the result is undefined. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point tree </td></tr>
    <tr><td class="paramname">attribute</td><td>the attribute to reduce </td></tr>
    <tr><td class="paramname">total</td><td>the computed total value </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
    <tr><td class="paramname">totalTree</td><td>if provided, builds a tiled tree of localised total results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if total has been set, false otherwise. Can be false if no points were processed or if the tree was empty. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceopenvdb.html">openvdb</a>;</div><div class="line"><span class="keyword">using namespace </span>openvdb::points;</div><div class="line"></div><div class="line"><span class="comment">// accumulate and store per leaf values in a new tree</span></div><div class="line"><a class="code" href="structopenvdb_1_1v10__0_1_1PromoteType.html#af1df57fa72e33748fb29c44bbaefdffa">PromoteType&lt;uint8_t&gt;::Highest</a> total;  <span class="comment">// evaluates to uint64_t</span></div><div class="line"><a class="code" href="structopenvdb_1_1v10__0_1_1tree_1_1Tree_1_1ValueConverter.html#a3391e452092dc3f47fe353a89ba0361e">PointDataTree::ValueConverter&lt;decltype(total)&gt;::Type</a> totalTree; <span class="comment">// uint64_t tree of totals</span></div><div class="line"><span class="keywordtype">bool</span> success = accumulate&lt;uint8_t&gt;(tree, <span class="stringliteral">&quot;attrib&quot;</span>, total, NullFilter(), &amp;totalTree);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ab79ffb24dc5aee12a75d1507966164bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void advectPoints </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VelGridT &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>integrationOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>timeSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AdvectFilterT &amp;&#160;</td>
          <td class="paramname"><em>advectFilter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>cached</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advect points in a PointDataGrid through a velocity grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the PointDataGrid containing the points to be advected. </td></tr>
    <tr><td class="paramname">velocity</td><td>a velocity grid to be sampled. </td></tr>
    <tr><td class="paramname">integrationOrder</td><td>the integration scheme to use (1 is forward euler, 4 is runge-kutta 4th) </td></tr>
    <tr><td class="paramname">dt</td><td>delta time. </td></tr>
    <tr><td class="paramname">timeSteps</td><td>number of advection steps to perform. </td></tr>
    <tr><td class="paramname">advectFilter</td><td>an optional advection index filter (moves a subset of the points) </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter (deletes a subset of the points) </td></tr>
    <tr><td class="paramname">cached</td><td>caches velocity interpolation for faster performance, disable to use less memory (default is on). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f8216e14812f6a9c9aaf1af5b2ad36b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void appendAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a3907786c2430dbab9f198bfd5b31ff7c">NamePair</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>strideOrTotalSize</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constantStride</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v10__0_1_1Metadata.html">Metadata</a> *&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>hidden</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new attribute to the VDB tree (this method does not require a templated AttributeType) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be appended to. </td></tr>
    <tr><td class="paramname">name</td><td>name for the new attribute. </td></tr>
    <tr><td class="paramname">type</td><td>the type of the attibute. </td></tr>
    <tr><td class="paramname">strideOrTotalSize</td><td>the stride of the attribute </td></tr>
    <tr><td class="paramname">constantStride</td><td>if <code>false</code>, stride is interpreted as total size of the array </td></tr>
    <tr><td class="paramname">defaultValue</td><td>metadata default attribute value </td></tr>
    <tr><td class="paramname">hidden</td><td>mark attribute as hidden </td></tr>
    <tr><td class="paramname">transient</td><td>mark attribute as transient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12af91f538ab5256ce2db4afe3b9dd31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void appendAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>uniformValue</em> = <code><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1point__attribute__internal_1_1Default.html">point_attribute_internal::Default</a>&lt;ValueType&gt;::<a class="el" href="GridBuilder_8h.html#a0bd8e8b76a16eb8c0d32d42313755c8e">value</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>strideOrTotalSize</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constantStride</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v10__0_1_1TypedMetadata.html">TypedMetadata</a>&lt; ValueType &gt; *&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>hidden</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new attribute to the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be appended to. </td></tr>
    <tr><td class="paramname">name</td><td>name for the new attribute </td></tr>
    <tr><td class="paramname">uniformValue</td><td>the initial value of the attribute </td></tr>
    <tr><td class="paramname">strideOrTotalSize</td><td>the stride of the attribute </td></tr>
    <tr><td class="paramname">constantStride</td><td>if <code>false</code>, stride is interpreted as total size of the array </td></tr>
    <tr><td class="paramname">defaultValue</td><td>metadata default attribute value </td></tr>
    <tr><td class="paramname">hidden</td><td>mark attribute as hidden </td></tr>
    <tr><td class="paramname">transient</td><td>mark attribute as transient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6df5f0462ae9d328e4987971cda4c7ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void appendGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new empty group to the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be appended to. </td></tr>
    <tr><td class="paramname">group</td><td>name of the new group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad2483abeddd3034b01b946caf10f84f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void appendGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends new empty groups to the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be appended to. </td></tr>
    <tr><td class="paramname">groups</td><td>names of the new groups. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa41bddc5c1099d146cee05b0dc3eb6ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boxSample </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceGridT &amp;&#160;</td>
          <td class="paramname"><em>sourceGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>targetAttribute</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs tri-linear sampling from a VDB grid onto a VDB Points attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the PointDataGrid whose points will be sampled on to </td></tr>
    <tr><td class="paramname">sourceGrid</td><td>VDB grid which will be sampled </td></tr>
    <tr><td class="paramname">targetAttribute</td><td>a target attribute on the points which will hold samples. This attribute will be created with the source grid type if it does not exist, and with the source grid name if the name is empty </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The target attribute may exist provided it can be cast to the SourceGridT ValueType </dd></dl>

</div>
</div>
<a class="anchor" id="a6b46b75155cc394f4ad4b540f167523a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void collapseAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>uniformValue</em> = <code><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1point__attribute__internal_1_1Default.html">point_attribute_internal::Default</a>&lt;ValueType&gt;::<a class="el" href="GridBuilder_8h.html#a0bd8e8b76a16eb8c0d32d42313755c8e">value</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collapse the attribute into a uniform value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree in which to collapse the attribute. </td></tr>
    <tr><td class="paramname">name</td><td>name for the attribute. </td></tr>
    <tr><td class="paramname">uniformValue</td><td>value of the attribute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a467b8eefb87ca02fa0f017c40c08d674"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compactAttributes </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compact attributes in a VDB tree (if possible). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6057529f97b428787a3e993ad12d3cf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compactGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compacts existing groups of a VDB Tree to use less memory if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be compacted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85baad70404957c0b435068440ae1c0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float computeVoxelSize </td>
          <td>(</td>
          <td class="paramtype">const PositionWrapper &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>pointsPerVoxel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0_1_1math.html#abaf7f913bf1752b9157259ffa32704ca">math::Mat4d</a>&#160;</td>
          <td class="paramname"><em>transform</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Mat4.html#a71890348d53084982694f39988f4b286">math::Mat4d::identity</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>decimalPlaces</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@ brief Given a container of world space positions and a target points per voxel, compute a uniform voxel size that would best represent the storage of the points in a grid. This voxel size is typically used for conversion of the points into a PointDataGrid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positions</td><td>array of world space positions </td></tr>
    <tr><td class="paramname">pointsPerVoxel</td><td>the target number of points per voxel, must be positive and non-zero </td></tr>
    <tr><td class="paramname">transform</td><td>voxel size will be computed using this optional transform if provided </td></tr>
    <tr><td class="paramname">decimalPlaces</td><td>for readability, truncate voxel size to this number of decimals </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>VecT will be PositionWrapper::value_type or Vec3R (if there is no value_type defined)</dd>
<dd>
if none or one point provided in positions, the default voxel size of 0.1 will be returned </dd></dl>

</div>
</div>
<a class="anchor" id="ac91e520838e75f17a4e0a3505c128931"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void convertPointDataGridAttribute </td>
          <td>(</td>
          <td class="paramtype">TypedAttribute &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td>
          <td class="paramname"><em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>arrayIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>stride</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>inCoreOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the attribute from a PointDataGrid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>the attribute to be populated. </td></tr>
    <tr><td class="paramname">tree</td><td>the PointDataTree to be converted. </td></tr>
    <tr><td class="paramname">pointOffsets</td><td>a vector of cumulative point offsets for each leaf. </td></tr>
    <tr><td class="paramname">startOffset</td><td>a value to shift all the point offsets by </td></tr>
    <tr><td class="paramname">arrayIndex</td><td>the index in the Descriptor of the array to be converted. </td></tr>
    <tr><td class="paramname">stride</td><td>the stride of the attribute </td></tr>
    <tr><td class="paramname">filter</td><td>an index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>true if out-of-core leaf nodes are to be ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4875034852344d7f676c955bb764d9c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void convertPointDataGridGroup </td>
          <td>(</td>
          <td class="paramtype">Group &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td>
          <td class="paramname"><em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeSet::Descriptor::GroupIndex&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>inCoreOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the group from a PointDataGrid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group to be populated. </td></tr>
    <tr><td class="paramname">tree</td><td>the PointDataTree to be converted. </td></tr>
    <tr><td class="paramname">pointOffsets</td><td>a vector of cumulative point offsets for each leaf </td></tr>
    <tr><td class="paramname">startOffset</td><td>a value to shift all the point offsets by </td></tr>
    <tr><td class="paramname">index</td><td>the group index to be converted. </td></tr>
    <tr><td class="paramname">filter</td><td>an index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>true if out-of-core leaf nodes are to be ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf905ca86b725954bf900e3caf6b431a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void convertPointDataGridPosition </td>
          <td>(</td>
          <td class="paramtype">PositionAttribute &amp;&#160;</td>
          <td class="paramname"><em>positionAttribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td>
          <td class="paramname"><em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>inCoreOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the position attribute from a Point Data <a class="el" href="classopenvdb_1_1v10__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positionAttribute</td><td>the position attribute to be populated. </td></tr>
    <tr><td class="paramname">grid</td><td>the PointDataGrid to be converted. </td></tr>
    <tr><td class="paramname">pointOffsets</td><td>a vector of cumulative point offsets for each leaf </td></tr>
    <tr><td class="paramname">startOffset</td><td>a value to shift all the point offsets by </td></tr>
    <tr><td class="paramname">filter</td><td>an index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>true if out-of-core leaf nodes are to be ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b55bc8e90ae04b25f2e09e5f88253e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#acbcb5f84dd5976c2bb8d02c10017d060">TreeBase</a>, PointDataTreeT &gt;::<a class="el" href="GridBuilder_8h.html#a0bd8e8b76a16eb8c0d32d42313755c8e">value</a> &amp;&amp;std::is_same&lt; typename MaskTreeT::ValueType, bool &gt;::<a class="el" href="GridBuilder_8h.html#a0bd8e8b76a16eb8c0d32d42313755c8e">value</a>, typename MaskTreeT::Ptr &gt;::type convertPointsToMask </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a Mask Tree from a Point Data Tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to extract the mask from. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ba59ee8dd9f55d6922565f27f3921c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classopenvdb_1_1v10__0_1_1GridBase.html">GridBase</a>, PointDataGridT &gt;::<a class="el" href="GridBuilder_8h.html#a0bd8e8b76a16eb8c0d32d42313755c8e">value</a> &amp;&amp;std::is_same&lt; typename MaskGridT::ValueType, bool &gt;::<a class="el" href="GridBuilder_8h.html#a0bd8e8b76a16eb8c0d32d42313755c8e">value</a>, typename MaskGridT::Ptr &gt;::type convertPointsToMask </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a Mask <a class="el" href="classopenvdb_1_1v10__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a> from a Point Data <a class="el" href="classopenvdb_1_1v10__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the PointDataGrid to extract the mask from. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this method is only available for Bool Grids and Mask Grids </dd></dl>

</div>
</div>
<a class="anchor" id="adfdf43efd3cbc67e8d781bd3d06fb85f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; typename MaskT::ValueType, bool &gt;::<a class="el" href="GridBuilder_8h.html#a0bd8e8b76a16eb8c0d32d42313755c8e">value</a>, typename MaskT::Ptr &gt;::type convertPointsToMask </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a Mask <a class="el" href="classopenvdb_1_1v10__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a> from a Point Data <a class="el" href="classopenvdb_1_1v10__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a> using a new transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the PointDataGrid to extract the mask from. </td></tr>
    <tr><td class="paramname">transform</td><td>target transform for the mask. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this method is only available for Bool Grids and Mask Grids </dd></dl>

</div>
</div>
<a class="anchor" id="ab15a1ee82d506999536458071ba44299"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr createPointDataGrid </td>
          <td>(</td>
          <td class="paramtype">const PointIndexGridT &amp;&#160;</td>
          <td class="paramname"><em>pointIndexGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionArrayT &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html">math::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v10__0_1_1Metadata.html">Metadata</a> *&#160;</td>
          <td class="paramname"><em>positionDefaultValue</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Localises points with position into a <code>PointDataGrid</code> into two stages: allocation of the leaf attribute data and population of the positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointIndexGrid</td><td>a PointIndexGrid into the points. </td></tr>
    <tr><td class="paramname">positions</td><td>list of world space point positions. </td></tr>
    <tr><td class="paramname">xform</td><td>world to index space transform. </td></tr>
    <tr><td class="paramname">positionDefaultValue</td><td>metadata default position value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The position data must be supplied in a Point-Partitioner compatible data structure. A convenience <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1PointAttributeVector.html" title="Point-partitioner compatible STL vector attribute wrapper for convenience. ">PointAttributeVector</a> class is offered.</dd>
<dd>
The position data is populated separately to perform world space to voxel space conversion and apply quantisation.</dd>
<dd>
A <code>PointIndexGrid</code> to the points must be supplied to perform this operation. Typically this is built implicitly by the PointDataGrid constructor. </dd></dl>

</div>
</div>
<a class="anchor" id="a07c2da02df6fb329b2684f56617c39b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr createPointDataGrid </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html">math::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v10__0_1_1Metadata.html">Metadata</a> *&#160;</td>
          <td class="paramname"><em>positionDefaultValue</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method to create a <code>PointDataGrid</code> from a std::vector of point positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positions</td><td>list of world space point positions. </td></tr>
    <tr><td class="paramname">xform</td><td>world to index space transform. </td></tr>
    <tr><td class="paramname">positionDefaultValue</td><td>metadata default position value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method implicitly wraps the std::vector for a Point-Partitioner compatible data structure and creates the required <code>PointIndexGrid</code> to the points. </dd></dl>

</div>
</div>
<a class="anchor" id="afdbd30a3741affcd2b2434124a34149d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deleteFromGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>pointTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drop</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete points that are members of a group. </p>
<p>This method will delete points which are members of the supplied group and will optionally drop the group from the tree. An invert flag can be used to delete points that belong to none of the groups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointTree</td><td>the point tree with the group to delete </td></tr>
    <tr><td class="paramname">group</td><td>the name of the group to delete </td></tr>
    <tr><td class="paramname">invert</td><td>if enabled, points not belonging to any of the groups will be deleted </td></tr>
    <tr><td class="paramname">drop</td><td>if enabled and invert is disabled, the group will be dropped from the tree</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the invert flag is true, the group will not be dropped after deleting points regardless of the value of the drop parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b9d921b422e929c3786e77c8d4c811f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deleteFromGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>pointTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drop</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete points that are members of specific groups. </p>
<p>This method will delete points which are members of any of the supplied groups and will optionally drop the groups from the tree. An invert flag can be used to delete points that belong to none of the groups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointTree</td><td>the point tree </td></tr>
    <tr><td class="paramname">groups</td><td>the groups from which to delete points </td></tr>
    <tr><td class="paramname">invert</td><td>if enabled, points not belonging to any of the groups will be deleted </td></tr>
    <tr><td class="paramname">drop</td><td>if enabled and invert is disabled, the groups will be dropped from the tree</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the invert flag is true, none of the groups will be dropped after deleting points regardless of the value of the drop parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e318d6bae7846125e0ac39c66024fc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deleteMissingPointGroups </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeSet.html#abf4c4c63e6ef3b54e88cd0cab0be66c8">AttributeSet::Descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>descriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete any group that is not present in the Descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>the vector of group names. </td></tr>
    <tr><td class="paramname">descriptor</td><td>the descriptor that holds the group map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a35fc7cff4396e3c0fed48af7150c30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr denseUniformPointScatter </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>pointsPerVoxel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>spread</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uniformly scatter a fixed number of points per active voxel. If the pointsPerVoxel value provided is a fractional value, each voxel calculates a delta value of how likely it is to contain an extra point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>A source grid. The resulting PointDataGrid will copy this grids transform and scatter in its active voxelized topology. </td></tr>
    <tr><td class="paramname">pointsPerVoxel</td><td>The number of points to scatter per voxel </td></tr>
    <tr><td class="paramname">seed</td><td>A seed for the RandGenT </td></tr>
    <tr><td class="paramname">spread</td><td>The spread of points as a scale from each voxels center. A value of 1.0f indicates points can be placed anywhere within the voxel, where as a value of 0.0f will force all points to be created exactly at the centers of each voxel. </td></tr>
    <tr><td class="paramname">interrupter</td><td>An optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns the scattered PointDataGrid </dd></dl>

</div>
</div>
<a class="anchor" id="a630071eb13957e9c9683fafb845ec9ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop one attribute from the VDB tree (convenience method). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be dropped from. </td></tr>
    <tr><td class="paramname">index</td><td>index of the attribute to drop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd25e23091c52fb8da4fcb50369ad45b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop one attribute from the VDB tree (convenience method). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be dropped from. </td></tr>
    <tr><td class="paramname">name</td><td>name of the attribute to drop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaaa22577ec29a353a700c9a3fa03906f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropAttributes </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops attributes from the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be dropped from. </td></tr>
    <tr><td class="paramname">indices</td><td>indices of the attributes to drop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa8ee0b505384ce90253b77516cedce4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropAttributes </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops attributes from the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be dropped from. </td></tr>
    <tr><td class="paramname">names</td><td>names of the attributes to drop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1f0afec32f566e10a0a25fde4466dba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>compact</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops an existing group from the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be dropped from. </td></tr>
    <tr><td class="paramname">group</td><td>name of the group. </td></tr>
    <tr><td class="paramname">compact</td><td>compact attributes if possible to reduce memory - if dropping more than one group, compacting once at the end will be faster </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c87fccd745143ae4e42c5b1f4998508"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops existing groups from the VDB tree, the tree is compacted after dropping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be dropped from. </td></tr>
    <tr><td class="paramname">groups</td><td>names of the groups. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7814ccafca96a095c60c6c6438b7eb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops all existing groups from the VDB tree, the tree is compacted after dropping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be dropped from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abee94dbff950fd1421a1f324bc5b4b2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v10__0_1_1ConvertElementType.html">ConvertElementType</a>&lt; ValueT, double &gt;::Type evalAverage </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the average value of a point attribute. </p>
<p>Performs parallel reduction by cumulative moving average. The reduction arithmetic and return value precision evaluates to: <a class="el" href="structopenvdb_1_1v10__0_1_1ConvertElementType.html#a801364d20664a6d2df467fcc266ed7c8">ConvertElementType&lt;ValueT, double&gt;::Type</a> which, for POD and VDB math types, is ValueT at double precision. If the PointDataGrid is empty or the filter evalutes to empty, <a class="el" href="namespaceopenvdb_1_1v10__0.html#a579236d56cbb62895f34b2ae02c4d479" title="Return the value of type T that corresponds to zero. ">zeroVal&lt;ValueT&gt;()</a> is returned. </p><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structopenvdb_1_1v10__0_1_1ConvertElementType.html" title="Conversion classes for changing the underlying type of VDB types. ">ConvertElementType</a> of the attribute must be copy constructible, support the same type + - * operators and * / operators from a double. This method will throw if ValueT does not match the given attribute. The function is deterministic. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if "P" is provided, the result is undefined. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point tree </td></tr>
    <tr><td class="paramname">attribute</td><td>the attribute to reduce </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the average value </dd></dl>

</div>
</div>
<a class="anchor" id="a2ca703db5f875505c22c5d2c142441a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evalAverage </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structopenvdb_1_1v10__0_1_1ConvertElementType.html">ConvertElementType</a>&lt; ValueT, double &gt;::Type &amp;&#160;</td>
          <td class="paramname"><em>average</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PointDataTreeT::template ValueConverter&lt; ResultTreeT &gt;::Type *&#160;</td>
          <td class="paramname"><em>averageTree</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the average value of a point attribute and returns whether the value is valid. Optionally constructs localised average value trees. </p>
<p>Performs parallel reduction by cumulative moving average. The reduction arithmetic and return value precision evaluates to: <a class="el" href="structopenvdb_1_1v10__0_1_1ConvertElementType.html#a801364d20664a6d2df467fcc266ed7c8">ConvertElementType&lt;ValueT, double&gt;::Type</a> which, for POD and VDB math types, is ValueT at double precision. This method will return true average has been set, false otherwise (when no points existed or a filter evaluated to empty). </p><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structopenvdb_1_1v10__0_1_1ConvertElementType.html" title="Conversion classes for changing the underlying type of VDB types. ">ConvertElementType</a> of the attribute must be copy constructible, support the same type + - * operators and * / operators from a double. This method will throw if ValueT does not match the given attribute. The function is deterministic. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if "P" is provided, the result is undefined. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point tree </td></tr>
    <tr><td class="paramname">attribute</td><td>the attribute to reduce </td></tr>
    <tr><td class="paramname">average</td><td>the computed averaged value at double precision </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
    <tr><td class="paramname">averageTree</td><td>if provided, builds a tiled tree of localised avg results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if average has been set, false otherwise. Can be false if no points were processed or if the tree was empty. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceopenvdb.html">openvdb</a>;</div><div class="line"><span class="keyword">using namespace </span>openvdb::points</div><div class="line"></div><div class="line"><span class="comment">// average and store per leaf values in a new tree</span></div><div class="line"><a class="code" href="structopenvdb_1_1v10__0_1_1ConvertElementType.html#a801364d20664a6d2df467fcc266ed7c8">ConvertElementType&lt;uint8_t, double&gt;::Type</a> avg;  <span class="comment">// evaluates to double</span></div><div class="line"><a class="code" href="structopenvdb_1_1v10__0_1_1tree_1_1Tree_1_1ValueConverter.html#a3391e452092dc3f47fe353a89ba0361e">PointDataTree::ValueConverter&lt;decltype(avg)&gt;::Type</a> avgTree; <span class="comment">// double tree of averages</span></div><div class="line"><span class="keywordtype">bool</span> success = evalAverage&lt;uint8_t&gt;(tree, <span class="stringliteral">&quot;attrib&quot;</span>, avg, NullFilter(), &amp;avgTree);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a7d93f4d68e2eb70dac85a685e9b9522e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; ValueT, ValueT &gt; evalMinMax </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the minimum and maximum values of a point attribute. </p>
<p>Performs parallel reduction by comparing values using their less than and greater than operators. If the PointDataGrid is empty or the filter evalutes to empty, <a class="el" href="namespaceopenvdb_1_1v10__0.html#a579236d56cbb62895f34b2ae02c4d479" title="Return the value of type T that corresponds to zero. ">zeroVal&lt;ValueT&gt;()</a> is returned for both values. </p><dl class="section note"><dt>Note</dt><dd>The ValueT of the attribute must be copy constructible. This method will throw if the templated ValueT does not match the given attribute. For vectors and matrices, this results in per component comparisons. See evalExtents for magnitudes or more custom control. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if "P" is provided, the result is undefined. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point tree </td></tr>
    <tr><td class="paramname">attribute</td><td>the attribute to reduce </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>min,max value pair </dd></dl>

</div>
</div>
<a class="anchor" id="a44690998e9733ab3498205299864e4a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool evalMinMax </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PointDataTreeT::template ValueConverter&lt; ValueT &gt;::Type *&#160;</td>
          <td class="paramname"><em>minTree</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PointDataTreeT::template ValueConverter&lt; ValueT &gt;::Type *&#160;</td>
          <td class="paramname"><em>maxTree</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the minimum and maximum values of a point attribute and returns whether the values are valid. Optionally constructs localised min and max value trees. </p>
<p>Performs parallel reduction by comparing values using their less than and greater than operators. This method will return true if min and max have been set, false otherwise (when no points existed or a filter evaluated to empty). </p><dl class="section note"><dt>Note</dt><dd>The ValueT of the attribute must also be copy constructible. This method will throw if the templated ValueT does not match the given attribute. For vectors and matrices, this results in per component comparisons. See evalExtents for magnitudes or more custom control. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if "P" is provided, the result is undefined. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point tree </td></tr>
    <tr><td class="paramname">attribute</td><td>the attribute to reduce </td></tr>
    <tr><td class="paramname">min</td><td>the computed min value </td></tr>
    <tr><td class="paramname">max</td><td>the computed max value </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
    <tr><td class="paramname">minTree</td><td>if provided, builds a tiled tree of localised min results </td></tr>
    <tr><td class="paramname">maxTree</td><td>if provided, builds a tiled tree of localised max results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if min and max have been set, false otherwise. Can be false if no points were processed or if the tree was empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a85c3dd120bd13cfeddaa95377e674471"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT openvdb::v10_0::points::fixedPointToFloatingPoint </td>
          <td>(</td>
          <td class="paramtype">const IntegerT&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abb7038f079a6df66adf5fc413c687029"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatVectorT openvdb::v10_0::points::fixedPointToFloatingPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; IntegerT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a62158f26e5900828b1dc3c574ef3e268"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerT openvdb::v10_0::points::floatingPointToFixedPoint </td>
          <td>(</td>
          <td class="paramtype">const FloatT&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6dbf4bd9ecbb55dc2107708fbff0def2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVectorT openvdb::v10_0::points::floatingPointToFixedPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; FloatT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2afb2350c490943a40eb6eaeec006ff2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openvdb::v10_0::points::isGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeArray.html">AttributeArray</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a95a7e9c443da80e78e308df87ba38846"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openvdb::v10_0::points::isString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeArray.html">AttributeArray</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adfb5e64392fdf29bc3462e5a60713158"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> iterCount </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count up the number of times the iterator can iterate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>the iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>counting by iteration only performed where a dynamic filter is in use, </dd></dl>

</div>
</div>
<a class="anchor" id="af351ce8e812595d5fede2fd73ce96420"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AttributeSet::Descriptor::Ptr makeDescriptorUnique </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy the descriptor across all leaf nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new descriptor.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method will fail if the Descriptors in the tree are not all identical. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d0082c20c402a864700014eae174838"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void movePoints </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeformerT &amp;&#160;</td>
          <td class="paramname"><em>deformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1future_1_1Advect.html">future::Advect</a> *&#160;</td>
          <td class="paramname"><em>objectNotInUse</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move points in a PointDataGrid using a custom deformer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the PointDataGrid containing the points to be moved. </td></tr>
    <tr><td class="paramname">deformer</td><td>a custom deformer that defines how to move the points. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">objectNotInUse</td><td>for future use, this object is currently ignored </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0d785b238fdbdf02b903fd9ddd453f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void movePoints </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html">math::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeformerT &amp;&#160;</td>
          <td class="paramname"><em>deformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1future_1_1Advect.html">future::Advect</a> *&#160;</td>
          <td class="paramname"><em>objectNotInUse</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move points in a PointDataGrid using a custom deformer and a new transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the PointDataGrid containing the points to be moved. </td></tr>
    <tr><td class="paramname">transform</td><td>target transform to use for the resulting points. </td></tr>
    <tr><td class="paramname">deformer</td><td>a custom deformer that defines how to move the points. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">objectNotInUse</td><td>for future use, this object is currently ignored </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea55ad121ac7274e8a5bb844253c695d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr nonUniformPointScatter </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>pointsPerVoxel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>spread</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non uniformly scatter points per active voxel. The pointsPerVoxel value is used to weight each grids cell value to compute a fixed number of points for every active voxel. If the computed result is a fractional value, each voxel calculates a delta value of how likely it is to contain an extra point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>A source grid. The resulting PointDataGrid will copy this grids transform, voxelized topology and use its values to compute a target points per voxel. The grids ValueType must be convertible to a scalar value. Only active and larger than zero values will contain points. </td></tr>
    <tr><td class="paramname">pointsPerVoxel</td><td>The number of points to scatter per voxel </td></tr>
    <tr><td class="paramname">seed</td><td>A seed for the RandGenT </td></tr>
    <tr><td class="paramname">spread</td><td>The spread of points as a scale from each voxels center. A value of 1.0f indicates points can be placed anywhere within the voxel, where as a value of 0.0f will force all points to be created exactly at the centers of each voxel. </td></tr>
    <tr><td class="paramname">interrupter</td><td>An optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns the scattered PointDataGrid </dd></dl>

</div>
</div>
<a class="anchor" id="a8dbfd50108bbe665a6e1a0607335a5df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> pointCount </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>inCoreOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the total number of points in a PointDataTree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree in which to count the points </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>if true, points in out-of-core leaf nodes are not counted </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90464075cf4382ab74a75288eebfce02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr pointCountGrid </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a new grid with voxel values to store the number of points per voxel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the PointDataGrid to use to compute the count grid </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The return type of the grid must be an integer or floating-point scalar grid. </dd></dl>

</div>
</div>
<a class="anchor" id="a2159bcf1fea38531ec493459f3b37857"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr pointCountGrid </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a new grid that uses the supplied transform with voxel values to store the number of points per voxel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the PointDataGrid to use to compute the count grid </td></tr>
    <tr><td class="paramname">transform</td><td>the transform to use to compute the count grid </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The return type of the grid must be an integer or floating-point scalar grid. </dd></dl>

</div>
</div>
<a class="anchor" id="a639be5922b4acf36c519e88f9ea8ff7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> pointOffsets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>inCoreOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate an array of cumulative point offsets per leaf node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointOffsets</td><td>array of offsets to be populated </td></tr>
    <tr><td class="paramname">tree</td><td>the PointDataTree from which to populate the offsets </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>if true, points in out-of-core leaf nodes are ignored </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final cumulative point offset. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7b556e743b5d3b8b336c75252264d96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pointSample </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceGridT &amp;&#160;</td>
          <td class="paramname"><em>sourceGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>targetAttribute</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs closest point sampling from a VDB grid onto a VDB Points attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the PointDataGrid whose points will be sampled on to </td></tr>
    <tr><td class="paramname">sourceGrid</td><td>VDB grid which will be sampled </td></tr>
    <tr><td class="paramname">targetAttribute</td><td>a target attribute on the points which will hold samples. This attribute will be created with the source grid type if it does not exist, and with the source grid name if the name is empty </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The target attribute may exist provided it can be cast to the SourceGridT ValueType </dd></dl>

</div>
</div>
<a class="anchor" id="ad7557b731e5392e4448f933a84139950"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void populateAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointIndexTreeT &amp;&#160;</td>
          <td class="paramname"><em>pointIndexTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">openvdb::Name</a> &amp;&#160;</td>
          <td class="paramname"><em>attributeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointArrayT &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>stride</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>insertMetadata</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores point attribute data in an existing <code>PointDataGrid</code> attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataGrid to be populated. </td></tr>
    <tr><td class="paramname">pointIndexTree</td><td>a PointIndexTree into the points. </td></tr>
    <tr><td class="paramname">attributeName</td><td>the name of the VDB Points attribute to be populated. </td></tr>
    <tr><td class="paramname">data</td><td>a wrapper to the attribute data. </td></tr>
    <tr><td class="paramname">stride</td><td>the stride of the attribute </td></tr>
    <tr><td class="paramname">insertMetadata</td><td>true if strings are to be automatically inserted as metadata.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A <code>PointIndexGrid</code> to the points must be supplied to perform this operation. This is required to ensure the same point index ordering. </dd></dl>

</div>
</div>
<a class="anchor" id="a2205d8c5a7c5fd2e24145a9df5ad6485"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void prefetch </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>position</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>otherAttributes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sequentially pre-fetch all delayed-load voxel and attribute data from disk in order to accelerate subsequent random access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
    <tr><td class="paramname">position</td><td>if enabled, prefetch the position attribute (default is on) </td></tr>
    <tr><td class="paramname">otherAttributes</td><td>if enabled, prefetch all other attributes (default is on) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad694b6c2cdbcd760f327fe3fb36ae936"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void quadraticSample </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceGridT &amp;&#160;</td>
          <td class="paramname"><em>sourceGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>targetAttribute</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs tri-quadratic sampling from a VDB grid onto a VDB Points attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the PointDataGrid whose points will be sampled on to </td></tr>
    <tr><td class="paramname">sourceGrid</td><td>VDB grid which will be sampled </td></tr>
    <tr><td class="paramname">targetAttribute</td><td>a target attribute on the points which will hold samples. This attribute will be created with the source grid type if it does not exist, and with the source grid name if the name is empty </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The target attribute may exist provided it can be cast to the SourceGridT ValueType </dd></dl>

</div>
</div>
<a class="anchor" id="ad115cf471d7feb23dec86b68073d54c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rasterize </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeOrGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransferT &amp;&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform potentially complex rasterization from a user defined transfer scheme. </p>
<dl class="section user"><dt>A transfer scheme must be configured to call the provided</dt><dd>rasterize methods. See below for an example or <a class="el" href="PointRasterizeSDF_8h.html" title="Transfer schemes for rasterizing point positional and radius data to signed distance fields with opti...">PointRasterizeSDF.h</a>/PointRasterizeTrilinear.h for implementations. <div class="fragment"><div class="line"><span class="keyword">struct </span>Transfer</div><div class="line">{<span class="comment"></span></div><div class="line"><span class="comment">    /// @return Returns the tree topology to loop over. This can be different</span></div><div class="line"><span class="comment">    ///   from the destination tree i.e. This can act as a mask.</span></div><div class="line"><span class="comment"></span>    <span class="keyword">inline</span> <span class="keyword">auto</span>&amp; topology();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  The maximum lookup range of this transfer scheme in index</span></div><div class="line"><span class="comment">    ///   space of the source points.</span></div><div class="line"><span class="comment">    /// @details The return value represent how far away from the destination</span></div><div class="line"><span class="comment">    ///   leaf node points should be accessed.</span></div><div class="line"><span class="comment">    /// @param origin  The leaf origin of the topology being accessed</span></div><div class="line"><span class="comment">    /// @param idx     The leaf index of the topology being accessed</span></div><div class="line"><span class="comment"></span>    <span class="keyword">inline</span> <a class="code" href="namespaceopenvdb_1_1v10__0.html#ac524bdfeb5d781872485d9321c881920">Int32</a> range(<span class="keyword">const</span> Coord&amp; origin, <span class="keywordtype">size_t</span> idx) <span class="keyword">const</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  The initialize function, called on each leaf which has valid</span></div><div class="line"><span class="comment">    ///   topology to write to.</span></div><div class="line"><span class="comment">    /// @param origin  The leaf origin of the topology being accessed</span></div><div class="line"><span class="comment">    /// @param idx     The leaf index of the topology being accessed</span></div><div class="line"><span class="comment">    /// @param bounds  The active voxel bounds of the leaf</span></div><div class="line"><span class="comment"></span>    <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespaceopenvdb_1_1v10__0.html#ad8d4a63fa555fe156466d0222d2711d7">initialize</a>(<span class="keyword">const</span> Coord&amp; origin, <span class="keywordtype">size_t</span> idx, <span class="keyword">const</span> <a class="code" href="namespacenanovdb.html#a8afc96c92541921d1a0a3ec2c2d6b783">CoordBBox</a>&amp; bounds);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  Run each time a point leaf is accessed. Typically this is</span></div><div class="line"><span class="comment">    ///  where attribute handles can be constructed</span></div><div class="line"><span class="comment">    /// @param leaf  The PointDataLeafNode which is being accessed.</span></div><div class="line"><span class="comment">    /// @return  Return true to continue rasterization, false to early exit</span></div><div class="line"><span class="comment">    ///   and skip the current leaf&#39;s contribution to the destination volume.</span></div><div class="line"><span class="comment"></span>    <span class="keyword">inline</span> <span class="keywordtype">bool</span> startPointLeaf(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v10__0_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">PointDataTree::LeafNodeType</a>&amp; leaf);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  The point stamp function. Each point which contributes to</span></div><div class="line"><span class="comment">    ///  the current leaf will call this function exactly once.</span></div><div class="line"><span class="comment">    /// @param ijk  The current voxel containing the point being rasterized.</span></div><div class="line"><span class="comment">    ///   May be outside the destination leaf node depending on the range()</span></div><div class="line"><span class="comment">    /// @param id   The point index being rasterized</span></div><div class="line"><span class="comment">    /// @param bounds  The active bounds of the leaf node.</span></div><div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> rasterizePoint(<span class="keyword">const</span> Coord&amp; ijk,</div><div class="line">                    <span class="keyword">const</span> Index <span class="keywordtype">id</span>,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="namespacenanovdb.html#a8afc96c92541921d1a0a3ec2c2d6b783">CoordBBox</a>&amp; bounds);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  Run each time a point leaf is finished with.</span></div><div class="line"><span class="comment">    /// @param leaf  The PointDataLeafNode which was being accessed.</span></div><div class="line"><span class="comment">    /// @return  Return true to continue rasterization, false to early exit</span></div><div class="line"><span class="comment">    ///   and stop rasterization to the destination leaf node.</span></div><div class="line"><span class="comment"></span>    <span class="keyword">inline</span> <span class="keywordtype">bool</span> endPointLeaf(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v10__0_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">PointDataTree::LeafNodeType</a>&amp; leaf);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  The finalization function for the given destination tree(s).</span></div><div class="line"><span class="comment">    /// @param origin  The leaf origin of the topology being accessed</span></div><div class="line"><span class="comment">    /// @param idx     The leaf index of the topology being accessed</span></div><div class="line"><span class="comment">    /// @return  Return true to stop, false to recursively rasterize</span></div><div class="line"><span class="comment"></span>    <span class="keyword">inline</span> <span class="keywordtype">bool</span> finalize(<span class="keyword">const</span> Coord&amp; origin, <span class="keywordtype">size_t</span> idx);</div><div class="line">};</div></div><!-- fragment --></dd></dl>
<p>Below is a full example using the native components.</p>
<div class="fragment"><div class="line"><span class="comment">/// @brief Sum point distances into a target float tree</span></div><div class="line"><span class="comment"></span><span class="comment">///   Note: Using TransformTransfer to handle different index spaces, and</span></div><div class="line"><span class="comment"></span><span class="comment">///   VolumeTransfer for automatic buffer setup</span></div><div class="line"><span class="comment"></span><span class="keyword">struct </span>MyTransfer :</div><div class="line">    <span class="keyword">public</span> TransformTransfer,</div><div class="line">    <span class="keyword">public</span> VolumeTransfer&lt;FloatTree&gt;</div><div class="line">{</div><div class="line">    MyTransfer(<a class="code" href="namespaceopenvdb_1_1v10__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a>&amp; dest, <span class="keyword">const</span> <a class="code" href="namespaceopenvdb_1_1v10__0_1_1points.html#acf438a63a8a41ec38b6d7ceae6467678">PointDataGrid</a>&amp; source)</div><div class="line">        : TransformTransfer(source.transform(), dest.transform())</div><div class="line">        , VolumeTransfer(dest.tree())</div><div class="line">        , mHandle(nullptr) {}</div><div class="line"></div><div class="line">    MyTransfer(<span class="keyword">const</span> MyTransfer&amp; other)</div><div class="line">        : TransformTransfer(other)</div><div class="line">        , VolumeTransfer(other)</div><div class="line">        , mHandle(nullptr) {}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief Range in index space of the source points</span></div><div class="line"><span class="comment"></span>    <a class="code" href="namespaceopenvdb_1_1v10__0.html#ac524bdfeb5d781872485d9321c881920">Int32</a> range(<span class="keyword">const</span> Coord&amp;, <span class="keywordtype">size_t</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="namespaceopenvdb_1_1v10__0.html#ac524bdfeb5d781872485d9321c881920">Int32</a>(1); }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief Every time we start a new point leaf, init the position array.</span></div><div class="line"><span class="comment">    ///   Always return true as we don&#39;t skip any leaf nodes.</span></div><div class="line"><span class="comment"></span>    <span class="keywordtype">bool</span> startPointLeaf(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v10__0_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">PointDataTree::LeafNodeType</a>&amp; leaf)</div><div class="line">    {</div><div class="line">        mHandle.reset(<span class="keyword">new</span> AttributeHandle&lt;Vec3f&gt;(leaf.constAttributeArray(<span class="stringliteral">&quot;P&quot;</span>));</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  For each point, compute its relative index space position in</span></div><div class="line"><span class="comment">    ///   the destination tree and sum the length of its distance</span></div><div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> rasterizePoint(<span class="keyword">const</span> Coord&amp; ijk, <span class="keyword">const</span> Index <span class="keywordtype">id</span>, <span class="keyword">const</span> <a class="code" href="namespacenanovdb.html#a8afc96c92541921d1a0a3ec2c2d6b783">CoordBBox</a>&amp; bounds)</div><div class="line">    {</div><div class="line">        <a class="code" href="namespaceopenvdb_1_1v10__0_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">Vec3d</a> P = ijk.asVec3d() + <a class="code" href="namespaceopenvdb_1_1v10__0_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">Vec3d</a>(this-&gt;mHandle-&gt;get(<span class="keywordtype">id</span>));</div><div class="line">        P = this-&gt;transformSourceToTarget(P); <span class="comment">// TransformTransfer::transformSourceToTarget</span></div><div class="line">        <span class="comment">// for each active voxel, accumulate distance</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>* mask = this-&gt;mask(); <span class="comment">// VolumeTransfer::mask</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; coord : bounds) {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="namespaceopenvdb_1_1v10__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> voxel = FloatTree::LeafNodeType::coordToOffset(coord);</div><div class="line">            <span class="keywordflow">if</span> (!mask-&gt;isOn(voxel)) <span class="keywordflow">continue</span>;</div><div class="line">            <a class="code" href="namespaceopenvdb_1_1v10__0_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">Vec3d</a> dist = coord.asVec3d() - P;</div><div class="line">            this-&gt;buffer()[voxel] += dist.<a class="code" href="classopenvdb_1_1v10__0_1_1math_1_1Vec3.html#ac391672014f7b4faed37018787333e4b">length</a>(); <span class="comment">// VolumeTransfer::buffer</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief Return true for endPointLeaf() to continue, false for finalize() so</span></div><div class="line"><span class="comment">    ///   we don&#39;t recurse.</span></div><div class="line"><span class="comment"></span>    <span class="keywordtype">bool</span> endPointLeaf(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v10__0_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">PointDataTree::LeafNodeType</a>&amp;) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div><div class="line">    <span class="keywordtype">bool</span> finalize(<span class="keyword">const</span> Coord&amp;, <span class="keywordtype">size_t</span>) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::unique_ptr&lt;AttributeHandle&lt;Vec3f&gt;&gt; mHandle;</div><div class="line">};</div></div><!-- fragment --><p>The method works by looping over a single Tree topology, looking up point data at a position relative to that topology and passing that data to a transfer scheme TransferT. </p><dl class="section note"><dt>Note</dt><dd>Each thread receives a copy of the transfer scheme object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point data grid to rasterize </td></tr>
    <tr><td class="paramname">transfer</td><td>the transfer scheme </td></tr>
    <tr><td class="paramname">filter</td><td>optional point filter </td></tr>
    <tr><td class="paramname">interrupter</td><td>optional interrupter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a082f0d3ace2f284f821b49d68535c64b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SdfT::Ptr rasterizeSmoothSpheres </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>searchRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>halfband</em> = <code><a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a>&#160;</td>
          <td class="paramname"><em>transform</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smoothed point distribution based sphere stamping with a uniform radius. </p>
<p>Rasterizes points into a level set using [Zhu Bridson 05] sphere stamping with a uniform radius. The radius and search radius parameters are given in world space units and are applied to every point to generate a fixed surface mask and consequent distance values. The search radius is each points points maximum contribution to the target level set. The search radius should always have a value equal to or larger than the point radius. </p><dl class="section warning"><dt>Warning</dt><dd>The width of the exterior half band <em>may</em> be smaller than the specified half band if the search radius is less than the equivalent world space halfband distance. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point data grid to rasterize </td></tr>
    <tr><td class="paramname">radius</td><td>the world space radius of every point </td></tr>
    <tr><td class="paramname">searchRadius</td><td>the maximum search distance of every point </td></tr>
    <tr><td class="paramname">halfband</td><td>the half band width </td></tr>
    <tr><td class="paramname">transform</td><td>the target transform for the surface </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
    <tr><td class="paramname">interrupter</td><td>optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed distance field. </dd></dl>

</div>
</div>
<a class="anchor" id="a061f2cdb45d004922a317239e13437a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SdfT::Ptr rasterizeSmoothSpheres </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>radiusScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>searchRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>halfband</em> = <code><a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a>&#160;</td>
          <td class="paramname"><em>transform</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smoothed point distribution based sphere stamping with a varying radius. </p>
<p>Rasterizes points into a level set using [Zhu Bridson 05] sphere stamping with a variable radius. The radius string parameter expects a point attribute of type RadiusT to exist. The radiusScale parameter is multiplier for radius values held on the radius attribute. The searchRadius parameter remains a fixed size value which represents each points points maximum contribution to the target level set. The radius scale and search radius parameters are given in world space units and are applied to every point to generate a fixed surface mask and consequent distance values. The search radius should always have a value equal to or larger than the point radii. </p><dl class="section warning"><dt>Warning</dt><dd>The width of the exterior half band <em>may</em> be smaller than the specified half band if the search radius is less than the equivalent world space halfband distance. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point data grid to rasterize </td></tr>
    <tr><td class="paramname">radius</td><td>the attribute containing the world space radius </td></tr>
    <tr><td class="paramname">radiusScale</td><td>the scale applied to every world space radius value </td></tr>
    <tr><td class="paramname">searchRadius</td><td>the maximum search distance of every point </td></tr>
    <tr><td class="paramname">halfband</td><td>the half band width </td></tr>
    <tr><td class="paramname">transform</td><td>the target transform for the surface </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
    <tr><td class="paramname">interrupter</td><td>optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed distance field. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a8effe83e84502ac0ba508d32f2e10a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v10__0.html#a0c9703e6ff5cc9deb6410c53412c22c3">GridPtrVec</a> rasterizeSmoothSpheres </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>searchRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>halfband</em> = <code><a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a>&#160;</td>
          <td class="paramname"><em>transform</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smoothed point distribution based sphere stamping with a uniform radius and closest point attribute transfer. </p>
<p>Rasterizes points into a level set using [Zhu Bridson 05] sphere stamping with a uniform radius. The radius and search radius parameters are given in world space units and are applied to every point to generate a fixed surface mask and consequent distance values. The search radius is each points points maximum contribution to the target level set. The search radius should always be larger than the point radius. Every voxel's closest point is used to transfer each attribute in the attributes parameter to a new grid of matching topology. The destination types of these grids is equal to the ValueConverter result of the attribute type applied to the PointDataGridT. </p><dl class="section note"><dt>Note</dt><dd>The AttributeTypes template parameter should be a <a class="el" href="structopenvdb_1_1v10__0_1_1TypeList.html" title="A list of types (not necessarily unique) ">TypeList</a> of the required or possible attributes types. i.e. TypeList&lt;int, float, double&gt;. A runtime error will be thrown if no equivalent type for a given attribute is found in the AttributeTypes <a class="el" href="structopenvdb_1_1v10__0_1_1TypeList.html" title="A list of types (not necessarily unique) ">TypeList</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The width of the exterior half band <em>may</em> be smaller than the specified half band if the search radius is less than the equivalent world space halfband distance. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point data grid to rasterize </td></tr>
    <tr><td class="paramname">radius</td><td>the world space radius of every point </td></tr>
    <tr><td class="paramname">searchRadius</td><td>the maximum search distance of every point </td></tr>
    <tr><td class="paramname">attributes</td><td>list of attributes to transfer </td></tr>
    <tr><td class="paramname">halfband</td><td>the half band width </td></tr>
    <tr><td class="paramname">transform</td><td>the target transform for the surface </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
    <tr><td class="paramname">interrupter</td><td>optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of grids. The signed distance field is guaranteed to be first and at the type specified by SdfT. Successive grids are the closest point attribute grids. These grids are guaranteed to have a topology and transform equal to the surface. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f3722592b607cb0eafbfa5c17ebdc3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v10__0.html#a0c9703e6ff5cc9deb6410c53412c22c3">GridPtrVec</a> rasterizeSmoothSpheres </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>radiusScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>searchRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>halfband</em> = <code><a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a>&#160;</td>
          <td class="paramname"><em>transform</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smoothed point distribution based sphere stamping with a varying radius and closest point attribute transfer. </p>
<p>Rasterizes points into a level set using [Zhu Bridson 05] sphere stamping with a variable radius. The radius string parameter expects a point attribute of type RadiusT to exist. The radiusScale parameter is multiplier for radius values held on the radius attribute. The searchRadius parameter remains a fixed size value which represents each points points maximum contribution to the target level set. The radius scale and search radius parameters are given in world space units and are applied to every point to generate a fixed surface mask and consequent distance values. The search radius should always have a value equal to or larger than the point radii. Every voxel's closest point is used to transfer each attribute in the attributes parameter to a new grid of matching topology. The destination types of these grids is equal to the ValueConverter result of the attribute type applied to the PointDataGridT. </p><dl class="section note"><dt>Note</dt><dd>The AttributeTypes template parameter should be a <a class="el" href="structopenvdb_1_1v10__0_1_1TypeList.html" title="A list of types (not necessarily unique) ">TypeList</a> of the required or possible attributes types. i.e. TypeList&lt;int, float, double&gt;. A runtime error will be thrown if no equivalent type for a given attribute is found in the AttributeTypes <a class="el" href="structopenvdb_1_1v10__0_1_1TypeList.html" title="A list of types (not necessarily unique) ">TypeList</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The width of the exterior half band <em>may</em> be smaller than the specified half band if the search radius is less than the equivalent world space halfband distance. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point data grid to rasterize </td></tr>
    <tr><td class="paramname">radius</td><td>the attribute containing the world space radius </td></tr>
    <tr><td class="paramname">radiusScale</td><td>the scale applied to every world space radius value </td></tr>
    <tr><td class="paramname">searchRadius</td><td>the maximum search distance of every point </td></tr>
    <tr><td class="paramname">attributes</td><td>list of attributes to transfer </td></tr>
    <tr><td class="paramname">halfband</td><td>the half band width </td></tr>
    <tr><td class="paramname">transform</td><td>the target transform for the surface </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
    <tr><td class="paramname">interrupter</td><td>optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of grids. The signed distance field is guaranteed to be first and at the type specified by SdfT. Successive grids are the closest point attribute grids. These grids are guaranteed to have a topology and transform equal to the surface. </dd></dl>

</div>
</div>
<a class="anchor" id="a120917a417a08b222180816d267f0e50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SdfT::Ptr rasterizeSpheres </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>halfband</em> = <code><a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a>&#160;</td>
          <td class="paramname"><em>transform</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Narrow band sphere stamping with a uniform radius. </p>
<p>Rasterizes points into a level set using basic sphere stamping with a uniform radius. The radius parameter is given in world space units and is applied to every point to generate a fixed surface mask and consequent distance values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point data grid to rasterize </td></tr>
    <tr><td class="paramname">radius</td><td>the world space radius of every point </td></tr>
    <tr><td class="paramname">halfband</td><td>the half band width </td></tr>
    <tr><td class="paramname">transform</td><td>the target transform for the surface </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
    <tr><td class="paramname">interrupter</td><td>optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed distance field. </dd></dl>

</div>
</div>
<a class="anchor" id="a368f4fde28a7b92a670af70045a3c08c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SdfT::Ptr rasterizeSpheres </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>halfband</em> = <code><a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a>&#160;</td>
          <td class="paramname"><em>transform</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Narrow band sphere stamping with a varying radius. </p>
<p>Rasterizes points into a level set using basic sphere stamping with a variable radius. The radius string parameter expects a point attribute of type RadiusT to exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point data grid to rasterize </td></tr>
    <tr><td class="paramname">radius</td><td>the name of the radius attribute </td></tr>
    <tr><td class="paramname">scale</td><td>an optional scale to apply to each per point radius </td></tr>
    <tr><td class="paramname">halfband</td><td>the half band width </td></tr>
    <tr><td class="paramname">transform</td><td>the target transform for the surface </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
    <tr><td class="paramname">interrupter</td><td>optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed distance field. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d7855e30f7a0d1526efa75cc1da5bd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v10__0.html#a0c9703e6ff5cc9deb6410c53412c22c3">GridPtrVec</a> rasterizeSpheres </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>halfband</em> = <code><a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a>&#160;</td>
          <td class="paramname"><em>transform</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Narrow band sphere stamping with a uniform radius and closest point attribute transfer. </p>
<p>Rasterizes points into a level set using basic sphere stamping with a uniform radius. The radius parameter is given in world space units and is applied to every point to generate a fixed surface mask and consequent distance values. Every voxel's closest point is used to transfer each attribute in the attributes parameter to a new grid of matching topology. The destination types of these grids is equal to the ValueConverter result of the attribute type applied to the PointDataGridT. </p><dl class="section note"><dt>Note</dt><dd>The AttributeTypes template parameter should be a <a class="el" href="structopenvdb_1_1v10__0_1_1TypeList.html" title="A list of types (not necessarily unique) ">TypeList</a> of the required or possible attributes types. i.e. TypeList&lt;int, float, double&gt;. A runtime error will be thrown if no equivalent type for a given attribute is found in the AttributeTypes <a class="el" href="structopenvdb_1_1v10__0_1_1TypeList.html" title="A list of types (not necessarily unique) ">TypeList</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point data grid to rasterize </td></tr>
    <tr><td class="paramname">radius</td><td>the world space radius of every point </td></tr>
    <tr><td class="paramname">attributes</td><td>list of attributes to transfer </td></tr>
    <tr><td class="paramname">halfband</td><td>the half band width </td></tr>
    <tr><td class="paramname">transform</td><td>the target transform for the surface </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
    <tr><td class="paramname">interrupter</td><td>optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of grids. The signed distance field is guaranteed to be first and at the type specified by SdfT. Successive grids are the closest point attribute grids. These grids are guaranteed to have a topology and transform equal to the surface. </dd></dl>

</div>
</div>
<a class="anchor" id="abc29e6ff518213c83a2868be36df2d58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v10__0.html#a0c9703e6ff5cc9deb6410c53412c22c3">GridPtrVec</a> rasterizeSpheres </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td>
          <td class="paramname"><em>halfband</em> = <code><a class="el" href="namespaceopenvdb_1_1v10__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v10__0_1_1math_1_1Transform.html#adda08830421865deca63de52158e9070">math::Transform::Ptr</a>&#160;</td>
          <td class="paramname"><em>transform</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Narrow band sphere stamping with a varying radius and closest point attribute transfer. </p>
<p>Rasterizes points into a level set using basic sphere stamping with a variable radius. The radius string parameter expects a point attribute of type RadiusT to exist. Every voxel's closest point is used to transfer each attribute in the attributes parameter to a new grid of matching topology. The destination types of these grids is equal to the ValueConverter result of the attribute type applied to the PointDataGridT. </p><dl class="section note"><dt>Note</dt><dd>The AttributeTypes template parameter should be a <a class="el" href="structopenvdb_1_1v10__0_1_1TypeList.html" title="A list of types (not necessarily unique) ">TypeList</a> of the required or possible attributes types. i.e. TypeList&lt;int, float, double&gt;. A runtime error will be thrown if no equivalent type for a given attribute is found in the AttributeTypes <a class="el" href="structopenvdb_1_1v10__0_1_1TypeList.html" title="A list of types (not necessarily unique) ">TypeList</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point data grid to rasterize </td></tr>
    <tr><td class="paramname">radius</td><td>the name of the radius attribute </td></tr>
    <tr><td class="paramname">attributes</td><td>list of attributes to transfer </td></tr>
    <tr><td class="paramname">scale</td><td>scale to apply to each per point radius </td></tr>
    <tr><td class="paramname">halfband</td><td>the half band width </td></tr>
    <tr><td class="paramname">transform</td><td>the target transform for the surface </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
    <tr><td class="paramname">interrupter</td><td>optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of grids. The signed distance field is guaranteed to be first and at the type specified by SdfT. Successive grids are the closest point attribute grids. These grids are guaranteed to have a topology and transform equal to the surface. </dd></dl>

</div>
</div>
<a class="anchor" id="a43f917f566a11a07b496f369adc7d6a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto rasterizeTrilinear </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform weighted trilinear rasterization of all points within a voxel. This method takes and returns a tree i.e. ignores grid transformations. </p>
<p>Accumulates values and weights according to a simple 0-1-0 weighted hat function. This algorithm is an exact inverse of a trilinear interpolation and thus a key method used in PIC/FLIP style simulations. Returns a tree of the same precision as the input source attribute, but may be of a different math type depending on the value of the Staggered template attribute. If Staggered is true, this method produces values at each voxels negative faces, causing scalar attributes to produce math::Vec3&lt;ValueT&gt; tree types. The result Tree type is equal to: TrilinearTraits&lt;ValueT, Staggered&gt;::template TreeT&lt;PointDataTreeT&gt; </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Staggered</td><td>whether to perform a staggered or collocated rasterization </td></tr>
    <tr><td class="paramname">ValueT</td><td>the value type of the point attribute to rasterize </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point tree to be rasterized </td></tr>
    <tr><td class="paramname">attribute</td><td>the name of the attribute to rasterize. Must be a scalar or Vec3 attribute. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional point filter to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb60e92fdbb25ad5822945cc30b3e8b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void renameAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>oldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename an attribute in a VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
    <tr><td class="paramname">oldName</td><td>the old attribute name to rename from. </td></tr>
    <tr><td class="paramname">newName</td><td>the new attribute name to rename to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>newName must not already exist and must not be a group attribute. </dd></dl>

</div>
</div>
<a class="anchor" id="aceb82e6282deeaa12012efbe386ce564"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void renameAttributes </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename attributes in a VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
    <tr><td class="paramname">oldNames</td><td>a list of old attribute names to rename from. </td></tr>
    <tr><td class="paramname">newNames</td><td>a list of new attribute names to rename to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Number of oldNames must match the number of newNames.</dd>
<dd>
Duplicate names and renaming group attributes are not allowed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ff8951f375ddac4b685e72f486489d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sampleGrid </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceGridT &amp;&#160;</td>
          <td class="paramname"><em>sourceGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>targetAttribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SamplerT &amp;&#160;</td>
          <td class="paramname"><em>sampler</em> = <code><a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1SampleWithRounding.html">SampleWithRounding</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs sampling and conversion from a VDB grid onto a VDB Points attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the sampling order - 0 = closest-point, 1 = trilinear, 2 = triquadratic </td></tr>
    <tr><td class="paramname">points</td><td>the PointDataGrid whose points will be sampled on to </td></tr>
    <tr><td class="paramname">sourceGrid</td><td>VDB grid which will be sampled </td></tr>
    <tr><td class="paramname">targetAttribute</td><td>a target attribute on the points which will hold samples. This attribute will be created with the source grid type if it does not exist, and with the source grid name if the name is empty </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">sampler</td><td>handles sampling and conversion into the target attribute type, which by default this uses the <a class="el" href="structopenvdb_1_1v10__0_1_1points_1_1SampleWithRounding.html">SampleWithRounding</a> struct. </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The target attribute may exist provided it can be cast to the SourceGridT ValueType </dd></dl>

</div>
</div>
<a class="anchor" id="a1866ee320dd051901bb7f4f49e155cee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointIndexTreeT &amp;&#160;</td>
          <td class="paramname"><em>indexTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; short &gt; &amp;&#160;</td>
          <td class="paramname"><em>membership</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets group membership from a PointIndexTree-ordered vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
    <tr><td class="paramname">indexTree</td><td>the PointIndexTree. </td></tr>
    <tr><td class="paramname">membership</td><td><code>1</code> if the point is in the group, 0 otherwise. </td></tr>
    <tr><td class="paramname">group</td><td>the name of the group. </td></tr>
    <tr><td class="paramname">remove</td><td>if <code>true</code> also perform removal of points from the group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>vector&lt;bool&gt; is not thread-safe on concurrent write, so use vector&lt;short&gt; instead </dd></dl>

</div>
</div>
<a class="anchor" id="a522af44dcf8da3f9e6c7b747e075f155"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>member</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets membership for the specified group for all points (on/off). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
    <tr><td class="paramname">group</td><td>the name of the group. </td></tr>
    <tr><td class="paramname">member</td><td>true / false for membership of the group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5ce5ef333b529b92e4acb1bddeec93c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setGroupByFilter </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets group membership based on a provided filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
    <tr><td class="paramname">group</td><td>the name of the group. </td></tr>
    <tr><td class="paramname">filter</td><td>filter data that is used to create a per-leaf filter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac775f2efb51fe765dc1e54e4f33f85cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v10_0::points::setGroupByRandomPercentage </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>percentage</em> = <code>10.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a630ad019fee99cc74bb048d047212218"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v10_0::points::setGroupByRandomTarget </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td>
          <td class="paramname"><em>targetPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0d85a4b1b93c26f69ecf71e75017275b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setStreamingMode </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle the streaming mode on all attributes in the tree to collapse the attributes after deconstructing a bound <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeHandle.html">AttributeHandle</a> to each array. This results in better memory efficiency when the data is streamed into another data structure (typically for rendering). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
    <tr><td class="paramname">on</td><td><code>true</code> to enable streaming</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Multiple threads cannot safely access the same <a class="el" href="classopenvdb_1_1v10__0_1_1points_1_1AttributeArray.html" title="Base class for storing attribute data. ">AttributeArray</a> when using streaming. </dd></dl>

</div>
</div>
<a class="anchor" id="abc4c70eaf37048c67356fd7189b15d95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr uniformPointScatter </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v10__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>spread</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The free functions depend on the following class: </p>
<p>The <code>InterrupterT</code> template argument below refers to any class with the following interface: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>Interrupter {</div><div class="line">   ...</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   <span class="keywordtype">void</span> start(<span class="keyword">const</span> <span class="keywordtype">char</span>* name = <span class="keyword">nullptr</span>) <span class="comment">// called when computations begin</span></div><div class="line">   void end()                             <span class="comment">// called when computations end</span></div><div class="line">   <span class="keywordtype">bool</span> <a class="code" href="namespaceopenvdb_1_1v10__0_1_1util.html#abb877488f5dfa45baa64078aab2cdb20">wasInterrupted</a>(<span class="keywordtype">int</span> percent=-1)    <span class="comment">// return true to break computation</span></div><div class="line">};</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If no template argument is provided for this InterrupterT the <a class="el" href="structopenvdb_1_1v10__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters. ">util::NullInterrupter</a> is used which implies that all interrupter calls are no-ops (i.e. incurs no computational overhead). Uniformly scatter a total amount of points in active regions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>A source grid. The resulting PointDataGrid will copy this grids transform and scatter in its active voxelized topology. </td></tr>
    <tr><td class="paramname">count</td><td>The total number of points to scatter </td></tr>
    <tr><td class="paramname">seed</td><td>A seed for the RandGenT </td></tr>
    <tr><td class="paramname">spread</td><td>The spread of points as a scale from each voxels center. A value of 1.0f indicates points can be placed anywhere within the voxel, where as a value of 0.0f will force all points to be created exactly at the centers of each voxel. </td></tr>
    <tr><td class="paramname">interrupter</td><td>An optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns the scattered PointDataGrid </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
