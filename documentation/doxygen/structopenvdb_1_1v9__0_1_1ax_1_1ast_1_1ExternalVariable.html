<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: ExternalVariable Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">9.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v9__0.html">v9_0</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v9__0_1_1ax.html">ax</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v9__0_1_1ax_1_1ast.html">ast</a></li><li class="navelem"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ExternalVariable Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> represent any access to external (custom) data, typically associated with the '$' symbol syntax. Note that the AST does not store any additional information on the given external other than its name and type, which together form a unique external identifier known as the <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> 'token'. This token is used by the compiler to map user provided values to these external values.  
 <a href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AST_8h_source.html">openvdb_ax/ast/AST.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Variable.html">Variable</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8f3aca5fd43929de43c38eb5e778ff67"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a8f3aca5fd43929de43c38eb5e778ff67">UniquePtr</a> = std::unique_ptr&lt; <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a> &gt;</td></tr>
<tr class="separator:a8f3aca5fd43929de43c38eb5e778ff67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac9cbaeea226ed297804c012dc12b16"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16">NodeType</a> { <br />
&#160;&#160;<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a6e3c9853eac7f791316173112a4c920d">TreeNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a48e5c1876288bf22cd46f986e38adf02">StatementListNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a43780fadfdb2235144acada7dbe105c7">BlockNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a4aab5c0f2459150efa56479af2eb819f">ConditionalStatementNode</a>, 
<br />
&#160;&#160;<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a9c67b92cc82860adc32a7bf2c3bdc31a">CommaOperatorNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a211255852991e0aa4bc65fc0efb5308d">LoopNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16abdc96277641e4564f49f05fd3332a3d4">KeywordNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16aeda94965a49b65abcb13ab789c6f0ed4">AssignExpressionNode</a>, 
<br />
&#160;&#160;<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16ae9a53f544375844ca76604ae5f2ca791">CrementNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a5eb95c2e659ce03204e6c0b0b0c87740">UnaryOperatorNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a1c1bb5e6682d57a60288fb496aeff4cf">BinaryOperatorNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a050af244605ad1322fc8e7b5a0179f1b">TernaryOperatorNode</a>, 
<br />
&#160;&#160;<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16af9a5d82c6573803b099c3adfc4b9b20c">CastNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a7b3e1e1d3d5d99fc9af0ba930f3db50d">AttributeNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a5eb065001855bf5fee13c8f1c40348ed">FunctionCallNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a9501cd3ee5528bcca1e51ac8f0966994">ExternalVariableNode</a>, 
<br />
&#160;&#160;<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16ac8a7cf9d5914e72e1b0d1d6b1209ab24">DeclareLocalNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a641de2f20e7205326940bae22fed24d3">ArrayPackNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16aa4c2677554db379f707701e1e033b766">ArrayUnpackNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a58e08f3e77b3e58192caac0a9a4c3465">LocalNode</a>, 
<br />
&#160;&#160;<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16ad367abc3c089565a6428ca827885f831">ValueBoolNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a86ec9f75634eb04e475dba4ee93933fb">ValueInt16Node</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16a764ee55f09a4bb6aac2eac083df73323">ValueInt32Node</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16aee71e3911c1b181f2d37f99668f44fc5">ValueInt64Node</a>, 
<br />
&#160;&#160;<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16ada29dd0c7c5827571517da57d290f7ca">ValueFloatNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16ad42b26e9f262c9059e38424d71a38d60">ValueDoubleNode</a>, 
<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16aa76996244034142252ec475e159c26bb">ValueStrNode</a>
<br />
 }<tr class="memdesc:acac9cbaeea226ed297804c012dc12b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumerated list of node types for all concrete node types. These can be used for faster evaluation of a given concrete node using the virtual function table via <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#ab703c8a88dcde2076cb089c07af0cc5c" title="Virtual method for accessing node type information. ">Node::nodetype()</a> rather than performing a dynamic_cast/calling <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#aa6af20b4807e0ff1021f08015a0c8779" title="Query whether or not this node is of a specific (derived) type. This method should be used to check i...">Node::isType</a>.  <a href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:acac9cbaeea226ed297804c012dc12b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2fb63266a358aa04393a2bb62c9478"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#abf2fb63266a358aa04393a2bb62c9478">Ptr</a> = std::shared_ptr&lt; <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html">Node</a> &gt;</td></tr>
<tr class="separator:abf2fb63266a358aa04393a2bb62c9478"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1091c5df90c10095784d3240830ce913"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a1091c5df90c10095784d3240830ce913">ExternalVariable</a> (const std::string &amp;<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Variable.html#a324e8c54c4c5161913681a1a52fef959">name</a>, const <a class="el" href="namespaceopenvdb_1_1v9__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a> <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a7cd48780d0b85f530faf694b017e7a56">type</a>)</td></tr>
<tr class="memdesc:a1091c5df90c10095784d3240830ce913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> with a given name and type.  <a href="#a1091c5df90c10095784d3240830ce913">More...</a><br /></td></tr>
<tr class="separator:a1091c5df90c10095784d3240830ce913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21930ab57f91197c92134aa471ef77b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a21930ab57f91197c92134aa471ef77b7">ExternalVariable</a> (const std::string &amp;<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Variable.html#a324e8c54c4c5161913681a1a52fef959">name</a>, const std::string &amp;token)</td></tr>
<tr class="memdesc:a21930ab57f91197c92134aa471ef77b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> with a given name and type/token string, delegating construction to the above <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> constructor.  <a href="#a21930ab57f91197c92134aa471ef77b7">More...</a><br /></td></tr>
<tr class="separator:a21930ab57f91197c92134aa471ef77b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d10a5985b1856aed093112572d0eb64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a5d10a5985b1856aed093112572d0eb64">ExternalVariable</a> (const <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a> &amp;other)</td></tr>
<tr class="memdesc:a5d10a5985b1856aed093112572d0eb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy constructor for a <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a>.  <a href="#a5d10a5985b1856aed093112572d0eb64">More...</a><br /></td></tr>
<tr class="separator:a5d10a5985b1856aed093112572d0eb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef466e788ac52c7fa240c1666ec18b1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#aef466e788ac52c7fa240c1666ec18b1e">~ExternalVariable</a> () override=default</td></tr>
<tr class="separator:aef466e788ac52c7fa240c1666ec18b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af331e15b6e30adeb382c2094871fdfe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#af331e15b6e30adeb382c2094871fdfe0">copy</a> () const  override final</td></tr>
<tr class="memdesc:af331e15b6e30adeb382c2094871fdfe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The deep copy method for a <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">Node</a>.  <a href="#af331e15b6e30adeb382c2094871fdfe0">More...</a><br /></td></tr>
<tr class="separator:af331e15b6e30adeb382c2094871fdfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e93792b1c66561e4c0b1d1950bb31e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16">NodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a0e93792b1c66561e4c0b1d1950bb31e7">nodetype</a> () const  override</td></tr>
<tr class="memdesc:a0e93792b1c66561e4c0b1d1950bb31e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method for accessing node type information.  <a href="#a0e93792b1c66561e4c0b1d1950bb31e7">More...</a><br /></td></tr>
<tr class="separator:a0e93792b1c66561e4c0b1d1950bb31e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9117048dc8873df412c574a6b57bba49"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a9117048dc8873df412c574a6b57bba49">nodename</a> () const  override</td></tr>
<tr class="memdesc:a9117048dc8873df412c574a6b57bba49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method for accessing node name information.  <a href="#a9117048dc8873df412c574a6b57bba49">More...</a><br /></td></tr>
<tr class="separator:a9117048dc8873df412c574a6b57bba49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad5e5c0b5f1bd6dae05e6322b0e0e5b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a2ad5e5c0b5f1bd6dae05e6322b0e0e5b">subname</a> () const  override</td></tr>
<tr class="memdesc:a2ad5e5c0b5f1bd6dae05e6322b0e0e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method for accessing node name information.  <a href="#a2ad5e5c0b5f1bd6dae05e6322b0e0e5b">More...</a><br /></td></tr>
<tr class="separator:a2ad5e5c0b5f1bd6dae05e6322b0e0e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aac72b4bc51801b3396bafce19d891"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Variable.html">Variable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a08aac72b4bc51801b3396bafce19d891">basetype</a> () const  override</td></tr>
<tr class="memdesc:a08aac72b4bc51801b3396bafce19d891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method for accessing a node's base class. Note that if this is called explicitly on an instance of <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">ast::Node</a> (the top most base class) a nullptr is returned. This is primarily used by the <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Visitor.html" title="The Visitor class uses the Curiously Recursive Template Pattern (CRTP) to provide a customizable inte...">Visitor</a> to support hierarchical visits.  <a href="#a08aac72b4bc51801b3396bafce19d891">More...</a><br /></td></tr>
<tr class="separator:a08aac72b4bc51801b3396bafce19d891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd48780d0b85f530faf694b017e7a56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v9__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a7cd48780d0b85f530faf694b017e7a56">type</a> () const </td></tr>
<tr class="memdesc:a7cd48780d0b85f530faf694b017e7a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the type that was used to access this external variable.  <a href="#a7cd48780d0b85f530faf694b017e7a56">More...</a><br /></td></tr>
<tr class="separator:a7cd48780d0b85f530faf694b017e7a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbc5929cea669e7fc6778b525a01cd7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#afdbc5929cea669e7fc6778b525a01cd7">typestr</a> () const </td></tr>
<tr class="memdesc:afdbc5929cea669e7fc6778b525a01cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the access type as a front end AX type/token string.  <a href="#afdbc5929cea669e7fc6778b525a01cd7">More...</a><br /></td></tr>
<tr class="separator:afdbc5929cea669e7fc6778b525a01cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cadff59b68ea4a61534cdf5f17423b"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a62cadff59b68ea4a61534cdf5f17423b">tokenname</a> () const </td></tr>
<tr class="memdesc:a62cadff59b68ea4a61534cdf5f17423b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return the full external token identifier. See <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a8ea12b19d116b2bc0bdb196759c6bb8a" title="Static method returning the full unique external token identifier by consolidating its name and type ...">ExternalVariable::tokenFromNameType</a>.  <a href="#a62cadff59b68ea4a61534cdf5f17423b">More...</a><br /></td></tr>
<tr class="separator:a62cadff59b68ea4a61534cdf5f17423b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdd2cebf8709beb3d2dd373c890f669"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Variable.html#accdd2cebf8709beb3d2dd373c890f669">children</a> () const  override</td></tr>
<tr class="memdesc:accdd2cebf8709beb3d2dd373c890f669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method for accessing child information. Returns the number of children a given AST node owns.  <a href="#accdd2cebf8709beb3d2dd373c890f669">More...</a><br /></td></tr>
<tr class="separator:accdd2cebf8709beb3d2dd373c890f669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fab488b1b21a535d6f073c6e6fab380"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Variable.html#a8fab488b1b21a535d6f073c6e6fab380">child</a> (const size_t) const  override</td></tr>
<tr class="memdesc:a8fab488b1b21a535d6f073c6e6fab380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method for accessing child information. Returns a const pointer to a child node at the given index. If the index is out of range, a nullptr is returned.  <a href="#a8fab488b1b21a535d6f073c6e6fab380">More...</a><br /></td></tr>
<tr class="separator:a8fab488b1b21a535d6f073c6e6fab380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324e8c54c4c5161913681a1a52fef959"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Variable.html#a324e8c54c4c5161913681a1a52fef959">name</a> () const </td></tr>
<tr class="separator:a324e8c54c4c5161913681a1a52fef959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Name/Type</div></td></tr>
<tr class="memitem:aa6af20b4807e0ff1021f08015a0c8779"><td class="memTemplParams" colspan="2">template&lt;typename NodeT &gt; </td></tr>
<tr class="memitem:aa6af20b4807e0ff1021f08015a0c8779"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#aa6af20b4807e0ff1021f08015a0c8779">isType</a> () const </td></tr>
<tr class="memdesc:aa6af20b4807e0ff1021f08015a0c8779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether or not this node is of a specific (derived) type. This method should be used to check if a node is of a particular abstract type. When checking concrete types, it's generally more efficient to check the return value of <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#ab703c8a88dcde2076cb089c07af0cc5c" title="Virtual method for accessing node type information. ">Node::nodetype()</a>  <a href="#aa6af20b4807e0ff1021f08015a0c8779">More...</a><br /></td></tr>
<tr class="separator:aa6af20b4807e0ff1021f08015a0c8779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Child Queries</div></td></tr>
<tr class="memitem:af0d2a30087bbaa79fe8bc74365403f94"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#af0d2a30087bbaa79fe8bc74365403f94">childidx</a> () const </td></tr>
<tr class="memdesc:af0d2a30087bbaa79fe8bc74365403f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the child index of this node in relation to its parent, or -1 if no valid index is found (usually representing the top most node (i.e. <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy. It represents an entire conversion of a valid AX string. ">Tree</a>)  <a href="#af0d2a30087bbaa79fe8bc74365403f94">More...</a><br /></td></tr>
<tr class="separator:af0d2a30087bbaa79fe8bc74365403f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Replacement</div></td></tr>
<tr class="memitem:a0919d7b8b04ebb9fadd7eb3c99db5929"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#a0919d7b8b04ebb9fadd7eb3c99db5929">replace</a> (<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a0919d7b8b04ebb9fadd7eb3c99db5929"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place replacement. Attempts to replace this node at its specific location within its Abstract Syntax <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy. It represents an entire conversion of a valid AX string. ">Tree</a>. On a successful replacement, this node is destroyed, the provided node is inserted in its place and ownership is transferred to the parent node. No further calls to this node can be made on successful replacements.  <a href="#a0919d7b8b04ebb9fadd7eb3c99db5929">More...</a><br /></td></tr>
<tr class="separator:a0919d7b8b04ebb9fadd7eb3c99db5929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39adc7dd66d859ef6f4ad0f7d1455692"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#a39adc7dd66d859ef6f4ad0f7d1455692">replacechild</a> (const size_t index, <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a39adc7dd66d859ef6f4ad0f7d1455692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method that attempted to replace a child at a given index with a provided node type.  <a href="#a39adc7dd66d859ef6f4ad0f7d1455692">More...</a><br /></td></tr>
<tr class="separator:a39adc7dd66d859ef6f4ad0f7d1455692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parent</div></td></tr>
<tr class="memitem:a380fac0257f0b37533f630d763250bb4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#a380fac0257f0b37533f630d763250bb4">parent</a> () const </td></tr>
<tr class="memdesc:a380fac0257f0b37533f630d763250bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a const pointer to this nodes parent.  <a href="#a380fac0257f0b37533f630d763250bb4">More...</a><br /></td></tr>
<tr class="separator:a380fac0257f0b37533f630d763250bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade468b936d43438b4fd722bea1243b5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#ade468b936d43438b4fd722bea1243b5d">setParent</a> (<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html">Node</a> *<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#a380fac0257f0b37533f630d763250bb4">parent</a>)</td></tr>
<tr class="memdesc:ade468b936d43438b4fd722bea1243b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this node's parent. This is used during construction of an AST and should not be used.  <a href="#ade468b936d43438b4fd722bea1243b5d">More...</a><br /></td></tr>
<tr class="separator:ade468b936d43438b4fd722bea1243b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a11cff13fc8017ac16388ba0e57266d03"><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a11cff13fc8017ac16388ba0e57266d03">symbolseparator</a> ()</td></tr>
<tr class="memdesc:a11cff13fc8017ac16388ba0e57266d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method returning the symbol associated with an <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> access as defined by AX Grammar.  <a href="#a11cff13fc8017ac16388ba0e57266d03">More...</a><br /></td></tr>
<tr class="separator:a11cff13fc8017ac16388ba0e57266d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea12b19d116b2bc0bdb196759c6bb8a"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a8ea12b19d116b2bc0bdb196759c6bb8a">tokenFromNameType</a> (const std::string &amp;<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Variable.html#a324e8c54c4c5161913681a1a52fef959">name</a>, const <a class="el" href="namespaceopenvdb_1_1v9__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a> <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a7cd48780d0b85f530faf694b017e7a56">type</a>)</td></tr>
<tr class="memdesc:a8ea12b19d116b2bc0bdb196759c6bb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method returning the full unique external token identifier by consolidating its name and type such that token = tokenstr + '$' + name, where tokenstr is the AX type token as a string, converted from the provided CoreType.  <a href="#a8ea12b19d116b2bc0bdb196759c6bb8a">More...</a><br /></td></tr>
<tr class="separator:a8ea12b19d116b2bc0bdb196759c6bb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aadd362d4ed6a3c50c402cbde7fddef"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a9aadd362d4ed6a3c50c402cbde7fddef">nametypeFromToken</a> (const std::string &amp;token, std::string *<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Variable.html#a324e8c54c4c5161913681a1a52fef959">name</a>, std::string *<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a7cd48780d0b85f530faf694b017e7a56">type</a>)</td></tr>
<tr class="memdesc:a9aadd362d4ed6a3c50c402cbde7fddef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method which splits a valid external token into its name and type counterparts. If the token cannot be split, neither name or type are updated and false is returned.  <a href="#a9aadd362d4ed6a3c50c402cbde7fddef">More...</a><br /></td></tr>
<tr class="separator:a9aadd362d4ed6a3c50c402cbde7fddef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> represent any access to external (custom) data, typically associated with the '$' symbol syntax. Note that the AST does not store any additional information on the given external other than its name and type, which together form a unique external identifier known as the <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> 'token'. This token is used by the compiler to map user provided values to these external values. </p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Attribute.html" title="Attributes represent any access to a primitive value, typically associated with the &#39;@&#39; symbol syntax...">Attribute</a> AST node works in a similar way </dd>
<dd>
An <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> is a complete "leaf-level" AST node. It has no children and nothing derives from it. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="abf2fb63266a358aa04393a2bb62c9478"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#abf2fb63266a358aa04393a2bb62c9478">Ptr</a> =  std::shared_ptr&lt;<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html">Node</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8f3aca5fd43929de43c38eb5e778ff67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#a2535f66344e41d5f3601465976377213">UniquePtr</a> =  std::unique_ptr&lt;<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="acac9cbaeea226ed297804c012dc12b16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16">NodeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enumerated list of node types for all concrete node types. These can be used for faster evaluation of a given concrete node using the virtual function table via <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#ab703c8a88dcde2076cb089c07af0cc5c" title="Virtual method for accessing node type information. ">Node::nodetype()</a> rather than performing a dynamic_cast/calling <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#aa6af20b4807e0ff1021f08015a0c8779" title="Query whether or not this node is of a specific (derived) type. This method should be used to check i...">Node::isType</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This is sometimes referred to as "manual RTTI". We use this technique combine with single dispatch due to opting for CRTP on the main visitor and no templated virtual method support in C++. i.e. no way to double dispatch: visit&lt;template T&gt;(Visitor&lt;T&gt;*) </dd>
<dd>
Abstract (pure-virtual) nodes are not listed here. <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#aa6af20b4807e0ff1021f08015a0c8779" title="Query whether or not this node is of a specific (derived) type. This method should be used to check i...">Node::isType</a> should be used to determine if a node is of a given abstract type. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a6e3c9853eac7f791316173112a4c920d"></a>TreeNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a48e5c1876288bf22cd46f986e38adf02"></a>StatementListNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a43780fadfdb2235144acada7dbe105c7"></a>BlockNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a4aab5c0f2459150efa56479af2eb819f"></a>ConditionalStatementNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a9c67b92cc82860adc32a7bf2c3bdc31a"></a>CommaOperatorNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a211255852991e0aa4bc65fc0efb5308d"></a>LoopNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16abdc96277641e4564f49f05fd3332a3d4"></a>KeywordNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16aeda94965a49b65abcb13ab789c6f0ed4"></a>AssignExpressionNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16ae9a53f544375844ca76604ae5f2ca791"></a>CrementNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a5eb95c2e659ce03204e6c0b0b0c87740"></a>UnaryOperatorNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a1c1bb5e6682d57a60288fb496aeff4cf"></a>BinaryOperatorNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a050af244605ad1322fc8e7b5a0179f1b"></a>TernaryOperatorNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16af9a5d82c6573803b099c3adfc4b9b20c"></a>CastNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a7b3e1e1d3d5d99fc9af0ba930f3db50d"></a>AttributeNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a5eb065001855bf5fee13c8f1c40348ed"></a>FunctionCallNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a9501cd3ee5528bcca1e51ac8f0966994"></a>ExternalVariableNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16ac8a7cf9d5914e72e1b0d1d6b1209ab24"></a>DeclareLocalNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a641de2f20e7205326940bae22fed24d3"></a>ArrayPackNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16aa4c2677554db379f707701e1e033b766"></a>ArrayUnpackNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a58e08f3e77b3e58192caac0a9a4c3465"></a>LocalNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16ad367abc3c089565a6428ca827885f831"></a>ValueBoolNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a86ec9f75634eb04e475dba4ee93933fb"></a>ValueInt16Node&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16a764ee55f09a4bb6aac2eac083df73323"></a>ValueInt32Node&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16aee71e3911c1b181f2d37f99668f44fc5"></a>ValueInt64Node&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16ada29dd0c7c5827571517da57d290f7ca"></a>ValueFloatNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16ad42b26e9f262c9059e38424d71a38d60"></a>ValueDoubleNode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acac9cbaeea226ed297804c012dc12b16aa76996244034142252ec475e159c26bb"></a>ValueStrNode&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1091c5df90c10095784d3240830ce913"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v9__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> with a given name and type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the attribute </td></tr>
    <tr><td class="paramname">type</td><td>The type of the attribute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21930ab57f91197c92134aa471ef77b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> with a given name and type/token string, delegating construction to the above <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the attribute </td></tr>
    <tr><td class="paramname">token</td><td>The type/token string of the attribute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d10a5985b1856aed093112572d0eb64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy constructor for a <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a>. </p>
<dl class="section note"><dt>Note</dt><dd>No parent information needs updating as an <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> is a "leaf level" node (contains no children) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A const reference to another <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> to deep copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef466e788ac52c7fa240c1666ec18b1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a08aac72b4bc51801b3396bafce19d891"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Variable.html">Variable</a>* basetype </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method for accessing a node's base class. Note that if this is called explicitly on an instance of <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">ast::Node</a> (the top most base class) a nullptr is returned. This is primarily used by the <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Visitor.html" title="The Visitor class uses the Curiously Recursive Template Pattern (CRTP) to provide a customizable inte...">Visitor</a> to support hierarchical visits. </p>

<p>Reimplemented from <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Variable.html#a7c30ced97a59ed9fbb7f2c9618c5c391">Variable</a>.</p>

</div>
</div>
<a class="anchor" id="a8fab488b1b21a535d6f073c6e6fab380"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html">Node</a>* child </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method for accessing child information. Returns a const pointer to a child node at the given index. If the index is out of range, a nullptr is returned. </p>
<dl class="section note"><dt>Note</dt><dd>This may still return a nullptr even if the given index is valid if the child node has not been created. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The child index to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Pointer to the child node, or a nullptr if none exists. </dd></dl>

<p>Implements <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#a0d765d86fff42c22c923404f97bf73ce">Node</a>.</p>

</div>
</div>
<a class="anchor" id="af0d2a30087bbaa79fe8bc74365403f94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t childidx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the child index of this node in relation to its parent, or -1 if no valid index is found (usually representing the top most node (i.e. <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy. It represents an entire conversion of a valid AX string. ">Tree</a>) </p>
<dl class="section return"><dt>Returns</dt><dd>The child index of this node </dd></dl>

</div>
</div>
<a class="anchor" id="accdd2cebf8709beb3d2dd373c890f669"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method for accessing child information. Returns the number of children a given AST node owns. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of children this node owns. </dd></dl>

<p>Implements <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#a8f803446a7900ab75871a6a93a481342">Node</a>.</p>

</div>
</div>
<a class="anchor" id="af331e15b6e30adeb382c2094871fdfe0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a>* copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The deep copy method for a <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">Node</a>. </p>

<p>Implements <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Variable.html#a66a701075f40d0f9adc23de5661f201f">Variable</a>.</p>

</div>
</div>
<a class="anchor" id="aa6af20b4807e0ff1021f08015a0c8779"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query whether or not this node is of a specific (derived) type. This method should be used to check if a node is of a particular abstract type. When checking concrete types, it's generally more efficient to check the return value of <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#ab703c8a88dcde2076cb089c07af0cc5c" title="Virtual method for accessing node type information. ">Node::nodetype()</a> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NodeT</td><td>The node type to query against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this node is of the given type, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a324e8c54c4c5161913681a1a52fef959"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9aadd362d4ed6a3c50c402cbde7fddef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool nametypeFromToken </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method which splits a valid external token into its name and type counterparts. If the token cannot be split, neither name or type are updated and false is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The token to split. </td></tr>
    <tr><td class="paramname">name</td><td>Set to the second part of the external token, representing the name. If a nullptr, it is ignored </td></tr>
    <tr><td class="paramname">type</td><td>Set to the first part of the external token, representing the type. If a nullptr, it is ignored. Note that this can be empty if the external token has an inferred type or a single character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the provided external token could be split </dd></dl>

</div>
</div>
<a class="anchor" id="a9117048dc8873df412c574a6b57bba49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* nodename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method for accessing node name information. </p>

<p>Implements <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#a127baabd01e0a915720e599c55bfeed4">Node</a>.</p>

</div>
</div>
<a class="anchor" id="a0e93792b1c66561e4c0b1d1950bb31e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#acac9cbaeea226ed297804c012dc12b16">NodeType</a> nodetype </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method for accessing node type information. </p>

<p>Implements <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#ab703c8a88dcde2076cb089c07af0cc5c">Node</a>.</p>

</div>
</div>
<a class="anchor" id="a380fac0257f0b37533f630d763250bb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html">Node</a>* parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access a const pointer to this nodes parent. </p>
<dl class="section note"><dt>Note</dt><dd>Can be a nullptr if this is the top most node in an AST (usually a <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy. It represents an entire conversion of a valid AX string. ">Tree</a>) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to this node's parent node </dd></dl>

</div>
</div>
<a class="anchor" id="a0919d7b8b04ebb9fadd7eb3c99db5929"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In place replacement. Attempts to replace this node at its specific location within its Abstract Syntax <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy. It represents an entire conversion of a valid AX string. ">Tree</a>. On a successful replacement, this node is destroyed, the provided node is inserted in its place and ownership is transferred to the parent node. No further calls to this node can be made on successful replacements. </p>
<dl class="section note"><dt>Note</dt><dd>A replacement will fail if this node is the top most node within an AST hierarchy or if the provided node type is not a compatible type for the required abstract storage. For example, if this node is an <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Attribute.html" title="Attributes represent any access to a primitive value, typically associated with the &#39;@&#39; symbol syntax...">Attribute</a> being held on a <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1BinaryOperator.html" title="A BinaryOperator represents a single binary operation between a left hand side (LHS) and right hand s...">BinaryOperator</a>, only concrete nodes derived from an <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Expression.html" title="Expressions are comprised of full or potentially partial parts of a full statement that may not neces...">Expression</a> can be used as a replacement. </dd>
<dd>
This method will dynamic_cast the provided node to check to see if it's a compatible type. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to insert on a successful replacement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the replacement was successful, resulting in destruction of this class and ownership transferal of the provided node. False otherwise, where this and the provided node are unchanged. </dd></dl>

</div>
</div>
<a class="anchor" id="a39adc7dd66d859ef6f4ad0f7d1455692"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool replacechild </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method that attempted to replace a child at a given index with a provided node type. </p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#a0919d7b8b04ebb9fadd7eb3c99db5929" title="In place replacement. Attempts to replace this node at its specific location within its Abstract Synt...">Node::replace</a> for a more detailed description </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The child index where a replacement should be attempted </td></tr>
    <tr><td class="paramname">node</td><td>The node to insert on a successful replacement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the replacement was successful, false otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1DeclareLocal.html#a87ac5af79c8c0df3592f36a6caaad473">DeclareLocal</a>, <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ArrayPack.html#a87ac5af79c8c0df3592f36a6caaad473">ArrayPack</a>, <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ArrayUnpack.html#a87ac5af79c8c0df3592f36a6caaad473">ArrayUnpack</a>, <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1FunctionCall.html#a87ac5af79c8c0df3592f36a6caaad473">FunctionCall</a>, <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Cast.html#a87ac5af79c8c0df3592f36a6caaad473">Cast</a>, <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1UnaryOperator.html#a87ac5af79c8c0df3592f36a6caaad473">UnaryOperator</a>, <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Crement.html#a87ac5af79c8c0df3592f36a6caaad473">Crement</a>, <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1AssignExpression.html#a87ac5af79c8c0df3592f36a6caaad473">AssignExpression</a>, <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1TernaryOperator.html#a87ac5af79c8c0df3592f36a6caaad473">TernaryOperator</a>, <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1BinaryOperator.html#a87ac5af79c8c0df3592f36a6caaad473">BinaryOperator</a>, <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ConditionalStatement.html#a87ac5af79c8c0df3592f36a6caaad473">ConditionalStatement</a>, <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Loop.html#a87ac5af79c8c0df3592f36a6caaad473">Loop</a>, <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1CommaOperator.html#a87ac5af79c8c0df3592f36a6caaad473">CommaOperator</a>, <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Block.html#a87ac5af79c8c0df3592f36a6caaad473">Block</a>, and <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1StatementList.html#a87ac5af79c8c0df3592f36a6caaad473">StatementList</a>.</p>

</div>
</div>
<a class="anchor" id="ade468b936d43438b4fd722bea1243b5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this node's parent. This is used during construction of an AST and should not be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ad5e5c0b5f1bd6dae05e6322b0e0e5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* subname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method for accessing node name information. </p>

<p>Implements <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1Node.html#a469c4e207fc3d67ed30b2426a56d3890">Node</a>.</p>

</div>
</div>
<a class="anchor" id="a11cff13fc8017ac16388ba0e57266d03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char symbolseparator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method returning the symbol associated with an <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> access as defined by AX Grammar. </p>
<dl class="section return"><dt>Returns</dt><dd>The '$' character as a char </dd></dl>

</div>
</div>
<a class="anchor" id="a8ea12b19d116b2bc0bdb196759c6bb8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tokenFromNameType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v9__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method returning the full unique external token identifier by consolidating its name and type such that token = tokenstr + '$' + name, where tokenstr is the AX type token as a string, converted from the provided CoreType. </p>
<dl class="section note"><dt>Note</dt><dd>This identifier is unique for accesses to the same external </dd>
<dd>
Due to inferred and single character accesses in AX, this return value does not necessarily represent the original syntax used to access this external. For example, v$data will be stored and returned as vec3f$data. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the external </td></tr>
    <tr><td class="paramname">type</td><td>The CoreType of the external </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representing the external token. </dd></dl>

</div>
</div>
<a class="anchor" id="a62cadff59b68ea4a61534cdf5f17423b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string tokenname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and return the full external token identifier. See <a class="el" href="structopenvdb_1_1v9__0_1_1ax_1_1ast_1_1ExternalVariable.html#a8ea12b19d116b2bc0bdb196759c6bb8a" title="Static method returning the full unique external token identifier by consolidating its name and type ...">ExternalVariable::tokenFromNameType</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A string representing the external variable token. </dd></dl>

</div>
</div>
<a class="anchor" id="a7cd48780d0b85f530faf694b017e7a56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v9__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a> type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the type that was used to access this external variable. </p>
<dl class="section return"><dt>Returns</dt><dd>The type used to access this external as a <a class="el" href="namespaceopenvdb_1_1v9__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afdbc5929cea669e7fc6778b525a01cd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string typestr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the access type as a front end AX type/token string. </p>
<dl class="section note"><dt>Note</dt><dd>This returns the associated token to the type, not necessarily equal to the OpenVDB type string </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A string representing the type/token </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
