<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: RootNode&lt; ChildType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html','','classopenvdb_1_1v13__0_1_1tree_1_1RootNode-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">RootNode&lt; ChildType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="RootNode_8h_source.html">openvdb/tree/RootNode.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:SameConfiguration" id="r_SameConfiguration"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1RootNode_1_1SameConfiguration.html">SameConfiguration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1RootNode_1_1SameConfiguration.html#a11ddd051208250c32dc4985abcafa86d">SameConfiguration&lt;OtherNodeType&gt;::value</a> is <code>true</code> if and only if OtherNodeType is the type of a <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> whose <a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> has the same configuration as this node's <a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a>.  <a href="structopenvdb_1_1v13__0_1_1tree_1_1RootNode_1_1SameConfiguration.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueConverter" id="r_ValueConverter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1RootNode_1_1ValueConverter.html">ValueConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1RootNode_1_1ValueConverter.html#a2662538b02a333f5673a6d34c42e466b">ValueConverter&lt;T&gt;::Type</a> is the type of a <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> having the same child hierarchy as this node but a different value type, T.  <a href="structopenvdb_1_1v13__0_1_1tree_1_1RootNode_1_1ValueConverter.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:add0b43407ef7279a458b5b63c604ae73" id="r_add0b43407ef7279a458b5b63c604ae73"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> = ChildType</td></tr>
<tr class="memitem:a47b1764141687712562480c3cdd74c1b" id="r_a47b1764141687712562480c3cdd74c1b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> = typename ChildType::LeafNodeType</td></tr>
<tr class="memitem:a89ab9062c358edc408d37deac2eb8538" id="r_a89ab9062c358edc408d37deac2eb8538"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> = typename ChildType::ValueType</td></tr>
<tr class="memitem:ab723abdcfd580fb1fc5eebf5da5d9660" id="r_ab723abdcfd580fb1fc5eebf5da5d9660"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab723abdcfd580fb1fc5eebf5da5d9660">BuildType</a> = typename ChildType::BuildType</td></tr>
<tr class="memitem:a476192215f8d4ee389caf42204e3020f" id="r_a476192215f8d4ee389caf42204e3020f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a476192215f8d4ee389caf42204e3020f">NodeChainType</a> = typename <a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1NodeChain.html">NodeChain</a>&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, <a class="el" href="#a7efd456219bae7db497d009ad92961a7">LEVEL</a>&gt;::Type</td></tr>
<tr class="memdesc:a476192215f8d4ee389caf42204e3020f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a476192215f8d4ee389caf42204e3020f" title="NodeChainType is a list of this tree&#39;s node types, from LeafNodeType to RootNode.">NodeChainType</a> is a list of this tree's node types, from <a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> to <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>.  <br /></td></tr>
<tr class="memitem:a53ddfd147d086003e983f40409d651ff" id="r_a53ddfd147d086003e983f40409d651ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53ddfd147d086003e983f40409d651ff">ChildOnIter</a> = ChildIter&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ChildOnPred, ChildType&gt;</td></tr>
<tr class="memitem:af961e6cbba1568e6b4e3edac87952dbd" id="r_af961e6cbba1568e6b4e3edac87952dbd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af961e6cbba1568e6b4e3edac87952dbd">ChildOnCIter</a> = ChildIter&lt;const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ChildOnPred, const ChildType&gt;</td></tr>
<tr class="memitem:ad70584e8033dbc079fdc0ac57d167eee" id="r_ad70584e8033dbc079fdc0ac57d167eee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad70584e8033dbc079fdc0ac57d167eee">ChildOffIter</a> = ValueIter&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ChildOffPred, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td></tr>
<tr class="memitem:a629fb04c86fa214750225c9f1d146a36" id="r_a629fb04c86fa214750225c9f1d146a36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a629fb04c86fa214750225c9f1d146a36">ChildOffCIter</a> = ValueIter&lt;const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ChildOffPred, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td></tr>
<tr class="memitem:a01bb1bcecd7385c19f214c7dd217fb27" id="r_a01bb1bcecd7385c19f214c7dd217fb27"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01bb1bcecd7385c19f214c7dd217fb27">ChildAllIter</a> = DenseIter&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ChildType, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td></tr>
<tr class="memitem:aba3a2d9f84085e3e6b54f4358df5eb28" id="r_aba3a2d9f84085e3e6b54f4358df5eb28"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba3a2d9f84085e3e6b54f4358df5eb28">ChildAllCIter</a> = DenseIter&lt;const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, const ChildType, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td></tr>
<tr class="memitem:a4eb611c9fc0de11faa69c866d88f680a" id="r_a4eb611c9fc0de11faa69c866d88f680a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eb611c9fc0de11faa69c866d88f680a">ValueOnIter</a> = ValueIter&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ValueOnPred, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td></tr>
<tr class="memitem:a15fddbb02f413af01b4b839e82f5e49f" id="r_a15fddbb02f413af01b4b839e82f5e49f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15fddbb02f413af01b4b839e82f5e49f">ValueOnCIter</a> = ValueIter&lt;const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ValueOnPred, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td></tr>
<tr class="memitem:a3cc6b3daa5baf71df51fb8426470d8c7" id="r_a3cc6b3daa5baf71df51fb8426470d8c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cc6b3daa5baf71df51fb8426470d8c7">ValueOffIter</a> = ValueIter&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ValueOffPred, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td></tr>
<tr class="memitem:a04bce38e91a758eb215875e9ad0c0add" id="r_a04bce38e91a758eb215875e9ad0c0add"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04bce38e91a758eb215875e9ad0c0add">ValueOffCIter</a> = ValueIter&lt;const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ValueOffPred, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td></tr>
<tr class="memitem:a3e96b29bec06304babad73d51b201945" id="r_a3e96b29bec06304babad73d51b201945"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e96b29bec06304babad73d51b201945">ValueAllIter</a> = ValueIter&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ValueAllPred, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td></tr>
<tr class="memitem:a755eaad7b1dba0812844255cee5c48bf" id="r_a755eaad7b1dba0812844255cee5c48bf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a755eaad7b1dba0812844255cee5c48bf">ValueAllCIter</a> = ValueIter&lt;const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ValueAllPred, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa5dbd319ba70f5491e4326ec341273d8" id="r_aa5dbd319ba70f5491e4326ec341273d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5dbd319ba70f5491e4326ec341273d8">RootNode</a> ()</td></tr>
<tr class="memdesc:aa5dbd319ba70f5491e4326ec341273d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new tree with a background value of 0.  <br /></td></tr>
<tr class="memitem:a962d5c3401f8c0a8f60d71b141e7fb3b" id="r_a962d5c3401f8c0a8f60d71b141e7fb3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a962d5c3401f8c0a8f60d71b141e7fb3b">RootNode</a> (const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;<a class="el" href="#acf204e0a650b353285fc5dc156a70dfd">background</a>)</td></tr>
<tr class="memdesc:a962d5c3401f8c0a8f60d71b141e7fb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new tree with the given background value.  <br /></td></tr>
<tr class="memitem:a08562b54850ff29ef167b7a1d1cfadd4" id="r_a08562b54850ff29ef167b7a1d1cfadd4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08562b54850ff29ef167b7a1d1cfadd4">RootNode</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> &amp;other)</td></tr>
<tr class="memitem:ad4048d463e26625beb9e08adbd50528e" id="r_ad4048d463e26625beb9e08adbd50528e"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType&gt; </td></tr>
<tr class="memitem:ad4048d463e26625beb9e08adbd50528e template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4048d463e26625beb9e08adbd50528e">RootNode</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other)</td></tr>
<tr class="memdesc:ad4048d463e26625beb9e08adbd50528e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new tree that reproduces the topology and active states of a tree of a different <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> but the same configuration (levels, node dimensions and branching factors). Cast the other tree's values to this tree's <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>.  <br /></td></tr>
<tr class="memitem:ab6e523d80a6b90c3b63ef1c40939c7d5" id="r_ab6e523d80a6b90c3b63ef1c40939c7d5"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType&gt; </td></tr>
<tr class="memitem:ab6e523d80a6b90c3b63ef1c40939c7d5 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6e523d80a6b90c3b63ef1c40939c7d5">RootNode</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;<a class="el" href="#acf204e0a650b353285fc5dc156a70dfd">background</a>, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;foreground, <a class="el" href="classopenvdb_1_1v13__0_1_1TopologyCopy.html">TopologyCopy</a>)</td></tr>
<tr class="memdesc:ab6e523d80a6b90c3b63ef1c40939c7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new tree that reproduces the topology and active states of another tree (which may have a different <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>), but not the other tree's values.  <br /></td></tr>
<tr class="memitem:a1376f67d16d5de9a4d152a45f863f0cf" id="r_a1376f67d16d5de9a4d152a45f863f0cf"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType&gt; </td></tr>
<tr class="memitem:a1376f67d16d5de9a4d152a45f863f0cf template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1376f67d16d5de9a4d152a45f863f0cf">RootNode</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;<a class="el" href="#acf204e0a650b353285fc5dc156a70dfd">background</a>, <a class="el" href="classopenvdb_1_1v13__0_1_1TopologyCopy.html">TopologyCopy</a>)</td></tr>
<tr class="memdesc:a1376f67d16d5de9a4d152a45f863f0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new tree that reproduces the topology and active states of another tree (which may have a different <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>), but not the other tree's values. All tiles and voxels in the new tree are set to <em class="arg">background</em> regardless of their active states in the other tree.  <br /></td></tr>
<tr class="memitem:a1b775efb979e2d7445d43aaf7cb900d0" id="r_a1b775efb979e2d7445d43aaf7cb900d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b775efb979e2d7445d43aaf7cb900d0">operator=</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> &amp;other)</td></tr>
<tr class="memdesc:a1b775efb979e2d7445d43aaf7cb900d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a root node of the same type as this node.  <br /></td></tr>
<tr class="memitem:a2808786e8db5081ca0b37f894fd1a446" id="r_a2808786e8db5081ca0b37f894fd1a446"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType&gt; </td></tr>
<tr class="memitem:a2808786e8db5081ca0b37f894fd1a446 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2808786e8db5081ca0b37f894fd1a446">operator=</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other)</td></tr>
<tr class="memdesc:a2808786e8db5081ca0b37f894fd1a446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a root node of the same tree configuration as this node but a different <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>.  <br /></td></tr>
<tr class="memitem:aaf38ff0107dcb0e50c0f4e5783146459" id="r_aaf38ff0107dcb0e50c0f4e5783146459"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf38ff0107dcb0e50c0f4e5783146459">~RootNode</a> ()</td></tr>
<tr class="memitem:a088045df8b72d08f243c05645441e7c9" id="r_a088045df8b72d08f243c05645441e7c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af961e6cbba1568e6b4e3edac87952dbd">ChildOnCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a088045df8b72d08f243c05645441e7c9">cbeginChildOn</a> () const</td></tr>
<tr class="memitem:a83f5ee6913372d15b560cfcc9d6bc025" id="r_a83f5ee6913372d15b560cfcc9d6bc025"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a629fb04c86fa214750225c9f1d146a36">ChildOffCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83f5ee6913372d15b560cfcc9d6bc025">cbeginChildOff</a> () const</td></tr>
<tr class="memitem:a6e215faf611a093dee0cc94fae637f5d" id="r_a6e215faf611a093dee0cc94fae637f5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aba3a2d9f84085e3e6b54f4358df5eb28">ChildAllCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e215faf611a093dee0cc94fae637f5d">cbeginChildAll</a> () const</td></tr>
<tr class="memitem:a0e0526f36e787eece5d83798c23bb4e9" id="r_a0e0526f36e787eece5d83798c23bb4e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af961e6cbba1568e6b4e3edac87952dbd">ChildOnCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e0526f36e787eece5d83798c23bb4e9">beginChildOn</a> () const</td></tr>
<tr class="memitem:a8747e818fa77600e87e5dd868c2eaa31" id="r_a8747e818fa77600e87e5dd868c2eaa31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a629fb04c86fa214750225c9f1d146a36">ChildOffCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8747e818fa77600e87e5dd868c2eaa31">beginChildOff</a> () const</td></tr>
<tr class="memitem:abde2b021fb4a5d0524b4c782ce48af13" id="r_abde2b021fb4a5d0524b4c782ce48af13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aba3a2d9f84085e3e6b54f4358df5eb28">ChildAllCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abde2b021fb4a5d0524b4c782ce48af13">beginChildAll</a> () const</td></tr>
<tr class="memitem:a0f712beff77da092dd726a59e1104cf0" id="r_a0f712beff77da092dd726a59e1104cf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a53ddfd147d086003e983f40409d651ff">ChildOnIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f712beff77da092dd726a59e1104cf0">beginChildOn</a> ()</td></tr>
<tr class="memitem:a845985fcf5013cc3fe15865b05b3abd5" id="r_a845985fcf5013cc3fe15865b05b3abd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad70584e8033dbc079fdc0ac57d167eee">ChildOffIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a845985fcf5013cc3fe15865b05b3abd5">beginChildOff</a> ()</td></tr>
<tr class="memitem:a7000148c6f1dc8bfbb0139a3606e188e" id="r_a7000148c6f1dc8bfbb0139a3606e188e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a01bb1bcecd7385c19f214c7dd217fb27">ChildAllIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7000148c6f1dc8bfbb0139a3606e188e">beginChildAll</a> ()</td></tr>
<tr class="memitem:a9141b760807bdde0cad1e9bee1cc137a" id="r_a9141b760807bdde0cad1e9bee1cc137a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a15fddbb02f413af01b4b839e82f5e49f">ValueOnCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9141b760807bdde0cad1e9bee1cc137a">cbeginValueOn</a> () const</td></tr>
<tr class="memitem:a1de8db6621c42bbe606d4b6739e4462f" id="r_a1de8db6621c42bbe606d4b6739e4462f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a04bce38e91a758eb215875e9ad0c0add">ValueOffCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1de8db6621c42bbe606d4b6739e4462f">cbeginValueOff</a> () const</td></tr>
<tr class="memitem:a45ab5e975ed9515b08cb3ce3cb5dc722" id="r_a45ab5e975ed9515b08cb3ce3cb5dc722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a755eaad7b1dba0812844255cee5c48bf">ValueAllCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45ab5e975ed9515b08cb3ce3cb5dc722">cbeginValueAll</a> () const</td></tr>
<tr class="memitem:a4ecac88b99d3c8064036ec4747260dfa" id="r_a4ecac88b99d3c8064036ec4747260dfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a15fddbb02f413af01b4b839e82f5e49f">ValueOnCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ecac88b99d3c8064036ec4747260dfa">beginValueOn</a> () const</td></tr>
<tr class="memitem:a6b2ad19bf53695a6a7c3ab316a67b40c" id="r_a6b2ad19bf53695a6a7c3ab316a67b40c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a04bce38e91a758eb215875e9ad0c0add">ValueOffCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b2ad19bf53695a6a7c3ab316a67b40c">beginValueOff</a> () const</td></tr>
<tr class="memitem:af3638d1f86ab66eb1087910b4172a81e" id="r_af3638d1f86ab66eb1087910b4172a81e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a755eaad7b1dba0812844255cee5c48bf">ValueAllCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3638d1f86ab66eb1087910b4172a81e">beginValueAll</a> () const</td></tr>
<tr class="memitem:a7b8568cb11eacfedf042fa1eda680a45" id="r_a7b8568cb11eacfedf042fa1eda680a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4eb611c9fc0de11faa69c866d88f680a">ValueOnIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b8568cb11eacfedf042fa1eda680a45">beginValueOn</a> ()</td></tr>
<tr class="memitem:ad555f92c70739496805fb480c3b38f85" id="r_ad555f92c70739496805fb480c3b38f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3cc6b3daa5baf71df51fb8426470d8c7">ValueOffIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad555f92c70739496805fb480c3b38f85">beginValueOff</a> ()</td></tr>
<tr class="memitem:afdf6fa279da1f6839a3ca381828220df" id="r_afdf6fa279da1f6839a3ca381828220df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3e96b29bec06304babad73d51b201945">ValueAllIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdf6fa279da1f6839a3ca381828220df">beginValueAll</a> ()</td></tr>
<tr class="memitem:ae7d5580aa0181f1610d1014563a41581" id="r_ae7d5580aa0181f1610d1014563a41581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7d5580aa0181f1610d1014563a41581">memUsage</a> () const</td></tr>
<tr class="memdesc:ae7d5580aa0181f1610d1014563a41581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total amount of memory in bytes occupied by this node and its children.  <br /></td></tr>
<tr class="memitem:ace68379b5a11804713fc050baba5159d" id="r_ace68379b5a11804713fc050baba5159d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace68379b5a11804713fc050baba5159d">evalActiveBoundingBox</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox, bool visitVoxels=true) const</td></tr>
<tr class="memdesc:ace68379b5a11804713fc050baba5159d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the specified bbox so it includes the active tiles of this root node as well as all the active values in its child nodes. If visitVoxels is false LeafNodes will be approximated as dense, i.e. with all voxels active. Else the individual active voxels are visited to produce a tight bbox.  <br /></td></tr>
<tr class="memitem:a1f5f8d33bc3f381b0cd796f16aee8d6b" id="r_a1f5f8d33bc3f381b0cd796f16aee8d6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f5f8d33bc3f381b0cd796f16aee8d6b">transientData</a> () const</td></tr>
<tr class="memdesc:a1f5f8d33bc3f381b0cd796f16aee8d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the transient data value.  <br /></td></tr>
<tr class="memitem:ac330ca3d33322b20db4aa7afe20b5a6d" id="r_ac330ca3d33322b20db4aa7afe20b5a6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac330ca3d33322b20db4aa7afe20b5a6d">setTransientData</a> (<a class="el" href="namespaceopenvdb_1_1v13__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> <a class="el" href="#a1f5f8d33bc3f381b0cd796f16aee8d6b">transientData</a>)</td></tr>
<tr class="memdesc:ac330ca3d33322b20db4aa7afe20b5a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the transient data value.  <br /></td></tr>
<tr class="memitem:ab9a9be183fae028c2479dd20163a52ee" id="r_ab9a9be183fae028c2479dd20163a52ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9a9be183fae028c2479dd20163a52ee">setBackground</a> (const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool updateChildNodes)</td></tr>
<tr class="memdesc:ab9a9be183fae028c2479dd20163a52ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change inactive tiles or voxels with a value equal to +/- the old background to the specified value (with the same sign). Active values are unchanged.  <br /></td></tr>
<tr class="memitem:acf204e0a650b353285fc5dc156a70dfd" id="r_acf204e0a650b353285fc5dc156a70dfd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf204e0a650b353285fc5dc156a70dfd">background</a> () const</td></tr>
<tr class="memdesc:acf204e0a650b353285fc5dc156a70dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this node's background value.  <br /></td></tr>
<tr class="memitem:a47ac2e923401b385063e3601fef9aaf5" id="r_a47ac2e923401b385063e3601fef9aaf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47ac2e923401b385063e3601fef9aaf5">isBackgroundTile</a> (const Tile &amp;) const</td></tr>
<tr class="memdesc:a47ac2e923401b385063e3601fef9aaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given tile is inactive and has the background value.  <br /></td></tr>
<tr class="memitem:aaee09a2f4089dc3e7d3e16d19768779c" id="r_aaee09a2f4089dc3e7d3e16d19768779c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaee09a2f4089dc3e7d3e16d19768779c">isBackgroundTile</a> (const MapIter &amp;) const</td></tr>
<tr class="memdesc:aaee09a2f4089dc3e7d3e16d19768779c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given iterator points to an inactive tile with the background value.  <br /></td></tr>
<tr class="memitem:a228a4f7a4f366863d37147c5fac8e0f9" id="r_a228a4f7a4f366863d37147c5fac8e0f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a228a4f7a4f366863d37147c5fac8e0f9">isBackgroundTile</a> (const MapCIter &amp;) const</td></tr>
<tr class="memitem:a62310fe5cddf3963e67ffd3f551dfe76" id="r_a62310fe5cddf3963e67ffd3f551dfe76"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62310fe5cddf3963e67ffd3f551dfe76">numBackgroundTiles</a> () const</td></tr>
<tr class="memdesc:a62310fe5cddf3963e67ffd3f551dfe76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of background tiles.  <br /></td></tr>
<tr class="memitem:a48dc4a8d53d718280d347a867cd6704b" id="r_a48dc4a8d53d718280d347a867cd6704b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48dc4a8d53d718280d347a867cd6704b">eraseBackgroundTiles</a> ()</td></tr>
<tr class="memdesc:a48dc4a8d53d718280d347a867cd6704b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all background tiles.  <br /></td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204" id="r_ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr class="memitem:a644718bb2fb240de962dc3c9a1fdf0dc" id="r_a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a644718bb2fb240de962dc3c9a1fdf0dc">empty</a> () const</td></tr>
<tr class="memdesc:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if this node's table is either empty or contains only background tiles.  <br /></td></tr>
<tr class="memitem:aed5bfeb2da24cc37e6561b3cd0f5f1f3" id="r_aed5bfeb2da24cc37e6561b3cd0f5f1f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed5bfeb2da24cc37e6561b3cd0f5f1f3">expand</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz)</td></tr>
<tr class="memdesc:aed5bfeb2da24cc37e6561b3cd0f5f1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand this node's table so that (x, y, z) is included in the index range.  <br /></td></tr>
<tr class="memitem:a552b15b6e1b6a9538f92d7d9259a4446" id="r_a552b15b6e1b6a9538f92d7d9259a4446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a552b15b6e1b6a9538f92d7d9259a4446">getTableSize</a> () const</td></tr>
<tr class="memdesc:a552b15b6e1b6a9538f92d7d9259a4446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of entries in this node's table.  <br /></td></tr>
<tr class="memitem:a54ebc384a69c3a30946b14cf4b19fb1f" id="r_a54ebc384a69c3a30946b14cf4b19fb1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54ebc384a69c3a30946b14cf4b19fb1f">getWidth</a> () const</td></tr>
<tr class="memitem:ac6c66ba3f55a2b185149aa68e629e693" id="r_ac6c66ba3f55a2b185149aa68e629e693"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6c66ba3f55a2b185149aa68e629e693">getHeight</a> () const</td></tr>
<tr class="memitem:a1102bd83dda994c134fe774fd1c914b1" id="r_a1102bd83dda994c134fe774fd1c914b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1102bd83dda994c134fe774fd1c914b1">getDepth</a> () const</td></tr>
<tr class="memitem:ad9bcb4cf379db9801dba49ba0ff5d9a0" id="r_ad9bcb4cf379db9801dba49ba0ff5d9a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9bcb4cf379db9801dba49ba0ff5d9a0">getMinIndex</a> () const</td></tr>
<tr class="memdesc:ad9bcb4cf379db9801dba49ba0ff5d9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smallest index of the current tree.  <br /></td></tr>
<tr class="memitem:a1ce8a4cb37cefb07d92a949c816c7dc9" id="r_a1ce8a4cb37cefb07d92a949c816c7dc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ce8a4cb37cefb07d92a949c816c7dc9">getMaxIndex</a> () const</td></tr>
<tr class="memdesc:a1ce8a4cb37cefb07d92a949c816c7dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the largest index of the current tree.  <br /></td></tr>
<tr class="memitem:a16f60a3586748dad01004e868bc2f525" id="r_a16f60a3586748dad01004e868bc2f525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16f60a3586748dad01004e868bc2f525">getIndexRange</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox) const</td></tr>
<tr class="memdesc:a16f60a3586748dad01004e868bc2f525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current index range. Both min and max are inclusive.  <br /></td></tr>
<tr class="memitem:abb283d5d20f2a472df7d1aee0708381c" id="r_abb283d5d20f2a472df7d1aee0708381c"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType&gt; </td></tr>
<tr class="memitem:abb283d5d20f2a472df7d1aee0708381c template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb283d5d20f2a472df7d1aee0708381c">hasSameTopology</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other) const</td></tr>
<tr class="memdesc:abb283d5d20f2a472df7d1aee0708381c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given tree has the same node and active value topology as this tree (but possibly a different <code><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a></code>).  <br /></td></tr>
<tr class="memitem:a6fb95cf16675717b8edc3178ec021c2f" id="r_a6fb95cf16675717b8edc3178ec021c2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fb95cf16675717b8edc3178ec021c2f">leafCount</a> () const</td></tr>
<tr class="memitem:a367f079ecce7c9f4cd5e9ae83f2e19cf" id="r_a367f079ecce7c9f4cd5e9ae83f2e19cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a367f079ecce7c9f4cd5e9ae83f2e19cf">nonLeafCount</a> () const</td></tr>
<tr class="memitem:a9def3b556156ce0fd3713640b2f81b95" id="r_a9def3b556156ce0fd3713640b2f81b95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9def3b556156ce0fd3713640b2f81b95">childCount</a> () const</td></tr>
<tr class="memitem:a984487a328711c403469cf21e62b0532" id="r_a984487a328711c403469cf21e62b0532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a984487a328711c403469cf21e62b0532">tileCount</a> () const</td></tr>
<tr class="memitem:a3ddbec0d00fe45a3916a4542d8a6cb90" id="r_a3ddbec0d00fe45a3916a4542d8a6cb90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ddbec0d00fe45a3916a4542d8a6cb90">activeTileCount</a> () const</td></tr>
<tr class="memitem:a81b0afbeba6288a492047f67424d0b9e" id="r_a81b0afbeba6288a492047f67424d0b9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81b0afbeba6288a492047f67424d0b9e">inactiveTileCount</a> () const</td></tr>
<tr class="memitem:a86a4db588f25113840ecc0dcee1cfe0b" id="r_a86a4db588f25113840ecc0dcee1cfe0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86a4db588f25113840ecc0dcee1cfe0b">onVoxelCount</a> () const</td></tr>
<tr class="memitem:aaf477adbc6f68604494fae8b06c6ba3c" id="r_aaf477adbc6f68604494fae8b06c6ba3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf477adbc6f68604494fae8b06c6ba3c">offVoxelCount</a> () const</td></tr>
<tr class="memitem:a401ea099593e2e1ac12badc526abdf51" id="r_a401ea099593e2e1ac12badc526abdf51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a401ea099593e2e1ac12badc526abdf51">onLeafVoxelCount</a> () const</td></tr>
<tr class="memitem:a53e093f41c97cb7dc8a22c9ea53b6ffb" id="r_a53e093f41c97cb7dc8a22c9ea53b6ffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53e093f41c97cb7dc8a22c9ea53b6ffb">offLeafVoxelCount</a> () const</td></tr>
<tr class="memitem:aa43bfe6b2bffa8ab5e0b7ad5da1afa77" id="r_aa43bfe6b2bffa8ab5e0b7ad5da1afa77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa43bfe6b2bffa8ab5e0b7ad5da1afa77">onTileCount</a> () const</td></tr>
<tr class="memitem:a90527600f0c60d8c36ea67005779c99d" id="r_a90527600f0c60d8c36ea67005779c99d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90527600f0c60d8c36ea67005779c99d">nodeCount</a> (std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;vec) const</td></tr>
<tr class="memitem:ae7a5e4f46465ad6bdf132b2967b324f2" id="r_ae7a5e4f46465ad6bdf132b2967b324f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7a5e4f46465ad6bdf132b2967b324f2">nodeCount</a> (std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> &gt; &amp;vec) const</td></tr>
<tr class="memitem:a149d3646dfe8b0ae5f352cea5c1e9cc7" id="r_a149d3646dfe8b0ae5f352cea5c1e9cc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a149d3646dfe8b0ae5f352cea5c1e9cc7">isValueOn</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memitem:ae27c5b1e634724be621234d2653c8eae" id="r_ae27c5b1e634724be621234d2653c8eae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae27c5b1e634724be621234d2653c8eae">hasActiveTiles</a> () const</td></tr>
<tr class="memdesc:ae27c5b1e634724be621234d2653c8eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if this root node, or any of its child nodes, have active tiles.  <br /></td></tr>
<tr class="memitem:ae6e67ec58b555ee2e403ffc7a92d108c" id="r_ae6e67ec58b555ee2e403ffc7a92d108c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6e67ec58b555ee2e403ffc7a92d108c">getValue</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memitem:a7ac3a88741d49d74b50c55b9a5371646" id="r_a7ac3a88741d49d74b50c55b9a5371646"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ac3a88741d49d74b50c55b9a5371646">probeValue</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value) const</td></tr>
<tr class="memitem:a03c8f00f509936998e0d47be7afd5e3f" id="r_a03c8f00f509936998e0d47be7afd5e3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03c8f00f509936998e0d47be7afd5e3f">getValueDepth</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memdesc:a03c8f00f509936998e0d47be7afd5e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tree depth (0 = root) at which the value of voxel (x, y, z) resides.  <br /></td></tr>
<tr class="memitem:a7b3e82eb582914ac6f31f32fea77292f" id="r_a7b3e82eb582914ac6f31f32fea77292f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b3e82eb582914ac6f31f32fea77292f">setActiveState</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, bool on)</td></tr>
<tr class="memdesc:a7b3e82eb582914ac6f31f32fea77292f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the active state of the voxel at the given coordinates but don't change its value.  <br /></td></tr>
<tr class="memitem:a63ff695beda11ed9ef625a28ce8a5faf" id="r_a63ff695beda11ed9ef625a28ce8a5faf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63ff695beda11ed9ef625a28ce8a5faf">setValueOnly</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a63ff695beda11ed9ef625a28ce8a5faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates but don't change its active state.  <br /></td></tr>
<tr class="memitem:ae95653046c85afb743075f139a26df9d" id="r_ae95653046c85afb743075f139a26df9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae95653046c85afb743075f139a26df9d">setValueOn</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:ae95653046c85afb743075f139a26df9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates and mark the voxel as active.  <br /></td></tr>
<tr class="memitem:a8a91d631df8f64f84a0aad7436cb11f3" id="r_a8a91d631df8f64f84a0aad7436cb11f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a91d631df8f64f84a0aad7436cb11f3">setValueOff</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz)</td></tr>
<tr class="memdesc:a8a91d631df8f64f84a0aad7436cb11f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the voxel at the given coordinates as inactive but don't change its value.  <br /></td></tr>
<tr class="memitem:a73a6e7c85d37e7d677eddc3cce8aa11b" id="r_a73a6e7c85d37e7d677eddc3cce8aa11b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73a6e7c85d37e7d677eddc3cce8aa11b">setValueOff</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a73a6e7c85d37e7d677eddc3cce8aa11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates and mark the voxel as inactive.  <br /></td></tr>
<tr class="memitem:aa6954a428c0ef18a03431f251f4e7d24" id="r_aa6954a428c0ef18a03431f251f4e7d24"><td class="memTemplParams" colspan="2">template&lt;typename ModifyOp&gt; </td></tr>
<tr class="memitem:aa6954a428c0ef18a03431f251f4e7d24 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6954a428c0ef18a03431f251f4e7d24">modifyValue</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const ModifyOp &amp;op)</td></tr>
<tr class="memdesc:aa6954a428c0ef18a03431f251f4e7d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to the value of the voxel at the given coordinates and mark the voxel as active.  <br /></td></tr>
<tr class="memitem:a5cb69af7e17c3a9a6d6dc360c878448c" id="r_a5cb69af7e17c3a9a6d6dc360c878448c"><td class="memTemplParams" colspan="2">template&lt;typename ModifyOp&gt; </td></tr>
<tr class="memitem:a5cb69af7e17c3a9a6d6dc360c878448c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cb69af7e17c3a9a6d6dc360c878448c">modifyValueAndActiveState</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const ModifyOp &amp;op)</td></tr>
<tr class="memdesc:a5cb69af7e17c3a9a6d6dc360c878448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to the voxel at the given coordinates.  <br /></td></tr>
<tr class="memitem:a69bd60c87fb75e3bb7a9b5099f3a4bdf" id="r_a69bd60c87fb75e3bb7a9b5099f3a4bdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69bd60c87fb75e3bb7a9b5099f3a4bdf">fill</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool active=true)</td></tr>
<tr class="memdesc:a69bd60c87fb75e3bb7a9b5099f3a4bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all voxels within a given axis-aligned box to a constant value.  <br /></td></tr>
<tr class="memitem:ad87de532e553a73bd6e3b55337eff1d5" id="r_ad87de532e553a73bd6e3b55337eff1d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad87de532e553a73bd6e3b55337eff1d5">sparseFill</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool active=true)</td></tr>
<tr class="memitem:abb399cd065108e53e7b65612e74372a5" id="r_abb399cd065108e53e7b65612e74372a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb399cd065108e53e7b65612e74372a5">denseFill</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool active=true)</td></tr>
<tr class="memdesc:abb399cd065108e53e7b65612e74372a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all voxels within a given axis-aligned box to a constant value and ensure that those voxels are all represented at the leaf level.  <br /></td></tr>
<tr class="memitem:a39a2211a02fb606e611d3ff5bbd6f50c" id="r_a39a2211a02fb606e611d3ff5bbd6f50c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39a2211a02fb606e611d3ff5bbd6f50c">voxelizeActiveTiles</a> (bool threaded=true)</td></tr>
<tr class="memdesc:a39a2211a02fb606e611d3ff5bbd6f50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Densify active tiles, i.e., replace them with leaf-level active voxels.  <br /></td></tr>
<tr class="memitem:a195825f611f78d1b10451ce535cffe79" id="r_a195825f611f78d1b10451ce535cffe79"><td class="memTemplParams" colspan="2">template&lt;typename DenseT&gt; </td></tr>
<tr class="memitem:a195825f611f78d1b10451ce535cffe79 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a195825f611f78d1b10451ce535cffe79">copyToDense</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox, DenseT &amp;dense) const</td></tr>
<tr class="memdesc:a195825f611f78d1b10451ce535cffe79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy into a dense grid the values of all voxels, both active and inactive, that intersect a given bounding box.  <br /></td></tr>
<tr class="memitem:a7385846a40d5a048e09f7a78c85d7983" id="r_a7385846a40d5a048e09f7a78c85d7983"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7385846a40d5a048e09f7a78c85d7983">writeTopology</a> (std::ostream &amp;, bool toHalf=false) const</td></tr>
<tr class="memitem:af5537d3d93b7137d3f03007b31077921" id="r_af5537d3d93b7137d3f03007b31077921"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5537d3d93b7137d3f03007b31077921">readTopology</a> (std::istream &amp;, bool fromHalf=false)</td></tr>
<tr class="memitem:a8fbb3742c8aa39e1036ca155035cc51f" id="r_a8fbb3742c8aa39e1036ca155035cc51f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fbb3742c8aa39e1036ca155035cc51f">writeBuffers</a> (std::ostream &amp;, bool toHalf=false) const</td></tr>
<tr class="memitem:aef270a4e4900e5e0bd24e6664d6a8a82" id="r_aef270a4e4900e5e0bd24e6664d6a8a82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef270a4e4900e5e0bd24e6664d6a8a82">readBuffers</a> (std::istream &amp;, bool fromHalf=false)</td></tr>
<tr class="memitem:a9d516efdbb242e00e7c77ae85cc426b6" id="r_a9d516efdbb242e00e7c77ae85cc426b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d516efdbb242e00e7c77ae85cc426b6">readBuffers</a> (std::istream &amp;, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;, bool fromHalf=false)</td></tr>
<tr class="memitem:a6e0e2349b41f63f8fcbf8340d47b666b" id="r_a6e0e2349b41f63f8fcbf8340d47b666b"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:a6e0e2349b41f63f8fcbf8340d47b666b template"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e0e2349b41f63f8fcbf8340d47b666b">getValueAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessorT &amp;) const</td></tr>
<tr class="memitem:a764d9f6528248f70fb667e91d35d7aab" id="r_a764d9f6528248f70fb667e91d35d7aab"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:a764d9f6528248f70fb667e91d35d7aab template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a764d9f6528248f70fb667e91d35d7aab">isValueOnAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessorT &amp;) const</td></tr>
<tr class="memitem:a01b75fc2aa129aa05ae677971dc1972e" id="r_a01b75fc2aa129aa05ae677971dc1972e"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:a01b75fc2aa129aa05ae677971dc1972e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01b75fc2aa129aa05ae677971dc1972e">setValueAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, AccessorT &amp;)</td></tr>
<tr class="memitem:a5cefbe46cc3180e5394a2f4fc775bfe8" id="r_a5cefbe46cc3180e5394a2f4fc775bfe8"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:a5cefbe46cc3180e5394a2f4fc775bfe8 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cefbe46cc3180e5394a2f4fc775bfe8">setValueOnlyAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, AccessorT &amp;)</td></tr>
<tr class="memitem:a7bed5c7c0d76cacfb514d9744f754402" id="r_a7bed5c7c0d76cacfb514d9744f754402"><td class="memTemplParams" colspan="2">template&lt;typename ModifyOp, typename AccessorT&gt; </td></tr>
<tr class="memitem:a7bed5c7c0d76cacfb514d9744f754402 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bed5c7c0d76cacfb514d9744f754402">modifyValueAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const ModifyOp &amp;op, AccessorT &amp;)</td></tr>
<tr class="memitem:af057648803b9073ce1703dbf061e0d1f" id="r_af057648803b9073ce1703dbf061e0d1f"><td class="memTemplParams" colspan="2">template&lt;typename ModifyOp, typename AccessorT&gt; </td></tr>
<tr class="memitem:af057648803b9073ce1703dbf061e0d1f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af057648803b9073ce1703dbf061e0d1f">modifyValueAndActiveStateAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const ModifyOp &amp;op, AccessorT &amp;)</td></tr>
<tr class="memitem:a6c0c65991a0b3c81933cd944d8fc4267" id="r_a6c0c65991a0b3c81933cd944d8fc4267"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:a6c0c65991a0b3c81933cd944d8fc4267 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c0c65991a0b3c81933cd944d8fc4267">setValueOffAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, AccessorT &amp;)</td></tr>
<tr class="memitem:ac04db06362bfb5ec0ed6212469eb4ff3" id="r_ac04db06362bfb5ec0ed6212469eb4ff3"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:ac04db06362bfb5ec0ed6212469eb4ff3 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac04db06362bfb5ec0ed6212469eb4ff3">setActiveStateAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, bool on, AccessorT &amp;)</td></tr>
<tr class="memitem:aca08a701c485990b261ff6be818688d2" id="r_aca08a701c485990b261ff6be818688d2"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:aca08a701c485990b261ff6be818688d2 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca08a701c485990b261ff6be818688d2">probeValueAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, AccessorT &amp;) const</td></tr>
<tr class="memitem:ae4024b60b62c7d365c6689c64edaaf5b" id="r_ae4024b60b62c7d365c6689c64edaaf5b"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:ae4024b60b62c7d365c6689c64edaaf5b template"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4024b60b62c7d365c6689c64edaaf5b">getValueDepthAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessorT &amp;) const</td></tr>
<tr class="memitem:a409633b422404c1c7df4e0ffdd02eac1" id="r_a409633b422404c1c7df4e0ffdd02eac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a409633b422404c1c7df4e0ffdd02eac1">clip</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;)</td></tr>
<tr class="memdesc:a409633b422404c1c7df4e0ffdd02eac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all voxels that lie outside the given axis-aligned box to the background.  <br /></td></tr>
<tr class="memitem:a462c7056adc55d8da2cc5828934ff859" id="r_a462c7056adc55d8da2cc5828934ff859"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a462c7056adc55d8da2cc5828934ff859">prune</a> (const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;tolerance=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b">zeroVal</a>&lt; <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &gt;())</td></tr>
<tr class="memdesc:a462c7056adc55d8da2cc5828934ff859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the same (optionally to within a tolerance) and have the same active state.  <br /></td></tr>
<tr class="memitem:a6c20c22e9a994a30c9640cbe1ec982bc" id="r_a6c20c22e9a994a30c9640cbe1ec982bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c20c22e9a994a30c9640cbe1ec982bc">addLeaf</a> (<a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *leaf)</td></tr>
<tr class="memdesc:a6c20c22e9a994a30c9640cbe1ec982bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given leaf node to this tree, creating a new branch if necessary. If a leaf node with the same origin already exists, replace it.  <br /></td></tr>
<tr class="memitem:a23d57da960fd963ab7a02836ebf005b5" id="r_a23d57da960fd963ab7a02836ebf005b5"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:a23d57da960fd963ab7a02836ebf005b5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23d57da960fd963ab7a02836ebf005b5">addLeafAndCache</a> (<a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *leaf, AccessorT &amp;)</td></tr>
<tr class="memdesc:a23d57da960fd963ab7a02836ebf005b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#a6c20c22e9a994a30c9640cbe1ec982bc" title="Add the given leaf node to this tree, creating a new branch if necessary. If a leaf node with the sam...">addLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <br /></td></tr>
<tr class="memitem:a37a91bb3ba79b24928bc0f68e950c837" id="r_a37a91bb3ba79b24928bc0f68e950c837"><td class="memTemplParams" colspan="2">template&lt;typename NodeT&gt; </td></tr>
<tr class="memitem:a37a91bb3ba79b24928bc0f68e950c837 template"><td class="memItemLeft" align="right" valign="top">NodeT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37a91bb3ba79b24928bc0f68e950c837">stealNode</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool state)</td></tr>
<tr class="memdesc:a37a91bb3ba79b24928bc0f68e950c837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the node of type <code>NodeT</code> that contains voxel (x, y, z) and replace it with a tile of the specified value and state. If no such node exists, leave the tree unchanged and return <code>nullptr</code>.  <br /></td></tr>
<tr class="memitem:a2ed56c39d458885f1191405c625e73d1" id="r_a2ed56c39d458885f1191405c625e73d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ed56c39d458885f1191405c625e73d1">addChild</a> (ChildType *child)</td></tr>
<tr class="memdesc:a2ed56c39d458885f1191405c625e73d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given child node at the root level. If a child node with the same origin already exists, delete the old node and add the new node in its place (i.e. ownership of the new child node is transferred to this <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>).  <br /></td></tr>
<tr class="memitem:a6fd27c86bf273fa436a0e8c9d41b28af" id="r_a6fd27c86bf273fa436a0e8c9d41b28af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fd27c86bf273fa436a0e8c9d41b28af">addTile</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool state)</td></tr>
<tr class="memdesc:a6fd27c86bf273fa436a0e8c9d41b28af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a tile containing voxel (x, y, z) at the root level, deleting the existing branch if necessary.  <br /></td></tr>
<tr class="memitem:a58ab61f904112334f418ea8a1235cdad" id="r_a58ab61f904112334f418ea8a1235cdad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58ab61f904112334f418ea8a1235cdad">addTile</a> (<a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> level, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool state)</td></tr>
<tr class="memdesc:a58ab61f904112334f418ea8a1235cdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a tile containing voxel (x, y, z) at the specified tree level, creating a new branch if necessary. Delete any existing lower-level nodes that contain (x, y, z).  <br /></td></tr>
<tr class="memitem:a88baa1b1d12b360589dbe49a344be2b6" id="r_a88baa1b1d12b360589dbe49a344be2b6"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:a88baa1b1d12b360589dbe49a344be2b6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88baa1b1d12b360589dbe49a344be2b6">addTileAndCache</a> (<a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> level, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;, bool state, AccessorT &amp;)</td></tr>
<tr class="memdesc:a88baa1b1d12b360589dbe49a344be2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#a6fd27c86bf273fa436a0e8c9d41b28af" title="Add a tile containing voxel (x, y, z) at the root level, deleting the existing branch if necessary.">addTile()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <br /></td></tr>
<tr class="memitem:add42c507d8a7a76e10a69bf5aa22c3b8" id="r_add42c507d8a7a76e10a69bf5aa22c3b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add42c507d8a7a76e10a69bf5aa22c3b8">deleteChildOrTile</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz)</td></tr>
<tr class="memdesc:add42c507d8a7a76e10a69bf5aa22c3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete any child or tile containing voxel (x, y, z) at the root level. Do nothing if no child or tile was found.  <br /></td></tr>
<tr class="memitem:ab67464c0a432fdd5591c830b5589ce42" id="r_ab67464c0a432fdd5591c830b5589ce42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab67464c0a432fdd5591c830b5589ce42">touchLeaf</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz)</td></tr>
<tr class="memdesc:ab67464c0a432fdd5591c830b5589ce42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, create one that preserves the values and active states of all voxels.  <br /></td></tr>
<tr class="memitem:a3c5297595af619235cf1cca34acad513" id="r_a3c5297595af619235cf1cca34acad513"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:a3c5297595af619235cf1cca34acad513 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c5297595af619235cf1cca34acad513">touchLeafAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessorT &amp;acc)</td></tr>
<tr class="memdesc:a3c5297595af619235cf1cca34acad513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#ab67464c0a432fdd5591c830b5589ce42" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists,...">touchLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <br /></td></tr>
<tr class="memitem:af4aba8013df108be4d7eb3f58dd72cc6" id="r_af4aba8013df108be4d7eb3f58dd72cc6"><td class="memTemplParams" colspan="2">template&lt;typename NodeT&gt; </td></tr>
<tr class="memitem:af4aba8013df108be4d7eb3f58dd72cc6 template"><td class="memItemLeft" align="right" valign="top">NodeT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4aba8013df108be4d7eb3f58dd72cc6">probeNode</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz)</td></tr>
<tr class="memdesc:af4aba8013df108be4d7eb3f58dd72cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <br /></td></tr>
<tr class="memitem:abddfa67e1d9924f0d9548776c144a9a3" id="r_abddfa67e1d9924f0d9548776c144a9a3"><td class="memTemplParams" colspan="2">template&lt;typename NodeT&gt; </td></tr>
<tr class="memitem:abddfa67e1d9924f0d9548776c144a9a3 template"><td class="memItemLeft" align="right" valign="top">const NodeT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abddfa67e1d9924f0d9548776c144a9a3">probeNode</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memitem:acd609db3b1f878fdf0000eaec6953d8f" id="r_acd609db3b1f878fdf0000eaec6953d8f"><td class="memTemplParams" colspan="2">template&lt;typename NodeT&gt; </td></tr>
<tr class="memitem:acd609db3b1f878fdf0000eaec6953d8f template"><td class="memItemLeft" align="right" valign="top">const NodeT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd609db3b1f878fdf0000eaec6953d8f">probeConstNode</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memitem:a122a27ebee28178f68596b9d2c9094ae" id="r_a122a27ebee28178f68596b9d2c9094ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a122a27ebee28178f68596b9d2c9094ae">probe</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, <a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> *&amp;child, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool &amp;active)</td></tr>
<tr class="memdesc:a122a27ebee28178f68596b9d2c9094ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the root child node that contains voxel (x, y, z). If no such node exists, query and set the tile value and active status and return <code>nullptr</code>.  <br /></td></tr>
<tr class="memitem:a72c1074419e1264a4cd9a24b2f3365f8" id="r_a72c1074419e1264a4cd9a24b2f3365f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72c1074419e1264a4cd9a24b2f3365f8">probeConst</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> *&amp;child, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool &amp;active) const</td></tr>
<tr class="memitem:a574f001e88a67e53de514afbcc99366c" id="r_a574f001e88a67e53de514afbcc99366c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a574f001e88a67e53de514afbcc99366c">probe</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const <a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> *&amp;child, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool &amp;active) const</td></tr>
<tr class="memitem:a4603c14d21fce223c55c03783fb7a8b2" id="r_a4603c14d21fce223c55c03783fb7a8b2"><td class="memTemplParams" colspan="2">template&lt;typename NodeT, typename AccessorT&gt; </td></tr>
<tr class="memitem:a4603c14d21fce223c55c03783fb7a8b2 template"><td class="memItemLeft" align="right" valign="top">NodeT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4603c14d21fce223c55c03783fb7a8b2">probeNodeAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessorT &amp;acc)</td></tr>
<tr class="memdesc:a4603c14d21fce223c55c03783fb7a8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#af4aba8013df108be4d7eb3f58dd72cc6" title="Return a pointer to the node that contains voxel (x, y, z). If no such node exists,...">probeNode()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <br /></td></tr>
<tr class="memitem:a77c0bb0a5580fc955a3414d6a3f641b8" id="r_a77c0bb0a5580fc955a3414d6a3f641b8"><td class="memTemplParams" colspan="2">template&lt;typename NodeT, typename AccessorT&gt; </td></tr>
<tr class="memitem:a77c0bb0a5580fc955a3414d6a3f641b8 template"><td class="memItemLeft" align="right" valign="top">const NodeT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77c0bb0a5580fc955a3414d6a3f641b8">probeConstNodeAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessorT &amp;acc) const</td></tr>
<tr class="memitem:a66bcd94e15cbbbc3d961d3991e101c37" id="r_a66bcd94e15cbbbc3d961d3991e101c37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66bcd94e15cbbbc3d961d3991e101c37">probeChild</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz)</td></tr>
<tr class="memdesc:a66bcd94e15cbbbc3d961d3991e101c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the root child node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <br /></td></tr>
<tr class="memitem:adcf3689b8b0f5fdc52412d12dcfcdd4c" id="r_adcf3689b8b0f5fdc52412d12dcfcdd4c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcf3689b8b0f5fdc52412d12dcfcdd4c">probeConstChild</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memitem:ace9e9a6c82db1781122b3f791e2b5ceb" id="r_ace9e9a6c82db1781122b3f791e2b5ceb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace9e9a6c82db1781122b3f791e2b5ceb">probeChild</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memitem:a416387666c1bf211debea718d27e5e2f" id="r_a416387666c1bf211debea718d27e5e2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a416387666c1bf211debea718d27e5e2f">probeLeaf</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz)</td></tr>
<tr class="memdesc:a416387666c1bf211debea718d27e5e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <br /></td></tr>
<tr class="memitem:a6560728b916708918a69e8752d25cb10" id="r_a6560728b916708918a69e8752d25cb10"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6560728b916708918a69e8752d25cb10">probeConstLeaf</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memitem:a96cc17c24b0907ba0de1a9e27174e8a5" id="r_a96cc17c24b0907ba0de1a9e27174e8a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96cc17c24b0907ba0de1a9e27174e8a5">probeLeaf</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memitem:a1f32b783d79134f3fa485160be57fc5c" id="r_a1f32b783d79134f3fa485160be57fc5c"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:a1f32b783d79134f3fa485160be57fc5c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f32b783d79134f3fa485160be57fc5c">probeLeafAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessorT &amp;acc)</td></tr>
<tr class="memdesc:a1f32b783d79134f3fa485160be57fc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#a416387666c1bf211debea718d27e5e2f" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists,...">probeLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <br /></td></tr>
<tr class="memitem:a404be1c06079fd001cd648b839054ddc" id="r_a404be1c06079fd001cd648b839054ddc"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:a404be1c06079fd001cd648b839054ddc template"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a404be1c06079fd001cd648b839054ddc">probeConstLeafAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessorT &amp;acc) const</td></tr>
<tr class="memitem:ac94a3f2e596ba587be668eb2635da699" id="r_ac94a3f2e596ba587be668eb2635da699"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:ac94a3f2e596ba587be668eb2635da699 template"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac94a3f2e596ba587be668eb2635da699">probeLeafAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessorT &amp;acc) const</td></tr>
<tr class="memitem:a33f8be482e79b81de4155ae05ce9d8c5" id="r_a33f8be482e79b81de4155ae05ce9d8c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33f8be482e79b81de4155ae05ce9d8c5">getTileValueUnsafe</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memdesc:a33f8be482e79b81de4155ae05ce9d8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tile value at the given coordinate.  <br /></td></tr>
<tr class="memitem:a3051b4db754362a7402255db86b0affc" id="r_a3051b4db754362a7402255db86b0affc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3051b4db754362a7402255db86b0affc">getTileValueUnsafe</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value) const</td></tr>
<tr class="memdesc:a3051b4db754362a7402255db86b0affc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tile value and active state at the given coordinate.  <br /></td></tr>
<tr class="memitem:ab9ac9f2f821f649e632b8d3c8e730348" id="r_ab9ac9f2f821f649e632b8d3c8e730348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9ac9f2f821f649e632b8d3c8e730348">getChildUnsafe</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz)</td></tr>
<tr class="memdesc:ab9ac9f2f821f649e632b8d3c8e730348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the child node at the given coordinate.  <br /></td></tr>
<tr class="memitem:a27cd686ba16c245ff676784d55ce4ed2" id="r_a27cd686ba16c245ff676784d55ce4ed2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27cd686ba16c245ff676784d55ce4ed2">getConstChildUnsafe</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memdesc:a27cd686ba16c245ff676784d55ce4ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the child node at the given coordinate.  <br /></td></tr>
<tr class="memitem:a75da7fd3583d220b1e6340892d106ba2" id="r_a75da7fd3583d220b1e6340892d106ba2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75da7fd3583d220b1e6340892d106ba2">getChildUnsafe</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memdesc:a75da7fd3583d220b1e6340892d106ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the child node at the given coordinate.  <br /></td></tr>
<tr class="memitem:a33a3cd99c0b9c78e1f6da3d9a36fdaff" id="r_a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT&gt; </td></tr>
<tr class="memitem:a33a3cd99c0b9c78e1f6da3d9a36fdaff template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33a3cd99c0b9c78e1f6da3d9a36fdaff">getNodes</a> (ArrayT &amp;array)</td></tr>
<tr class="memdesc:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all nodes of a certain type to a container with the following API:  <br /></td></tr>
<tr class="memitem:ab6a64f33ad83ba0854b8502a061eb30b" id="r_ab6a64f33ad83ba0854b8502a061eb30b"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT&gt; </td></tr>
<tr class="memitem:ab6a64f33ad83ba0854b8502a061eb30b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6a64f33ad83ba0854b8502a061eb30b">getNodes</a> (ArrayT &amp;array) const</td></tr>
<tr class="memitem:ac4a8fd1479bd7b61a23884680d5d49e0" id="r_ac4a8fd1479bd7b61a23884680d5d49e0"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT&gt; </td></tr>
<tr class="memitem:ac4a8fd1479bd7b61a23884680d5d49e0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4a8fd1479bd7b61a23884680d5d49e0">stealNodes</a> (ArrayT &amp;array, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool state)</td></tr>
<tr class="memdesc:ac4a8fd1479bd7b61a23884680d5d49e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steals all nodes of a certain type from the tree and adds them to a container with the following API:  <br /></td></tr>
<tr class="memitem:ae9865f5a8eabf75fc2ad06581e22edcd" id="r_ae9865f5a8eabf75fc2ad06581e22edcd"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT&gt; </td></tr>
<tr class="memitem:ae9865f5a8eabf75fc2ad06581e22edcd template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9865f5a8eabf75fc2ad06581e22edcd">stealNodes</a> (ArrayT &amp;array)</td></tr>
<tr class="memitem:a52a7e4a512b1082887098547c2781ed0" id="r_a52a7e4a512b1082887098547c2781ed0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceopenvdb_1_1v13__0.html#ade9c95ac55c647839e6f3e9b462c0575">MergePolicy</a> Policy&gt; </td></tr>
<tr class="memitem:a52a7e4a512b1082887098547c2781ed0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52a7e4a512b1082887098547c2781ed0">merge</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> &amp;other)</td></tr>
<tr class="memdesc:a52a7e4a512b1082887098547c2781ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently merge another tree into this tree using one of several schemes.  <br /></td></tr>
<tr class="memitem:a3fb824077105112bae944f31ad9c2fe0" id="r_a3fb824077105112bae944f31ad9c2fe0"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType&gt; </td></tr>
<tr class="memitem:a3fb824077105112bae944f31ad9c2fe0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fb824077105112bae944f31ad9c2fe0">topologyUnion</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other, const bool preserveTiles=false)</td></tr>
<tr class="memdesc:a3fb824077105112bae944f31ad9c2fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union this tree's set of active values with the active values of the other tree, whose <code><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a></code> may be different.  <br /></td></tr>
<tr class="memitem:ac29f98775a4d88dc3163abc979db6060" id="r_ac29f98775a4d88dc3163abc979db6060"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType&gt; </td></tr>
<tr class="memitem:ac29f98775a4d88dc3163abc979db6060 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac29f98775a4d88dc3163abc979db6060">topologyIntersection</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other)</td></tr>
<tr class="memdesc:ac29f98775a4d88dc3163abc979db6060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects this tree's set of active values with the active values of the other tree, whose <code><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a></code> may be different.  <br /></td></tr>
<tr class="memitem:a4bfa9bd46c8206d75f01c69c05425b5d" id="r_a4bfa9bd46c8206d75f01c69c05425b5d"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType&gt; </td></tr>
<tr class="memitem:a4bfa9bd46c8206d75f01c69c05425b5d template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bfa9bd46c8206d75f01c69c05425b5d">topologyDifference</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other)</td></tr>
<tr class="memdesc:a4bfa9bd46c8206d75f01c69c05425b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference this tree's set of active values with the active values of the other tree, whose <code><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a></code> may be different. So a resulting voxel will be active only if the original voxel is active in this tree and inactive in the other tree.  <br /></td></tr>
<tr class="memitem:a2d0f6f48c7b53111118bf1a14a8dff03" id="r_a2d0f6f48c7b53111118bf1a14a8dff03"><td class="memTemplParams" colspan="2">template&lt;typename CombineOp&gt; </td></tr>
<tr class="memitem:a2d0f6f48c7b53111118bf1a14a8dff03 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d0f6f48c7b53111118bf1a14a8dff03">combine</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> &amp;other, CombineOp &amp;, bool <a class="el" href="#a462c7056adc55d8da2cc5828934ff859">prune</a>=false)</td></tr>
<tr class="memitem:a59d05166d77d6604823a6e669f3b53f7" id="r_a59d05166d77d6604823a6e669f3b53f7"><td class="memTemplParams" colspan="2">template&lt;typename CombineOp, typename OtherRootNode&gt; </td></tr>
<tr class="memitem:a59d05166d77d6604823a6e669f3b53f7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59d05166d77d6604823a6e669f3b53f7">combine2</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> &amp;other0, const OtherRootNode &amp;other1, CombineOp &amp;op, bool <a class="el" href="#a462c7056adc55d8da2cc5828934ff859">prune</a>=false)</td></tr>
<tr class="memitem:a5ade9746f288b38a00b1041100707b89" id="r_a5ade9746f288b38a00b1041100707b89"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ade9746f288b38a00b1041100707b89">origin</a> () const</td></tr>
<tr class="memdesc:a5ade9746f288b38a00b1041100707b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the grid index coordinates of this node's local origin.  <br /></td></tr>
<tr class="memitem:a594b25da67e57a3b0f252ce8417bb5e1" id="r_a594b25da67e57a3b0f252ce8417bb5e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a594b25da67e57a3b0f252ce8417bb5e1">setOrigin</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;<a class="el" href="#a5ade9746f288b38a00b1041100707b89">origin</a>)</td></tr>
<tr class="memdesc:a594b25da67e57a3b0f252ce8417bb5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the origin on this root node  <br /></td></tr>
<tr class="memitem:a2a504cf4afe0238e9d8121da84460cca" id="r_a2a504cf4afe0238e9d8121da84460cca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a504cf4afe0238e9d8121da84460cca">coordToKey</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz) const</td></tr>
<tr class="memdesc:a2a504cf4afe0238e9d8121da84460cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MapType key for the given coordinates, offset by the mOrigin.  <br /></td></tr>
<tr class="memitem:acdfafbdce62e6f6b734cec30dc9b241b" id="r_acdfafbdce62e6f6b734cec30dc9b241b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdfafbdce62e6f6b734cec30dc9b241b">hasKey</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;key) const</td></tr>
<tr class="memdesc:acdfafbdce62e6f6b734cec30dc9b241b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if this node's mTable contains the given key.  <br /></td></tr>
<tr class="memitem:ae7b436923b1f65752e7386206cdb5fab" id="r_ae7b436923b1f65752e7386206cdb5fab"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType&gt; </td></tr>
<tr class="memitem:ae7b436923b1f65752e7386206cdb5fab template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildT &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7b436923b1f65752e7386206cdb5fab">operator=</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other)</td></tr>
<tr class="memitem:af9e0b81808dc291d691d937428e932ad" id="r_af9e0b81808dc291d691d937428e932ad"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:af9e0b81808dc291d691d937428e932ad template"><td class="memItemLeft" align="right" valign="top">const ChildT::ValueType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9e0b81808dc291d691d937428e932ad">getValueAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessorT &amp;acc) const</td></tr>
<tr class="memitem:aba6a9efb0c0909d5fcaaaa3ffd07b8f3" id="r_aba6a9efb0c0909d5fcaaaa3ffd07b8f3"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:aba6a9efb0c0909d5fcaaaa3ffd07b8f3 template"><td class="memItemLeft" align="right" valign="top">ChildT::LeafNodeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba6a9efb0c0909d5fcaaaa3ffd07b8f3">touchLeafAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessorT &amp;acc)</td></tr>
<tr class="memitem:a2da64b537fda9c85ae6d53515b0f3eab" id="r_a2da64b537fda9c85ae6d53515b0f3eab"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:a2da64b537fda9c85ae6d53515b0f3eab template"><td class="memItemLeft" align="right" valign="top">ChildT::LeafNodeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2da64b537fda9c85ae6d53515b0f3eab">probeLeafAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessorT &amp;acc)</td></tr>
<tr class="memitem:ac9b5668c364dde085dd4e7fd227acaba" id="r_ac9b5668c364dde085dd4e7fd227acaba"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:ac9b5668c364dde085dd4e7fd227acaba template"><td class="memItemLeft" align="right" valign="top">const ChildT::LeafNodeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9b5668c364dde085dd4e7fd227acaba">probeConstLeafAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessorT &amp;acc) const</td></tr>
<tr class="memitem:a99d61d8a0cd5fe2e6cc18ebd432f747a" id="r_a99d61d8a0cd5fe2e6cc18ebd432f747a"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT&gt; </td></tr>
<tr class="memitem:a99d61d8a0cd5fe2e6cc18ebd432f747a template"><td class="memItemLeft" align="right" valign="top">const ChildT::LeafNodeType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99d61d8a0cd5fe2e6cc18ebd432f747a">probeLeafAndCache</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, AccessorT &amp;acc) const</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a00265a6f2e4bb7edf268ce430744f410" id="r_a00265a6f2e4bb7edf268ce430744f410"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00265a6f2e4bb7edf268ce430744f410">getNodeBoundingBox</a> ()</td></tr>
<tr class="memdesc:a00265a6f2e4bb7edf268ce430744f410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounding box of this <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, i.e., an infinite bounding box.  <br /></td></tr>
<tr class="memitem:a7364ceedc39ddbd16d4f61f89dda4883" id="r_a7364ceedc39ddbd16d4f61f89dda4883"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7364ceedc39ddbd16d4f61f89dda4883">getLevel</a> ()</td></tr>
<tr class="memitem:ad3b91d6e713861046431c86630d23ae2" id="r_ad3b91d6e713861046431c86630d23ae2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3b91d6e713861046431c86630d23ae2">getNodeLog2Dims</a> (std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &gt; &amp;dims)</td></tr>
<tr class="memitem:a252a41011fe13e50c8d49b5ca14a979b" id="r_a252a41011fe13e50c8d49b5ca14a979b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a252a41011fe13e50c8d49b5ca14a979b">getChildDim</a> ()</td></tr>
<tr class="memitem:a0332904c042d4dc9e88136294e048ed0" id="r_a0332904c042d4dc9e88136294e048ed0"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType&gt; </td></tr>
<tr class="memitem:a0332904c042d4dc9e88136294e048ed0 template"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0332904c042d4dc9e88136294e048ed0">hasSameConfiguration</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other)</td></tr>
<tr class="memdesc:a0332904c042d4dc9e88136294e048ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>false</code> if the other node's dimensions don't match this node's.  <br /></td></tr>
<tr class="memitem:a44152640d1b71b1a5eaf192b9018bd53" id="r_a44152640d1b71b1a5eaf192b9018bd53"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType&gt; </td></tr>
<tr class="memitem:a44152640d1b71b1a5eaf192b9018bd53 template"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44152640d1b71b1a5eaf192b9018bd53">hasCompatibleValueType</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7efd456219bae7db497d009ad92961a7" id="r_a7efd456219bae7db497d009ad92961a7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7efd456219bae7db497d009ad92961a7">LEVEL</a> = 1 + ChildType::LEVEL</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aff4f5e7209d5ad66394519639bd989f8" id="r_aff4f5e7209d5ad66394519639bd989f8"><td class="memTemplParams" colspan="2">template&lt;typename&gt; </td></tr>
<tr class="memitem:aff4f5e7209d5ad66394519639bd989f8 template"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff4f5e7209d5ad66394519639bd989f8">RootNode</a></td></tr>
<tr class="memitem:adac3b94dde9b204ff858644761361a95" id="r_adac3b94dde9b204ff858644761361a95"><td class="memTemplParams" colspan="2">template&lt;typename, typename, bool&gt; </td></tr>
<tr class="memitem:adac3b94dde9b204ff858644761361a95 template"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adac3b94dde9b204ff858644761361a95">RootNodeCopyHelper</a></td></tr>
<tr class="memitem:a733720747a659027d37f72bd461207eb" id="r_a733720747a659027d37f72bd461207eb"><td class="memTemplParams" colspan="2">template&lt;typename, typename, typename, bool&gt; </td></tr>
<tr class="memitem:a733720747a659027d37f72bd461207eb template"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a733720747a659027d37f72bd461207eb">RootNodeCombineHelper</a></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="ab723abdcfd580fb1fc5eebf5da5d9660" name="ab723abdcfd580fb1fc5eebf5da5d9660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab723abdcfd580fb1fc5eebf5da5d9660">&#9670;&#160;</a></span>BuildType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab723abdcfd580fb1fc5eebf5da5d9660">BuildType</a> = typename ChildType::BuildType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba3a2d9f84085e3e6b54f4358df5eb28" name="aba3a2d9f84085e3e6b54f4358df5eb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3a2d9f84085e3e6b54f4358df5eb28">&#9670;&#160;</a></span>ChildAllCIter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aba3a2d9f84085e3e6b54f4358df5eb28">ChildAllCIter</a> = DenseIter&lt;const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, const ChildType, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01bb1bcecd7385c19f214c7dd217fb27" name="a01bb1bcecd7385c19f214c7dd217fb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bb1bcecd7385c19f214c7dd217fb27">&#9670;&#160;</a></span>ChildAllIter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a01bb1bcecd7385c19f214c7dd217fb27">ChildAllIter</a> = DenseIter&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ChildType, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add0b43407ef7279a458b5b63c604ae73" name="add0b43407ef7279a458b5b63c604ae73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0b43407ef7279a458b5b63c604ae73">&#9670;&#160;</a></span>ChildNodeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> = ChildType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a629fb04c86fa214750225c9f1d146a36" name="a629fb04c86fa214750225c9f1d146a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629fb04c86fa214750225c9f1d146a36">&#9670;&#160;</a></span>ChildOffCIter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a629fb04c86fa214750225c9f1d146a36">ChildOffCIter</a> = ValueIter&lt;const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ChildOffPred, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad70584e8033dbc079fdc0ac57d167eee" name="ad70584e8033dbc079fdc0ac57d167eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70584e8033dbc079fdc0ac57d167eee">&#9670;&#160;</a></span>ChildOffIter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad70584e8033dbc079fdc0ac57d167eee">ChildOffIter</a> = ValueIter&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ChildOffPred, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af961e6cbba1568e6b4e3edac87952dbd" name="af961e6cbba1568e6b4e3edac87952dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af961e6cbba1568e6b4e3edac87952dbd">&#9670;&#160;</a></span>ChildOnCIter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af961e6cbba1568e6b4e3edac87952dbd">ChildOnCIter</a> = ChildIter&lt;const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ChildOnPred, const ChildType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53ddfd147d086003e983f40409d651ff" name="a53ddfd147d086003e983f40409d651ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ddfd147d086003e983f40409d651ff">&#9670;&#160;</a></span>ChildOnIter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a53ddfd147d086003e983f40409d651ff">ChildOnIter</a> = ChildIter&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ChildOnPred, ChildType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47b1764141687712562480c3cdd74c1b" name="a47b1764141687712562480c3cdd74c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b1764141687712562480c3cdd74c1b">&#9670;&#160;</a></span>LeafNodeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> = typename ChildType::LeafNodeType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a476192215f8d4ee389caf42204e3020f" name="a476192215f8d4ee389caf42204e3020f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476192215f8d4ee389caf42204e3020f">&#9670;&#160;</a></span>NodeChainType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a476192215f8d4ee389caf42204e3020f">NodeChainType</a> = typename <a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1NodeChain.html">NodeChain</a>&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, <a class="el" href="#a7efd456219bae7db497d009ad92961a7">LEVEL</a>&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#a476192215f8d4ee389caf42204e3020f" title="NodeChainType is a list of this tree&#39;s node types, from LeafNodeType to RootNode.">NodeChainType</a> is a list of this tree's node types, from <a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> to <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>. </p>

</div>
</div>
<a id="a755eaad7b1dba0812844255cee5c48bf" name="a755eaad7b1dba0812844255cee5c48bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755eaad7b1dba0812844255cee5c48bf">&#9670;&#160;</a></span>ValueAllCIter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a755eaad7b1dba0812844255cee5c48bf">ValueAllCIter</a> = ValueIter&lt;const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ValueAllPred, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e96b29bec06304babad73d51b201945" name="a3e96b29bec06304babad73d51b201945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e96b29bec06304babad73d51b201945">&#9670;&#160;</a></span>ValueAllIter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3e96b29bec06304babad73d51b201945">ValueAllIter</a> = ValueIter&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ValueAllPred, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04bce38e91a758eb215875e9ad0c0add" name="a04bce38e91a758eb215875e9ad0c0add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bce38e91a758eb215875e9ad0c0add">&#9670;&#160;</a></span>ValueOffCIter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a04bce38e91a758eb215875e9ad0c0add">ValueOffCIter</a> = ValueIter&lt;const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ValueOffPred, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cc6b3daa5baf71df51fb8426470d8c7" name="a3cc6b3daa5baf71df51fb8426470d8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc6b3daa5baf71df51fb8426470d8c7">&#9670;&#160;</a></span>ValueOffIter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3cc6b3daa5baf71df51fb8426470d8c7">ValueOffIter</a> = ValueIter&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ValueOffPred, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15fddbb02f413af01b4b839e82f5e49f" name="a15fddbb02f413af01b4b839e82f5e49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fddbb02f413af01b4b839e82f5e49f">&#9670;&#160;</a></span>ValueOnCIter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a15fddbb02f413af01b4b839e82f5e49f">ValueOnCIter</a> = ValueIter&lt;const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ValueOnPred, const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4eb611c9fc0de11faa69c866d88f680a" name="a4eb611c9fc0de11faa69c866d88f680a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb611c9fc0de11faa69c866d88f680a">&#9670;&#160;</a></span>ValueOnIter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4eb611c9fc0de11faa69c866d88f680a">ValueOnIter</a> = ValueIter&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ValueOnPred, <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89ab9062c358edc408d37deac2eb8538" name="a89ab9062c358edc408d37deac2eb8538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ab9062c358edc408d37deac2eb8538">&#9670;&#160;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> = typename ChildType::ValueType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa5dbd319ba70f5491e4326ec341273d8" name="aa5dbd319ba70f5491e4326ec341273d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5dbd319ba70f5491e4326ec341273d8">&#9670;&#160;</a></span>RootNode() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new tree with a background value of 0. </p>

</div>
</div>
<a id="a962d5c3401f8c0a8f60d71b141e7fb3b" name="a962d5c3401f8c0a8f60d71b141e7fb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962d5c3401f8c0a8f60d71b141e7fb3b">&#9670;&#160;</a></span>RootNode() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>background</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new tree with the given background value. </p>

</div>
</div>
<a id="a08562b54850ff29ef167b7a1d1cfadd4" name="a08562b54850ff29ef167b7a1d1cfadd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08562b54850ff29ef167b7a1d1cfadd4">&#9670;&#160;</a></span>RootNode() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4048d463e26625beb9e08adbd50528e" name="ad4048d463e26625beb9e08adbd50528e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4048d463e26625beb9e08adbd50528e">&#9670;&#160;</a></span>RootNode() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename OtherChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new tree that reproduces the topology and active states of a tree of a different <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> but the same configuration (levels, node dimensions and branching factors). Cast the other tree's values to this tree's <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if the other tree's configuration doesn't match this tree's or if this tree's <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> is not constructible from the other tree's <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6e523d80a6b90c3b63ef1c40939c7d5" name="ab6e523d80a6b90c3b63ef1c40939c7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e523d80a6b90c3b63ef1c40939c7d5">&#9670;&#160;</a></span>RootNode() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename OtherChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>background</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foreground</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1TopologyCopy.html">TopologyCopy</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new tree that reproduces the topology and active states of another tree (which may have a different <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>), but not the other tree's values. </p>
<p>All tiles and voxels that are active in the other tree are set to <em class="arg">foreground</em> in the new tree, and all inactive tiles and voxels are set to <em class="arg">background</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the root node of a tree having (possibly) a different <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> </td></tr>
    <tr><td class="paramname">background</td><td>the value to which inactive tiles and voxels are initialized </td></tr>
    <tr><td class="paramname">foreground</td><td>the value to which active tiles and voxels are initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if the other tree's configuration doesn't match this tree's. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1376f67d16d5de9a4d152a45f863f0cf" name="a1376f67d16d5de9a4d152a45f863f0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1376f67d16d5de9a4d152a45f863f0cf">&#9670;&#160;</a></span>RootNode() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename OtherChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>background</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1TopologyCopy.html">TopologyCopy</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new tree that reproduces the topology and active states of another tree (which may have a different <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>), but not the other tree's values. All tiles and voxels in the new tree are set to <em class="arg">background</em> regardless of their active states in the other tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the root node of a tree having (possibly) a different <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> </td></tr>
    <tr><td class="paramname">background</td><td>the value to which inactive tiles and voxels are initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This copy constructor is generally faster than the one that takes both a foreground and a background value. Its main application is in multithreaded operations where the topology of the output tree exactly matches the input tree. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if the other tree's configuration doesn't match this tree's. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf38ff0107dcb0e50c0f4e5783146459" name="aaf38ff0107dcb0e50c0f4e5783146459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf38ff0107dcb0e50c0f4e5783146459">&#9670;&#160;</a></span>~RootNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a3ddbec0d00fe45a3916a4542d8a6cb90" name="a3ddbec0d00fe45a3916a4542d8a6cb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ddbec0d00fe45a3916a4542d8a6cb90">&#9670;&#160;</a></span>activeTileCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> activeTileCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ed56c39d458885f1191405c625e73d1" name="a2ed56c39d458885f1191405c625e73d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed56c39d458885f1191405c625e73d1">&#9670;&#160;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool addChild </td>
          <td>(</td>
          <td class="paramtype">ChildType *</td>          <td class="paramname"><span class="paramname"><em>child</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given child node at the root level. If a child node with the same origin already exists, delete the old node and add the new node in its place (i.e. ownership of the new child node is transferred to this <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> (for consistency with InternalNode::addChild) </dd></dl>

</div>
</div>
<a id="a6c20c22e9a994a30c9640cbe1ec982bc" name="a6c20c22e9a994a30c9640cbe1ec982bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c20c22e9a994a30c9640cbe1ec982bc">&#9670;&#160;</a></span>addLeaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *</td>          <td class="paramname"><span class="paramname"><em>leaf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given leaf node to this tree, creating a new branch if necessary. If a leaf node with the same origin already exists, replace it. </p>

</div>
</div>
<a id="a23d57da960fd963ab7a02836ebf005b5" name="a23d57da960fd963ab7a02836ebf005b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d57da960fd963ab7a02836ebf005b5">&#9670;&#160;</a></span>addLeafAndCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addLeafAndCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *</td>          <td class="paramname"><span class="paramname"><em>leaf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="#a6c20c22e9a994a30c9640cbe1ec982bc" title="Add the given leaf node to this tree, creating a new branch if necessary. If a leaf node with the sam...">addLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a id="a6fd27c86bf273fa436a0e8c9d41b28af" name="a6fd27c86bf273fa436a0e8c9d41b28af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd27c86bf273fa436a0e8c9d41b28af">&#9670;&#160;</a></span>addTile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addTile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a tile containing voxel (x, y, z) at the root level, deleting the existing branch if necessary. </p>

</div>
</div>
<a id="a58ab61f904112334f418ea8a1235cdad" name="a58ab61f904112334f418ea8a1235cdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ab61f904112334f418ea8a1235cdad">&#9670;&#160;</a></span>addTile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addTile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a tile containing voxel (x, y, z) at the specified tree level, creating a new branch if necessary. Delete any existing lower-level nodes that contain (x, y, z). </p>

</div>
</div>
<a id="a88baa1b1d12b360589dbe49a344be2b6" name="a88baa1b1d12b360589dbe49a344be2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88baa1b1d12b360589dbe49a344be2b6">&#9670;&#160;</a></span>addTileAndCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addTileAndCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="#a6fd27c86bf273fa436a0e8c9d41b28af" title="Add a tile containing voxel (x, y, z) at the root level, deleting the existing branch if necessary.">addTile()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a id="acf204e0a650b353285fc5dc156a70dfd" name="acf204e0a650b353285fc5dc156a70dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf204e0a650b353285fc5dc156a70dfd">&#9670;&#160;</a></span>background()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp; background </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this node's background value. </p>

</div>
</div>
<a id="a7000148c6f1dc8bfbb0139a3606e188e" name="a7000148c6f1dc8bfbb0139a3606e188e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7000148c6f1dc8bfbb0139a3606e188e">&#9670;&#160;</a></span>beginChildAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a01bb1bcecd7385c19f214c7dd217fb27">ChildAllIter</a> beginChildAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abde2b021fb4a5d0524b4c782ce48af13" name="abde2b021fb4a5d0524b4c782ce48af13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde2b021fb4a5d0524b4c782ce48af13">&#9670;&#160;</a></span>beginChildAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aba3a2d9f84085e3e6b54f4358df5eb28">ChildAllCIter</a> beginChildAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a845985fcf5013cc3fe15865b05b3abd5" name="a845985fcf5013cc3fe15865b05b3abd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845985fcf5013cc3fe15865b05b3abd5">&#9670;&#160;</a></span>beginChildOff() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad70584e8033dbc079fdc0ac57d167eee">ChildOffIter</a> beginChildOff </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8747e818fa77600e87e5dd868c2eaa31" name="a8747e818fa77600e87e5dd868c2eaa31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8747e818fa77600e87e5dd868c2eaa31">&#9670;&#160;</a></span>beginChildOff() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a629fb04c86fa214750225c9f1d146a36">ChildOffCIter</a> beginChildOff </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f712beff77da092dd726a59e1104cf0" name="a0f712beff77da092dd726a59e1104cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f712beff77da092dd726a59e1104cf0">&#9670;&#160;</a></span>beginChildOn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a53ddfd147d086003e983f40409d651ff">ChildOnIter</a> beginChildOn </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e0526f36e787eece5d83798c23bb4e9" name="a0e0526f36e787eece5d83798c23bb4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0526f36e787eece5d83798c23bb4e9">&#9670;&#160;</a></span>beginChildOn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af961e6cbba1568e6b4e3edac87952dbd">ChildOnCIter</a> beginChildOn </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afdf6fa279da1f6839a3ca381828220df" name="afdf6fa279da1f6839a3ca381828220df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf6fa279da1f6839a3ca381828220df">&#9670;&#160;</a></span>beginValueAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3e96b29bec06304babad73d51b201945">ValueAllIter</a> beginValueAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3638d1f86ab66eb1087910b4172a81e" name="af3638d1f86ab66eb1087910b4172a81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3638d1f86ab66eb1087910b4172a81e">&#9670;&#160;</a></span>beginValueAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a755eaad7b1dba0812844255cee5c48bf">ValueAllCIter</a> beginValueAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad555f92c70739496805fb480c3b38f85" name="ad555f92c70739496805fb480c3b38f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad555f92c70739496805fb480c3b38f85">&#9670;&#160;</a></span>beginValueOff() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3cc6b3daa5baf71df51fb8426470d8c7">ValueOffIter</a> beginValueOff </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b2ad19bf53695a6a7c3ab316a67b40c" name="a6b2ad19bf53695a6a7c3ab316a67b40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2ad19bf53695a6a7c3ab316a67b40c">&#9670;&#160;</a></span>beginValueOff() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a04bce38e91a758eb215875e9ad0c0add">ValueOffCIter</a> beginValueOff </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b8568cb11eacfedf042fa1eda680a45" name="a7b8568cb11eacfedf042fa1eda680a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8568cb11eacfedf042fa1eda680a45">&#9670;&#160;</a></span>beginValueOn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4eb611c9fc0de11faa69c866d88f680a">ValueOnIter</a> beginValueOn </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ecac88b99d3c8064036ec4747260dfa" name="a4ecac88b99d3c8064036ec4747260dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ecac88b99d3c8064036ec4747260dfa">&#9670;&#160;</a></span>beginValueOn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a15fddbb02f413af01b4b839e82f5e49f">ValueOnCIter</a> beginValueOn </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e215faf611a093dee0cc94fae637f5d" name="a6e215faf611a093dee0cc94fae637f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e215faf611a093dee0cc94fae637f5d">&#9670;&#160;</a></span>cbeginChildAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aba3a2d9f84085e3e6b54f4358df5eb28">ChildAllCIter</a> cbeginChildAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a83f5ee6913372d15b560cfcc9d6bc025" name="a83f5ee6913372d15b560cfcc9d6bc025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f5ee6913372d15b560cfcc9d6bc025">&#9670;&#160;</a></span>cbeginChildOff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a629fb04c86fa214750225c9f1d146a36">ChildOffCIter</a> cbeginChildOff </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a088045df8b72d08f243c05645441e7c9" name="a088045df8b72d08f243c05645441e7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088045df8b72d08f243c05645441e7c9">&#9670;&#160;</a></span>cbeginChildOn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af961e6cbba1568e6b4e3edac87952dbd">ChildOnCIter</a> cbeginChildOn </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45ab5e975ed9515b08cb3ce3cb5dc722" name="a45ab5e975ed9515b08cb3ce3cb5dc722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ab5e975ed9515b08cb3ce3cb5dc722">&#9670;&#160;</a></span>cbeginValueAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a755eaad7b1dba0812844255cee5c48bf">ValueAllCIter</a> cbeginValueAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1de8db6621c42bbe606d4b6739e4462f" name="a1de8db6621c42bbe606d4b6739e4462f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de8db6621c42bbe606d4b6739e4462f">&#9670;&#160;</a></span>cbeginValueOff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a04bce38e91a758eb215875e9ad0c0add">ValueOffCIter</a> cbeginValueOff </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9141b760807bdde0cad1e9bee1cc137a" name="a9141b760807bdde0cad1e9bee1cc137a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9141b760807bdde0cad1e9bee1cc137a">&#9670;&#160;</a></span>cbeginValueOn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a15fddbb02f413af01b4b839e82f5e49f">ValueOnCIter</a> cbeginValueOn </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9def3b556156ce0fd3713640b2f81b95" name="a9def3b556156ce0fd3713640b2f81b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9def3b556156ce0fd3713640b2f81b95">&#9670;&#160;</a></span>childCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> childCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8bb3912a3ce86b15842e79d0b421204" name="ac8bb3912a3ce86b15842e79d0b421204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bb3912a3ce86b15842e79d0b421204">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a409633b422404c1c7df4e0ffdd02eac1" name="a409633b422404c1c7df4e0ffdd02eac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409633b422404c1c7df4e0ffdd02eac1">&#9670;&#160;</a></span>clip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>clipBBox</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all voxels that lie outside the given axis-aligned box to the background. </p>

</div>
</div>
<a id="a2d0f6f48c7b53111118bf1a14a8dff03" name="a2d0f6f48c7b53111118bf1a14a8dff03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0f6f48c7b53111118bf1a14a8dff03">&#9670;&#160;</a></span>combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename CombineOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombineOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>prune</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a59d05166d77d6604823a6e669f3b53f7" name="a59d05166d77d6604823a6e669f3b53f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d05166d77d6604823a6e669f3b53f7">&#9670;&#160;</a></span>combine2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename CombineOp, typename OtherRootNode&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherRootNode&lt; ChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombineOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>prune</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a504cf4afe0238e9d8121da84460cca" name="a2a504cf4afe0238e9d8121da84460cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a504cf4afe0238e9d8121da84460cca">&#9670;&#160;</a></span>coordToKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> coordToKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a MapType key for the given coordinates, offset by the mOrigin. </p>

</div>
</div>
<a id="a195825f611f78d1b10451ce535cffe79" name="a195825f611f78d1b10451ce535cffe79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195825f611f78d1b10451ce535cffe79">&#9670;&#160;</a></span>copyToDense()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename DenseT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void copyToDense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseT &amp;</td>          <td class="paramname"><span class="paramname"><em>dense</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy into a dense grid the values of all voxels, both active and inactive, that intersect a given bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>inclusive bounding box of the voxels to be copied into the dense grid </td></tr>
    <tr><td class="paramname">dense</td><td>dense grid with a stride in <em>z</em> of one (see <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Dense.html" title="Dense is a simple dense grid API used by the CopyToDense and CopyFromDense classes defined below.">tools::Dense</a> in <a class="el" href="Dense_8h.html" title="This file defines a simple dense grid and efficient converters to and from VDB grids.">tools/Dense.h</a> for the required API) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add42c507d8a7a76e10a69bf5aa22c3b8" name="add42c507d8a7a76e10a69bf5aa22c3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add42c507d8a7a76e10a69bf5aa22c3b8">&#9670;&#160;</a></span>deleteChildOrTile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool deleteChildOrTile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete any child or tile containing voxel (x, y, z) at the root level. Do nothing if no child or tile was found. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method will invalidate any existing <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> iterators. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if child or tile was deleted </dd></dl>

</div>
</div>
<a id="abb399cd065108e53e7b65612e74372a5" name="abb399cd065108e53e7b65612e74372a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb399cd065108e53e7b65612e74372a5">&#9670;&#160;</a></span>denseFill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void denseFill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>active</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all voxels within a given axis-aligned box to a constant value and ensure that those voxels are all represented at the leaf level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>inclusive coordinates of opposite corners of an axis-aligned box. </td></tr>
    <tr><td class="paramname">value</td><td>the value to which to set voxels within the box. </td></tr>
    <tr><td class="paramname">active</td><td>if true, mark voxels within the box as active, otherwise mark them as inactive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a39a2211a02fb606e611d3ff5bbd6f50c" title="Densify active tiles, i.e., replace them with leaf-level active voxels.">voxelizeActiveTiles()</a> </dd></dl>

</div>
</div>
<a id="a644718bb2fb240de962dc3c9a1fdf0dc" name="a644718bb2fb240de962dc3c9a1fdf0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644718bb2fb240de962dc3c9a1fdf0dc">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if this node's table is either empty or contains only background tiles. </p>

</div>
</div>
<a id="a48dc4a8d53d718280d347a867cd6704b" name="a48dc4a8d53d718280d347a867cd6704b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dc4a8d53d718280d347a867cd6704b">&#9670;&#160;</a></span>eraseBackgroundTiles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t eraseBackgroundTiles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all background tiles. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of tiles removed. </dd></dl>

</div>
</div>
<a id="ace68379b5a11804713fc050baba5159d" name="ace68379b5a11804713fc050baba5159d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace68379b5a11804713fc050baba5159d">&#9670;&#160;</a></span>evalActiveBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evalActiveBoundingBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>visitVoxels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand the specified bbox so it includes the active tiles of this root node as well as all the active values in its child nodes. If visitVoxels is false LeafNodes will be approximated as dense, i.e. with all voxels active. Else the individual active voxels are visited to produce a tight bbox. </p>

</div>
</div>
<a id="aed5bfeb2da24cc37e6561b3cd0f5f1f3" name="aed5bfeb2da24cc37e6561b3cd0f5f1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5bfeb2da24cc37e6561b3cd0f5f1f3">&#9670;&#160;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool expand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand this node's table so that (x, y, z) is included in the index range. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an expansion was performed (i.e., if (x, y, z) was not already included in the index range). </dd></dl>

</div>
</div>
<a id="a69bd60c87fb75e3bb7a9b5099f3a4bdf" name="a69bd60c87fb75e3bb7a9b5099f3a4bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69bd60c87fb75e3bb7a9b5099f3a4bdf">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>active</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all voxels within a given axis-aligned box to a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>inclusive coordinates of opposite corners of an axis-aligned box </td></tr>
    <tr><td class="paramname">value</td><td>the value to which to set voxels within the box </td></tr>
    <tr><td class="paramname">active</td><td>if true, mark voxels within the box as active, otherwise mark them as inactive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation generates a sparse, but not always optimally sparse, representation of the filled box. Follow fill operations with a <a class="el" href="#a462c7056adc55d8da2cc5828934ff859" title="Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the s...">prune()</a> operation for optimal sparseness. </dd></dl>

</div>
</div>
<a id="a252a41011fe13e50c8d49b5ca14a979b" name="a252a41011fe13e50c8d49b5ca14a979b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252a41011fe13e50c8d49b5ca14a979b">&#9670;&#160;</a></span>getChildDim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getChildDim </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9ac9f2f821f649e632b8d3c8e730348" name="ab9ac9f2f821f649e632b8d3c8e730348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ac9f2f821f649e632b8d3c8e730348">&#9670;&#160;</a></span>getChildUnsafe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT * getChildUnsafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the child node at the given coordinate. </p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="#a7000148c6f1dc8bfbb0139a3606e188e">beginChildAll()</a> for a safer alternative. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method should only be used by experts seeking low-level optimizations. </dd></dl>

</div>
</div>
<a id="a75da7fd3583d220b1e6340892d106ba2" name="a75da7fd3583d220b1e6340892d106ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75da7fd3583d220b1e6340892d106ba2">&#9670;&#160;</a></span>getChildUnsafe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT * getChildUnsafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the child node at the given coordinate. </p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="#a6e215faf611a093dee0cc94fae637f5d">cbeginChildAll()</a> for a safer alternative. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method should only be used by experts seeking low-level optimizations. </dd></dl>

</div>
</div>
<a id="a27cd686ba16c245ff676784d55ce4ed2" name="a27cd686ba16c245ff676784d55ce4ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27cd686ba16c245ff676784d55ce4ed2">&#9670;&#160;</a></span>getConstChildUnsafe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT * getConstChildUnsafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the child node at the given coordinate. </p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="#a6e215faf611a093dee0cc94fae637f5d">cbeginChildAll()</a> for a safer alternative. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method should only be used by experts seeking low-level optimizations. </dd></dl>

</div>
</div>
<a id="a1102bd83dda994c134fe774fd1c914b1" name="a1102bd83dda994c134fe774fd1c914b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1102bd83dda994c134fe774fd1c914b1">&#9670;&#160;</a></span>getDepth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getDepth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6c66ba3f55a2b185149aa68e629e693" name="ac6c66ba3f55a2b185149aa68e629e693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c66ba3f55a2b185149aa68e629e693">&#9670;&#160;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getHeight </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16f60a3586748dad01004e868bc2f525" name="a16f60a3586748dad01004e868bc2f525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f60a3586748dad01004e868bc2f525">&#9670;&#160;</a></span>getIndexRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getIndexRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current index range. Both min and max are inclusive. </p>

</div>
</div>
<a id="a7364ceedc39ddbd16d4f61f89dda4883" name="a7364ceedc39ddbd16d4f61f89dda4883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7364ceedc39ddbd16d4f61f89dda4883">&#9670;&#160;</a></span>getLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getLevel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ce8a4cb37cefb07d92a949c816c7dc9" name="a1ce8a4cb37cefb07d92a949c816c7dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce8a4cb37cefb07d92a949c816c7dc9">&#9670;&#160;</a></span>getMaxIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> getMaxIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the largest index of the current tree. </p>

</div>
</div>
<a id="ad9bcb4cf379db9801dba49ba0ff5d9a0" name="ad9bcb4cf379db9801dba49ba0ff5d9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9bcb4cf379db9801dba49ba0ff5d9a0">&#9670;&#160;</a></span>getMinIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> getMinIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the smallest index of the current tree. </p>

</div>
</div>
<a id="a00265a6f2e4bb7edf268ce430744f410" name="a00265a6f2e4bb7edf268ce430744f410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00265a6f2e4bb7edf268ce430744f410">&#9670;&#160;</a></span>getNodeBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> getNodeBoundingBox </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bounding box of this <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>, i.e., an infinite bounding box. </p>

</div>
</div>
<a id="ad3b91d6e713861046431c86630d23ae2" name="ad3b91d6e713861046431c86630d23ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b91d6e713861046431c86630d23ae2">&#9670;&#160;</a></span>getNodeLog2Dims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getNodeLog2Dims </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dims</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a33a3cd99c0b9c78e1f6da3d9a36fdaff" name="a33a3cd99c0b9c78e1f6da3d9a36fdaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a3cd99c0b9c78e1f6da3d9a36fdaff">&#9670;&#160;</a></span>getNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename ArrayT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all nodes of a certain type to a container with the following API: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayT {</div>
<div class="line">   <span class="keyword">using </span>value_type = ...;<span class="comment">// defines the type of nodes to be added to the array</span></div>
<div class="line">   <span class="keywordtype">void</span> push_back(value_type nodePtr);<span class="comment">// method that add nodes to the array</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>An example of a wrapper around a c-style array is: </p><div class="fragment"><div class="line"> <span class="keyword">struct </span>MyArray {</div>
<div class="line">    <span class="keyword">using </span>value_type = LeafType*;</div>
<div class="line">    value_type* ptr;</div>
<div class="line">    MyArray(value_type* array) : ptr(array) {}</div>
<div class="line">    <span class="keywordtype">void</span> push_back(value_type leaf) { *ptr++ = leaf; }</div>
<div class="line">};</div>
</div><!-- fragment --><p>An example that constructs a list of pointer to all leaf nodes is: </p><div class="fragment"><div class="line">std::vector&lt;const LeafNodeType*&gt; array;<span class="comment">//most std contains have the required API</span></div>
<div class="line">array.reserve(<a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1tree.html">tree</a>.leafCount());<span class="comment">//this is a fast preallocation.</span></div>
<div class="line"><a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1tree.html">tree</a>.getNodes(array);</div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tree_html"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0_1_1tree.html">openvdb::v13_0::tree</a></div><div class="ttdef"><b>Definition</b> PointDataGrid.h:170</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab6a64f33ad83ba0854b8502a061eb30b" name="ab6a64f33ad83ba0854b8502a061eb30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a64f33ad83ba0854b8502a061eb30b">&#9670;&#160;</a></span>getNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename ArrayT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a552b15b6e1b6a9538f92d7d9259a4446" name="a552b15b6e1b6a9538f92d7d9259a4446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552b15b6e1b6a9538f92d7d9259a4446">&#9670;&#160;</a></span>getTableSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getTableSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of entries in this node's table. </p>

</div>
</div>
<a id="a33f8be482e79b81de4155ae05ce9d8c5" name="a33f8be482e79b81de4155ae05ce9d8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f8be482e79b81de4155ae05ce9d8c5">&#9670;&#160;</a></span>getTileValueUnsafe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::ValueType &amp; getTileValueUnsafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the tile value at the given coordinate. </p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="#a45ab5e975ed9515b08cb3ce3cb5dc722">cbeginValueAll()</a> for a safer alternative. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method should only be used by experts seeking low-level optimizations. </dd></dl>

</div>
</div>
<a id="a3051b4db754362a7402255db86b0affc" name="a3051b4db754362a7402255db86b0affc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3051b4db754362a7402255db86b0affc">&#9670;&#160;</a></span>getTileValueUnsafe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool getTileValueUnsafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the tile value and active state at the given coordinate. </p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="#a45ab5e975ed9515b08cb3ce3cb5dc722">cbeginValueAll()</a> for a safer alternative. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method should only be used by experts seeking low-level optimizations. </dd></dl>

</div>
</div>
<a id="ae6e67ec58b555ee2e403ffc7a92d108c" name="ae6e67ec58b555ee2e403ffc7a92d108c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e67ec58b555ee2e403ffc7a92d108c">&#9670;&#160;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::ValueType &amp; getValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e0e2349b41f63f8fcbf8340d47b666b" name="a6e0e2349b41f63f8fcbf8340d47b666b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0e2349b41f63f8fcbf8340d47b666b">&#9670;&#160;</a></span>getValueAndCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp; getValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the voxel at the given coordinates and, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a id="af9e0b81808dc291d691d937428e932ad" name="af9e0b81808dc291d691d937428e932ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e0b81808dc291d691d937428e932ad">&#9670;&#160;</a></span>getValueAndCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::ValueType &amp; getValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03c8f00f509936998e0d47be7afd5e3f" name="a03c8f00f509936998e0d47be7afd5e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c8f00f509936998e0d47be7afd5e3f">&#9670;&#160;</a></span>getValueDepth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getValueDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the tree depth (0 = root) at which the value of voxel (x, y, z) resides. </p>
<p>If (x, y, z) isn't explicitly represented in the tree (i.e., it is implicitly a background voxel), return -1. </p>

</div>
</div>
<a id="ae4024b60b62c7d365c6689c64edaaf5b" name="ae4024b60b62c7d365c6689c64edaaf5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4024b60b62c7d365c6689c64edaaf5b">&#9670;&#160;</a></span>getValueDepthAndCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getValueDepthAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tree depth (0 = root) at which the value of voxel (x, y, z) resides. If (x, y, z) isn't explicitly represented in the tree (i.e., it is implicitly a background voxel), return -1. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a id="a54ebc384a69c3a30946b14cf4b19fb1f" name="a54ebc384a69c3a30946b14cf4b19fb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ebc384a69c3a30946b14cf4b19fb1f">&#9670;&#160;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getWidth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae27c5b1e634724be621234d2653c8eae" name="ae27c5b1e634724be621234d2653c8eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27c5b1e634724be621234d2653c8eae">&#9670;&#160;</a></span>hasActiveTiles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasActiveTiles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if this root node, or any of its child nodes, have active tiles. </p>

</div>
</div>
<a id="a44152640d1b71b1a5eaf192b9018bd53" name="a44152640d1b71b1a5eaf192b9018bd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44152640d1b71b1a5eaf192b9018bd53">&#9670;&#160;</a></span>hasCompatibleValueType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename OtherChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasCompatibleValueType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if values of the other node's <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> can be converted to values of this node's <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>. </p>

</div>
</div>
<a id="acdfafbdce62e6f6b734cec30dc9b241b" name="acdfafbdce62e6f6b734cec30dc9b241b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfafbdce62e6f6b734cec30dc9b241b">&#9670;&#160;</a></span>hasKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if this node's mTable contains the given key. </p>

</div>
</div>
<a id="a0332904c042d4dc9e88136294e048ed0" name="a0332904c042d4dc9e88136294e048ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0332904c042d4dc9e88136294e048ed0">&#9670;&#160;</a></span>hasSameConfiguration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename OtherChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasSameConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>false</code> if the other node's dimensions don't match this node's. </p>

</div>
</div>
<a id="abb283d5d20f2a472df7d1aee0708381c" name="abb283d5d20f2a472df7d1aee0708381c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb283d5d20f2a472df7d1aee0708381c">&#9670;&#160;</a></span>hasSameTopology()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename OtherChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasSameTopology </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given tree has the same node and active value topology as this tree (but possibly a different <code><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a></code>). </p>

</div>
</div>
<a id="a81b0afbeba6288a492047f67424d0b9e" name="a81b0afbeba6288a492047f67424d0b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b0afbeba6288a492047f67424d0b9e">&#9670;&#160;</a></span>inactiveTileCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> inactiveTileCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a228a4f7a4f366863d37147c5fac8e0f9" name="a228a4f7a4f366863d37147c5fac8e0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228a4f7a4f366863d37147c5fac8e0f9">&#9670;&#160;</a></span>isBackgroundTile() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isBackgroundTile </td>
          <td>(</td>
          <td class="paramtype">const MapCIter &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaee09a2f4089dc3e7d3e16d19768779c" name="aaee09a2f4089dc3e7d3e16d19768779c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee09a2f4089dc3e7d3e16d19768779c">&#9670;&#160;</a></span>isBackgroundTile() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isBackgroundTile </td>
          <td>(</td>
          <td class="paramtype">const MapIter &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given iterator points to an inactive tile with the background value. </p>

</div>
</div>
<a id="a47ac2e923401b385063e3601fef9aaf5" name="a47ac2e923401b385063e3601fef9aaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ac2e923401b385063e3601fef9aaf5">&#9670;&#160;</a></span>isBackgroundTile() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isBackgroundTile </td>
          <td>(</td>
          <td class="paramtype">const Tile &amp;</td>          <td class="paramname"><span class="paramname"><em>tile</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given tile is inactive and has the background value. </p>

</div>
</div>
<a id="a149d3646dfe8b0ae5f352cea5c1e9cc7" name="a149d3646dfe8b0ae5f352cea5c1e9cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149d3646dfe8b0ae5f352cea5c1e9cc7">&#9670;&#160;</a></span>isValueOn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValueOn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a764d9f6528248f70fb667e91d35d7aab" name="a764d9f6528248f70fb667e91d35d7aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764d9f6528248f70fb667e91d35d7aab">&#9670;&#160;</a></span>isValueOnAndCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValueOnAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if the voxel at the given coordinates is active and, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a id="a6fb95cf16675717b8edc3178ec021c2f" name="a6fb95cf16675717b8edc3178ec021c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb95cf16675717b8edc3178ec021c2f">&#9670;&#160;</a></span>leafCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> leafCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7d5580aa0181f1610d1014563a41581" name="ae7d5580aa0181f1610d1014563a41581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d5580aa0181f1610d1014563a41581">&#9670;&#160;</a></span>memUsage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> memUsage </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total amount of memory in bytes occupied by this node and its children. </p>

</div>
</div>
<a id="a52a7e4a512b1082887098547c2781ed0" name="a52a7e4a512b1082887098547c2781ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a7e4a512b1082887098547c2781ed0">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceopenvdb_1_1v13__0.html#ade9c95ac55c647839e6f3e9b462c0575">MergePolicy</a> Policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Efficiently merge another tree into this tree using one of several schemes. </p>
<p>This operation is primarily intended to combine trees that are mostly non-overlapping (for example, intermediate trees from computations that are parallelized across disjoint regions of space). </p><dl class="section note"><dt>Note</dt><dd>This operation is not guaranteed to produce an optimally sparse tree. Follow <a class="el" href="#a52a7e4a512b1082887098547c2781ed0" title="Efficiently merge another tree into this tree using one of several schemes.">merge()</a> with <a class="el" href="#a462c7056adc55d8da2cc5828934ff859" title="Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the s...">prune()</a> for optimal sparseness. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation always empties the other tree. </dd></dl>

</div>
</div>
<a id="aa6954a428c0ef18a03431f251f4e7d24" name="aa6954a428c0ef18a03431f251f4e7d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6954a428c0ef18a03431f251f4e7d24">&#9670;&#160;</a></span>modifyValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename ModifyOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void modifyValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModifyOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a functor to the value of the voxel at the given coordinates and mark the voxel as active. </p>

</div>
</div>
<a id="a5cb69af7e17c3a9a6d6dc360c878448c" name="a5cb69af7e17c3a9a6d6dc360c878448c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb69af7e17c3a9a6d6dc360c878448c">&#9670;&#160;</a></span>modifyValueAndActiveState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename ModifyOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void modifyValueAndActiveState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModifyOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a functor to the voxel at the given coordinates. </p>

</div>
</div>
<a id="af057648803b9073ce1703dbf061e0d1f" name="af057648803b9073ce1703dbf061e0d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af057648803b9073ce1703dbf061e0d1f">&#9670;&#160;</a></span>modifyValueAndActiveStateAndCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename ModifyOp, typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void modifyValueAndActiveStateAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModifyOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a functor to the voxel at the given coordinates. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a id="a7bed5c7c0d76cacfb514d9744f754402" name="a7bed5c7c0d76cacfb514d9744f754402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bed5c7c0d76cacfb514d9744f754402">&#9670;&#160;</a></span>modifyValueAndCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename ModifyOp, typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void modifyValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModifyOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a functor to the value of the voxel at the given coordinates and mark the voxel as active. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a id="ae7a5e4f46465ad6bdf132b2967b324f2" name="ae7a5e4f46465ad6bdf132b2967b324f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a5e4f46465ad6bdf132b2967b324f2">&#9670;&#160;</a></span>nodeCount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nodeCount </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated</a></b></dt><dd>"Use input type std::vector&lt;Index64&gt; for nodeCount." <br  />
 </dd></dl>

</div>
</div>
<a id="a90527600f0c60d8c36ea67005779c99d" name="a90527600f0c60d8c36ea67005779c99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90527600f0c60d8c36ea67005779c99d">&#9670;&#160;</a></span>nodeCount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nodeCount </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a367f079ecce7c9f4cd5e9ae83f2e19cf" name="a367f079ecce7c9f4cd5e9ae83f2e19cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367f079ecce7c9f4cd5e9ae83f2e19cf">&#9670;&#160;</a></span>nonLeafCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> nonLeafCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62310fe5cddf3963e67ffd3f551dfe76" name="a62310fe5cddf3963e67ffd3f551dfe76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62310fe5cddf3963e67ffd3f551dfe76">&#9670;&#160;</a></span>numBackgroundTiles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t numBackgroundTiles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of background tiles. </p>

</div>
</div>
<a id="a53e093f41c97cb7dc8a22c9ea53b6ffb" name="a53e093f41c97cb7dc8a22c9ea53b6ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e093f41c97cb7dc8a22c9ea53b6ffb">&#9670;&#160;</a></span>offLeafVoxelCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> offLeafVoxelCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf477adbc6f68604494fae8b06c6ba3c" name="aaf477adbc6f68604494fae8b06c6ba3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf477adbc6f68604494fae8b06c6ba3c">&#9670;&#160;</a></span>offVoxelCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> offVoxelCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a401ea099593e2e1ac12badc526abdf51" name="a401ea099593e2e1ac12badc526abdf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401ea099593e2e1ac12badc526abdf51">&#9670;&#160;</a></span>onLeafVoxelCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> onLeafVoxelCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa43bfe6b2bffa8ab5e0b7ad5da1afa77" name="aa43bfe6b2bffa8ab5e0b7ad5da1afa77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43bfe6b2bffa8ab5e0b7ad5da1afa77">&#9670;&#160;</a></span>onTileCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> onTileCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a86a4db588f25113840ecc0dcee1cfe0b" name="a86a4db588f25113840ecc0dcee1cfe0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a4db588f25113840ecc0dcee1cfe0b">&#9670;&#160;</a></span>onVoxelCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> onVoxelCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b775efb979e2d7445d43aaf7cb900d0" name="a1b775efb979e2d7445d43aaf7cb900d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b775efb979e2d7445d43aaf7cb900d0">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildT &gt; &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a root node of the same type as this node. </p>

</div>
</div>
<a id="a2808786e8db5081ca0b37f894fd1a446" name="a2808786e8db5081ca0b37f894fd1a446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2808786e8db5081ca0b37f894fd1a446">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename OtherChildType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a root node of the same tree configuration as this node but a different <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if the other tree's configuration doesn't match this tree's. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This node's <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> must be constructible from the other node's <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>. For example, a root node with values of type float can be assigned to a root node with values of type <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a>, because a <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> can be constructed from a float. But a <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> root node cannot be assigned to a float root node. </dd></dl>

</div>
</div>
<a id="ae7b436923b1f65752e7386206cdb5fab" name="ae7b436923b1f65752e7386206cdb5fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b436923b1f65752e7386206cdb5fab">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename OtherChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildT &gt; &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ade9746f288b38a00b1041100707b89" name="a5ade9746f288b38a00b1041100707b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ade9746f288b38a00b1041100707b89">&#9670;&#160;</a></span>origin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp; origin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the grid index coordinates of this node's local origin. </p>

</div>
</div>
<a id="a122a27ebee28178f68596b9d2c9094ae" name="a122a27ebee28178f68596b9d2c9094ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122a27ebee28178f68596b9d2c9094ae">&#9670;&#160;</a></span>probe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool probe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>child</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>active</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the root child node that contains voxel (x, y, z). If no such node exists, query and set the tile value and active status and return <code>nullptr</code>. </p>

</div>
</div>
<a id="a574f001e88a67e53de514afbcc99366c" name="a574f001e88a67e53de514afbcc99366c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574f001e88a67e53de514afbcc99366c">&#9670;&#160;</a></span>probe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool probe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>child</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>active</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66bcd94e15cbbbc3d961d3991e101c37" name="a66bcd94e15cbbbc3d961d3991e101c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bcd94e15cbbbc3d961d3991e101c37">&#9670;&#160;</a></span>probeChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT * probeChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the root child node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a id="ace9e9a6c82db1781122b3f791e2b5ceb" name="ace9e9a6c82db1781122b3f791e2b5ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9e9a6c82db1781122b3f791e2b5ceb">&#9670;&#160;</a></span>probeChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> * probeChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a72c1074419e1264a4cd9a24b2f3365f8" name="a72c1074419e1264a4cd9a24b2f3365f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c1074419e1264a4cd9a24b2f3365f8">&#9670;&#160;</a></span>probeConst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool probeConst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>child</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>active</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adcf3689b8b0f5fdc52412d12dcfcdd4c" name="adcf3689b8b0f5fdc52412d12dcfcdd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf3689b8b0f5fdc52412d12dcfcdd4c">&#9670;&#160;</a></span>probeConstChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT * probeConstChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6560728b916708918a69e8752d25cb10" name="a6560728b916708918a69e8752d25cb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6560728b916708918a69e8752d25cb10">&#9670;&#160;</a></span>probeConstLeaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::LeafNodeType * probeConstLeaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a404be1c06079fd001cd648b839054ddc" name="a404be1c06079fd001cd648b839054ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404be1c06079fd001cd648b839054ddc">&#9670;&#160;</a></span>probeConstLeafAndCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> * probeConstLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9b5668c364dde085dd4e7fd227acaba" name="ac9b5668c364dde085dd4e7fd227acaba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b5668c364dde085dd4e7fd227acaba">&#9670;&#160;</a></span>probeConstLeafAndCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::LeafNodeType * probeConstLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd609db3b1f878fdf0000eaec6953d8f" name="acd609db3b1f878fdf0000eaec6953d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd609db3b1f878fdf0000eaec6953d8f">&#9670;&#160;</a></span>probeConstNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename NodeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const NodeT * probeConstNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77c0bb0a5580fc955a3414d6a3f641b8" name="a77c0bb0a5580fc955a3414d6a3f641b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c0bb0a5580fc955a3414d6a3f641b8">&#9670;&#160;</a></span>probeConstNodeAndCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename NodeT, typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const NodeT * probeConstNodeAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a416387666c1bf211debea718d27e5e2f" name="a416387666c1bf211debea718d27e5e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416387666c1bf211debea718d27e5e2f">&#9670;&#160;</a></span>probeLeaf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT::LeafNodeType * probeLeaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a id="a96cc17c24b0907ba0de1a9e27174e8a5" name="a96cc17c24b0907ba0de1a9e27174e8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cc17c24b0907ba0de1a9e27174e8a5">&#9670;&#160;</a></span>probeLeaf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> * probeLeaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f32b783d79134f3fa485160be57fc5c" name="a1f32b783d79134f3fa485160be57fc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f32b783d79134f3fa485160be57fc5c">&#9670;&#160;</a></span>probeLeafAndCache() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> * probeLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="#a416387666c1bf211debea718d27e5e2f" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists,...">probeLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a id="a2da64b537fda9c85ae6d53515b0f3eab" name="a2da64b537fda9c85ae6d53515b0f3eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da64b537fda9c85ae6d53515b0f3eab">&#9670;&#160;</a></span>probeLeafAndCache() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT::LeafNodeType * probeLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac94a3f2e596ba587be668eb2635da699" name="ac94a3f2e596ba587be668eb2635da699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94a3f2e596ba587be668eb2635da699">&#9670;&#160;</a></span>probeLeafAndCache() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> * probeLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99d61d8a0cd5fe2e6cc18ebd432f747a" name="a99d61d8a0cd5fe2e6cc18ebd432f747a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d61d8a0cd5fe2e6cc18ebd432f747a">&#9670;&#160;</a></span>probeLeafAndCache() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::LeafNodeType * probeLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af4aba8013df108be4d7eb3f58dd72cc6" name="af4aba8013df108be4d7eb3f58dd72cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4aba8013df108be4d7eb3f58dd72cc6">&#9670;&#160;</a></span>probeNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename NodeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeT * probeNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a id="abddfa67e1d9924f0d9548776c144a9a3" name="abddfa67e1d9924f0d9548776c144a9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abddfa67e1d9924f0d9548776c144a9a3">&#9670;&#160;</a></span>probeNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename NodeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const NodeT * probeNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4603c14d21fce223c55c03783fb7a8b2" name="a4603c14d21fce223c55c03783fb7a8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4603c14d21fce223c55c03783fb7a8b2">&#9670;&#160;</a></span>probeNodeAndCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename NodeT, typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeT * probeNodeAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="#af4aba8013df108be4d7eb3f58dd72cc6" title="Return a pointer to the node that contains voxel (x, y, z). If no such node exists,...">probeNode()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a id="a7ac3a88741d49d74b50c55b9a5371646" name="a7ac3a88741d49d74b50c55b9a5371646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac3a88741d49d74b50c55b9a5371646">&#9670;&#160;</a></span>probeValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool probeValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca08a701c485990b261ff6be818688d2" name="aca08a701c485990b261ff6be818688d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca08a701c485990b261ff6be818688d2">&#9670;&#160;</a></span>probeValueAndCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool probeValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return, in <em class="arg">value</em>, the value of the voxel at the given coordinates and, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the voxel at the given coordinates is active </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a id="a462c7056adc55d8da2cc5828934ff859" name="a462c7056adc55d8da2cc5828934ff859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462c7056adc55d8da2cc5828934ff859">&#9670;&#160;</a></span>prune()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void prune </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b">zeroVal</a>&lt;<a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the same (optionally to within a tolerance) and have the same active state. </p>
<dl class="section note"><dt>Note</dt><dd>Consider instead using <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tools.html#a8057e1165c928a37703f90eb9496083c" title="Reduce the memory footprint of a tree by replacing with tiles any nodes whose values are all the same...">tools::prune</a> which is multi-threaded! </dd></dl>

</div>
</div>
<a id="aef270a4e4900e5e0bd24e6664d6a8a82" name="aef270a4e4900e5e0bd24e6664d6a8a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef270a4e4900e5e0bd24e6664d6a8a82">&#9670;&#160;</a></span>readBuffers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void readBuffers </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>fromHalf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d516efdbb242e00e7c77ae85cc426b6" name="a9d516efdbb242e00e7c77ae85cc426b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d516efdbb242e00e7c77ae85cc426b6">&#9670;&#160;</a></span>readBuffers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void readBuffers </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>clipBBox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>fromHalf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5537d3d93b7137d3f03007b31077921" name="af5537d3d93b7137d3f03007b31077921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5537d3d93b7137d3f03007b31077921">&#9670;&#160;</a></span>readTopology()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool readTopology </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>fromHalf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b3e82eb582914ac6f31f32fea77292f" name="a7b3e82eb582914ac6f31f32fea77292f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3e82eb582914ac6f31f32fea77292f">&#9670;&#160;</a></span>setActiveState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setActiveState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>on</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the active state of the voxel at the given coordinates but don't change its value. </p>

</div>
</div>
<a id="ac04db06362bfb5ec0ed6212469eb4ff3" name="ac04db06362bfb5ec0ed6212469eb4ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04db06362bfb5ec0ed6212469eb4ff3">&#9670;&#160;</a></span>setActiveStateAndCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setActiveStateAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>on</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the active state of the voxel at the given coordinates without changing its value. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a id="ab9a9be183fae028c2479dd20163a52ee" name="ab9a9be183fae028c2479dd20163a52ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a9be183fae028c2479dd20163a52ee">&#9670;&#160;</a></span>setBackground()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setBackground </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>updateChildNodes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change inactive tiles or voxels with a value equal to +/- the old background to the specified value (with the same sign). Active values are unchanged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The new background value </td></tr>
    <tr><td class="paramname">updateChildNodes</td><td>If true the background values of the child nodes is also updated. Else only the background value stored in the <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a> itself is changed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Instead of setting <em class="arg">updateChildNodes</em> to true, consider using <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tools.html#ad795f2f3910144753a5e03d12f4703de" title="Replace the background value in all the nodes of a tree.">tools::changeBackground</a> or <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tools.html#ae9b9e9c02f534160f2571613f2d67ef5" title="Replace the background value in all the nodes of a floating-point tree containing a symmetric narrow-...">tools::changeLevelSetBackground</a> which are multi-threaded! </dd></dl>

</div>
</div>
<a id="a594b25da67e57a3b0f252ce8417bb5e1" name="a594b25da67e57a3b0f252ce8417bb5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594b25da67e57a3b0f252ce8417bb5e1">&#9670;&#160;</a></span>setOrigin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setOrigin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>origin</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>change the origin on this root node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>the index coordinates of the new alignment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This method will throw if the origin is non-zero, since other tools do not yet support variable offsets. </dd></dl>

</div>
</div>
<a id="ac330ca3d33322b20db4aa7afe20b5a6d" name="ac330ca3d33322b20db4aa7afe20b5a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac330ca3d33322b20db4aa7afe20b5a6d">&#9670;&#160;</a></span>setTransientData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setTransientData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a></td>          <td class="paramname"><span class="paramname"><em>transientData</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the transient data value. </p>

</div>
</div>
<a id="a01b75fc2aa129aa05ae677971dc1972e" name="a01b75fc2aa129aa05ae677971dc1972e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b75fc2aa129aa05ae677971dc1972e">&#9670;&#160;</a></span>setValueAndCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the value of the voxel at the given coordinates and mark it as active. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a id="a8a91d631df8f64f84a0aad7436cb11f3" name="a8a91d631df8f64f84a0aad7436cb11f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a91d631df8f64f84a0aad7436cb11f3">&#9670;&#160;</a></span>setValueOff() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the voxel at the given coordinates as inactive but don't change its value. </p>

</div>
</div>
<a id="a73a6e7c85d37e7d677eddc3cce8aa11b" name="a73a6e7c85d37e7d677eddc3cce8aa11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a6e7c85d37e7d677eddc3cce8aa11b">&#9670;&#160;</a></span>setValueOff() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates and mark the voxel as inactive. </p>

</div>
</div>
<a id="a6c0c65991a0b3c81933cd944d8fc4267" name="a6c0c65991a0b3c81933cd944d8fc4267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0c65991a0b3c81933cd944d8fc4267">&#9670;&#160;</a></span>setValueOffAndCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOffAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the value of the voxel at the given coordinates and mark it as inactive. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a id="ae95653046c85afb743075f139a26df9d" name="ae95653046c85afb743075f139a26df9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95653046c85afb743075f139a26df9d">&#9670;&#160;</a></span>setValueOn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates and mark the voxel as active. </p>

</div>
</div>
<a id="a63ff695beda11ed9ef625a28ce8a5faf" name="a63ff695beda11ed9ef625a28ce8a5faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ff695beda11ed9ef625a28ce8a5faf">&#9670;&#160;</a></span>setValueOnly()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates but don't change its active state. </p>

</div>
</div>
<a id="a5cefbe46cc3180e5394a2f4fc775bfe8" name="a5cefbe46cc3180e5394a2f4fc775bfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cefbe46cc3180e5394a2f4fc775bfe8">&#9670;&#160;</a></span>setValueOnlyAndCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnlyAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the value of the voxel at the given coordinates without changing its active state. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a id="ad87de532e553a73bd6e3b55337eff1d5" name="ad87de532e553a73bd6e3b55337eff1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87de532e553a73bd6e3b55337eff1d5">&#9670;&#160;</a></span>sparseFill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparseFill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>active</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a37a91bb3ba79b24928bc0f68e950c837" name="a37a91bb3ba79b24928bc0f68e950c837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a91bb3ba79b24928bc0f68e950c837">&#9670;&#160;</a></span>stealNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename NodeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeT * stealNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the node of type <code>NodeT</code> that contains voxel (x, y, z) and replace it with a tile of the specified value and state. If no such node exists, leave the tree unchanged and return <code>nullptr</code>. </p>
<dl class="section note"><dt>Note</dt><dd>The caller takes ownership of the node and is responsible for deleting it.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Since this method potentially removes nodes and branches of the tree, it is important to clear the caches of all ValueAccessors associated with this tree. </dd></dl>

</div>
</div>
<a id="ae9865f5a8eabf75fc2ad06581e22edcd" name="ae9865f5a8eabf75fc2ad06581e22edcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9865f5a8eabf75fc2ad06581e22edcd">&#9670;&#160;</a></span>stealNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename ArrayT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stealNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4a8fd1479bd7b61a23884680d5d49e0" name="ac4a8fd1479bd7b61a23884680d5d49e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a8fd1479bd7b61a23884680d5d49e0">&#9670;&#160;</a></span>stealNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename ArrayT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stealNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Steals all nodes of a certain type from the tree and adds them to a container with the following API: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayT {</div>
<div class="line">   <span class="keyword">using </span>value_type = ...;<span class="comment">// defines the type of nodes to be added to the array</span></div>
<div class="line">   <span class="keywordtype">void</span> push_back(value_type nodePtr);<span class="comment">// method that add nodes to the array</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>An example of a wrapper around a c-style array is: </p><div class="fragment"><div class="line"> <span class="keyword">struct </span>MyArray {</div>
<div class="line">    <span class="keyword">using </span>value_type = LeafType*;</div>
<div class="line">    value_type* ptr;</div>
<div class="line">    MyArray(value_type* array) : ptr(array) {}</div>
<div class="line">    <span class="keywordtype">void</span> push_back(value_type leaf) { *ptr++ = leaf; }</div>
<div class="line">};</div>
</div><!-- fragment --><p>An example that constructs a list of pointer to all leaf nodes is: </p><div class="fragment"><div class="line">std::vector&lt;const LeafNodeType*&gt; array;<span class="comment">//most std contains have the required API</span></div>
<div class="line">array.reserve(<a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1tree.html">tree</a>.leafCount());<span class="comment">//this is a fast preallocation.</span></div>
<div class="line"><a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1tree.html">tree</a>.stealNodes(array);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a984487a328711c403469cf21e62b0532" name="a984487a328711c403469cf21e62b0532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984487a328711c403469cf21e62b0532">&#9670;&#160;</a></span>tileCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> tileCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bfa9bd46c8206d75f01c69c05425b5d" name="a4bfa9bd46c8206d75f01c69c05425b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfa9bd46c8206d75f01c69c05425b5d">&#9670;&#160;</a></span>topologyDifference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename OtherChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void topologyDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Difference this tree's set of active values with the active values of the other tree, whose <code><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a></code> may be different. So a resulting voxel will be active only if the original voxel is active in this tree and inactive in the other tree. </p>
<dl class="section note"><dt>Note</dt><dd>This operation can delete branches in this grid if they overlap with active tiles in the other grid. Likewise active voxels can be turned into inactive voxels resulting in leaf nodes with no active values. Thus, it is recommended to subsequently call prune. </dd></dl>

</div>
</div>
<a id="ac29f98775a4d88dc3163abc979db6060" name="ac29f98775a4d88dc3163abc979db6060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29f98775a4d88dc3163abc979db6060">&#9670;&#160;</a></span>topologyIntersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename OtherChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void topologyIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersects this tree's set of active values with the active values of the other tree, whose <code><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a></code> may be different. </p>
<p>The resulting state of a value is active only if the corresponding value was already active AND if it is active in the other tree. Also, a resulting value maps to a voxel if the corresponding value already mapped to an active voxel in either of the two grids and it maps to an active tile or voxel in the other grid.</p>
<dl class="section note"><dt>Note</dt><dd>This operation can delete branches in this grid if they overlap with inactive tiles in the other grid. Likewise active voxels can be turned into inactive voxels resulting in leaf nodes with no active values. Thus, it is recommended to subsequently call prune. </dd></dl>

</div>
</div>
<a id="a3fb824077105112bae944f31ad9c2fe0" name="a3fb824077105112bae944f31ad9c2fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb824077105112bae944f31ad9c2fe0">&#9670;&#160;</a></span>topologyUnion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<div class="memtemplate">
template&lt;typename OtherChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void topologyUnion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>preserveTiles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Union this tree's set of active values with the active values of the other tree, whose <code><a class="el" href="#a89ab9062c358edc408d37deac2eb8538">ValueType</a></code> may be different. </p>
<p>The resulting state of a value is active if the corresponding value was already active OR if it is active in the other tree. Also, a resulting value maps to a voxel if the corresponding value already mapped to a voxel OR if it is a voxel in the other tree. Thus, a resulting value can only map to a tile if the corresponding value already mapped to a tile AND if it is a tile value in other tree.</p>
<dl class="section note"><dt>Note</dt><dd>This operation modifies only active states, not values. Specifically, active tiles and voxels in this tree are not changed, and tiles or voxels that were inactive in this tree but active in the other tree are marked as active in this tree but left with their original values.</dd>
<dd>
If preserveTiles is true, any active tile in this topology will not be densified by overlapping child topology. </dd></dl>

</div>
</div>
<a id="ab67464c0a432fdd5591c830b5589ce42" name="ab67464c0a432fdd5591c830b5589ce42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67464c0a432fdd5591c830b5589ce42">&#9670;&#160;</a></span>touchLeaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT::LeafNodeType * touchLeaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, create one that preserves the values and active states of all voxels. </p>
<p>Use this method to preallocate a static tree topology over which to safely perform multithreaded processing. </p>

</div>
</div>
<a id="a3c5297595af619235cf1cca34acad513" name="a3c5297595af619235cf1cca34acad513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5297595af619235cf1cca34acad513">&#9670;&#160;</a></span>touchLeafAndCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> * touchLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="#ab67464c0a432fdd5591c830b5589ce42" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists,...">touchLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a id="aba6a9efb0c0909d5fcaaaa3ffd07b8f3" name="aba6a9efb0c0909d5fcaaaa3ffd07b8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6a9efb0c0909d5fcaaaa3ffd07b8f3">&#9670;&#160;</a></span>touchLeafAndCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename AccessorT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT::LeafNodeType * touchLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f5f8d33bc3f381b0cd796f16aee8d6b" name="a1f5f8d33bc3f381b0cd796f16aee8d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5f8d33bc3f381b0cd796f16aee8d6b">&#9670;&#160;</a></span>transientData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> transientData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the transient data value. </p>

</div>
</div>
<a id="a39a2211a02fb606e611d3ff5bbd6f50c" name="a39a2211a02fb606e611d3ff5bbd6f50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a2211a02fb606e611d3ff5bbd6f50c">&#9670;&#160;</a></span>voxelizeActiveTiles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void voxelizeActiveTiles </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Densify active tiles, i.e., replace them with leaf-level active voxels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threaded</td><td>if true, this operation is multi-threaded (over the internal nodes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This method can explode the tree's memory footprint, especially if it contains active tiles at the upper levels (in particular the root level)!</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abb399cd065108e53e7b65612e74372a5" title="Set all voxels within a given axis-aligned box to a constant value and ensure that those voxels are a...">denseFill()</a> </dd></dl>

</div>
</div>
<a id="a8fbb3742c8aa39e1036ca155035cc51f" name="a8fbb3742c8aa39e1036ca155035cc51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbb3742c8aa39e1036ca155035cc51f">&#9670;&#160;</a></span>writeBuffers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeBuffers </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>toHalf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7385846a40d5a048e09f7a78c85d7983" name="a7385846a40d5a048e09f7a78c85d7983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7385846a40d5a048e09f7a78c85d7983">&#9670;&#160;</a></span>writeTopology()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool writeTopology </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>toHalf</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="aff4f5e7209d5ad66394519639bd989f8" name="aff4f5e7209d5ad66394519639bd989f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4f5e7209d5ad66394519639bd989f8">&#9670;&#160;</a></span>RootNode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>During topology-only construction, access is needed to protected/private members of other template instances. </p>

</div>
</div>
<a id="a733720747a659027d37f72bd461207eb" name="a733720747a659027d37f72bd461207eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733720747a659027d37f72bd461207eb">&#9670;&#160;</a></span>RootNodeCombineHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename, typename, typename, bool&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1RootNodeCombineHelper.html">RootNodeCombineHelper</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adac3b94dde9b204ff858644761361a95" name="adac3b94dde9b204ff858644761361a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac3b94dde9b204ff858644761361a95">&#9670;&#160;</a></span>RootNodeCopyHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<div class="memtemplate">
template&lt;typename, typename, bool&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1RootNodeCopyHelper.html">RootNodeCopyHelper</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a7efd456219bae7db497d009ad92961a7" name="a7efd456219bae7db497d009ad92961a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efd456219bae7db497d009ad92961a7">&#9670;&#160;</a></span>LEVEL</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChildType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> LEVEL = 1 + ChildType::LEVEL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1tree.html">tree</a></li><li class="navelem"><a href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">RootNode</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
