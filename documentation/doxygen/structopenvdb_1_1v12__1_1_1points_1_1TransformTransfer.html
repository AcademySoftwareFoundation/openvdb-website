<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: TransformTransfer Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">12.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v12__1.html">v12_1</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1points.html">points</a></li><li class="navelem"><a class="el" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html">TransformTransfer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TransformTransfer Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html" title="The TransformTransfer module should be used if the source transform of the input points and the targe...">TransformTransfer</a> module should be used if the source transform of the input points and the target transforms of the destination volumes differ. The default rasterizer will skip index to world (and vice versa) transformations unless a transfer scheme derives from a <a class="el" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html" title="The TransformTransfer module should be used if the source transform of the input points and the targe...">TransformTransfer</a>.  
 <a href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PointTransfer_8h_source.html">openvdb/points/PointTransfer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0adf292877ed1cd7955bd4c752dc12e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html#af0adf292877ed1cd7955bd4c752dc12e">TransformTransfer</a> (const <a class="el" href="classopenvdb_1_1v12__1_1_1math_1_1Transform.html">math::Transform</a> &amp;st, const <a class="el" href="classopenvdb_1_1v12__1_1_1math_1_1Transform.html">math::Transform</a> &amp;tt)</td></tr>
<tr class="separator:af0adf292877ed1cd7955bd4c752dc12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af706ba490b42b827fce576b17a4051d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af706ba490b42b827fce576b17a4051d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html#af706ba490b42b827fce576b17a4051d8">transformSourceToTarget</a> (const T &amp;value) const </td></tr>
<tr class="separator:af706ba490b42b827fce576b17a4051d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6aa11d3ec06afc2287e01845944a6ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6aa11d3ec06afc2287e01845944a6ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html#af6aa11d3ec06afc2287e01845944a6ad">transformTargetToSource</a> (const T &amp;value) const </td></tr>
<tr class="separator:af6aa11d3ec06afc2287e01845944a6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86590a233121178127b187016c1408b9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v12__1_1_1math_1_1Transform.html">math::Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html#a86590a233121178127b187016c1408b9">sourceTransform</a> () const </td></tr>
<tr class="separator:a86590a233121178127b187016c1408b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067c02b91ad0939bf44151e40d47d9ec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v12__1_1_1math_1_1Transform.html">math::Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html#a067c02b91ad0939bf44151e40d47d9ec">targetTransform</a> () const </td></tr>
<tr class="separator:a067c02b91ad0939bf44151e40d47d9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html" title="The TransformTransfer module should be used if the source transform of the input points and the targe...">TransformTransfer</a> module should be used if the source transform of the input points and the target transforms of the destination volumes differ. The default rasterizer will skip index to world (and vice versa) transformations unless a transfer scheme derives from a <a class="el" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html" title="The TransformTransfer module should be used if the source transform of the input points and the targe...">TransformTransfer</a>. </p>
<dl class="section user"><dt>A transfer scheme must be configured to call the provided rasterize</dt><dd>methods. See below for an example, or the various native VDB files which implement schemes e.g.:<ul>
<li><a class="el" href="PointRasterizeSDF_8h.html" title="Various transfer schemes for rasterizing point positions and radius data to signed distance fields wi...">PointRasterizeSDF.h</a></li>
<li><a class="el" href="PointRasterizeTrilinear_8h.html" title="Transfer schemes for rasterizing point data. ">PointRasterizeTrilinear.h</a></li>
<li><a class="el" href="PrincipalComponentAnalysisImpl_8h.html">PrincipalComponentAnalysisImpl.h</a> <div class="fragment"><div class="line"><span class="keyword">struct </span>Transfer</div><div class="line">{<span class="comment"></span></div><div class="line"><span class="comment">    /// @return Returns the tree topology to loop over. This can be different</span></div><div class="line"><span class="comment">    ///   from the destination tree i.e. This can act as a mask.</span></div><div class="line"><span class="comment"></span>    <span class="keyword">inline</span> <span class="keyword">auto</span>&amp; topology();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  The maximum lookup range of this transfer scheme in index</span></div><div class="line"><span class="comment">    ///   space of the source points.</span></div><div class="line"><span class="comment">    /// @details The return value represent how far away from the destination</span></div><div class="line"><span class="comment">    ///   leaf node points should be accessed.</span></div><div class="line"><span class="comment">    /// @param origin  The leaf origin of the topology being accessed</span></div><div class="line"><span class="comment">    /// @param idx     The leaf index of the topology being accessed</span></div><div class="line"><span class="comment"></span>    <span class="keyword">inline</span> <a class="code" href="namespaceopenvdb_1_1v12__1.html#ac524bdfeb5d781872485d9321c881920">Int32</a> range(<span class="keyword">const</span> Coord&amp; origin, <span class="keywordtype">size_t</span> idx) <span class="keyword">const</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  The initialize function, called on each leaf which has valid</span></div><div class="line"><span class="comment">    ///   topology to write to.</span></div><div class="line"><span class="comment">    /// @param origin  The leaf origin of the topology being accessed</span></div><div class="line"><span class="comment">    /// @param idx     The leaf index of the topology being accessed</span></div><div class="line"><span class="comment">    /// @param bounds  The active voxel bounds of the leaf</span></div><div class="line"><span class="comment"></span>    <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespaceopenvdb_1_1v12__1.html#a49c172664d07773fe108364eafe82942">initialize</a>(<span class="keyword">const</span> Coord&amp; origin, <span class="keywordtype">size_t</span> idx, <span class="keyword">const</span> CoordBBox&amp; bounds);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  Run each time a point leaf is accessed. Typically this is</span></div><div class="line"><span class="comment">    ///  where attribute handles can be constructed</span></div><div class="line"><span class="comment">    /// @param leaf  The PointDataLeafNode which is being accessed.</span></div><div class="line"><span class="comment">    /// @return  Return true to continue rasterization, false to early exit</span></div><div class="line"><span class="comment">    ///   and skip the current leaf&#39;s contribution to the destination volume.</span></div><div class="line"><span class="comment"></span>    <span class="keyword">inline</span> <span class="keywordtype">bool</span> startPointLeaf(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v12__1_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">PointDataTree::LeafNodeType</a>&amp; leaf);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    ///////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment"></span></div><div class="line">    <span class="comment">// Transfer scheme must implement either:</span></div><div class="line">    <span class="comment">//   - rasterizePoint(Coord, Index, CoordBBox) OR</span></div><div class="line">    <span class="comment">//   - rasterizePoints(Coord, Index, Index, CoordBBox)</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  The point stamp function. Each point which contributes to</span></div><div class="line"><span class="comment">    ///  the current leaf will call this function exactly once.</span></div><div class="line"><span class="comment">    /// @param ijk  The current voxel containing the point being rasterized.</span></div><div class="line"><span class="comment">    ///   May be outside the destination leaf node depending on the range()</span></div><div class="line"><span class="comment">    /// @param id   The point index being rasterized</span></div><div class="line"><span class="comment">    /// @param bounds  The active bounds of the leaf node.</span></div><div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> rasterizePoint(<span class="keyword">const</span> Coord&amp; ijk,</div><div class="line">        <span class="keyword">const</span> Index <span class="keywordtype">id</span>,</div><div class="line">        <span class="keyword">const</span> CoordBBox&amp; bounds);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  Same as above, except this is passed a range of points</span></div><div class="line"><span class="comment">    ///   that all belong to the same voxel</span></div><div class="line"><span class="comment">    /// @param ijk  The current voxel containing the point being rasterized.</span></div><div class="line"><span class="comment">    ///   May be outside the destination leaf node depending on the range()</span></div><div class="line"><span class="comment">    /// @param start   The start point index being rasterized</span></div><div class="line"><span class="comment">    /// @param end     The end point index being rasterized</span></div><div class="line"><span class="comment">    /// @param bounds  The active bounds of the leaf node.</span></div><div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> rasterizePoints(<span class="keyword">const</span> Coord&amp; ijk,</div><div class="line">         <span class="keyword">const</span> Index start,</div><div class="line">         <span class="keyword">const</span> Index end,</div><div class="line">         <span class="keyword">const</span> CoordBBox&amp; bounds);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    ///////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment"></span><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  Run each time a point leaf is finished with.</span></div><div class="line"><span class="comment">    /// @param leaf  The PointDataLeafNode which was being accessed.</span></div><div class="line"><span class="comment">    /// @return  Return true to continue rasterization, false to early exit</span></div><div class="line"><span class="comment">    ///   and stop rasterization to the destination leaf node.</span></div><div class="line"><span class="comment"></span>    <span class="keyword">inline</span> <span class="keywordtype">bool</span> endPointLeaf(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v12__1_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">PointDataTree::LeafNodeType</a>&amp; leaf);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  The finalization function for the given destination tree(s).</span></div><div class="line"><span class="comment">    /// @param origin  The leaf origin of the topology being accessed</span></div><div class="line"><span class="comment">    /// @param idx     The leaf index of the topology being accessed</span></div><div class="line"><span class="comment">    /// @return  Return true to stop, false to recursively rasterize</span></div><div class="line"><span class="comment"></span>    <span class="keyword">inline</span> <span class="keywordtype">bool</span> finalize(<span class="keyword">const</span> Coord&amp; origin, <span class="keywordtype">size_t</span> idx);</div><div class="line">};</div></div><!-- fragment --></li>
</ul>
</dd></dl>
<p>Below is a full example using the native components.</p>
<div class="fragment"><div class="line"><span class="comment">/// @brief Sum point distances into a target float tree</span></div><div class="line"><span class="comment"></span><span class="comment">///   Note: Using TransformTransfer to handle different index spaces, and</span></div><div class="line"><span class="comment"></span><span class="comment">///   VolumeTransfer for automatic buffer setup</span></div><div class="line"><span class="comment"></span><span class="keyword">struct </span>MyTransfer :</div><div class="line">    <span class="keyword">public</span> <a class="code" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html#af0adf292877ed1cd7955bd4c752dc12e">TransformTransfer</a>,</div><div class="line">    <span class="keyword">public</span> VolumeTransfer&lt;FloatTree&gt;</div><div class="line">{</div><div class="line">    MyTransfer(<a class="code" href="namespaceopenvdb_1_1v12__1.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a>&amp; dest, <span class="keyword">const</span> <a class="code" href="namespaceopenvdb_1_1v12__1_1_1points.html#acf438a63a8a41ec38b6d7ceae6467678">PointDataGrid</a>&amp; source)</div><div class="line">        : <a class="code" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html#af0adf292877ed1cd7955bd4c752dc12e">TransformTransfer</a>(source.transform(), dest.transform())</div><div class="line">        , VolumeTransfer(dest.tree()) {}</div><div class="line"></div><div class="line">    MyTransfer(<span class="keyword">const</span> MyTransfer&amp; other)</div><div class="line">        : <a class="code" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html#af0adf292877ed1cd7955bd4c752dc12e">TransformTransfer</a>(other)</div><div class="line">        , VolumeTransfer(other) {}</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief Range in index space of the source points</span></div><div class="line"><span class="comment"></span>    <a class="code" href="namespaceopenvdb_1_1v12__1_1_1math.html#adf6e1d7d066bb09da957cc89f2b3ceb2">Vec3i</a> range(<span class="keyword">const</span> Coord&amp;, <span class="keywordtype">size_t</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="namespaceopenvdb_1_1v12__1_1_1math.html#adf6e1d7d066bb09da957cc89f2b3ceb2">Vec3i</a>(1); }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief Every time we start a new point leaf, init the position array.</span></div><div class="line"><span class="comment">    ///   Always return true as we don&#39;t skip any leaf nodes.</span></div><div class="line"><span class="comment"></span>    <span class="keywordtype">bool</span> startPointLeaf(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v12__1_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">PointDataTree::LeafNodeType</a>&amp; leaf)</div><div class="line">    {</div><div class="line">        <span class="comment">// @note consider caching the indices to &quot;P&quot; and &quot;mygroup&quot; for faster lookups</span></div><div class="line">        mHandle = std::make_unique&lt;AttributeHandle&lt;Vec3f&gt;&gt;(leaf.constAttributeArray(<span class="stringliteral">&quot;P&quot;</span>));</div><div class="line">        mFilter = std::make_unique&lt;GroupFilter&gt;(<span class="stringliteral">&quot;mygroup&quot;</span>, leaf.attributeSet());</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief  For each point, compute its relative index space position in</span></div><div class="line"><span class="comment">    ///   the destination tree and sum the length of its distance</span></div><div class="line"><span class="comment"></span>    <span class="keywordtype">void</span> rasterizePoint(<span class="keyword">const</span> Coord&amp; ijk, <span class="keyword">const</span> Index <span class="keywordtype">id</span>, <span class="keyword">const</span> CoordBBox&amp; bounds)</div><div class="line">    {</div><div class="line">        <span class="comment">// skip points not in &quot;mygroup&quot;</span></div><div class="line">        <span class="keywordflow">if</span> (!mFilter-&gt;valid(&amp;<span class="keywordtype">id</span>)) <span class="keywordflow">return</span>;</div><div class="line">        <a class="code" href="namespaceopenvdb_1_1v12__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">Vec3d</a> P = ijk.asVec3d() + <a class="code" href="namespaceopenvdb_1_1v12__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">Vec3d</a>(this-&gt;mHandle-&gt;get(<span class="keywordtype">id</span>));</div><div class="line">        P = this-&gt;<a class="code" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html#af706ba490b42b827fce576b17a4051d8">transformSourceToTarget</a>(P); <span class="comment">// TransformTransfer::transformSourceToTarget</span></div><div class="line">        <span class="comment">// for each active voxel, accumulate distance</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>* mask = this-&gt;mask(); <span class="comment">// VolumeTransfer::mask</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; coord : bounds) {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="namespaceopenvdb_1_1v12__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> voxel = FloatTree::LeafNodeType::coordToOffset(coord);</div><div class="line">            <span class="keywordflow">if</span> (!mask-&gt;isOn(voxel)) <span class="keywordflow">continue</span>;</div><div class="line">            <a class="code" href="namespaceopenvdb_1_1v12__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">Vec3d</a> dist = coord.asVec3d() - P;</div><div class="line">            this-&gt;buffer()[voxel] += dist.<a class="code" href="classopenvdb_1_1v12__1_1_1math_1_1Vec3.html#ac391672014f7b4faed37018787333e4b">length</a>(); <span class="comment">// VolumeTransfer::buffer</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    /// @brief Return true for endPointLeaf() to continue, false for finalize() so</span></div><div class="line"><span class="comment">    ///   we don&#39;t recurse.</span></div><div class="line"><span class="comment"></span>    <span class="keywordtype">bool</span> endPointLeaf(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v12__1_1_1tree_1_1Tree.html#ad69afaa4f94a67ce2f7d0b18b339291e">PointDataTree::LeafNodeType</a>&amp;) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div><div class="line">    <span class="keywordtype">bool</span> finalize(<span class="keyword">const</span> Coord&amp;, <span class="keywordtype">size_t</span>) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::unique_ptr&lt;AttributeHandle&lt;Vec3f&gt;&gt; mHandle {<span class="keyword">nullptr</span>};</div><div class="line">    std::unique_ptr&lt;GroupFilter&gt; mFilter {<span class="keyword">nullptr</span>};</div><div class="line">};</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af0adf292877ed1cd7955bd4c752dc12e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v12__1_1_1points_1_1TransformTransfer.html">TransformTransfer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v12__1_1_1math_1_1Transform.html">math::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v12__1_1_1math_1_1Transform.html">math::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>tt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a86590a233121178127b187016c1408b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v12__1_1_1math_1_1Transform.html">math::Transform</a>&amp; sourceTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a067c02b91ad0939bf44151e40d47d9ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v12__1_1_1math_1_1Transform.html">math::Transform</a>&amp; targetTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af706ba490b42b827fce576b17a4051d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto transformSourceToTarget </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af6aa11d3ec06afc2287e01845944a6ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto transformTargetToSource </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
