<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: Utils.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6b5a99191d79160345fea4068dd59b89.html">openvdb_ax</a></li><li class="navelem"><a class="el" href="dir_cae5b229f742550e00edd472eaaf99f1.html">openvdb_ax</a></li><li class="navelem"><a class="el" href="dir_de747e3eb4c4c2c23b38546883fd0233.html">codegen</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">openvdb_ax/openvdb_ax/codegen/Utils.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility code generation methods for performing various llvm operations.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="ax_2openvdb__ax_2codegen_2Types_8h_source.html">Types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Tokens_8h_source.html">../ast/Tokens.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ax_2openvdb__ax_2Exceptions_8h_source.html">../Exceptions.h</a>&quot;</code><br />
<code>#include &lt;<a class="el" href="version_8h_source.html">openvdb/version.h</a>&gt;</code><br />
<code>#include &lt;llvm/IR/IRBuilder.h&gt;</code><br />
<code>#include &lt;llvm/IR/LLVMContext.h&gt;</code><br />
<code>#include &lt;llvm/Support/raw_ostream.h&gt;</code><br />
</div>
<p><a href="openvdb__ax_2openvdb__ax_2codegen_2Utils_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceopenvdb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb.html">openvdb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0.html">openvdb::v8_0</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1ax"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax.html">openvdb::v8_0::ax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html">openvdb::v8_0::ax::codegen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9fa676ff0f183beeb7ce9d4a5158c52c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openvdb__ax_2openvdb__ax_2codegen_2Utils_8h.html#a9fa676ff0f183beeb7ce9d4a5158c52c">BIND_ARITHMETIC_CAST_OP</a>(Function,  Twine)</td></tr>
<tr class="separator:a9fa676ff0f183beeb7ce9d4a5158c52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace87667103f79d4094575e2411da5ffc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openvdb__ax_2openvdb__ax_2codegen_2Utils_8h.html#ace87667103f79d4094575e2411da5ffc">BIND_BINARY_OP</a>(Function)</td></tr>
<tr class="separator:ace87667103f79d4094575e2411da5ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a86b6ff3a4013769265f8c3dee2cbf17b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a86b6ff3a4013769265f8c3dee2cbf17b">CastFunction</a> = std::function&lt; llvm::Value *(llvm::IRBuilder&lt;&gt; &amp;, llvm::Value *, llvm::Type *)&gt;</td></tr>
<tr class="separator:a86b6ff3a4013769265f8c3dee2cbf17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af036ec3b03ba7981a9af071bce3c7648"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#af036ec3b03ba7981a9af071bce3c7648">BinaryFunction</a> = std::function&lt; llvm::Value *(llvm::IRBuilder&lt;&gt; &amp;, llvm::Value *, llvm::Value *)&gt;</td></tr>
<tr class="separator:af036ec3b03ba7981a9af071bce3c7648"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9b8dc85816cb96a8cf0f4a3d90f57eac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a9b8dc85816cb96a8cf0f4a3d90f57eac">valuesToTypes</a> (const std::vector&lt; llvm::Value * &gt; &amp;values, std::vector&lt; llvm::Type * &gt; &amp;types)</td></tr>
<tr class="memdesc:a9b8dc85816cb96a8cf0f4a3d90f57eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a vector of llvm Types from a vector of llvm values.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a9b8dc85816cb96a8cf0f4a3d90f57eac">More...</a><br /></td></tr>
<tr class="separator:a9b8dc85816cb96a8cf0f4a3d90f57eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cea9b545c0751cdc7e10891e9004cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a05cea9b545c0751cdc7e10891e9004cb">llvmTypeToString</a> (const llvm::Type *const type, std::string &amp;str)</td></tr>
<tr class="memdesc:a05cea9b545c0751cdc7e10891e9004cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints an llvm type to a std string.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a05cea9b545c0751cdc7e10891e9004cb">More...</a><br /></td></tr>
<tr class="separator:a05cea9b545c0751cdc7e10891e9004cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e48c04531a4f86902302a3c0b06dd9"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#ae2e48c04531a4f86902302a3c0b06dd9">getBaseContainedType</a> (llvm::Type *const type)</td></tr>
<tr class="memdesc:ae2e48c04531a4f86902302a3c0b06dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base llvm value which is being pointed to through any number of layered pointers.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#ae2e48c04531a4f86902302a3c0b06dd9">More...</a><br /></td></tr>
<tr class="separator:ae2e48c04531a4f86902302a3c0b06dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf5db5e6d0f2ccd96c5eb6de2bfc693"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a3bf5db5e6d0f2ccd96c5eb6de2bfc693"><td class="memTemplItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a3bf5db5e6d0f2ccd96c5eb6de2bfc693">llvmPointerFromAddress</a> (const ValueT *const &amp;ptr, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a3bf5db5e6d0f2ccd96c5eb6de2bfc693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an llvm value representing a pointer to the provided ptr builtin ValueT.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a3bf5db5e6d0f2ccd96c5eb6de2bfc693">More...</a><br /></td></tr>
<tr class="separator:a3bf5db5e6d0f2ccd96c5eb6de2bfc693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab073bc74a39de15c4872311424b3add8"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#ab073bc74a39de15c4872311424b3add8">insertStaticAlloca</a> (llvm::IRBuilder&lt;&gt; &amp;B, llvm::Type *type, llvm::Value *size=nullptr)</td></tr>
<tr class="memdesc:ab073bc74a39de15c4872311424b3add8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a stack allocation at the beginning of the current function of the provided type and size. The IRBuilder's insertion point must be set to a BasicBlock with a valid <a class="el" href="structopenvdb_1_1v8__0_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a> parent.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#ab073bc74a39de15c4872311424b3add8">More...</a><br /></td></tr>
<tr class="separator:ab073bc74a39de15c4872311424b3add8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e15a3c0fd2a28fd7aa58e2c58225d24"><td class="memItemLeft" align="right" valign="top">llvm::Argument *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a8e15a3c0fd2a28fd7aa58e2c58225d24">extractArgument</a> (llvm::Function *F, const size_t idx)</td></tr>
<tr class="separator:a8e15a3c0fd2a28fd7aa58e2c58225d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651218b2cd471b6715cfbe99e1a2752e"><td class="memItemLeft" align="right" valign="top">llvm::Argument *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a651218b2cd471b6715cfbe99e1a2752e">extractArgument</a> (llvm::Function *F, const std::string &amp;name)</td></tr>
<tr class="separator:a651218b2cd471b6715cfbe99e1a2752e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea29d5a8fa2dabb1559d844d15d21e2"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#aaea29d5a8fa2dabb1559d844d15d21e2">typePrecedence</a> (llvm::Type *const typeA, llvm::Type *const typeB)</td></tr>
<tr class="memdesc:aaea29d5a8fa2dabb1559d844d15d21e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest order type from two LLVM Scalar types.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#aaea29d5a8fa2dabb1559d844d15d21e2">More...</a><br /></td></tr>
<tr class="separator:aaea29d5a8fa2dabb1559d844d15d21e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3139b979c14b7cf3f676d69b826cc68"><td class="memItemLeft" align="right" valign="top">CastFunction&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#ae3139b979c14b7cf3f676d69b826cc68">llvmArithmeticConversion</a> (const llvm::Type *const sourceType, const llvm::Type *const targetType, const std::string &amp;twine=&quot;&quot;)</td></tr>
<tr class="memdesc:ae3139b979c14b7cf3f676d69b826cc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a CastFunction which represents the corresponding instruction to convert a source llvm Type to a target llvm Type. If the conversion is unsupported, throws an error.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#ae3139b979c14b7cf3f676d69b826cc68">More...</a><br /></td></tr>
<tr class="separator:ae3139b979c14b7cf3f676d69b826cc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfd3d49cfd8296659fd3c3e32e79b3f"><td class="memItemLeft" align="right" valign="top">BinaryFunction&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#aacfd3d49cfd8296659fd3c3e32e79b3f">llvmBinaryConversion</a> (const llvm::Type *const type, const ast::tokens::OperatorToken &amp;token, const std::string &amp;twine=&quot;&quot;)</td></tr>
<tr class="memdesc:aacfd3d49cfd8296659fd3c3e32e79b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a BinaryFunction representing the corresponding instruction to peform on two scalar values, relative to a provided operator token. Note that not all operations are supported on floating point types! If the token is not supported, or the llvm type is not a scalar type, throws an error.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#aacfd3d49cfd8296659fd3c3e32e79b3f">More...</a><br /></td></tr>
<tr class="separator:aacfd3d49cfd8296659fd3c3e32e79b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad707eac230d2ab47234b968575f980e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#ad707eac230d2ab47234b968575f980e1">isValidCast</a> (llvm::Type *from, llvm::Type *to)</td></tr>
<tr class="memdesc:ad707eac230d2ab47234b968575f980e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the llvm Type 'from' can be safely cast to the llvm Type 'to'.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#ad707eac230d2ab47234b968575f980e1">More...</a><br /></td></tr>
<tr class="separator:ad707eac230d2ab47234b968575f980e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5973c2d86403c4267f458f770dc288b6"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a5973c2d86403c4267f458f770dc288b6">arithmeticConversion</a> (llvm::Value *value, llvm::Type *targetType, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a5973c2d86403c4267f458f770dc288b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a scalar llvm Value to a target scalar llvm Type. Returns the cast scalar value of type targetType.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a5973c2d86403c4267f458f770dc288b6">More...</a><br /></td></tr>
<tr class="separator:a5973c2d86403c4267f458f770dc288b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e14569382f99ffcb953baac085eb441"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a1e14569382f99ffcb953baac085eb441">arrayCast</a> (llvm::Value *ptrToArray, llvm::Type *targetElementType, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a1e14569382f99ffcb953baac085eb441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts an array to another array of equal size but of a different element type. Both source and target array element types must be scalar types. The source array llvm Value should be a pointer to the array to cast.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a1e14569382f99ffcb953baac085eb441">More...</a><br /></td></tr>
<tr class="separator:a1e14569382f99ffcb953baac085eb441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcd8bdda510b27a9e49801353b9f84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a3fcd8bdda510b27a9e49801353b9f84b">arithmeticConversion</a> (std::vector&lt; llvm::Value * &gt; &amp;values, llvm::Type *targetElementType, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a3fcd8bdda510b27a9e49801353b9f84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of loaded llvm scalar values of the same type to a target scalar type. Each value is converted individually and the loaded result stored in the same location within values.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a3fcd8bdda510b27a9e49801353b9f84b">More...</a><br /></td></tr>
<tr class="separator:a3fcd8bdda510b27a9e49801353b9f84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df3bf061a5f5d38bfb589fc213070e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a3df3bf061a5f5d38bfb589fc213070e0">arithmeticConversion</a> (std::vector&lt; llvm::Value * &gt; &amp;values, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a3df3bf061a5f5d38bfb589fc213070e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of loaded llvm scalar values to the highest precision type stored amongst them. Any values which are not scalar types are ignored.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a3df3bf061a5f5d38bfb589fc213070e0">More...</a><br /></td></tr>
<tr class="separator:a3df3bf061a5f5d38bfb589fc213070e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61c7c709fdc868553e7e37ad8a3532a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#ab61c7c709fdc868553e7e37ad8a3532a">arithmeticConversion</a> (llvm::Value *&amp;valueA, llvm::Value *&amp;valueB, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:ab61c7c709fdc868553e7e37ad8a3532a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses the highest order llvm Type as defined by typePrecedence from either of the two incoming values and casts the other value to the choosen type if it is not already. The types of valueA and valueB are guaranteed to match. Both values must be scalar LLVM types.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#ab61c7c709fdc868553e7e37ad8a3532a">More...</a><br /></td></tr>
<tr class="separator:ab61c7c709fdc868553e7e37ad8a3532a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e4b8b7d3f4148c224f8e9e1770b906"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a07e4b8b7d3f4148c224f8e9e1770b906">boolComparison</a> (llvm::Value *value, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a07e4b8b7d3f4148c224f8e9e1770b906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a C style boolean comparison from a given scalar LLVM value.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a07e4b8b7d3f4148c224f8e9e1770b906">More...</a><br /></td></tr>
<tr class="separator:a07e4b8b7d3f4148c224f8e9e1770b906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40ce6adbdbaeaa848a4f0e1c251293e"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#ad40ce6adbdbaeaa848a4f0e1c251293e">binaryOperator</a> (llvm::Value *lhs, llvm::Value *rhs, const ast::tokens::OperatorToken &amp;token, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="separator:ad40ce6adbdbaeaa848a4f0e1c251293e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c45ea406e261f970837bc26aed09c8"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#ad4c45ea406e261f970837bc26aed09c8">arrayIndexUnpack</a> (llvm::Value *ptrToArray, const int16_t index, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:ad4c45ea406e261f970837bc26aed09c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a particular element of an array and return a pointer to that element The provided llvm Value is expected to be a pointer to an array.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#ad4c45ea406e261f970837bc26aed09c8">More...</a><br /></td></tr>
<tr class="separator:ad4c45ea406e261f970837bc26aed09c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bff6d440f9e779e1f3daa9da25ba29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a08bff6d440f9e779e1f3daa9da25ba29">arrayUnpack</a> (llvm::Value *ptrToArray, std::vector&lt; llvm::Value * &gt; &amp;values, llvm::IRBuilder&lt;&gt; &amp;builder, const bool loadElements=false)</td></tr>
<tr class="memdesc:a08bff6d440f9e779e1f3daa9da25ba29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack an array type into llvm Values which represent all its elements The provided llvm Value is expected to be a pointer to an array If loadElements is true, values will store loaded llvm values instead of pointers to the array elements.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a08bff6d440f9e779e1f3daa9da25ba29">More...</a><br /></td></tr>
<tr class="separator:a08bff6d440f9e779e1f3daa9da25ba29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad559a79fafbf5a3be7230c598d9fc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#aaad559a79fafbf5a3be7230c598d9fc7">array3Unpack</a> (llvm::Value *ptrToArray, llvm::Value *&amp;value1, llvm::Value *&amp;value2, llvm::Value *&amp;value3, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:aaad559a79fafbf5a3be7230c598d9fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack the first three elements of an array. The provided llvm Value is expected to be a pointer to an array.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#aaad559a79fafbf5a3be7230c598d9fc7">More...</a><br /></td></tr>
<tr class="separator:aaad559a79fafbf5a3be7230c598d9fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa0c53ec14d376e8a5267a686ded535"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a6fa0c53ec14d376e8a5267a686ded535">array3Pack</a> (llvm::Value *value1, llvm::Value *value2, llvm::Value *value3, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a6fa0c53ec14d376e8a5267a686ded535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack three values into a new array and return a pointer to the newly allocated array. If the values are of a mismatching type, the highets order type is uses, as defined by typePrecedence. All llvm values are expected to a be a loaded scalar type.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a6fa0c53ec14d376e8a5267a686ded535">More...</a><br /></td></tr>
<tr class="separator:a6fa0c53ec14d376e8a5267a686ded535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c5ca2083a3ee7d0909b217c359c545"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a22c5ca2083a3ee7d0909b217c359c545">arrayPack</a> (llvm::Value *value, llvm::IRBuilder&lt;&gt; &amp;builder, const size_t size=3)</td></tr>
<tr class="memdesc:a22c5ca2083a3ee7d0909b217c359c545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a loaded llvm scalar value into a new array of a specified size and return a pointer to the newly allocated array. Each element of the new array will have the value of the given scalar.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a22c5ca2083a3ee7d0909b217c359c545">More...</a><br /></td></tr>
<tr class="separator:a22c5ca2083a3ee7d0909b217c359c545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d0ac9d3b004eea7bf7be377b2168cc"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a59d0ac9d3b004eea7bf7be377b2168cc">arrayPack</a> (const std::vector&lt; llvm::Value * &gt; &amp;values, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a59d0ac9d3b004eea7bf7be377b2168cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a vector of loaded llvm scalar values into a new array of equal size and return a pointer to the newly allocated array.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a59d0ac9d3b004eea7bf7be377b2168cc">More...</a><br /></td></tr>
<tr class="separator:a59d0ac9d3b004eea7bf7be377b2168cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897cba60c353f2d3080ce20a2bd6ddc9"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a897cba60c353f2d3080ce20a2bd6ddc9">arrayPackCast</a> (std::vector&lt; llvm::Value * &gt; &amp;values, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a897cba60c353f2d3080ce20a2bd6ddc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a vector of loaded llvm scalar values into a new array of equal size and return a pointer to the newly allocated array. arrayPackCast first checks all the contained types in values and casts all types to the highest order type present. All llvm values in values are expected to be loaded scalar types.  <a href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a897cba60c353f2d3080ce20a2bd6ddc9">More...</a><br /></td></tr>
<tr class="separator:a897cba60c353f2d3080ce20a2bd6ddc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e589274555ebdd18be770ce2137a502"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__0_1_1ax_1_1codegen.html#a9e589274555ebdd18be770ce2137a502">scalarToMatrix</a> (llvm::Value *scalar, llvm::IRBuilder&lt;&gt; &amp;builder, const size_t dim=3)</td></tr>
<tr class="separator:a9e589274555ebdd18be770ce2137a502"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility code generation methods for performing various llvm operations. </p>
<dl class="section author"><dt>Authors</dt><dd>Nick Avramoussis </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a9fa676ff0f183beeb7ce9d4a5158c52c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIND_ARITHMETIC_CAST_OP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Function, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Twine&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">std::bind(&amp;Function, \</div><div class="line">        std::placeholders::_1, \</div><div class="line">        std::placeholders::_2, \</div><div class="line">        std::placeholders::_3, \</div><div class="line">        Twine)</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ace87667103f79d4094575e2411da5ffc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIND_BINARY_OP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Function</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">[twine](llvm::IRBuilder&lt;&gt;&amp; B, llvm::Value* L, llvm::Value* R) \</div><div class="line">        -&gt; llvm::Value* { <span class="keywordflow">return</span> B.Function(L, R, twine); }</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
