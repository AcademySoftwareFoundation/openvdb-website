<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: openvdb_ax/codegen/Utils.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">12.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_cae5b229f742550e00edd472eaaf99f1.html">openvdb_ax</a></li><li class="navelem"><a class="el" href="dir_de747e3eb4c4c2c23b38546883fd0233.html">codegen</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utils.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility code generation methods for performing various llvm operations.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="ax_2openvdb__ax_2codegen_2Types_8h_source.html">Types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Tokens_8h_source.html">../ast/Tokens.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ax_2openvdb__ax_2Exceptions_8h_source.html">../Exceptions.h</a>&quot;</code><br />
<code>#include &lt;openvdb/version.h&gt;</code><br />
<code>#include &lt;<a class="el" href="Assert_8h_source.html">openvdb/util/Assert.h</a>&gt;</code><br />
<code>#include &lt;llvm/IR/IRBuilder.h&gt;</code><br />
<code>#include &lt;llvm/IR/LLVMContext.h&gt;</code><br />
<code>#include &lt;llvm/Support/raw_ostream.h&gt;</code><br />
</div>
<p><a href="openvdb__ax_2openvdb__ax_2codegen_2Utils_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceopenvdb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb.html">openvdb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v12__1"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1.html">openvdb::v12_1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v12__1_1_1ax"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax.html">openvdb::v12_1::ax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html">openvdb::v12_1::ax::codegen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9fa676ff0f183beeb7ce9d4a5158c52c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openvdb__ax_2openvdb__ax_2codegen_2Utils_8h.html#a9fa676ff0f183beeb7ce9d4a5158c52c">BIND_ARITHMETIC_CAST_OP</a>(Function,  Twine)</td></tr>
<tr class="separator:a9fa676ff0f183beeb7ce9d4a5158c52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba589b49ea5ccbdea7e4417509f50277"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openvdb__ax_2openvdb__ax_2codegen_2Utils_8h.html#aba589b49ea5ccbdea7e4417509f50277">BIND_ARITHMETIC_CAST_OP_TRUNC</a>(Function,  Twine)</td></tr>
<tr class="separator:aba589b49ea5ccbdea7e4417509f50277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f40ebf4d788475bc57181584622a3e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openvdb__ax_2openvdb__ax_2codegen_2Utils_8h.html#a5f40ebf4d788475bc57181584622a3e6">BIND_ARITHMETIC_CAST_OP_UIFP</a>(Function,  Twine)</td></tr>
<tr class="separator:a5f40ebf4d788475bc57181584622a3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cf193324e7a5fa1a28c5332a1af3ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openvdb__ax_2openvdb__ax_2codegen_2Utils_8h.html#a22cf193324e7a5fa1a28c5332a1af3ef">BIND_ARITHMETIC_CAST_OP_ZEXT</a>(Function,  Twine)</td></tr>
<tr class="separator:a22cf193324e7a5fa1a28c5332a1af3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091bebe60f222e83d4647eb45180754e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openvdb__ax_2openvdb__ax_2codegen_2Utils_8h.html#a091bebe60f222e83d4647eb45180754e">BIND_ARITHMETIC_CAST_OP_FP</a>(Function,  Twine)</td></tr>
<tr class="separator:a091bebe60f222e83d4647eb45180754e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace87667103f79d4094575e2411da5ffc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openvdb__ax_2openvdb__ax_2codegen_2Utils_8h.html#ace87667103f79d4094575e2411da5ffc">BIND_BINARY_OP</a>(Function)</td></tr>
<tr class="separator:ace87667103f79d4094575e2411da5ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a86b6ff3a4013769265f8c3dee2cbf17b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a86b6ff3a4013769265f8c3dee2cbf17b">CastFunction</a> = std::function&lt; llvm::Value *(llvm::IRBuilder&lt;&gt; &amp;, llvm::Value *, llvm::Type *)&gt;</td></tr>
<tr class="separator:a86b6ff3a4013769265f8c3dee2cbf17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af036ec3b03ba7981a9af071bce3c7648"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#af036ec3b03ba7981a9af071bce3c7648">BinaryFunction</a> = std::function&lt; llvm::Value *(llvm::IRBuilder&lt;&gt; &amp;, llvm::Value *, llvm::Value *)&gt;</td></tr>
<tr class="separator:af036ec3b03ba7981a9af071bce3c7648"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aead5a912ed66d0e49a23bd1d6898a53f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#aead5a912ed66d0e49a23bd1d6898a53f">AssertOpaquePtrs</a> ([[maybe_unused]]llvm::Value *opaque, [[maybe_unused]]llvm::Type *type)</td></tr>
<tr class="separator:aead5a912ed66d0e49a23bd1d6898a53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06dfcb1f366de8b74fa116e247d3d7e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a06dfcb1f366de8b74fa116e247d3d7e8">valuesToTypes</a> (const std::vector&lt; llvm::Value * &gt; &amp;values, std::vector&lt; llvm::Type * &gt; &amp;types)</td></tr>
<tr class="memdesc:a06dfcb1f366de8b74fa116e247d3d7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a vector of llvm Types from a vector of llvm values.  <a href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a06dfcb1f366de8b74fa116e247d3d7e8">More...</a><br /></td></tr>
<tr class="separator:a06dfcb1f366de8b74fa116e247d3d7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace85c5a2d3d7f1466270ea0903aca467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#ace85c5a2d3d7f1466270ea0903aca467">llvmTypeToString</a> (const llvm::Type *const type, std::string &amp;str)</td></tr>
<tr class="memdesc:ace85c5a2d3d7f1466270ea0903aca467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints an llvm type to a std string.  <a href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#ace85c5a2d3d7f1466270ea0903aca467">More...</a><br /></td></tr>
<tr class="separator:ace85c5a2d3d7f1466270ea0903aca467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5285949a98b311d957dbe2570e40fee7"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a5285949a98b311d957dbe2570e40fee7"><td class="memTemplItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a5285949a98b311d957dbe2570e40fee7">llvmPointerFromAddress</a> (const ValueT *const &amp;ptr, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a5285949a98b311d957dbe2570e40fee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an llvm value representing a pointer to the provided ptr builtin ValueT.  <a href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a5285949a98b311d957dbe2570e40fee7">More...</a><br /></td></tr>
<tr class="separator:a5285949a98b311d957dbe2570e40fee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0603ef0ae535223941f8963b511978c9"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a0603ef0ae535223941f8963b511978c9">insertStaticAlloca</a> (llvm::IRBuilder&lt;&gt; &amp;B, llvm::Type *type, llvm::Value *size=nullptr)</td></tr>
<tr class="memdesc:a0603ef0ae535223941f8963b511978c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a stack allocation at the beginning of the current function of the provided type and size. The IRBuilder's insertion point must be set to a BasicBlock with a valid <a class="el" href="structopenvdb_1_1v12__1_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a> parent.  <a href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a0603ef0ae535223941f8963b511978c9">More...</a><br /></td></tr>
<tr class="separator:a0603ef0ae535223941f8963b511978c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeec70e79104577418848cae1a4a4866"><td class="memItemLeft" align="right" valign="top">llvm::Argument *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#aaeec70e79104577418848cae1a4a4866">extractArgument</a> (llvm::Function *F, const size_t idx)</td></tr>
<tr class="separator:aaeec70e79104577418848cae1a4a4866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c7c4b920e91c72d1cf5b4564ee2ad8"><td class="memItemLeft" align="right" valign="top">llvm::Argument *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a87c7c4b920e91c72d1cf5b4564ee2ad8">extractArgument</a> (llvm::Function *F, const std::string &amp;name)</td></tr>
<tr class="separator:a87c7c4b920e91c72d1cf5b4564ee2ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e0f2789af28ccf37b40296971d902c"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a69e0f2789af28ccf37b40296971d902c">typePrecedence</a> (llvm::Type *const typeA, llvm::Type *const typeB)</td></tr>
<tr class="memdesc:a69e0f2789af28ccf37b40296971d902c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest order type from two LLVM Scalar types.  <a href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a69e0f2789af28ccf37b40296971d902c">More...</a><br /></td></tr>
<tr class="separator:a69e0f2789af28ccf37b40296971d902c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94315b7704f558cfa3f1dc0d8123efaa"><td class="memItemLeft" align="right" valign="top">CastFunction&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a94315b7704f558cfa3f1dc0d8123efaa">llvmArithmeticConversion</a> (const llvm::Type *const sourceType, const llvm::Type *const targetType, const std::string &amp;twine=&quot;&quot;)</td></tr>
<tr class="memdesc:a94315b7704f558cfa3f1dc0d8123efaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a CastFunction which represents the corresponding instruction to convert a source llvm Type to a target llvm Type. If the conversion is unsupported, throws an error.  <a href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a94315b7704f558cfa3f1dc0d8123efaa">More...</a><br /></td></tr>
<tr class="separator:a94315b7704f558cfa3f1dc0d8123efaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb768f5671dc7148e9934d1ea1d763ea"><td class="memItemLeft" align="right" valign="top">BinaryFunction&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#abb768f5671dc7148e9934d1ea1d763ea">llvmBinaryConversion</a> (const llvm::Type *const type, const ast::tokens::OperatorToken &amp;token, const std::string &amp;twine=&quot;&quot;)</td></tr>
<tr class="memdesc:abb768f5671dc7148e9934d1ea1d763ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a BinaryFunction representing the corresponding instruction to perform on two scalar values, relative to a provided operator token. Note that not all operations are supported on floating point types! If the token is not supported, or the llvm type is not a scalar type, throws an error.  <a href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#abb768f5671dc7148e9934d1ea1d763ea">More...</a><br /></td></tr>
<tr class="separator:abb768f5671dc7148e9934d1ea1d763ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750a6142cbfc3b01bdfa2e73b937ca31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a750a6142cbfc3b01bdfa2e73b937ca31">isValidCast</a> (llvm::Type *from, llvm::Type *to)</td></tr>
<tr class="memdesc:a750a6142cbfc3b01bdfa2e73b937ca31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the llvm Type 'from' can be safely cast to the llvm Type 'to'.  <a href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a750a6142cbfc3b01bdfa2e73b937ca31">More...</a><br /></td></tr>
<tr class="separator:a750a6142cbfc3b01bdfa2e73b937ca31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8785101ed9b15b1c62986804ce7578"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a8f8785101ed9b15b1c62986804ce7578">arithmeticConversion</a> (llvm::Value *value, llvm::Type *targetType, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a8f8785101ed9b15b1c62986804ce7578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a scalar llvm <a class="el" href="classopenvdb_1_1v12__1_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances. ">Value</a> to a target scalar llvm Type. Returns the cast scalar value of type targetType.  <a href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a8f8785101ed9b15b1c62986804ce7578">More...</a><br /></td></tr>
<tr class="separator:a8f8785101ed9b15b1c62986804ce7578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1066ddb1e1bbbe4fc2da5dbcbdb7932"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#af1066ddb1e1bbbe4fc2da5dbcbdb7932">arithmeticConversion</a> (std::vector&lt; llvm::Value * &gt; &amp;values, llvm::Type *targetElementType, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:af1066ddb1e1bbbe4fc2da5dbcbdb7932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of loaded llvm scalar values of the same type to a target scalar type. Each value is converted individually and the loaded result stored in the same location within values.  <a href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#af1066ddb1e1bbbe4fc2da5dbcbdb7932">More...</a><br /></td></tr>
<tr class="separator:af1066ddb1e1bbbe4fc2da5dbcbdb7932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bed41edb6563469fd066d612ba5273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#ab4bed41edb6563469fd066d612ba5273">arithmeticConversion</a> (std::vector&lt; llvm::Value * &gt; &amp;values, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:ab4bed41edb6563469fd066d612ba5273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of loaded llvm scalar values to the highest precision type stored amongst them. Any values which are not scalar types are ignored.  <a href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#ab4bed41edb6563469fd066d612ba5273">More...</a><br /></td></tr>
<tr class="separator:ab4bed41edb6563469fd066d612ba5273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a54cac5ea8be3c818cd3dbb20e1db9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#af3a54cac5ea8be3c818cd3dbb20e1db9">arithmeticConversion</a> (llvm::Value *&amp;valueA, llvm::Value *&amp;valueB, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:af3a54cac5ea8be3c818cd3dbb20e1db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses the highest order llvm Type as defined by typePrecedence from either of the two incoming values and casts the other value to the choosen type if it is not already. The types of valueA and valueB are guaranteed to match. Both values must be scalar LLVM types.  <a href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#af3a54cac5ea8be3c818cd3dbb20e1db9">More...</a><br /></td></tr>
<tr class="separator:af3a54cac5ea8be3c818cd3dbb20e1db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85271379aac84d291632075fbe48069d"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a85271379aac84d291632075fbe48069d">boolComparison</a> (llvm::Value *value, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="memdesc:a85271379aac84d291632075fbe48069d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a C style boolean comparison from a given scalar LLVM value.  <a href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#a85271379aac84d291632075fbe48069d">More...</a><br /></td></tr>
<tr class="separator:a85271379aac84d291632075fbe48069d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9378b626f6d4ffb6ba873c9d39b0327"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v12__1_1_1ax_1_1codegen.html#ac9378b626f6d4ffb6ba873c9d39b0327">binaryOperator</a> (llvm::Value *lhs, llvm::Value *rhs, const ast::tokens::OperatorToken &amp;token, llvm::IRBuilder&lt;&gt; &amp;builder)</td></tr>
<tr class="separator:ac9378b626f6d4ffb6ba873c9d39b0327"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility code generation methods for performing various llvm operations. </p>
<dl class="section author"><dt>Authors</dt><dd>Nick Avramoussis </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a9fa676ff0f183beeb7ce9d4a5158c52c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIND_ARITHMETIC_CAST_OP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Function, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Twine&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">std::bind(&amp;Function, \</div><div class="line">        std::placeholders::_1, \</div><div class="line">        std::placeholders::_2, \</div><div class="line">        std::placeholders::_3, \</div><div class="line">        Twine)</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a091bebe60f222e83d4647eb45180754e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIND_ARITHMETIC_CAST_OP_FP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Function, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Twine&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">std::bind(&amp;Function, \</div><div class="line">        std::placeholders::_1, \</div><div class="line">        std::placeholders::_2, \</div><div class="line">        std::placeholders::_3, \</div><div class="line">        Twine)</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aba589b49ea5ccbdea7e4417509f50277"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIND_ARITHMETIC_CAST_OP_TRUNC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Function, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Twine&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">std::bind(&amp;Function, \</div><div class="line">        std::placeholders::_1, \</div><div class="line">        std::placeholders::_2, \</div><div class="line">        std::placeholders::_3, \</div><div class="line">        Twine)</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5f40ebf4d788475bc57181584622a3e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIND_ARITHMETIC_CAST_OP_UIFP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Function, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Twine&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">std::bind(&amp;Function, \</div><div class="line">        std::placeholders::_1, \</div><div class="line">        std::placeholders::_2, \</div><div class="line">        std::placeholders::_3, \</div><div class="line">        Twine)</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a22cf193324e7a5fa1a28c5332a1af3ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIND_ARITHMETIC_CAST_OP_ZEXT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Function, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Twine&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">std::bind(&amp;Function, \</div><div class="line">        std::placeholders::_1, \</div><div class="line">        std::placeholders::_2, \</div><div class="line">        std::placeholders::_3, \</div><div class="line">        Twine)</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ace87667103f79d4094575e2411da5ffc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIND_BINARY_OP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Function</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">[twine](llvm::IRBuilder&lt;&gt;&amp; B, llvm::Value* L, llvm::Value* R) \</div><div class="line">        -&gt; llvm::Value* { <span class="keywordflow">return</span> B.Function(L, R, twine); }</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
