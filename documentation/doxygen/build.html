<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: Building OpenVDB</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">7.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenVDB</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Building OpenVDB </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="buildContents"></a>
Contents</h1>
<ul>
<li><a class="el" href="build.html#buildIntroduction">Introduction</a></li>
<li><a class="el" href="build.html#buildCmakeStructure">CMake Structure</a><ul>
<li><a class="el" href="build.html#buildDependencies">Locating Dependencies</a></li>
<li><a class="el" href="build.html#buildMixingDepInstalls">Mixing Dependency Installations</a></li>
<li><a class="el" href="build.html#buildBloscSupport">Blosc Support</a></li>
<li><a class="el" href="build.html#buildVCPKG">Building Dependencies using VCPKG</a></li>
</ul>
</li>
<li><a class="el" href="build.html#buildComponents">OpenVDB Components</a></li>
<li><a class="el" href="build.html#buildGuide">Building With CMake</a><ul>
<li><a class="el" href="build.html#buildBuildTypes">Build Types</a></li>
<li><a class="el" href="build.html#buildBuildHouMaya">Building Against Houdini/Maya</a><ul>
<li><a class="el" href="build.html#buildBuildHou">Building Against Houdini</a></li>
<li><a class="el" href="build.html#buildBuildMaya">Building Against Maya</a></li>
</ul>
</li>
<li><a class="el" href="build.html#buildBuildStandalone">Building Standalone</a></li>
</ul>
</li>
<li><a class="el" href="build.html#buildUsingOpenVDB">Building With OpenVDB</a></li>
<li><a class="el" href="build.html#buildUsingMake">Building With Make</a></li>
<li><a class="el" href="build.html#buildTroubleshooting">Troubleshooting</a></li>
</ul>
<hr/>
<h1><a class="anchor" id="buildIntroduction"></a>
Introduction</h1>
<p><a href="https://cmake.org/">CMake</a> is a cross-platform family of tools designed to help build software. CMake doesn't <em>actually</em> build the project but instead generates the files required for your toolchain, for example makefiles that serve as input to <a href="https://www.gnu.org/software/make/">GNU Make</a>. Makefiles have historically been included in the OpenVDB distribution and until recently were the preferred means of building OpenVDB on UNIX platforms (see <a class="el" href="build.html#buildUsingMake">Building With Make</a> below). But CMake support ensures a high level of flexibility and pre-compile verification to the build process, making it much easier to control and customize the installation process for a wider range of platforms.</p>
<p>CMake also makes it easier to automatically find and handle dependencies. As OpenVDB has a number of required and optional dependencies, it's recommended that new users to the software use the CMake build system over the Makefiles. If you're completely new to CMake, you may find it useful to read over the brief <a href="https://cmake.org/runningcmake/">introduction to CMake</a> and the CMake structure section below. However the <a class="el" href="build.html#buildGuide">build guide</a> runs through the build process step by step.</p>
<h1><a class="anchor" id="buildCmakeStructure"></a>
CMake Structure</h1>
<p>CMake will configure a set of build files which represent the commands and dependencies for the OpenVDB components you wish to install. Finding and handling these dependencies on different platforms comprises the majority of the complexity involved in writing CMake. In general, software which uses CMake is expected to provide their own configuration files which dependent software will locate and use. Not all of OpenVDB's dependencies provide CMake support and therefore do not deploy with CMake configurations that OpenVDB can use. OpenVDB provides a set of <code>FindModules</code> in the <code>cmake</code> folder for finding these various dependencies e.g. <code>FindBlosc.cmake</code>. These are designed such that they can theoretically be used by any project that needs to locate the given library and are invoked by the <code>find_package()</code> call. For more information on FindModules and locating packages with CMake, see the following CMake documentation:</p>
<ul>
<li><a href="https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html#using-packages">Using Packages with CMake</a></li>
<li><a href="https://cmake.org/cmake/help/latest/command/find_package.html">Calling find_package()</a></li>
</ul>
<p>The other type of file provided by OpenVDB are <code>OpenVDBSetupX.cmake</code> includes. These are primarily designed to configure the building of OpenVDB components against supported DCC's (Houdini/Maya) by locating their installations and setting various CMake variables for subsequent <code>find_package()</code> dependency calls. They also represent packages which already provide their own CMake modules, but additionally provide the same input variable interface as OpenVDB's other <code>Find</code> Modules.</p>
<h2><a class="anchor" id="buildDependencies"></a>
Locating Dependencies</h2>
<p>Each CMake FindModule provides a description of the possible inputs which can be provided to help drive the search for OpenVDB dependencies (as well as the resulting outputs). They have been homogenized such that these variables follow a set convention, typically followed by most CMake projects. For a given FindModule e.g. <code>FindBlosc.cmake</code>:</p>
<ul>
<li>FindXxx.cmake provides the module interface where Xxx becomes the library name</li>
<li>Invoked with the called <code>find_package( Xxx )</code></li>
</ul>
<ul>
<li><b>Inputs</b> - The following variables can be used to help drive the search path on first runs of CMake (i.e. these variables are not <a href="https://cmake.org/cmake/help/latest/command/set.html#set-cache-entry">cached</a>). They are listed in priority order. Note that the prefix is always capitalized.<ul>
<li><b>XXX_INCLUDEDIR</b> / <b>XXX_LIBRARYDIR</b> - Preferred include and library directories</li>
<li><b>Xxx_ROOT</b> - Preferred installation prefix. The given dependency is expected to follow a folder structure <code>Xxx_ROOT/include</code> and <code>Xxx_ROOT/lib</code> exist. Note that unlike the above, this is the case matching name of the find package .i.e. Blosc_ROOT, IlmBase_ROOT, TBB_ROOT etc.</li>
<li><b>SYSTEM_LIBRARY_PATHS</b> - A list of paths appended to all include and lib searches.</li>
<li><b>XXX_USE_STATIC_LIBS</b> - Only search for static libraries for the given dependency. If OFF, the shared library is prioritized, falling back to the static library. This is OFF by default.</li>
<li><b>DISABLE_CMAKE_SEARCH_PATHS</b> - The above variables are custom to the OpenVDB project. CMake itself implements its own search system to try and find the given libraries and packages. When ON, this variable disables CMake's inbuilt search, guaranteeing that only the above user provided paths are searched. See <a href="https://cmake.org/cmake/help/latest/command/find_package.html#search-procedure">CMakes Search Procedure</a> for more information. This is OFF by default (and thus CMake's search is enabled).</li>
</ul>
</li>
</ul>
<ul>
<li><b>Outputs</b> The following variables are always set if the project is found:<ul>
<li><b>Xxx_FOUND</b> - True if the headers and library was found and exists</li>
<li><b>Xxx_VERSION</b> - The library version</li>
<li><b>Xxx_INCLUDE_DIRS</b> - A list of paths to all required include directories</li>
<li><b>Xxx_LIBRARY_DIRS</b> - A list of paths to all required library directories</li>
<li><b>Xxx_LIBRARIES</b> - A list of libraries needed to use Xxx</li>
</ul>
</li>
<li>Each module produces an <a href="https://cmake.org/cmake/help/latest/command/add_library.html#imported-libraries">imported target</a> in the form <b>Xxx::xxx</b>, and may generate multiple imported targets if multiple components are found.</li>
</ul>
<h2><a class="anchor" id="buildMixingDepInstalls"></a>
Mixing Dependency Installations</h2>
<p>There may be a situation where you use a package manager to install some dependencies, use a DCC such as Maya to provide others and manually build and install others from source. Care must be taken when providing CMake with these locations to ensure that the correct files are used. Incorrect use of the above variables can lead to difficult to diagnose build and runtime errors.</p>
<p>As an example, let's assume we have a manual installation of TBB (either through a Maya installation or a manual installation from source) and we want to use this with other dependencies installed through a package manager such as homebrew. As homebrew copies all headers and libraries it installs to a <code>&lt;homebrew&gt;/include</code> <code>&lt;homebrew&gt;/lib</code> directory structure, it can be tempting to set <b>Xxx_ROOT</b> variables to points to the <code>&lt;homebrew&gt;</code> folder. However you may already have an existing installation of TBB through your package manager, potentially installed by as a dependency of a completely unrelated piece of software. Whilst CMake may report to you the correct include/lib path, this can end up being hidden at compile time through these types of shared installations. You should not rely on the dependency order of the CMake build system - instead, it's important that you try to use the explicit directory paths where possible. For example homebrew will install each piece of software to <code>&lt;homebrew&gt;/Cellar/&lt;dep_name&gt;/&lt;dep_version&gt;</code>, where the subsequent include and library directories can be passed to <b>XXX_INCLUDEDIR</b> and <b>XXX_LIBRARYDIR</b> respectively.</p>
<p>In summary try to stick to a single installation workflow and, if in doubt, provide direct include/lib paths to isolated software locations.</p>
<h2><a class="anchor" id="buildBloscSupport"></a>
Blosc Support</h2>
<p>Blosc is one of the optional dependencies of all OpenVDB components. It is the only dependency which is enabled by default. The documented build steps below treat blosc as a required dependency. There are two reasons for this:</p>
<ul>
<li>Blosc produces significantly smaller <code>.vdb</code> files</li>
<li>If Blosc is disabled, you will not be able to read or use any <code>.vdb</code> files that were created using blosc compression. This includes OpenVDB files from Houdini.</li>
</ul>
<p>You can disable Blosc using <code>-D USE_BLOSC=OFF</code>.</p>
<h2><a class="anchor" id="buildVCPKG"></a>
Building Dependencies using VCPKG</h2>
<p>It is recommended to set the VCPKG_DEFAULT_TRIPLET=x64-windows environment variable to use 64-bit libraries by default as even on a 64-bit Windows OS, VCPKG builds and installs 32-bit libraries by default.</p>
<h1><a class="anchor" id="buildComponents"></a>
OpenVDB Components</h1>
<p>The following table lists all targets (mainly library and binary components) which can be built through the CMake build system. They can be set when using CMake from the command line with <code>-D VAR=ON/OFF</code> or with a CMake gui:</p>
<table class="doxtable">
<tr>
<th>Component </th><th>Description </th><th>CMake Variable </th><th>Default  </th></tr>
<tr>
<td>OpenVDB Core Library </td><td>The Core OpenVDB shared/static library </td><td>OPENVDB_BUILD_CORE </td><td>ON </td></tr>
<tr>
<td>OpenVDB Print </td><td>Command line binary for displaying information about OpenVDB files </td><td>OPENVDB_BUILD_BINARIES / OPENVDB_BUILD_VDB_PRINT </td><td>ON / ON </td></tr>
<tr>
<td>OpenVDB LOD </td><td>Command line binary for generating volume mipmaps from an OpenVDB grid </td><td>OPENVDB_BUILD_BINARIES / OPENVDB_BUILD_VDB_LOD </td><td>ON / OFF </td></tr>
<tr>
<td>OpenVDB Render </td><td>Command line binary for ray-tracing OpenVDB grids </td><td>OPENVDB_BUILD_BINARIES / OPENVDB_BUILD_VDB_RENDER </td><td>ON / OFF </td></tr>
<tr>
<td>OpenVDB View </td><td>Command line binary for displaying OpenVDB grids in a GL viewport </td><td>OPENVDB_BUILD_BINARIES / OPENVDB_BUILD_VDB_VIEW </td><td>ON / OFF </td></tr>
<tr>
<td>OpenVDB Python </td><td>Python module for OpenVDB C++ Python bindings </td><td>OPENVDB_BUILD_PYTHON_MODULE </td><td>OFF </td></tr>
<tr>
<td>OpenVDB UnitTests </td><td>OpenVDB's Unit Test suite </td><td>OPENVDB_BUILD_UNITTESTS </td><td>OFF </td></tr>
<tr>
<td>OpenVDB Houdini Plugin </td><td>The OpenVDB Houdini shared library and OpenVDB Nodes </td><td>OPENVDB_BUILD_HOUDINI_PLUGIN </td><td>OFF </td></tr>
<tr>
<td>OpenVDB Maya Plugin </td><td>The Maya OpenVDB Nodes </td><td>OPENVDB_BUILD_MAYA_PLUGIN </td><td>OFF </td></tr>
<tr>
<td>Documentation </td><td>The OpenVDB doxygen documentation </td><td>OPENVDB_BUILD_DOCS </td><td>OFF </td></tr>
</table>
<h1><a class="anchor" id="buildGuide"></a>
Building With CMake</h1>
<h2><a class="anchor" id="buildBuildTypes"></a>
Build Types</h2>
<p>The first step is to decide what type of OpenVDB build you're after. This primarily boils down to three main options:</p>
<ul>
<li>A standalone OpenVDB build (no Houdini/Maya plugins)</li>
<li>OpenVDB for <a href="https://www.sidefx.com/">Houdini</a></li>
<li>OpenVDB for <a href="https://www.autodesk.co.uk/products/maya/overview">Maya</a></li>
</ul>
<p>Each option provides various benefits. Apart from the support for either the Houdini or Maya OpenVDB plugins, the latter two options can make it easier for new users to install the range of OpenVDB dependencies without having to worry about using a package manager or manually installing for source. You'll still be able to build and use all components of OpenVDB with these methods. However depending on the DCC (Digital Content Creation) software's version, you may find that some features of the Core library are restricted to ensure compatibility. For more information of building OpenVDB against a Houdini or Maya installation, see <a class="el" href="build.html#buildBuildHouMaya">here</a>.</p>
<p>Developers may wish to build a standalone version of OpenVDB to take advantage of newer dependencies and newer library features. See <a class="el" href="build.html#buildBuildStandalone">here</a> for more information.</p>
<p><b>Note:</b> Blosc is treated as a required dependency in these install instructions. See the <a class="el" href="build.html#buildBloscSupport">blosc support</a> section for more information.</p>
<h2><a class="anchor" id="buildBuildHouMaya"></a>
Building Against Houdini/Maya</h2>
<p>Building against a DCC reduces the list of dependencies you need to provide. You should not mix between Houdini and Maya libraries and should not attempt to build the Maya plugin using Houdini libraries and vice-versa. Additionally, it's a good idea to read the above section on <a class="el" href="build.html#buildMixingDepInstalls">mixing dependency installations</a>.</p>
<table class="doxtable">
<tr>
<th>DCC </th><th>Supported Version </th><th>OpenVDB ABI  </th></tr>
<tr>
<td>Houdini </td><td>17.0 </td><td>5 </td></tr>
<tr>
<td>Houdini </td><td>17.5 </td><td>5 </td></tr>
<tr>
<td>Maya </td><td>2017 </td><td>Any </td></tr>
<tr>
<td>Maya </td><td>2018 </td><td>Any </td></tr>
<tr>
<td>Maya </td><td>2019 </td><td>Any </td></tr>
</table>
<h2><a class="anchor" id="buildBuildHou"></a>
Building Against Houdini</h2>
<p>Houdini ships with a number of libraries that OpenVDB requires. When downloading Houdini, take note of the file version information. The version you install will determine the compiler version you should try and use to build OpenVDB. For example, for <b>Linux</b> Houdini 17.5, with a file name of <code>houdini-17.5.219-linux_x86_64_gcc6.3.tar.gz</code>, GCC 6.3 should be used. You will need to install some of the following dependencies depending on which OpenVDB components you wish to build.</p>
<table class="doxtable">
<tr>
<th>Package </th><th>Description </th><th>OpenVDB Components  </th></tr>
<tr>
<td>CMake </td><td>Cross-platform family of tools designed to help build software </td><td>All </td></tr>
<tr>
<td>C++11 Compiler </td><td>Matching Houdini compiler and version </td><td>All </td></tr>
<tr>
<td>Boost </td><td>Components: system, iostreams, python, thread </td><td>All </td></tr>
<tr>
<td>CppUnit </td><td>A unit testing framework module for C++ </td><td>Unit Tests </td></tr>
<tr>
<td>GLFW </td><td>Simple API for OpenGL development </td><td>OpenVDB View </td></tr>
<tr>
<td>Doxygen </td><td>Documentation generation from C++ </td><td>Documentation </td></tr>
<tr>
<td>Log4cplus </td><td>An optional dependency for improved OpenVDB Logging </td><td>Optional (All) </td></tr>
<tr>
<td>NumPy </td><td>Scientific computing with Python </td><td>Optional (Python) </td></tr>
</table>
<p>At a minimum, boost, a matching C++11 compiler and CMake will be required. See the full <a class="el" href="dependencies.html">dependency list</a> for help with downloading and installing the above software. Note that as Blosc is provided as part of the Houdini installation <code>USE_BLOSC</code> should be left <code>ON</code>.</p>
<p>With the necessary dependencies installed, create and enter a directory for cmake to write to. It's generally useful to create this in the location you've extracted the OpenVDB repository. It will house CMake's generated build files.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;mkdir build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd build</div></div><!-- fragment --><p>Now you can call CMake by providing the absolute or relative path to the root of the OpenVDB source tree along with the following options:</p>
<p>Required:</p>
<ul>
<li><b>Houdini_ROOT</b> =<code>/path/to/houdini/install</code> # Path to Houdini Install</li>
<li><b>USE_HOUDINI</b> =<code>ON</code> # Force all components to build against Houdini</li>
<li><b>OPENVDB_BUILD_HOUDINI_PLUGIN</b> =<code>ON</code> # Required for building the Houdini Plugin.</li>
</ul>
<p>Optional:</p>
<ul>
<li><b></b> <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html">CMAKE_INSTALL_PREFIX</a> =<code>/path/to/install/dir</code> # The location you wish to install OpenVDB to. See the link for default values.</li>
<li><b>OPENVDB_HOUDINI_INSTALL_PREFIX</b> =<code>/path/to/install/dir</code> # The location to install the Houdini plugin to. Defaults to directories defined by Houdini:<ul>
<li>Linux: <code>$ENV{HOME}/houdiniX.X</code></li>
<li>Mac: <code>$ENV{HOME}/Library/Preferences/houdini/X.X</code></li>
<li>Windows: <code>$ENV{HOMEDRIVE}$ENV{HOMEPATH}\Documents\houdiniX.X</code></li>
</ul>
</li>
<li><b>USE_DEFAULT_HOUDINI_INSTALL</b> =<code>ON</code> # Use the above default locations if <b>OPENVDB_HOUDINI_INSTALL_PREFIX</b> is not specified. If <code>OFF</code>, uses the value of <b>CMAKE_INSTALL_PREFIX</b>.</li>
<li><b>BOOST_ROOT</b> =<code>/path/to/boost/install</code> # Path to boost. May not be required, CMake may find it automatically</li>
</ul>
<p>For example on MacOS and where the build folder has been created inside the OpenVDB source root:</p>
<div class="fragment"><div class="line">cmake -D BOOST_ROOT=/path/to/boost/install \</div><div class="line">      -D Houdini_ROOT=/Applications/Houdini/Houdini17.0.506/ \</div><div class="line">      -D USE_HOUDINI=ON \</div><div class="line">      ../</div></div><!-- fragment --><p>After the CMake build files have been successfully generated, run make within the build directory to compile the project, where the value of the <code>j</code> argument is the number of CPU threads to use for a multi-threaded build. </p><div class="fragment"><div class="line">make -j4</div></div><!-- fragment --><p>Finally, once a successful build has completed, you can install all files. </p><div class="fragment"><div class="line">make install</div></div><!-- fragment --><p>See the <a class="el" href="build.html#buildTroubleshooting">troubleshooting</a> section for help with CMake and Make errors.</p>
<h2><a class="anchor" id="buildBuildMaya"></a>
Building Against Maya</h2>
<p>Supported versions of maya only ship with TBB.</p>
<table class="doxtable">
<tr>
<th>Package </th><th>Description </th><th>OpenVDB Components  </th></tr>
<tr>
<td>CMake </td><td>Cross-platform family of tools designed to help build software </td><td>All </td></tr>
<tr>
<td>C++11 Compiler </td><td>Matching Houdini compiler and version </td><td>All </td></tr>
<tr>
<td>Boost </td><td>Components: system, iostreams, python, thread </td><td>All </td></tr>
<tr>
<td>IlmBase </td><td>Used half precision floating points and EXR serialization support </td><td>All </td></tr>
<tr>
<td>ZLIB </td><td>Compression library for disk serialization compression </td><td>All </td></tr>
<tr>
<td>Blosc </td><td>Recommended dependency for improved disk compression </td><td>All* </td></tr>
<tr>
<td>CppUnit </td><td>A unit testing framework module for C++ </td><td>Unit Tests </td></tr>
<tr>
<td>GLFW </td><td>Simple API for OpenGL development </td><td>OpenVDB View </td></tr>
<tr>
<td>Doxygen </td><td>Documentation generation from C++ </td><td>Documentation </td></tr>
<tr>
<td>OpenEXR </td><td>EXR serialization support </td><td>Optional (Core) / OpenVDB Render </td></tr>
<tr>
<td>Log4cplus </td><td>An optional dependency for improved OpenVDB Logging </td><td>Optional (All) </td></tr>
<tr>
<td>NumPy </td><td>Scientific computing with Python </td><td>Optional (Python) </td></tr>
</table>
<p>See <a class="el" href="build.html#buildBloscSupport">blosc support</a></p>
<p>At a minimum, boost, a matching C++11 compiler, IlmBase, ZLIB, blosc and CMake will be required. See the full <a class="el" href="dependencies.html">dependency list</a> for help with downloading and installing the above software.</p>
<p>With the necessary dependencies installed, create and enter a directory for cmake to write to. It's generally useful to create this in the location you've extracted the OpenVDB repository. It will house CMake's generated build files.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;mkdir build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd build</div></div><!-- fragment --><p>Now you can call CMake by providing the absolute or relative path to the root of the OpenVDB source tree along with the following options:</p>
<p>Required:</p>
<ul>
<li><b>Maya_ROOT</b> =<code>/path/to/maya/install</code> # Path to Maya Install</li>
<li><b>USE_MAYA</b> =<code>ON</code> # Force all components to build against Maya</li>
</ul>
<p>Optional:</p>
<ul>
<li><b></b> <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html">CMAKE_INSTALL_PREFIX</a> =<code>/path/to/install/dir</code> # The location you wish to install OpenVDB to. See the link for default values.</li>
<li><b>OPENVDB_MAYA_INSTALL_PREFIX</b> =<code>/path/to/install/dir</code> # The location to install the Maya plugin to. Defaults to the value of <code>${CMAKE_INSTALL_PREFIX}/maya${Maya_VERSION}</code></li>
<li><b>BOOST_ROOT</b> =<code>/path/to/boost/install</code> # Path to boost. May not be required, CMake may find it automatically</li>
<li><b>IlmBase_ROOT</b> =<code>/path/to/ilmbase/install</code> # Path to ilmbase.</li>
</ul>
<p>For example on MacOS and where the build folder has been created inside the OpenVDB source root:</p>
<div class="fragment"><div class="line">cmake -D BOOST_ROOT=/path/to/boost/install \</div><div class="line">      -D IlmBase_ROOT=/path/to/ilmbase/install \</div><div class="line">      -D Maya_ROOT=/Applications/Autodesk/maya2019/ \</div><div class="line">      -D USE_MAYA=ON \</div><div class="line">      ../</div></div><!-- fragment --><p>As the Maya plugin is disabled by default, you may also want to add <code>-D OPENVDB_BUILD_MAYA_PLUGIN=ON</code> to the command. The <a class="el" href="build.html#buildComponents">components</a> section shows which targets are enabled by default.</p>
<p>After the CMake build files have been successfully generated, run make within the build directory to compile the project, where the value of the <code>j</code> argument is the number of CPU threads to use for a multi-threaded build. </p><div class="fragment"><div class="line">make -j4</div></div><!-- fragment --><p>Finally, once a successful build has completed, you can install all files. </p><div class="fragment"><div class="line">make install</div></div><!-- fragment --><p><b>Note:</b> The Maya OpenVDB Visualize Node is <b>only</b> compatible with Legacy OpenGL support. You can enable this in Maya by navigating to <code>Windows-&gt;Settings/Preferences-&gt;Preferences-&gt;Display</code> and changing <code>Rendering Engine</code> to OpenGL - Legacy.</p>
<p>See the <a class="el" href="build.html#buildTroubleshooting">troubleshooting</a> section for help with CMake and Make errors.</p>
<h2><a class="anchor" id="buildBuildStandalone"></a>
Building Standalone</h2>
<p>It's recommended you first visit the <a class="el" href="dependencies.html">dependency list page</a> before attempting to run CMake on a standalone build. With the necessary dependencies installed, create and enter a directory for cmake to write to. It's generally useful to create this in the location you've extracted the OpenVDB repository. It will house CMake's generated build files.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;mkdir build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd build</div></div><!-- fragment --><p>Now you can call CMake by providing the absolute or relative path to the root of the OpenVDB source tree. Below are some common options you may want to provide:</p>
<ul>
<li><b></b> <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html">CMAKE_INSTALL_PREFIX</a> =<code>/path/to/install/dir</code> # The location you wish to install OpenVDB to. See the link for default values.</li>
<li><b>Xxx_ROOT</b> =<code>/path/to/Xxx/</code> # Give CMake a path to where a package has been installed or simply to where your prefered package is installed if it cannot locate it.</li>
</ul>
<p>For example, a typical first attempt at generating the build files may look as follows:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cmake -D CMAKE_INSTALL_PREFIX=$HOME/openvdb ../</div></div><!-- fragment --><p>See the <a class="el" href="build.html#buildComponents">components</a> section to find which targets are available, their corresponding CMake flags and their default values.</p>
<p>After the CMake build files have been successfully generated, run make within the build directory to compile the project, where the value of the <code>j</code> argument is the number of CPU threads to use for a multi-threaded build. </p><div class="fragment"><div class="line">make -j4</div></div><!-- fragment --><p>Finally, once a successful build has completed, you can install all files. </p><div class="fragment"><div class="line">make install</div></div><!-- fragment --><p>See the <a class="el" href="build.html#buildTroubleshooting">troubleshooting</a> section for help with CMake and Make errors.</p>
<h1><a class="anchor" id="buildUsingOpenVDB"></a>
Building With OpenVDB</h1>
<p>This section is for users wishing to use a build of OpenVDB in their own applications with CMake.</p>
<p>The following assumes that OpenVDB was installed with <code>OPENVDB_BUILD_CORE=ON</code> and <code>OPENVDB_INSTALL_CMAKE_MODULES=ON</code>. Don't worry if you didn't specify these options directly, they both default to <code>ON</code>. This ensures that OpenVDB has installed the required CMake modules that your application will need to use.</p>
<p><b>Note:</b> Typically, projects provide a <b>Config-file</b> rather than a <b>Find-module</b> for downstream use. OpenVDB currently provides a <b>Find-module</b>. This may change in the future. Further information <a href="https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html#using-packages">here</a>.</p>
<p>You can add the below CMake snippet to your main <code>CMakeLists.txt</code> to bring in OpenVDB as a dependency:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cmake_minimum_required(VERSION 3.3)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;list(APPEND CMAKE_MODULE_PATH &quot;/location/of/openvdb/install/lib/cmake/OpenVDB&quot;)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;find_package(OpenVDB REQUIRED)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;target_link_libraries(myapp OpenVDB::openvdb)</div></div><!-- fragment --><p><code>myapp</code> in the above is a CMake target, usually created with <code>add_library()</code> or <code>add_executable()</code>. You can optionally provide <code>CMAKE_MODULE_PATH</code> as a <code>-D</code> argument to the cmake command line instead of specifying it in your <code>CMakeLists.txt</code>.</p>
<p>Note that the <code>FindOpenVDB.cmake</code> module relies on the other <code>FindModules</code> provided in the OpenVDB installation to find it's own dependencies. This may require you to provide additional dependency locations for OpenVDB's dependencies. See <a class="el" href="build.html#buildDependencies">Locating Dependencies</a> or the below troubleshooting for more information.</p>
<h1><a class="anchor" id="buildUsingMake"></a>
Building With Make</h1>
<p>Makefiles are provided for those not wishing to use the CMake build system. However, Make support is now deprecated and will be removed in a future release, so one should not expect the Makefiles to provide the same level of functionality as the CMake build system.</p>
<p>To build the core library, ensure that you have <a href="https://www.gnu.org/software/make/">GNU Make</a> version 4.1 or later, then proceed as follows:</p>
<ol>
<li>
<p class="startli">Set values appropriate to your environment for the following variables at the top of <code>openvdb/Makefile</code>: </p><table class="doxtable">
<tr>
<td><code>INSTALL_DIR</code></td><td><p class="starttd">the directory into which to install libraries, executables and header files (e.g., <code>/usr/local</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>BOOST_INCL_DIR</code></td><td><p class="starttd">the parent directory of the <code>boost/</code> header directory (e.g., <code>/usr/include</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>BOOST_LIB_DIR</code></td><td><p class="starttd">the directory containing <code>libboost_iostreams</code>, etc.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>BOOST_LIB</code></td><td><p class="starttd">linker flags for <code>libboost_iostreams</code> and <code>libboost_system</code></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>BOOST_THREAD_LIB</code></td><td><p class="starttd">linker flags for <code>libboost_thread</code></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>ILMBASE_INCL_DIR</code></td><td><p class="starttd">the parent directory of the <code>OpenEXR/</code> header directory (which contains <code>half.h</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>ILMBASE_LIB_DIR</code></td><td><p class="starttd">the directory containing <code>libHalf.so</code> and/or <code>libHalf.a</code></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>ILMBASE_LIB</code></td><td><p class="starttd">linker flags for <code>libIlmThread</code>, <code>libIex</code> and <code>libImath</code></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>HALF_LIB</code></td><td><p class="starttd">linker flag(s) for the Half library (e.g., <code>-lHalf</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>EXR_INCL_DIR</code></td><td><p class="starttd">the parent directory of the <code>OpenEXR/</code> header directory<br />
 </p>
<p>Note: some OpenEXR headers incorrectly include other OpenEXR headers with, e.g., <code>#include &lt;ImfName.h&gt;</code> instead of <code>#include "ImfName.h"</code>. When compiling with Clang, set <code>EXR_INCL_DIR</code> to the parent directory of the <code>OpenEXR/</code> directory and <code>ILMBASE_INCL_DIR</code> to the <code>OpenEXR/</code> directory itself to avoid errors.</p>
<p></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>EXR_LIB_DIR</code></td><td><p class="starttd">the directory containing <code>libIlmImf</code></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>EXR_LIB</code></td><td><p class="starttd">linker flags for <code>libIlmImf</code></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>TBB_INCL_DIR</code></td><td><p class="starttd">the parent directory of the <code>tbb/</code> header directory</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>TBB_LIB_DIR</code></td><td><p class="starttd">the directory containing <code>libtbb</code></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>TBB_LIB</code></td><td><p class="starttd">linker flag(s) for the TBB library (e.g., <code>-ltbb</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>BLOSC_INCL_DIR</code></td><td><p class="starttd">the parent directory of the <code>blosc.h</code> header</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>BLOSC_LIB_DIR</code></td><td><p class="starttd">the directory containing <code>libblosc</code></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>BLOSC_LIB</code></td><td><p class="starttd">linker flags for <code>libblosc</code></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>CONCURRENT_MALLOC_LIB_DIR</code></td><td><p class="starttd">a directory containing a scalable, concurrent malloc replacement library such as jemalloc or TBB malloc<br />
 (leave blank if no such library is available, but be aware that using standard malloc in concurrent code incurs a significant performance penalty)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>CONCURRENT_MALLOC_LIB</code></td><td><p class="starttd">linker flag(s) for the malloc replacement library<br />
(e.g., <code>-ltbbmalloc_proxy -ltbbmalloc</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>CPPUNIT_INCL_DIR</code></td><td><p class="starttd">the parent directory of the <code>cppunit/</code> header directory<br />
 (leave blank if CppUnit is not available)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>CPPUNIT_LIB_DIR</code></td><td><p class="starttd">the directory containing <code>libcppunit.so</code> or <code>libcppunit.a</code></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>CPPUNIT_LIB</code></td><td><p class="starttd">linker flag(s) for the CppUnit library (e.g., <code>-lcppunit</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>GLFW_INCL_DIR</code></td><td><p class="starttd">the directory containing <code>glfw.h</code><br />
 (leave blank if GLFW is not available; GLFW is needed only for the command-line viewer tool)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>GLFW_LIB_DIR</code></td><td><p class="starttd">the directory containing <code>libglfw</code></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>GLFW_LIB</code></td><td><p class="starttd">linker flags for the GLFW library (e.g., <code>-lglfw</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>GLFW_MAJOR_VERSION</code></td><td><p class="starttd">the major version number of the GLFW library<br />
 (header filenames changed between GLFW 2 and 3, so this must be specified explicitly)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>LOG4CPLUS_INCL_DIR</code></td><td><p class="starttd">the parent directory of the <code>log4cplus/</code> header directory<br />
 (leave blank if log4cplus is not available)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>LOG4CPLUS_LIB_DIR</code></td><td><p class="starttd">directory containing <code>liblog4cplus.so</code> or <code>liblog4cplus.a</code></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>LOG4CPLUS_LIB</code></td><td><p class="starttd">linker flags for the log4cplus library (e.g., <code>-llog4cplus</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>PYTHON_VERSION</code></td><td><p class="starttd">the version of Python (e.g.,&#160;2.7) for which to build the OpenVDB module (leave blank if Python is unavailable)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>PYTHON_INCL_DIR</code></td><td><p class="starttd">the directory containing the <code>Python.h</code> header file<br />
(on macOS, this is usually <code>/System/Library/Frameworks/Python.framework/Versions/$(PYTHON_VERSION)/Headers</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>PYCONFIG_INCL_DIR</code></td><td><p class="starttd">the directory containing the <code>pyconfig.h</code> header file (usually but not always the same as <code>PYTHON_INCL_DIR</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>PYTHON_LIB_DIR</code></td><td><p class="starttd">the directory containing the Python library<br />
 (on macOS, this is usually <code>/System/Library/Frameworks/Python.framework/Versions/$(PYTHON_VERSION)/lib</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>PYTHON_LIB</code></td><td><p class="starttd">linker flags for the Python library (e.g., <code>-lpython2.7</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>BOOST_PYTHON_LIB_DIR</code></td><td><p class="starttd">the directory containing the Boost.Python library</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>BOOST_PYTHON_LIB</code></td><td><p class="starttd">linker flags for the Boost.Python library (e.g., <code>-lboost_python-mt</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>NUMPY_INCL_DIR</code></td><td><p class="starttd">the directory containing the NumPy <code>arrayobject.h</code> header file (leave blank if NumPy is unavailable)<br />
(on macOS, this is usually <code>/System/Library/Frameworks/Python.framework/Versions/$(PYTHON_VERSION)/Extras/lib/python/numpy/core/include/numpy</code>)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>EPYDOC</code></td><td><p class="starttd">the path to the Epydoc executable (leave blank if Epydoc is unavailable)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>PYTHON_WRAP_ALL_GRID_TYPES</code></td><td><p class="starttd">if set to "<code>no</code>", expose only <a class="el" href="namespaceopenvdb_1_1v7__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a>, <a class="el" href="namespaceopenvdb_1_1v7__0.html#a44c7484144fab7fb2c436e938e2d87ce">BoolGrid</a> and <a class="el" href="namespaceopenvdb_1_1v7__0.html#a77ff1a3a38ec99a56b4d99a15a2970bf">Vec3SGrid</a> in Python, otherwise expose (most of) the standard grid types defined in <a class="el" href="openvdb_8h.html">openvdb.h</a>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><code>DOXYGEN</code></td><td>the path to the Doxygen executable (leave blank if Doxygen is unavailable) </td></tr>
</table>
<p>Note that if you plan to build the Houdini OpenVDB tools, you must build the OpenVDB library and the Houdini tools against compatible versions of the Boost, OpenEXR and TBB libraries. Until Houdini&#160;16.5, all three were included in the HDK, so by default several of the variables above reference the Houdini environment variables <code>$HDSO</code>, <code>$HFS</code> and <code>$HT</code> (source the <code>houdini_setup</code> script provided with your Houdini installation to set those environment variables). You must provide your own installation of Boost.</p>
<p>Also note that certain new features in OpenVDB (see the <a class="el" href="changes.html">Release Notes</a> for details) necessitated changes to the ABI of the <a class="el" href="classopenvdb_1_1v7__0_1_1Grid.html">Grid</a> class, rendering it incompatible with earlier versions of the library, such as the ones built into Houdini. Passing grids between native VDB nodes in a scene graph and nodes built against the new ABI will lead to crashes, so to use OpenVDB with Houdini&#160;17.5 set <code>abi=5</code> to compile with the incompatible features disabled.</p>
<p>To build the OpenVDB Python module, you will need local installations of Python, Boost.Python, and optionally NumPy. Houdini ships with Python&#160;2 but not with the <code>libboost_python</code> library or with NumPy or with the Boost.Python headers, so both Boost.Python and NumPy have to be built separately. Point the variables <code>$(BOOST_PYTHON_LIB_DIR)</code>, <code>$(BOOST_PYTHON_LIB)</code> and <code>$(NUMPY_INCL_DIR)</code> to your local installations of those libraries. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">From the top-level <code>openvdb/</code> directory, type "<code>make</code>" (or "<code>make -s</code>" for less verbose output) to locally build the library and commands. The Makefile supports parallel builds (e.g. "<code>make -j 8</code>").</p>
<p>A default local build generates the following libraries and executables (but see the Makefile for additional targets and build options): </p><table class="doxtable">
<tr>
<td><code>openvdb/libopenvdb.so.<em>X.Y.Z</em></code></td><td>the OpenVDB library </td></tr>
<tr>
<td><code>openvdb/libopenvdb.so</code></td><td>symlink to <code>libopenvdb.so.<em>X.Y.Z</em></code> </td></tr>
<tr>
<td><code>openvdb/pyopenvdb.so</code></td><td>the OpenVDB Python module (if Python and Boost.Python are available) </td></tr>
<tr>
<td><code>openvdb/vdb_print</code></td><td>command-line tool that prints info about OpenVDB <code>.vdb</code> files </td></tr>
<tr>
<td><code>openvdb/vdb_render</code></td><td>command-line tool that ray-traces OpenVDB volumes </td></tr>
<tr>
<td><code>openvdb/vdb_test</code></td><td>unit test runner for <code>libopenvdb</code> (if CppUnit is available) </td></tr>
</table>
<p>From the <code>openvdb/</code> directory, type "<code>make test</code>" to run the unit tests and verify that the library is working correctly. (Alternatively, once the library has been installed, run the unit test executable directly with "<code>./vdb_test</code>", or "<code>./vdb_test -v</code>" for more verbose output.) Type "<code>make pytest</code>" to run the Python module unit tests. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">From the <code>openvdb/</code> directory, type "<code>make doc</code>" (or "<code>make -s doc</code>") to generate HTML library documentation, then open the file <code>openvdb/doc/html/index.html</code> in a browser. Type "<code>make pydoc</code>" (or "<code>make -s pydoc</code>") to generate HTML Python module documentation, then open <code>openvdb/doc/html/python/index.html</code> in a browser. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Optionally (if OpenGL and GLFW are available), from the top-level <code>openvdb/</code> directory, type "<code>make vdb_view</code>" (or "<code>make -s vdb_view</code>") to locally build the OpenVDB viewer tool. Then type "<code>./vdb_view</code>" for usage information. </p>
<p class="endli"></p>
</li>
<li>
From the <code>openvdb/</code> directory, type "<code>make install</code>" (or "<code>make -s install</code>") to copy generated files into the directory tree rooted at <code>$(INSTALL_DIR)</code>.  </li>
</ol>
<p>To build the Houdini and Maya plugins the process is similar, but see the Makefiles in the <code>openvdb_</code><code>houdini/</code> and <code>openvdb_</code><code>maya/</code> directories for additional requirements </p><hr/>
<h1><a class="anchor" id="buildTroubleshooting"></a>
Troubleshooting</h1>
<p>If after reading this guide you're unable to find your specific issue below, please get in touch with the OpenVDB TSC.</p>
<p><b>Note:</b> If running into issues when changing CMake settings/dependency paths, try clearing the designated CMake build directory and running your <code>cmake</code> command again.</p>
<h2><a class="anchor" id="troubleshoot1"></a>
CMake Error ... Could NOT find XXX (missing: ... )</h2>
<p>It's fairly typical that CMake may fail to find some dependencies on first runs, especially if you've manually compiled from source your own dependencies. Analyzing any dependency errors will help with running further invocations of cmake. The <a class="el" href="build.html#buildDependencies">Locating Dependencies</a> section details the variable format required to point CMake to the correct locations. Alternatively, with interactive cmake systems such as <code>ccmake</code> or CMake GUI, variables which are not found will be shown, allowing you to provide them directly.</p>
<p>As an example, earlier versions of <a href="https://www.threadingbuildingblocks.org/">Threading Building Blocks (TBB)</a> do not come with CMake modules or <a href="https://www.freedesktop.org/wiki/Software/pkg-config/">pkg-config</a> modules. For OpenVDB to locate TBB, you typically need to provide this location manually:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cmake -D CMAKE_INSTALL_PREFIX=$HOME/openvdb -D TBB_ROOT=/path/to/tbb/install ../</div></div><!-- fragment --><p>Note that this is also equivalent to:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cmake -D CMAKE_INSTALL_PREFIX=$HOME/openvdb \</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    -D TBB_INCLUDEDIR=/path/to/tbb/install/include \</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    -D TBB_LIBRARYDIR=/path/to/tbb/install/lib \</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    ../</div></div><!-- fragment --><h2><a class="anchor" id="troubleshoot2"></a>
CMake Error ... Could NOT find XXX (Found unsuitable version: ... )</h2>
<p>By default, OpenVDB sets a number of minimum version requires for its dependencies. These can be found in the root CMakeList.txt or in the <a class="el" href="dependencies.html">dependency table</a>. These minimum versions either track the oldest supported <a href="https://www.vfxplatform.com/">VFX Reference Platform</a> or are otherwise required for compatibility. Although not recommended, you can bypass these checks with <code>-D DISABLE_DEPENDENCY_VERSION_CHECKS=ON</code> if necessary. Note that using older or untested dependencies may produce undesired behavior. Older versions in particular are not supported by OpenVDB.</p>
<p><b>Note:</b> Boost will produce a version error in the format <code>Detected version of Boost is too old.</code></p>
<h2><a class="anchor" id="troubleshoot3"></a>
CMake warnings/errors in FindBoost.cmake</h2>
<p>There are a variety of potential warnings and errors that may arise from the version compatibility of Boost and CMake. These are related to how both Boost and CMake have historically been kept in sync. A common warning and error combination is:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;CMake Warning at ...  Imported targets not available for Boost version XXXXXX</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Target &quot;...&quot; links to target &quot;Boost::XXX&quot; but the target</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;was not found.  Perhaps a find_package() call is missing for an IMPORTED</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;target, or an ALIAS target is missing?</div></div><!-- fragment --><p>OpenVDB uses <a href="https://cmake.org/cmake/help/latest/command/add_library.html#imported-libraries">imported targets</a> for all its dependencies. For imported Boost compatibility, the following versions of CMake are required:</p>
<ul>
<li>Boost 1.63 requires CMake 3.7 or newer.</li>
<li>Boost 1.64 requires CMake 3.8 or newer.</li>
<li>Boost 1.65 and 1.65.1 require CMake 3.9.3 or newer.</li>
<li>Boost 1.66 requires CMake 3.11 or newer.</li>
<li>Boost 1.67 requires CMake 3.12 or newer.</li>
<li>Boost 1.68, 1.69 require CMake 3.13 or newer.</li>
<li>Boost 1.70 requires CMake 3.14 or newer.</li>
</ul>
<p>Use the above list to identify the version of CMake you require for your version of Boost. Note that this may be implemented into the OpenVDB CMake in the future. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
