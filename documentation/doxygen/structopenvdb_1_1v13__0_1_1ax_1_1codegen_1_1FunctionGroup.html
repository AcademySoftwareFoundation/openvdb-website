<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: FunctionGroup Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html','','structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">FunctionGroup Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A group of functions which all have the same name but different signatures. For example: float abs(float) double abs(double) As well as serving as a way of grouping common functions, this class provides an API for selecting the best possible function signature, should a match exist, against a provided set of argument types.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="FunctionTypes_8h_source.html">openvdb_ax/codegen/FunctionTypes.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6c198bf170c50fd1f29e6e5a1362f8c5" id="r_a6c198bf170c50fd1f29e6e5a1362f8c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c198bf170c50fd1f29e6e5a1362f8c5">Ptr</a> = std::shared_ptr&lt;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html">FunctionGroup</a>&gt;</td></tr>
<tr class="memitem:a779d4b812427c0220a95cbfefd060f27" id="r_a779d4b812427c0220a95cbfefd060f27"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a779d4b812427c0220a95cbfefd060f27">UniquePtr</a> = std::unique_ptr&lt;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html">FunctionGroup</a>&gt;</td></tr>
<tr class="memitem:a542b85435760a1b15507546b6cc661a7" id="r_a542b85435760a1b15507546b6cc661a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a542b85435760a1b15507546b6cc661a7">FunctionList</a> = std::vector&lt;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a70d985fa48c8b1bd1f0d85cf96ec82d6">Function::Ptr</a>&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aefb1f06a5d437ba692358a087ca27d5a" id="r_aefb1f06a5d437ba692358a087ca27d5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefb1f06a5d437ba692358a087ca27d5a">FunctionGroup</a> (const char *<a class="el" href="#a860a900733b4494b77121df7259a064f">name</a>, const char *<a class="el" href="#ab20b10116a89166e66fe5c3c502db8e1">doc</a>, const <a class="el" href="#a542b85435760a1b15507546b6cc661a7">FunctionList</a> &amp;<a class="el" href="#ae8a817e74e15936fc7eda06287e679ff">list</a>)</td></tr>
<tr class="memitem:aed023f1493b672cf595f4cc55e2575df" id="r_aed023f1493b672cf595f4cc55e2575df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed023f1493b672cf595f4cc55e2575df">~FunctionGroup</a> ()=default</td></tr>
<tr class="memitem:a22d1a380213d66730080b4616f3e4ee4" id="r_a22d1a380213d66730080b4616f3e4ee4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22d1a380213d66730080b4616f3e4ee4">HasUniqueTypeSignatures</a> (llvm::LLVMContext &amp;C) const</td></tr>
<tr class="memdesc:a22d1a380213d66730080b4616f3e4ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the function signatures in this group.  <br /></td></tr>
<tr class="memitem:a6a032018733bf3d17f18daadfd03e1c4" id="r_a6a032018733bf3d17f18daadfd03e1c4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html">Function</a> *, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">Function::SignatureMatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a032018733bf3d17f18daadfd03e1c4">match</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;args, llvm::LLVMContext &amp;C) const</td></tr>
<tr class="memdesc:a6a032018733bf3d17f18daadfd03e1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of args, automatically returns the best possible function declaration from the stored function list. The 'best' declaration is determined by the provided types compatibility to each functions signature.  <br /></td></tr>
<tr class="memitem:a559782c89d155504fd859c39530bfd15" id="r_a559782c89d155504fd859c39530bfd15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a559782c89d155504fd859c39530bfd15">execute</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html">Arguments</a> &amp;args, llvm::IRBuilder&lt;&gt; &amp;B) const</td></tr>
<tr class="memdesc:a559782c89d155504fd859c39530bfd15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html" title="Arbitrary, potentially &quot;non-native&quot; arguments. This wrapper struct can be used when generating functi...">Arguments</a>, find an EXPLICIT signature match, generate and execute the function body. If no explicit match exists, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> is returned.  <br /></td></tr>
<tr class="memitem:a3e93fcfc432344c5d3986a02e570bb24" id="r_a3e93fcfc432344c5d3986a02e570bb24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e93fcfc432344c5d3986a02e570bb24">execute</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html">NativeArguments</a> &amp;args, llvm::IRBuilder&lt;&gt; &amp;B) const</td></tr>
<tr class="memdesc:a3e93fcfc432344c5d3986a02e570bb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html" title="Wrapper struct to represent &quot;native&quot; function arguments; that is, the set of Value type that the AX g...">NativeArguments</a>, find the best possible function signature, generate and execute the function body. Returns the return value of the function or <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> if no Explicit or Implicit match is found.  <br /></td></tr>
<tr class="memitem:ae8a817e74e15936fc7eda06287e679ff" id="r_ae8a817e74e15936fc7eda06287e679ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a542b85435760a1b15507546b6cc661a7">FunctionList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8a817e74e15936fc7eda06287e679ff">list</a> () const</td></tr>
<tr class="memdesc:ae8a817e74e15936fc7eda06287e679ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the underlying function signature list.  <br /></td></tr>
<tr class="memitem:a860a900733b4494b77121df7259a064f" id="r_a860a900733b4494b77121df7259a064f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a860a900733b4494b77121df7259a064f">name</a> () const</td></tr>
<tr class="memitem:ab20b10116a89166e66fe5c3c502db8e1" id="r_ab20b10116a89166e66fe5c3c502db8e1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab20b10116a89166e66fe5c3c502db8e1">doc</a> () const</td></tr>
<tr class="memitem:a824032018bcbf98c0feb287d458be062" id="r_a824032018bcbf98c0feb287d458be062"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a824032018bcbf98c0feb287d458be062">match</a> (const std::vector&lt; llvm::Type * &gt; &amp;types, llvm::LLVMContext &amp;C, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">Function::SignatureMatch</a> *type=nullptr) const</td></tr>
<tr class="memitem:aaa05b4f454fedf3e625d5ff1155f8e57" id="r_aaa05b4f454fedf3e625d5ff1155f8e57"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa05b4f454fedf3e625d5ff1155f8e57">execute</a> (const std::vector&lt; llvm::Value * &gt; &amp;args, llvm::IRBuilder&lt;&gt; &amp;B) const</td></tr>
<tr class="memitem:adb6edc58a749ac18e50223ec48fb5b43" id="r_adb6edc58a749ac18e50223ec48fb5b43"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb6edc58a749ac18e50223ec48fb5b43">execute</a> (const std::vector&lt; llvm::Value * &gt; &amp;args, llvm::IRBuilder&lt;&gt; &amp;B, llvm::Value *&amp;result) const</td></tr>
<tr class="memdesc:adb6edc58a749ac18e50223ec48fb5b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of llvm values, find the best possible function signature, generate and execute the function body. Returns the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a> that was selected and executed or a nullptr if no valid match was found. Sets the result variable to the return value of the function (nullptr if void). If no match is found, the result variable if left unset.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A group of functions which all have the same name but different signatures. For example: float abs(float) double abs(double) As well as serving as a way of grouping common functions, this class provides an API for selecting the best possible function signature, should a match exist, against a provided set of argument types. </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a542b85435760a1b15507546b6cc661a7" name="a542b85435760a1b15507546b6cc661a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542b85435760a1b15507546b6cc661a7">&#9670;&#160;</a></span>FunctionList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a542b85435760a1b15507546b6cc661a7">FunctionList</a> = std::vector&lt;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a70d985fa48c8b1bd1f0d85cf96ec82d6">Function::Ptr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c198bf170c50fd1f29e6e5a1362f8c5" name="a6c198bf170c50fd1f29e6e5a1362f8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c198bf170c50fd1f29e6e5a1362f8c5">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6c198bf170c50fd1f29e6e5a1362f8c5">Ptr</a> = std::shared_ptr&lt;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html">FunctionGroup</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a779d4b812427c0220a95cbfefd060f27" name="a779d4b812427c0220a95cbfefd060f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779d4b812427c0220a95cbfefd060f27">&#9670;&#160;</a></span>UniquePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a779d4b812427c0220a95cbfefd060f27">UniquePtr</a> = std::unique_ptr&lt;<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html">FunctionGroup</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aefb1f06a5d437ba692358a087ca27d5a" name="aefb1f06a5d437ba692358a087ca27d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb1f06a5d437ba692358a087ca27d5a">&#9670;&#160;</a></span>FunctionGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html">FunctionGroup</a> </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>doc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a542b85435760a1b15507546b6cc661a7">FunctionList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed023f1493b672cf595f4cc55e2575df" name="aed023f1493b672cf595f4cc55e2575df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed023f1493b672cf595f4cc55e2575df">&#9670;&#160;</a></span>~FunctionGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html">FunctionGroup</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ab20b10116a89166e66fe5c3c502db8e1" name="ab20b10116a89166e66fe5c3c502db8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20b10116a89166e66fe5c3c502db8e1">&#9670;&#160;</a></span>doc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * doc </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a559782c89d155504fd859c39530bfd15" name="a559782c89d155504fd859c39530bfd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559782c89d155504fd859c39530bfd15">&#9670;&#160;</a></span>execute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> execute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html">Arguments</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Arguments.html" title="Arbitrary, potentially &quot;non-native&quot; arguments. This wrapper struct can be used when generating functi...">Arguments</a>, find an EXPLICIT signature match, generate and execute the function body. If no explicit match exists, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> is returned. </p>
<dl class="section note"><dt>Note</dt><dd>To ensure something is matched/executed, consider calling <a class="el" href="#a6a032018733bf3d17f18daadfd03e1c4" title="Given a vector of args, automatically returns the best possible function declaration from the stored ...">match()</a> and <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#a8260c8666f1cbbb10279dd0f7b44e643" title="Uses the IRBuilder to create a call to this function with the given arguments, creating the function ...">Function::call</a> instead. This method should only be used by internal methods that can assert an explicit match exists.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a> arguments </td></tr>
    <tr><td class="paramname">B</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e93fcfc432344c5d3986a02e570bb24" name="a3e93fcfc432344c5d3986a02e570bb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e93fcfc432344c5d3986a02e570bb24">&#9670;&#160;</a></span>execute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> execute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html">NativeArguments</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1NativeArguments.html" title="Wrapper struct to represent &quot;native&quot; function arguments; that is, the set of Value type that the AX g...">NativeArguments</a>, find the best possible function signature, generate and execute the function body. Returns the return value of the function or <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> if no Explicit or Implicit match is found. </p>
<dl class="section note"><dt>Note</dt><dd>This function will throw if no valid return is provided by the matched declaration implementation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Natively supported function arguments </td></tr>
    <tr><td class="paramname">B</td><td>The current llvm IRBuilder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa05b4f454fedf3e625d5ff1155f8e57" name="aaa05b4f454fedf3e625d5ff1155f8e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa05b4f454fedf3e625d5ff1155f8e57">&#9670;&#160;</a></span>execute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * execute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated</a></b></dt><dd>"FunctionGroup::execute which takes llvm::Value's and " "supports argument matching/casting is incompatible with LLVM 16+ and will be " "removed." <br  />
 </dd></dl>

</div>
</div>
<a id="adb6edc58a749ac18e50223ec48fb5b43" name="adb6edc58a749ac18e50223ec48fb5b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6edc58a749ac18e50223ec48fb5b43">&#9670;&#160;</a></span>execute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html">Function</a> * execute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of llvm values, find the best possible function signature, generate and execute the function body. Returns the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a> that was selected and executed or a nullptr if no valid match was found. Sets the result variable to the return value of the function (nullptr if void). If no match is found, the result variable if left unset. </p>
<dl class="section note"><dt>Note</dt><dd>This function will throw if no valid return is provided by the matched declaration implementation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>A vector of values representing the function arguments </td></tr>
    <tr><td class="paramname">B</td><td>The current llvm IRBuilder </td></tr>
    <tr><td class="paramname">result</td><td>The result to set. nullptr on void return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matched function. nullptr if no match was found </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated</a></b></dt><dd>"FunctionGroup::execute which takes llvm::Value's and " "supports argument matching/casting is incompatible with LLVM 16+ and will be " "removed." <br  />
 </dd></dl>

</div>
</div>
<a id="a22d1a380213d66730080b4616f3e4ee4" name="a22d1a380213d66730080b4616f3e4ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d1a380213d66730080b4616f3e4ee4">&#9670;&#160;</a></span>HasUniqueTypeSignatures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasUniqueTypeSignatures </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify the function signatures in this group. </p>

</div>
</div>
<a id="ae8a817e74e15936fc7eda06287e679ff" name="ae8a817e74e15936fc7eda06287e679ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a817e74e15936fc7eda06287e679ff">&#9670;&#160;</a></span>list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a542b85435760a1b15507546b6cc661a7">FunctionList</a> &amp; list </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor to the underlying function signature list. </p>

</div>
</div>
<a id="a6a032018733bf3d17f18daadfd03e1c4" name="a6a032018733bf3d17f18daadfd03e1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a032018733bf3d17f18daadfd03e1c4">&#9670;&#160;</a></span>match() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html">Function</a> *, <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">Function::SignatureMatch</a> &gt; match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1ArgInfoVector.html">ArgInfoVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>args</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of args, automatically returns the best possible function declaration from the stored function list. The 'best' declaration is determined by the provided types compatibility to each functions signature. </p>
<dl class="section note"><dt>Note</dt><dd>Returns a nullptr if no compatible match was found or if the function list is empty. A compatible match is defined as an Explicit, Implicit or Ambiguous match (where the latter returns the first matched implicit function where other implicit matches exist).</dd>
<dd>
If multiple implicit matches are found, the first match is returned and 'type' is set to Ambiguous (if provided). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All funcions in this group must implement the types(ArgInfo) virtual function, which is optional in LLVM 15 but required from LLVM 16.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Args representing the function argument types </td></tr>
    <tr><td class="paramname">C</td><td>The llvm context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a824032018bcbf98c0feb287d458be062" name="a824032018bcbf98c0feb287d458be062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824032018bcbf98c0feb287d458be062">&#9670;&#160;</a></span>match() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html">Function</a> * match </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Type * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">Function::SignatureMatch</a> *</td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>Does not support detecting Ambiguous functions (returns Implicit in these cases). </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated</a></b></dt><dd>"Switch to AX's internal ArgInfo types for LLVM 16 onwards" <br  />
 </dd></dl>

</div>
</div>
<a id="a860a900733b4494b77121df7259a064f" name="a860a900733b4494b77121df7259a064f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860a900733b4494b77121df7259a064f">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax.html">ax</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html">codegen</a></li><li class="navelem"><a href="structopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1FunctionGroup.html">FunctionGroup</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
