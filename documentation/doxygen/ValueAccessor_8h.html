<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: openvdb/tree/ValueAccessor.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('ValueAccessor_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">ValueAccessor.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>ValueAccessors are designed to help accelerate accesses into the OpenVDB Tree structures by storing caches to Tree branches. When traversing a grid in a spatially coherent pattern (e.g., iterating over neighboring voxels), the same branches and nodes of the underlying tree can be hit. If you do this using the Tree/RootNode methods directly, traversal will occur at O(log(n)) (or O(n) depending on the hash map implementation) for every access. However, using a ValueAccessor allows for the Accessor to cache previously visited Nodes, providing possible subsequent access speeds of O(1) if the next access is close to a previously cached Node. Accessors are lightweight and can be configured to cache any number of arbitrary Tree levels.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;openvdb/version.h&gt;</code><br />
<code>#include &lt;<a class="el" href="openvdb_2Types_8h_source.html">openvdb/Types.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="Assert_8h_source.html">openvdb/util/Assert.h</a>&gt;</code><br />
<code>#include &lt;tbb/spin_mutex.h&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;mutex&gt;</code><br />
</div>
<p><a href="ValueAccessor_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:ValueAccessorBase_3C_20TreeType_2C_20IsSafe_20_3E" id="r_ValueAccessorBase_3C_20TreeType_2C_20IsSafe_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase&lt; TreeType, IsSafe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class for ValueAccessors manages registration of an accessor with a tree so that the tree can automatically clear the accessor whenever one of its nodes is deleted.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueAccessorLock_3C_20MutexT_20_3E" id="r_ValueAccessorLock_3C_20MutexT_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorLock.html">ValueAccessorLock&lt; MutexT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small class that contains a Mutex which is derived from by the internal Value Accessor Implementation. This allows for the empty base class optimization to be performed in the case where a Mutex/Lock is not in use. From C++20 we can instead switch to [[no_unique_address]].  <a href="structopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorLock.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueAccessorLock_3C_20void_20_3E" id="r_ValueAccessorLock_3C_20void_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorLock_3_01void_01_4.html">ValueAccessorLock&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the case where no Mutex is in use. See above.  <a href="structopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorLock_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueAccessorLeafBuffer_3C_20TreeTypeT_2C_20IntegerSequence_2C_20Enable_20_3E" id="r_ValueAccessorLeafBuffer_3C_20TreeTypeT_2C_20IntegerSequence_2C_20Enable_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorLeafBuffer.html">ValueAccessorLeafBuffer&lt; TreeTypeT, IntegerSequence, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small class that contains a cached pointer to a <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim....">LeafNode</a> data buffer which is derived from by the internal Value Accessor Implementation. This allows for the empty base class optimization to be performed in the case where a <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim....">LeafNode</a> does not store a contiguous index-able buffer. From C++20 we can instead switch to [[no_unique_address]].  <a href="structopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorLeafBuffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueAccessorImpl_3C_20_5FTreeType_2C_20IsSafe_2C_20MutexT_2C_20IntegerSequence_20_3E" id="r_ValueAccessorImpl_3C_20_5FTreeType_2C_20IsSafe_2C_20MutexT_2C_20IntegerSequence_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl&lt; _TreeType, IsSafe, MutexT, IntegerSequence &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Value Accessor Implementation and API methods. The majoirty of the API matches the API of a compatible OpenVDB <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1Tree.html">Tree</a> Node.  <a href="classopenvdb_1_1v13__0_1_1tree_1_1ValueAccessorImpl.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:openvdb" id="r_openvdb"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb.html">openvdb</a></td></tr>
<tr class="memitem:openvdb_3A_3Av13_5F0" id="r_openvdb_3A_3Av13_5F0"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0.html">openvdb::v13_0</a></td></tr>
<tr class="memitem:openvdb_3A_3Av13_5F0_3A_3Atree" id="r_openvdb_3A_3Av13_5F0_3A_3Atree"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html">openvdb::v13_0::tree</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a09d15a8ce9e84448003ae4bb40326488" id="r_a09d15a8ce9e84448003ae4bb40326488"><td class="memTemplParams" colspan="2">template&lt;typename TreeType, bool IsSafe = true, size_t CacheLevels = std::max(Index(1),TreeType::DEPTH)-1, typename MutexType = void&gt; </td></tr>
<tr class="memitem:a09d15a8ce9e84448003ae4bb40326488 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488">ValueAccessor</a></td></tr>
<tr class="memdesc:a09d15a8ce9e84448003ae4bb40326488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default alias for a <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a>. This is simply a helper alias for the generic definition but takes a single <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> specifying the number of nodes to cache. This is expanded into an index sequence (required for backward compatibility).  <br /></td></tr>
<tr class="memitem:a71c89514a00864f659030a7d88272bb7" id="r_a71c89514a00864f659030a7d88272bb7"><td class="memTemplParams" colspan="2">template&lt;typename TreeType, bool IsSafe&gt; </td></tr>
<tr class="memitem:a71c89514a00864f659030a7d88272bb7 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a71c89514a00864f659030a7d88272bb7">ValueAccessor0</a></td></tr>
<tr class="memdesc:a71c89514a00864f659030a7d88272bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a> which doesn't cache any Internal or Leaf nodes.  <br /></td></tr>
<tr class="memitem:ab2453161a80247daa47ab68fdbbf7303" id="r_ab2453161a80247daa47ab68fdbbf7303"><td class="memTemplParams" colspan="2">template&lt;typename TreeType, bool IsSafe, size_t L0 = 0&gt; </td></tr>
<tr class="memitem:ab2453161a80247daa47ab68fdbbf7303 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#ab2453161a80247daa47ab68fdbbf7303">ValueAccessor1</a></td></tr>
<tr class="memdesc:ab2453161a80247daa47ab68fdbbf7303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a> which caches a single node level. By default, the node level is 0, which corresponds to the lowest node level, typically LeafNodes.  <br /></td></tr>
<tr class="memitem:a592c66f93fb0e930ce01a393884f35d6" id="r_a592c66f93fb0e930ce01a393884f35d6"><td class="memTemplParams" colspan="2">template&lt;typename TreeType, bool IsSafe, size_t L0 = 0, size_t L1 = 1&gt; </td></tr>
<tr class="memitem:a592c66f93fb0e930ce01a393884f35d6 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a592c66f93fb0e930ce01a393884f35d6">ValueAccessor2</a></td></tr>
<tr class="memdesc:a592c66f93fb0e930ce01a393884f35d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a> which caches two node levels. By default the two lowest node levels are selected (0, 1) which typically correspond to an InternalNode and its child LeafNodes. This instantiation will only be valid for <a class="el" href="namespaceopenvdb_1_1v13__0.html#a3a90960207f67b6eef0b2bd45c820e94">TreeTypes</a> which have at least two levels of nodes (excluding the Root node).  <br /></td></tr>
<tr class="memitem:a682224f88f42583ec31fc43552b962b8" id="r_a682224f88f42583ec31fc43552b962b8"><td class="memTemplParams" colspan="2">template&lt;typename TreeType, bool IsSafe, size_t L0 = 0, size_t L1 = 1, size_t L2 = 2&gt; </td></tr>
<tr class="memitem:a682224f88f42583ec31fc43552b962b8 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a682224f88f42583ec31fc43552b962b8">ValueAccessor3</a></td></tr>
<tr class="memdesc:a682224f88f42583ec31fc43552b962b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a <a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a09d15a8ce9e84448003ae4bb40326488" title="Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes...">ValueAccessor</a> which caches three node levels. By default the three lowest node levels are selected (0, 1, 2) which typically correspond to two InternalNodes followed by the bottom LeafNodes. This instantiation will only be valid for <a class="el" href="namespaceopenvdb_1_1v13__0.html#a3a90960207f67b6eef0b2bd45c820e94">TreeTypes</a> which have at least three levels of nodes (excluding the Root node).  <br /></td></tr>
<tr class="memitem:a2be6027a90f96de5f0afc733ef61967b" id="r_a2be6027a90f96de5f0afc733ef61967b"><td class="memTemplParams" colspan="2">template&lt;typename TreeType, bool IsSafe = true, size_t CacheLevels = std::max(Index(1),TreeType::DEPTH)-1&gt; </td></tr>
<tr class="memitem:a2be6027a90f96de5f0afc733ef61967b template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tree.html#a2be6027a90f96de5f0afc733ef61967b">ValueAccessorRW</a></td></tr>
<tr class="memdesc:a2be6027a90f96de5f0afc733ef61967b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a ValueAccesor which spin locks every API call.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ValueAccessors are designed to help accelerate accesses into the OpenVDB Tree structures by storing caches to Tree branches. When traversing a grid in a spatially coherent pattern (e.g., iterating over neighboring voxels), the same branches and nodes of the underlying tree can be hit. If you do this using the Tree/RootNode methods directly, traversal will occur at O(log(n)) (or O(n) depending on the hash map implementation) for every access. However, using a ValueAccessor allows for the Accessor to cache previously visited Nodes, providing possible subsequent access speeds of O(1) if the next access is close to a previously cached Node. Accessors are lightweight and can be configured to cache any number of arbitrary Tree levels. </p>
<p>The ValueAccessor interfaces matches that of compatible OpenVDB Tree nodes. You can request an Accessor from a Grid (with Grid::getAccessor()) or construct one directly from a Tree. You can use, for example, the accessor's <code>getValue()</code> and <code>setValue()</code> methods in place of those on OpenVDB Nodes/Trees.</p>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">FloatGrid grid;</div>
<div class="line">FloatGrid::Accessor acc = grid.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1Grid.html#afd9327e5a015e2e860017765f0eb372c">getAccessor</a>();</div>
<div class="line"><span class="comment">// First access is slow:</span></div>
<div class="line">acc.setValue(Coord(0, 0, 0), 100);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Subsequent nearby accesses are fast, since the accessor now holds pointers</span></div>
<div class="line"><span class="comment">// to nodes that contain (0, 0, 0) along the path from the root of the grid&#39;s</span></div>
<div class="line"><span class="comment">// tree to the leaf:</span></div>
<div class="line">acc.setValue(Coord(0, 0, 1), 100);</div>
<div class="line">acc.getValue(Coord(0, 2, 0), 100);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Slow, because the accessor must be repopulated:</span></div>
<div class="line">acc.getValue(Coord(-1, -1, -1));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fast:</span></div>
<div class="line">acc.getValue(Coord(-1, -1, -2));</div>
<div class="line">acc.setValue(Coord(-1, -2, 0), -100);</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1Grid_html_afd9327e5a015e2e860017765f0eb372c"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1Grid.html#afd9327e5a015e2e860017765f0eb372c">openvdb::v13_0::Grid::getAccessor</a></div><div class="ttdeci">Accessor getAccessor()</div><div class="ttdoc">Return an accessor that provides random read and write access to this grid&#39;s voxels.</div><div class="ttdef"><b>Definition</b> Grid.h:732</div></div>
</div><!-- fragment --> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_5862e09d5e9b1231151ba919eed3a485.html">openvdb</a></li><li class="navelem"><a href="dir_743a3d2d25c0a54b71ee8e9cf4fb62cd.html">tree</a></li><li class="navelem"><a href="ValueAccessor_8h.html">ValueAccessor.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
