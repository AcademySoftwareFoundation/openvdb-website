<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: openvdb/tree/ValueAccessor.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">10.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_5862e09d5e9b1231151ba919eed3a485.html">openvdb</a></li><li class="navelem"><a class="el" href="dir_743a3d2d25c0a54b71ee8e9cf4fb62cd.html">tree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">ValueAccessor.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>ValueAccessors are designed to help accelerate accesses into the OpenVDB Tree structures by storing caches to Tree branches. When traversing a grid in a spatially coherent pattern (e.g., iterating over neighboring voxels), the same branches and nodes of the underlying tree can be hit. If you do this using the Tree/RootNode methods directly, traversal will occur at O(log(n)) (or O(n) depending on the hash map implementation) for every access. However, using a ValueAccessor allows for the Accessor to cache previously visited Nodes, providing possible subsequent access speeds of O(1) if the next access is close to a previously cached Node. Accessors are lightweight and can be configured to cache any number of arbitrary Tree levels.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;openvdb/version.h&gt;</code><br />
<code>#include &lt;<a class="el" href="openvdb_2Types_8h_source.html">openvdb/Types.h</a>&gt;</code><br />
<code>#include &lt;tbb/spin_mutex.h&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;mutex&gt;</code><br />
</div>
<p><a href="ValueAccessor_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl&lt; _TreeType, IsSafe, MutexT, IntegerSequence &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Value Accessor Implementation and API methods. The majoirty of the API matches the API of a compatible OpenVDB <a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1Tree.html">Tree</a> Node.  <a href="classopenvdb_1_1v10__0_1_1tree_1_1ValueAccessorImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1ValueAccessorBase.html">ValueAccessorBase&lt; TreeType, IsSafe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class for ValueAccessors manages registration of an accessor with a tree so that the tree can automatically clear the accessor whenever one of its nodes is deleted.  <a href="classopenvdb_1_1v10__0_1_1tree_1_1ValueAccessorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1tree_1_1ValueAccessorLock.html">ValueAccessorLock&lt; MutexT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small class that contains a Mutex which is derived from by the internal Value Accessor Implementation. This allows for the empty base class optimization to be performed in the case where a Mutex/Lock is not in use. From C++20 we can instead switch to [[no_unique_address]].  <a href="structopenvdb_1_1v10__0_1_1tree_1_1ValueAccessorLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1tree_1_1ValueAccessorLock_3_01void_01_4.html">ValueAccessorLock&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the case where no Mutex is in use. See above.  <a href="structopenvdb_1_1v10__0_1_1tree_1_1ValueAccessorLock_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1tree_1_1ValueAccessorLeafBuffer.html">ValueAccessorLeafBuffer&lt; TreeTypeT, IntegerSequence, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small class that contains a cached pointer to a <a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim...">LeafNode</a> data buffer which is derived from by the internal Value Accessor Implementation. This allows for the empty base class optimization to be performed in the case where a <a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1LeafNode.html" title="Templated block class to hold specific data types and a fixed number of values determined by Log2Dim...">LeafNode</a> does not store a contiguous index-able buffer. From C++20 we can instead switch to [[no_unique_address]].  <a href="structopenvdb_1_1v10__0_1_1tree_1_1ValueAccessorLeafBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v10__0_1_1tree_1_1ValueAccessorLeafBuffer_3_01TreeTypeT_00_01IntegerSequence_00741773d190eb0eb35a97259e40ef6ee0.html">ValueAccessorLeafBuffer&lt; TreeTypeT, IntegerSequence,           typename std::enable_if&lt;                                                  !value_accessor_internal::EnableLeafBuffer&lt; TreeTypeT, IntegerSequence &gt;::value           &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the case where a Leaf Buffer cannot be cached.  <a href="structopenvdb_1_1v10__0_1_1tree_1_1ValueAccessorLeafBuffer_3_01TreeTypeT_00_01IntegerSequence_00741773d190eb0eb35a97259e40ef6ee0.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1ValueAccessorImpl.html">ValueAccessorImpl&lt; _TreeType, IsSafe, MutexT, IntegerSequence &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Value Accessor Implementation and API methods. The majoirty of the API matches the API of a compatible OpenVDB <a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1Tree.html">Tree</a> Node.  <a href="classopenvdb_1_1v10__0_1_1tree_1_1ValueAccessorImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceopenvdb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb.html">openvdb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v10__0"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0.html">openvdb::v10_0</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v10__0_1_1tree"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1tree.html">openvdb::v10_0::tree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9bffaa36c0bfe91d3ac486db84d76410"><td class="memTemplParams" colspan="2">template&lt;typename TreeType , bool IsSafe = true, size_t CacheLevels = std::max(Index(1),TreeType::DEPTH)-1, typename MutexType  = void&gt; </td></tr>
<tr class="memitem:a9bffaa36c0bfe91d3ac486db84d76410"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1tree.html#a9bffaa36c0bfe91d3ac486db84d76410">ValueAccessor</a> = ValueAccessorImpl&lt; TreeType, IsSafe, MutexType, <a class="el" href="namespaceopenvdb_1_1v10__0.html#a64bb796a5880d027cddd2f6a2f43224c">openvdb::make_index_sequence</a>&lt; CacheLevels &gt;&gt;</td></tr>
<tr class="memdesc:a9bffaa36c0bfe91d3ac486db84d76410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default alias for a ValueAccessor. This is simply a helper alias for the generic definition but takes a single Index specifying the number of nodes to cache. This is expanded into an index sequence (required for backward compatibility).  <a href="namespaceopenvdb_1_1v10__0_1_1tree.html#a9bffaa36c0bfe91d3ac486db84d76410">More...</a><br /></td></tr>
<tr class="separator:a9bffaa36c0bfe91d3ac486db84d76410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91391009e65d76543e7e542bc18b395f"><td class="memTemplParams" colspan="2">template&lt;typename TreeType , bool IsSafe&gt; </td></tr>
<tr class="memitem:a91391009e65d76543e7e542bc18b395f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1tree.html#a91391009e65d76543e7e542bc18b395f">ValueAccessor0</a> = ValueAccessorImpl&lt; TreeType, IsSafe, void, <a class="el" href="structopenvdb_1_1v10__0_1_1index__sequence.html">openvdb::index_sequence</a>&lt;&gt;&gt;</td></tr>
<tr class="memdesc:a91391009e65d76543e7e542bc18b395f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a ValueAccessor which doesn't cache any Internal or Leaf nodes.  <a href="namespaceopenvdb_1_1v10__0_1_1tree.html#a91391009e65d76543e7e542bc18b395f">More...</a><br /></td></tr>
<tr class="separator:a91391009e65d76543e7e542bc18b395f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc6cb02d8dbeef5695e7e10b98768ec"><td class="memTemplParams" colspan="2">template&lt;typename TreeType , bool IsSafe, size_t L0 = 0&gt; </td></tr>
<tr class="memitem:acfc6cb02d8dbeef5695e7e10b98768ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1tree.html#acfc6cb02d8dbeef5695e7e10b98768ec">ValueAccessor1</a> = ValueAccessorImpl&lt; TreeType, IsSafe, void, <a class="el" href="structopenvdb_1_1v10__0_1_1index__sequence.html">openvdb::index_sequence</a>&lt; L0 &gt;&gt;</td></tr>
<tr class="memdesc:acfc6cb02d8dbeef5695e7e10b98768ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a ValueAccessor which caches a single node level. By default, the node level is 0, which corresponds to the lowest node level, typically LeafNodes.  <a href="namespaceopenvdb_1_1v10__0_1_1tree.html#acfc6cb02d8dbeef5695e7e10b98768ec">More...</a><br /></td></tr>
<tr class="separator:acfc6cb02d8dbeef5695e7e10b98768ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d86ca6794e2fa6a7a71a358ca8eeda0"><td class="memTemplParams" colspan="2">template&lt;typename TreeType , bool IsSafe, size_t L0 = 0, size_t L1 = 1&gt; </td></tr>
<tr class="memitem:a1d86ca6794e2fa6a7a71a358ca8eeda0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1tree.html#a1d86ca6794e2fa6a7a71a358ca8eeda0">ValueAccessor2</a> = ValueAccessorImpl&lt; TreeType, IsSafe, void, <a class="el" href="structopenvdb_1_1v10__0_1_1index__sequence.html">openvdb::index_sequence</a>&lt; L0, L1 &gt;&gt;</td></tr>
<tr class="memdesc:a1d86ca6794e2fa6a7a71a358ca8eeda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a ValueAccessor which caches two node levels. By default the two lowest node levels are selected (0, 1) which typically correspond to an <a class="el" href="classopenvdb_1_1v10__0_1_1tree_1_1InternalNode.html">InternalNode</a> and its child LeafNodes. This instantiation will only be valid for TreeTypes which have at least two levels of nodes (excluding the Root node).  <a href="namespaceopenvdb_1_1v10__0_1_1tree.html#a1d86ca6794e2fa6a7a71a358ca8eeda0">More...</a><br /></td></tr>
<tr class="separator:a1d86ca6794e2fa6a7a71a358ca8eeda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1d265463c2153d920dcefb872ed705"><td class="memTemplParams" colspan="2">template&lt;typename TreeType , bool IsSafe, size_t L0 = 0, size_t L1 = 1, size_t L2 = 2&gt; </td></tr>
<tr class="memitem:afc1d265463c2153d920dcefb872ed705"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1tree.html#afc1d265463c2153d920dcefb872ed705">ValueAccessor3</a> = ValueAccessorImpl&lt; TreeType, IsSafe, void, <a class="el" href="structopenvdb_1_1v10__0_1_1index__sequence.html">openvdb::index_sequence</a>&lt; L0, L1, L2 &gt;&gt;</td></tr>
<tr class="memdesc:afc1d265463c2153d920dcefb872ed705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a ValueAccessor which caches three node levels. By default the three lowest node levels are selected (0, 1, 2) which typically correspond to two InternalNodes followed by the bottom LeafNodes. This instantiation will only be valid for TreeTypes which have at least three levels of nodes (excluding the Root node).  <a href="namespaceopenvdb_1_1v10__0_1_1tree.html#afc1d265463c2153d920dcefb872ed705">More...</a><br /></td></tr>
<tr class="separator:afc1d265463c2153d920dcefb872ed705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac968581579c1f235f8f0a22a68d7fe9b"><td class="memTemplParams" colspan="2">template&lt;typename TreeType , bool IsSafe = true, size_t CacheLevels = std::max(Index(1),TreeType::DEPTH)-1&gt; </td></tr>
<tr class="memitem:ac968581579c1f235f8f0a22a68d7fe9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v10__0_1_1tree.html#ac968581579c1f235f8f0a22a68d7fe9b">ValueAccessorRW</a> = ValueAccessorImpl&lt; TreeType, IsSafe, tbb::spin_mutex, <a class="el" href="namespaceopenvdb_1_1v10__0.html#a64bb796a5880d027cddd2f6a2f43224c">openvdb::make_index_sequence</a>&lt; CacheLevels &gt;&gt;</td></tr>
<tr class="memdesc:ac968581579c1f235f8f0a22a68d7fe9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for a ValueAccesor which spin locks every API call.  <a href="namespaceopenvdb_1_1v10__0_1_1tree.html#ac968581579c1f235f8f0a22a68d7fe9b">More...</a><br /></td></tr>
<tr class="separator:ac968581579c1f235f8f0a22a68d7fe9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ValueAccessors are designed to help accelerate accesses into the OpenVDB Tree structures by storing caches to Tree branches. When traversing a grid in a spatially coherent pattern (e.g., iterating over neighboring voxels), the same branches and nodes of the underlying tree can be hit. If you do this using the Tree/RootNode methods directly, traversal will occur at O(log(n)) (or O(n) depending on the hash map implementation) for every access. However, using a ValueAccessor allows for the Accessor to cache previously visited Nodes, providing possible subsequent access speeds of O(1) if the next access is close to a previously cached Node. Accessors are lightweight and can be configured to cache any number of arbitrary Tree levels. </p>
<p>The ValueAccessor interfaces matches that of compatible OpenVDB Tree nodes. You can request an Accessor from a Grid (with Grid::getAccessor()) or construct one directly from a Tree. You can use, for example, the accessor's <code>getValue()</code> and <code>setValue()</code> methods in place of those on OpenVDB Nodes/Trees.</p>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="namespaceopenvdb_1_1v10__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> grid;</div><div class="line">FloatGrid::Accessor acc = grid.getAccessor();</div><div class="line"><span class="comment">// First access is slow:</span></div><div class="line">acc.setValue(Coord(0, 0, 0), 100);</div><div class="line"></div><div class="line"><span class="comment">// Subsequent nearby accesses are fast, since the accessor now holds pointers</span></div><div class="line"><span class="comment">// to nodes that contain (0, 0, 0) along the path from the root of the grid&#39;s</span></div><div class="line"><span class="comment">// tree to the leaf:</span></div><div class="line">acc.setValue(Coord(0, 0, 1), 100);</div><div class="line">acc.getValue(Coord(0, 2, 0), 100);</div><div class="line"></div><div class="line"><span class="comment">// Slow, because the accessor must be repopulated:</span></div><div class="line">acc.getValue(Coord(-1, -1, -1));</div><div class="line"></div><div class="line"><span class="comment">// Fast:</span></div><div class="line">acc.getValue(Coord(-1, -1, -2));</div><div class="line">acc.setValue(Coord(-1, -2, 0), -100);</div></div><!-- fragment --> </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
