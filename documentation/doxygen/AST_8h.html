<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: openvdb_ax/ast/AST.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('AST_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">AST.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provides the definition for every abstract and concrete derived class which represent a particular abstract syntax tree (AST) node type.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="Tokens_8h_source.html">Tokens.h</a>&quot;</code><br />
<code>#include &lt;openvdb/version.h&gt;</code><br />
<code>#include &lt;<a class="el" href="Assert_8h_source.html">openvdb/util/Assert.h</a>&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="AST_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Node" id="r_Node"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base abstract node which determines the interface and required methods for all derived concrete nodes which comprise a valid AST.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="memitem:Statement" id="r_Statement"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Statement.html">Statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract (pure-virtual) AST nodes.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Statement.html#details">More...</a><br /></td></tr>
<tr class="memitem:Expression" id="r_Expression"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expressions are comprised of full or potentially partial parts of a full statement that may not necessary make up an entire valid statement on their own. For example, while a Binary Operator such as "3 + 5;"" is a valid statement on its own, the full statement
       "3 + 5 + 6;" must be broken down into two expressions which together form the statement as well as determining precedence.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Expression.html#details">More...</a><br /></td></tr>
<tr class="memitem:Variable" id="r_Variable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variables are a base type for Locals, Attributes and ExternalVariables. Unlike other abstract types, they also consolidate data for the derived types.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Variable.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueBase" id="r_ValueBase"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ValueBase.html">ValueBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ValueBases are a base class for anything that holds a value (literal). Derived classes store the actual typed values.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ValueBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:StatementList" id="r_StatementList"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1StatementList.html">StatementList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete AST nodes.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1StatementList.html#details">More...</a><br /></td></tr>
<tr class="memitem:Block" id="r_Block"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html" title="A Block node represents a scoped list of statements. It may comprise of 0 or more statements,...">Block</a> node represents a scoped list of statements. It may comprise of 0 or more statements, and specifically indicates that a new scope is activated, typically represented by curly braces. Note that a block does not alway have to be encapsulated by curly braces, but always represents a new scope.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html#details">More...</a><br /></td></tr>
<tr class="memitem:Tree" id="r_Tree"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html">Tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy....">Tree</a> is the highest concrete (non-abstract) node in the entire AX AST hierarchy. It represents an entire conversion of a valid AX string.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Tree.html#details">More...</a><br /></td></tr>
<tr class="memitem:CommaOperator" id="r_CommaOperator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1CommaOperator.html">CommaOperator</a></td></tr>
<tr class="memitem:Loop" id="r_Loop"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Loop.html">Loop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loops represent for, while and do-while loop constructs. These all consist of a condition - evaluated to determine if loop iteration should continue, and a body which is the logic to be repeated. For loops also have initial statements which are evaluated prior to loop execution (at loop scope) and commonly used to set up iterators, and iteration expressions which are evaluated between iterations after the body and before the condition. Both conditions and initial statements can be declarations or expressions, so are Statements, and iteration expressions can consist of multiple expressions. The loop body is a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Block.html" title="A Block node represents a scoped list of statements. It may comprise of 0 or more statements,...">Block</a> defining its own scope (encapsulated by initial statement scope for for-loops).  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Loop.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConditionalStatement" id="r_ConditionalStatement"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html">ConditionalStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ConditionalStatements represents all combinations of 'if', 'else' and 'else if' syntax and semantics. A single <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html" title="ConditionalStatements represents all combinations of &#39;if&#39;, &#39;else&#39; and &#39;else if&#39; syntax and semantics....">ConditionalStatement</a> only ever represents up to two branches; an 'if' (true) and an optional 'else' (false). ConditionalStatements are nested within the second 'else' branch to support 'else if' logic. As well as both 'if' and 'else' branches, a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html" title="ConditionalStatements represents all combinations of &#39;if&#39;, &#39;else&#39; and &#39;else if&#39; syntax and semantics....">ConditionalStatement</a> also holds an <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Expression.html" title="Expressions are comprised of full or potentially partial parts of a full statement that may not neces...">Expression</a> related to its primary condition.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ConditionalStatement.html#details">More...</a><br /></td></tr>
<tr class="memitem:BinaryOperator" id="r_BinaryOperator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html">BinaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html" title="A BinaryOperator represents a single binary operation between a left hand side (LHS) and right hand s...">BinaryOperator</a> represents a single binary operation between a left hand side (LHS) and right hand side (RHS) expression. The operation type is stored as a <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">tokens::OperatorToken</a> enumerated type on the node. AX grammar guarantees that this token will only ever be a valid binary operator token type when initialized by the parser.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html#details">More...</a><br /></td></tr>
<tr class="memitem:TernaryOperator" id="r_TernaryOperator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html">TernaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html" title="A TernaryOperator represents a ternary (conditional) expression &#39;a ? b : c&#39; which evaluates to &#39;b&#39; if...">TernaryOperator</a> represents a ternary (conditional) expression 'a ? b : c' which evaluates to 'b' if 'a' is true and 'c' if 'a' is false. Requires 'b' and 'c' to be convertibly typed expressions, or both void. The 'true' expression ('b') is optional with the conditional expression 'a' returned if it evaluates to true, otherwise returning 'c'. Note that 'a' will only be evaluated once in this case.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1TernaryOperator.html#details">More...</a><br /></td></tr>
<tr class="memitem:AssignExpression" id="r_AssignExpression"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1AssignExpression.html">AssignExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AssignExpressions represents a similar object construction to a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1BinaryOperator.html" title="A BinaryOperator represents a single binary operation between a left hand side (LHS) and right hand s...">BinaryOperator</a>. AssignExpressions can be chained together and are thus derived as Expressions rather than Statements.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1AssignExpression.html#details">More...</a><br /></td></tr>
<tr class="memitem:Crement" id="r_Crement"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html">Crement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html" title="A Crement node represents a single increment &#39;++&#39; and decrement &#39;â€“&#39; operation. As well as it&#39;s cremen...">Crement</a> node represents a single increment '++' and decrement '&ndash;' operation. As well as it's crement type, it also stores whether the semantics constructed a post or pre-crement i.e. ++a or a++.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Crement.html#details">More...</a><br /></td></tr>
<tr class="memitem:UnaryOperator" id="r_UnaryOperator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html">UnaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html" title="A UnaryOperator represents a single unary operation on an expression. The operation type is stored as...">UnaryOperator</a> represents a single unary operation on an expression. The operation type is stored as a <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">tokens::OperatorToken</a> enumerated type on the node. AX grammar guarantees that this token will only every be a valid unary operator token type when initialized by the parser.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1UnaryOperator.html#details">More...</a><br /></td></tr>
<tr class="memitem:Cast" id="r_Cast"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html" title="Cast nodes represent the conversion of an underlying expression to a target type. Cast nodes are typi...">Cast</a> nodes represent the conversion of an underlying expression to a target type. <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html" title="Cast nodes represent the conversion of an underlying expression to a target type. Cast nodes are typi...">Cast</a> nodes are typically constructed from functional notation and do not represent construction of the target type, rather a type-casted conversion.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Cast.html#details">More...</a><br /></td></tr>
<tr class="memitem:FunctionCall" id="r_FunctionCall"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1FunctionCall.html">FunctionCall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FunctionCalls represent a single call to a function and any provided arguments. The argument list can be empty. The function name is expected to exist in the AX function registry.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1FunctionCall.html#details">More...</a><br /></td></tr>
<tr class="memitem:Keyword" id="r_Keyword"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Keyword.html">Keyword</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keywords represent keyword statements defining changes in execution. These include those that define changes in loop execution such as break and continue, as well as return statements.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Keyword.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArrayUnpack" id="r_ArrayUnpack"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html">ArrayUnpack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html" title="ArrayUnpack represent indexing operations into AX container types, primarily vectors and matrices ind...">ArrayUnpack</a> represent indexing operations into AX container types, primarily vectors and matrices indexed by the square brackets [] syntax. Multiple levels of indirection (multiple components) can be specified but current construction is limited to either a single or double component lookup. Providing two components infers a matrix indexing operation.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayUnpack.html#details">More...</a><br /></td></tr>
<tr class="memitem:ArrayPack" id="r_ArrayPack"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayPack.html">ArrayPack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ArrayPacks represent temporary container creations of arbitrary sizes, typically generated through the use of curly braces {}.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ArrayPack.html#details">More...</a><br /></td></tr>
<tr class="memitem:Attribute" id="r_Attribute"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes represent any access to a primitive value, typically associated with the '@' symbol syntax. Note that the AST does not store any additional information on the given attribute other than its name and type, which together form a unique <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html" title="Attributes represent any access to a primitive value, typically associated with the &#39;@&#39; symbol syntax...">Attribute</a> identifier known as the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html" title="Attributes represent any access to a primitive value, typically associated with the &#39;@&#39; symbol syntax...">Attribute</a> 'token'. A 'primitive value' in this instance refers to a value on an OpenVDB Volume or OpenVDB Points tree.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Attribute.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExternalVariable" id="r_ExternalVariable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> represent any access to external (custom) data, typically associated with the '$' symbol syntax. Note that the AST does not store any additional information on the given external other than its name and type, which together form a unique external identifier known as the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> 'token'. This token is used by the compiler to map user provided values to these external values.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1ExternalVariable.html#details">More...</a><br /></td></tr>
<tr class="memitem:Local" id="r_Local"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Local.html">Local</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Local.html" title="Local AST nodes represent a single accesses to a local variable. The only store the name of the varia...">Local</a> AST nodes represent a single accesses to a local variable. The only store the name of the variable being accessed.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Local.html#details">More...</a><br /></td></tr>
<tr class="memitem:DeclareLocal" id="r_DeclareLocal"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html">DeclareLocal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html" title="DeclareLocal AST nodes symbolize a single type declaration of a local variable. These store the local...">DeclareLocal</a> AST nodes symbolize a single type declaration of a local variable. These store the local variables that They also however store its specified type. These have the important distinction of representing the initial creation and allocation of a variable, in comparison to a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Local.html" title="Local AST nodes represent a single accesses to a local variable. The only store the name of the varia...">Local</a> node which only represents access.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1DeclareLocal.html#details">More...</a><br /></td></tr>
<tr class="memitem:Value_3C_20T_20_3E" id="r_Value_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value.html">Value&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value.html" title="A Value (literal) AST node holds either literal text or absolute value information on all numerical,...">Value</a> (literal) AST node holds either literal text or absolute value information on all numerical, string and boolean constants. A single instance of a <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value.html" title="A Value (literal) AST node holds either literal text or absolute value information on all numerical,...">Value</a> is templated on the requested scalar, boolean or string type. If scalar or boolean value is constructed from a string (as typically is the case in the parser), the value is automatically converted to its numerical representation. If this fails, the original text is stored instead.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value.html#details">More...</a><br /></td></tr>
<tr class="memitem:Value_3C_20std_3A_3Astring_20_3E" id="r_Value_3C_20std_3A_3Astring_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value_3_01std_1_1string_01_4.html">Value&lt; std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of Values for strings.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Value_3_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:openvdb" id="r_openvdb"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb.html">openvdb</a></td></tr>
<tr class="memitem:openvdb_3A_3Av13_5F0" id="r_openvdb_3A_3Av13_5F0"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0.html">openvdb::v13_0</a></td></tr>
<tr class="memitem:openvdb_3A_3Av13_5F0_3A_3Aax" id="r_openvdb_3A_3Av13_5F0_3A_3Aax"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax.html">openvdb::v13_0::ax</a></td></tr>
<tr class="memitem:openvdb_3A_3Av13_5F0_3A_3Aax_3A_3Aast" id="r_openvdb_3A_3Av13_5F0_3A_3Aax_3A_3Aast"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast.html">openvdb::v13_0::ax::ast</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides the definition for every abstract and concrete derived class which represent a particular abstract syntax tree (AST) node type. </p>
<dl class="section author"><dt>Authors</dt><dd>Nick Avramoussis, Richard Jones</dd></dl>
<p>AST nodes represents a particular branch of a complete AST. Concrete nodes can be thought of as leaf node types which hold semantic information of a partial or complete statement or expression. A string of AX can be fully represented by building the correct AST structure. The AX grammar defined in axparser.y represents the valid mapping of a tokenized string to AST nodes.</p>
<p>AST node classes can either represent a "leaf-level" semantic component of a given AX AST, or an abstract base type. The latter are used by the parser and leaf-level AST nodes for storage of compatible child nodes, and provide grouping of various nodes which share common semantics. The main two types of abstract AST nodes are statements and expressions. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_cae5b229f742550e00edd472eaaf99f1.html">openvdb_ax</a></li><li class="navelem"><a href="dir_5f1e3d7507c796010e80f0c4098c8b36.html">ast</a></li><li class="navelem"><a href="AST_8h.html">AST.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
