<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: openvdb::v13_0::points Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespaceopenvdb_1_1v13__0_1_1points.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">openvdb::v13_0::points Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:attribute_5Ftraits" id="r_attribute_5Ftraits"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1points_1_1attribute__traits.html">attribute_traits</a></td></tr>
<tr class="memitem:future" id="r_future"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1points_1_1future.html">future</a></td></tr>
<tr class="memdesc:namespaceopenvdb_1_1v13__0_1_1points_1_1future"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for ABI=5 to help ease introduction of upcoming features. <br /></td></tr>
<tr class="memitem:index" id="r_index"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1points_1_1index.html">index</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:AccessorEval" id="r_AccessorEval"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1AccessorEval.html">AccessorEval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to call unsafe get and set methods based on templated Codec and Value.  <a href="structopenvdb_1_1v13__0_1_1points_1_1AccessorEval.html#details">More...</a><br /></td></tr>
<tr class="memitem:AccessorEval_3C_20UnknownCodec_2C_20ValueType_20_3E" id="r_AccessorEval_3C_20UnknownCodec_2C_20ValueType_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1AccessorEval_3_01UnknownCodec_00_01ValueType_01_4.html">AccessorEval&lt; UnknownCodec, ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization when Codec is not known at compile-time to use the supplied functor instead.  <a href="structopenvdb_1_1v13__0_1_1points_1_1AccessorEval_3_01UnknownCodec_00_01ValueType_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttributeArray" id="r_AttributeArray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeArray.html">AttributeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for storing attribute data.  <a href="classopenvdb_1_1v13__0_1_1points_1_1AttributeArray.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttributeHandle" id="r_AttributeHandle"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeHandle.html">AttributeHandle</a></td></tr>
<tr class="memitem:AttributeHashFilter" id="r_AttributeHashFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeHashFilter.html">AttributeHashFilter</a></td></tr>
<tr class="memitem:AttributeSet" id="r_AttributeSet"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeSet.html">AttributeSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered collection of uniquely-named attribute arrays.  <a href="classopenvdb_1_1v13__0_1_1points_1_1AttributeSet.html#details">More...</a><br /></td></tr>
<tr class="memitem:AttributeWriteHandle" id="r_AttributeWriteHandle"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeWriteHandle.html">AttributeWriteHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write-able version of <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeHandle.html">AttributeHandle</a>.  <a href="classopenvdb_1_1v13__0_1_1points_1_1AttributeWriteHandle.html#details">More...</a><br /></td></tr>
<tr class="memitem:BBoxFilter" id="r_BBoxFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1BBoxFilter.html">BBoxFilter</a></td></tr>
<tr class="memitem:BinaryFilter" id="r_BinaryFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1BinaryFilter.html">BinaryFilter</a></td></tr>
<tr class="memitem:DeformerTraits" id="r_DeformerTraits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1DeformerTraits.html">DeformerTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deformer Traits for optionally configuring deformers to be applied in index-space. The default is world-space.  <a href="structopenvdb_1_1v13__0_1_1points_1_1DeformerTraits.html#details">More...</a><br /></td></tr>
<tr class="memitem:DummySampleType" id="r_DummySampleType"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1DummySampleType.html">DummySampleType</a></td></tr>
<tr class="memitem:EllipsoidSettings" id="r_EllipsoidSettings"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings.html">EllipsoidSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anisotropic point rasterization based on the principal component analysis of point neighbours. See the struct member documentation for detailed behavior.  <a href="structopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings.html#details">More...</a><br /></td></tr>
<tr class="memitem:FilteredTransfer" id="r_FilteredTransfer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1FilteredTransfer.html">FilteredTransfer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1FilteredTransfer.html" title="FilteredTransfer module, when derived from allows for schemes to apply point filtering....">FilteredTransfer</a> module, when derived from allows for schemes to apply point filtering. Note that this module handles the thread safe intialization and storage of the filter, but derived schemes must call <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1FilteredTransfer.html#a73bb2a1eb90f28e972582fec6e4d2eb6">FilteredTransfer::filter()</a> per point id and handle the result.  <a href="structopenvdb_1_1v13__0_1_1points_1_1FilteredTransfer.html#details">More...</a><br /></td></tr>
<tr class="memitem:FilteredTransfer_3C_20NullFilter_20_3E" id="r_FilteredTransfer_3C_20NullFilter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1FilteredTransfer_3_01NullFilter_01_4.html">FilteredTransfer&lt; NullFilter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1FilteredTransfer.html" title="FilteredTransfer module, when derived from allows for schemes to apply point filtering....">FilteredTransfer</a> for NullFilters which do nothing.  <a href="structopenvdb_1_1v13__0_1_1points_1_1FilteredTransfer_3_01NullFilter_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:FilterTraits" id="r_FilterTraits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1FilterTraits.html">FilterTraits</a></td></tr>
<tr class="memitem:FilterTraits_3C_20BBoxFilter_20_3E" id="r_FilterTraits_3C_20BBoxFilter_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1FilterTraits_3_01BBoxFilter_01_4.html">FilterTraits&lt; BBoxFilter &gt;</a></td></tr>
<tr class="memitem:FilterTraits_3C_20BinaryFilter_3C_20T0_2C_20T1_2C_20And_20_3E_20_3E" id="r_FilterTraits_3C_20BinaryFilter_3C_20T0_2C_20T1_2C_20And_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1FilterTraits_3_01BinaryFilter_3_01T0_00_01T1_00_01And_01_4_01_4.html">FilterTraits&lt; BinaryFilter&lt; T0, T1, And &gt; &gt;</a></td></tr>
<tr class="memitem:FilterTraits_3C_20LevelSetFilter_3C_20T_20_3E_20_3E" id="r_FilterTraits_3C_20LevelSetFilter_3C_20T_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1FilterTraits_3_01LevelSetFilter_3_01T_01_4_01_4.html">FilterTraits&lt; LevelSetFilter&lt; T &gt; &gt;</a></td></tr>
<tr class="memitem:FixedPointCodec" id="r_FixedPointCodec"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1FixedPointCodec.html">FixedPointCodec</a></td></tr>
<tr class="memitem:FrustumRasterizer" id="r_FrustumRasterizer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1FrustumRasterizer.html">FrustumRasterizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient rasterization of one or more VDB Points grids into a linear or frustum volume with the option to bake in camera or geometry motion blur.  <a href="classopenvdb_1_1v13__0_1_1points_1_1FrustumRasterizer.html#details">More...</a><br /></td></tr>
<tr class="memitem:FrustumRasterizerMask" id="r_FrustumRasterizerMask"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1FrustumRasterizerMask.html">FrustumRasterizerMask</a></td></tr>
<tr class="memitem:FrustumRasterizerSettings" id="r_FrustumRasterizerSettings"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1FrustumRasterizerSettings.html">FrustumRasterizerSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A group of shared settings to be used in the Volume Rasterizer.  <a href="structopenvdb_1_1v13__0_1_1points_1_1FrustumRasterizerSettings.html#details">More...</a><br /></td></tr>
<tr class="memitem:GroupCodec" id="r_GroupCodec"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1GroupCodec.html">GroupCodec</a></td></tr>
<tr class="memitem:GroupFilter" id="r_GroupFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1GroupFilter.html">GroupFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> filtering on group membership.  <a href="classopenvdb_1_1v13__0_1_1points_1_1GroupFilter.html#details">More...</a><br /></td></tr>
<tr class="memitem:GroupHandle" id="r_GroupHandle"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1GroupHandle.html">GroupHandle</a></td></tr>
<tr class="memitem:GroupWriteHandle" id="r_GroupWriteHandle"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1GroupWriteHandle.html">GroupWriteHandle</a></td></tr>
<tr class="memitem:IndexIter" id="r_IndexIter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1IndexIter.html">IndexIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator over array indices with filtering IteratorT can be either <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1IndexIter.html" title="A forward iterator over array indices with filtering IteratorT can be either IndexIter or ValueIndexI...">IndexIter</a> or <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1IndexIter_1_1ValueIndexIter.html" title="A forward iterator over array indices from a value iterator (such as ValueOnCIter)">ValueIndexIter</a> (or some custom index iterator) FilterT should be a struct or class with a valid() method than can be evaluated per index Here's a simple filter example that only accepts even indices:  <a href="classopenvdb_1_1v13__0_1_1points_1_1IndexIter.html#details">More...</a><br /></td></tr>
<tr class="memitem:InterruptableTransfer" id="r_InterruptableTransfer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1InterruptableTransfer.html">InterruptableTransfer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1InterruptableTransfer.html" title="InterruptableTransfer module, when derived from allows for schemes to callback into a interrupter,...">InterruptableTransfer</a> module, when derived from allows for schemes to callback into a interrupter, derived from <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a>.  <a href="structopenvdb_1_1v13__0_1_1points_1_1InterruptableTransfer.html#details">More...</a><br /></td></tr>
<tr class="memitem:LevelSetFilter" id="r_LevelSetFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1LevelSetFilter.html">LevelSetFilter</a></td></tr>
<tr class="memitem:MultiGroupFilter" id="r_MultiGroupFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1MultiGroupFilter.html">MultiGroupFilter</a></td></tr>
<tr class="memitem:NullCodec" id="r_NullCodec"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1NullCodec.html">NullCodec</a></td></tr>
<tr class="memitem:NullDeformer" id="r_NullDeformer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1NullDeformer.html">NullDeformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op deformer (adheres to the deformer interface documented in <a class="el" href="PointMove_8h.html" title="Ability to move VDB Points using a custom deformer.">PointMove.h</a>)  <a href="structopenvdb_1_1v13__0_1_1points_1_1NullDeformer.html#details">More...</a><br /></td></tr>
<tr class="memitem:NullFilter" id="r_NullFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-op filter that can be used when iterating over all indices.  <a href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html#details">More...</a><br /></td></tr>
<tr class="memitem:PcaAttributes" id="r_PcaAttributes"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1PcaAttributes.html">PcaAttributes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The persistent attributes created by the PCA methods.  <a href="structopenvdb_1_1v13__0_1_1points_1_1PcaAttributes.html#details">More...</a><br /></td></tr>
<tr class="memitem:PcaSettings" id="r_PcaSettings"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1PcaSettings.html">PcaSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various settings for the neighborhood analysis of point distributions.  <a href="structopenvdb_1_1v13__0_1_1points_1_1PcaSettings.html#details">More...</a><br /></td></tr>
<tr class="memitem:PointAttributeVector" id="r_PointAttributeVector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1PointAttributeVector.html">PointAttributeVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-partitioner compatible STL vector attribute wrapper for convenience.  <a href="classopenvdb_1_1v13__0_1_1points_1_1PointAttributeVector.html#details">More...</a><br /></td></tr>
<tr class="memitem:PointDataLeafNode" id="r_PointDataLeafNode"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1PointDataLeafNode.html">PointDataLeafNode</a></td></tr>
<tr class="memitem:PositionRange" id="r_PositionRange"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1PositionRange.html">PositionRange</a></td></tr>
<tr class="memitem:RandomLeafFilter" id="r_RandomLeafFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1RandomLeafFilter.html">RandomLeafFilter</a></td></tr>
<tr class="memitem:RasterCamera" id="r_RasterCamera"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1RasterCamera.html">RasterCamera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A camera class that provides an interface for camera motion blur when rasterizing.  <a href="classopenvdb_1_1v13__0_1_1points_1_1RasterCamera.html#details">More...</a><br /></td></tr>
<tr class="memitem:RasterGroups" id="r_RasterGroups"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1RasterGroups.html">RasterGroups</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that stores all include/exclude attribute names as strings and is internally converted into the resolved <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1MultiGroupFilter.html">MultiGroupFilter</a>.  <a href="structopenvdb_1_1v13__0_1_1points_1_1RasterGroups.html#details">More...</a><br /></td></tr>
<tr class="memitem:SampleWithRounding" id="r_SampleWithRounding"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1SampleWithRounding.html">SampleWithRounding</a></td></tr>
<tr class="memitem:SmoothSphereSettings" id="r_SmoothSphereSettings"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1SmoothSphereSettings.html">SmoothSphereSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothed point distribution based sphere stamping with a uniform radius or varying radius and optionally with closest point attribute transfer of arbitrary attributes. See the struct member documentation for detailed behavior.  <a href="structopenvdb_1_1v13__0_1_1points_1_1SmoothSphereSettings.html#details">More...</a><br /></td></tr>
<tr class="memitem:SphereSettings" id="r_SphereSettings"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1SphereSettings.html">SphereSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic settings for narrow band spherical stamping with a uniform or varying radius and optionally with closest point attribute transfer of arbitrary attributes. See the struct member documentation for detailed behavior.  <a href="structopenvdb_1_1v13__0_1_1points_1_1SphereSettings.html#details">More...</a><br /></td></tr>
<tr class="memitem:StringAttributeHandle" id="r_StringAttributeHandle"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1StringAttributeHandle.html">StringAttributeHandle</a></td></tr>
<tr class="memitem:StringAttributeWriteHandle" id="r_StringAttributeWriteHandle"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1StringAttributeWriteHandle.html">StringAttributeWriteHandle</a></td></tr>
<tr class="memitem:StringCodec" id="r_StringCodec"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1StringCodec.html">StringCodec</a></td></tr>
<tr class="memitem:StringMetaCache" id="r_StringMetaCache"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1StringMetaCache.html">StringMetaCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to compute a string-&gt;index map from all string:N metadata.  <a href="classopenvdb_1_1v13__0_1_1points_1_1StringMetaCache.html#details">More...</a><br /></td></tr>
<tr class="memitem:StringMetaInserter" id="r_StringMetaInserter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1StringMetaInserter.html">StringMetaInserter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to help with insertion of keyed string values into metadata.  <a href="classopenvdb_1_1v13__0_1_1points_1_1StringMetaInserter.html#details">More...</a><br /></td></tr>
<tr class="memitem:TransformTransfer" id="r_TransformTransfer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1TransformTransfer.html">TransformTransfer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1TransformTransfer.html" title="The TransformTransfer module should be used if the source transform of the input points and the targe...">TransformTransfer</a> module should be used if the source transform of the input points and the target transforms of the destination volumes differ. The default rasterizer will skip index to world (and vice versa) transformations unless a transfer scheme derives from a <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1TransformTransfer.html" title="The TransformTransfer module should be used if the source transform of the input points and the targe...">TransformTransfer</a>.  <a href="structopenvdb_1_1v13__0_1_1points_1_1TransformTransfer.html#details">More...</a><br /></td></tr>
<tr class="memitem:TreeConverter" id="r_TreeConverter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1TreeConverter.html">TreeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similiar to ValueConverter, but allows for tree configuration conversion to a <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a>. ValueConverter&lt;PointDataIndex32&gt; cannot be used as a <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1PointDataLeafNode.html">PointDataLeafNode</a> is not a specialization of LeafNode.  <a href="structopenvdb_1_1v13__0_1_1points_1_1TreeConverter.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrilinearTraits" id="r_TrilinearTraits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1TrilinearTraits.html">TrilinearTraits</a></td></tr>
<tr class="memitem:TrilinearTraits_3C_20ValueT_2C_20false_20_3E" id="r_TrilinearTraits_3C_20ValueT_2C_20false_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1TrilinearTraits_3_01ValueT_00_01false_01_4.html">TrilinearTraits&lt; ValueT, false &gt;</a></td></tr>
<tr class="memitem:TruncateCodec" id="r_TruncateCodec"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1TruncateCodec.html">TruncateCodec</a></td></tr>
<tr class="memitem:TypedAttributeArray" id="r_TypedAttributeArray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typed class for storing attribute data.  <a href="classopenvdb_1_1v13__0_1_1points_1_1TypedAttributeArray.html#details">More...</a><br /></td></tr>
<tr class="memitem:UnitRange" id="r_UnitRange"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1UnitRange.html">UnitRange</a></td></tr>
<tr class="memitem:UnitVecCodec" id="r_UnitVecCodec"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1UnitVecCodec.html">UnitVecCodec</a></td></tr>
<tr class="memitem:UnknownCodec" id="r_UnknownCodec"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1UnknownCodec.html">UnknownCodec</a></td></tr>
<tr class="memitem:ValueMaskFilter" id="r_ValueMaskFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> filtering on active / inactive state of host voxel.  <a href="classopenvdb_1_1v13__0_1_1points_1_1ValueMaskFilter.html#details">More...</a><br /></td></tr>
<tr class="memitem:ValueVoxelCIter" id="r_ValueVoxelCIter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1ValueVoxelCIter.html">ValueVoxelCIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator over array indices in a single voxel.  <a href="classopenvdb_1_1v13__0_1_1points_1_1ValueVoxelCIter.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeTransfer" id="r_VolumeTransfer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1VolumeTransfer.html">VolumeTransfer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1VolumeTransfer.html" title="The VolumeTransfer module provides methods to automatically setup and access destination buffers for ...">VolumeTransfer</a> module provides methods to automatically setup and access destination buffers for multiple target volumes of arbitrary types. Deriving from a <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1VolumeTransfer.html" title="The VolumeTransfer module provides methods to automatically setup and access destination buffers for ...">VolumeTransfer</a> ensures that the available buffers correlate to the order of the provided tree arguments.  <a href="structopenvdb_1_1v13__0_1_1points_1_1VolumeTransfer.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeTransfer_3C_20TreeT_20_3E" id="r_VolumeTransfer_3C_20TreeT_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1VolumeTransfer_3_01TreeT_01_4.html">VolumeTransfer&lt; TreeT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1VolumeTransfer.html" title="The VolumeTransfer module provides methods to automatically setup and access destination buffers for ...">VolumeTransfer</a> specialization for a single target volume.  <a href="structopenvdb_1_1v13__0_1_1points_1_1VolumeTransfer_3_01TreeT_01_4.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af44fac5036c56999ca811116b73eca72" id="r_af44fac5036c56999ca811116b73eca72"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af44fac5036c56999ca811116b73eca72">StringAttributeArray</a> = <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a>&lt;<a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1StringCodec.html">StringCodec</a>&lt;false&gt;&gt;</td></tr>
<tr class="memitem:a9bc95058fb208e9baa08dab77d98c5fa" id="r_a9bc95058fb208e9baa08dab77d98c5fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bc95058fb208e9baa08dab77d98c5fa">GroupAttributeArray</a> = <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a>&lt;<a class="el" href="#a714bfd681b0e82019a95174ecdb6a889">GroupType</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1GroupCodec.html">GroupCodec</a>&gt;</td></tr>
<tr class="memitem:a714bfd681b0e82019a95174ecdb6a889" id="r_a714bfd681b0e82019a95174ecdb6a889"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a714bfd681b0e82019a95174ecdb6a889">GroupType</a> = uint8_t</td></tr>
<tr class="memitem:a8954944cf980f1f874a6510497568338" id="r_a8954944cf980f1f874a6510497568338"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8954944cf980f1f874a6510497568338">ActiveFilter</a> = <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a>&lt;true&gt;</td></tr>
<tr class="memitem:a8273cc7bb48dded419013b35a6491bc0" id="r_a8273cc7bb48dded419013b35a6491bc0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8273cc7bb48dded419013b35a6491bc0">InactiveFilter</a> = <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a>&lt;false&gt;</td></tr>
<tr class="memitem:a7fa856a8e82a8ff9db585d9429d2c5df" id="r_a7fa856a8e82a8ff9db585d9429d2c5df"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df">PointDataTree</a></td></tr>
<tr class="memdesc:a7fa856a8e82a8ff9db585d9429d2c5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point index tree configured to match the default VDB configurations.  <br /></td></tr>
<tr class="memitem:acf438a63a8a41ec38b6d7ceae6467678" id="r_acf438a63a8a41ec38b6d7ceae6467678"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678">PointDataGrid</a> = <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html">Grid</a>&lt;<a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df">PointDataTree</a>&gt;</td></tr>
<tr class="memdesc:acf438a63a8a41ec38b6d7ceae6467678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point data grid.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae71b1a4d4abc6a321046036c37ae645e" id="r_ae71b1a4d4abc6a321046036c37ae645e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae71b1a4d4abc6a321046036c37ae645e">RasterMode</a> { <a class="el" href="#ae71b1a4d4abc6a321046036c37ae645eac5d2a98a2112d89452e04fe14de91b91">ACCUMULATE</a> = 0
, <a class="el" href="#ae71b1a4d4abc6a321046036c37ae645ea115f17a28532bbd6f0f5ec83ed20692a">MAXIMUM</a>
, <a class="el" href="#ae71b1a4d4abc6a321046036c37ae645ea16de38737a9f8366e9b2042b4e9b6290">AVERAGE</a>
 }</td></tr>
<tr class="memdesc:ae71b1a4d4abc6a321046036c37ae645e"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to composite points into a volume.  <a href="#ae71b1a4d4abc6a321046036c37ae645e">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac237583ca1f8ce413b0c2fcf531f5c4f" id="r_ac237583ca1f8ce413b0c2fcf531f5c4f"><td class="memTemplParams" colspan="2">template&lt;typename IntegerT, typename FloatT&gt; </td></tr>
<tr class="memitem:ac237583ca1f8ce413b0c2fcf531f5c4f template"><td class="memItemLeft" align="right" valign="top">IntegerT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac237583ca1f8ce413b0c2fcf531f5c4f">floatingPointToFixedPoint</a> (const FloatT s)</td></tr>
<tr class="memitem:a9462e09e2caf64d1c8aa6438e55d8d90" id="r_a9462e09e2caf64d1c8aa6438e55d8d90"><td class="memTemplParams" colspan="2">template&lt;typename FloatT, typename IntegerT&gt; </td></tr>
<tr class="memitem:a9462e09e2caf64d1c8aa6438e55d8d90 template"><td class="memItemLeft" align="right" valign="top">FloatT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9462e09e2caf64d1c8aa6438e55d8d90">fixedPointToFloatingPoint</a> (const IntegerT s)</td></tr>
<tr class="memitem:a1f77e99a8e388f3166e57550570299d2" id="r_a1f77e99a8e388f3166e57550570299d2"><td class="memTemplParams" colspan="2">template&lt;typename IntegerVectorT, typename FloatT&gt; </td></tr>
<tr class="memitem:a1f77e99a8e388f3166e57550570299d2 template"><td class="memItemLeft" align="right" valign="top">IntegerVectorT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f77e99a8e388f3166e57550570299d2">floatingPointToFixedPoint</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; FloatT &gt; &amp;v)</td></tr>
<tr class="memitem:a203a4416f7a5d8877eb65027015d700a" id="r_a203a4416f7a5d8877eb65027015d700a"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT, typename IntegerT&gt; </td></tr>
<tr class="memitem:a203a4416f7a5d8877eb65027015d700a template"><td class="memItemLeft" align="right" valign="top">FloatVectorT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a203a4416f7a5d8877eb65027015d700a">fixedPointToFloatingPoint</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; IntegerT &gt; &amp;v)</td></tr>
<tr class="memitem:a119b709e5eeb5608faeea2de42e54637" id="r_a119b709e5eeb5608faeea2de42e54637"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a119b709e5eeb5608faeea2de42e54637">isString</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeArray.html">AttributeArray</a> &amp;array)</td></tr>
<tr class="memitem:a95b9808c9991f5e067d27f62fa598756" id="r_a95b9808c9991f5e067d27f62fa598756"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95b9808c9991f5e067d27f62fa598756">isGroup</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeArray.html">AttributeArray</a> &amp;array)</td></tr>
<tr class="memitem:adfb5e64392fdf29bc3462e5a60713158" id="r_adfb5e64392fdf29bc3462e5a60713158"><td class="memTemplParams" colspan="2">template&lt;typename IterT&gt; </td></tr>
<tr class="memitem:adfb5e64392fdf29bc3462e5a60713158 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfb5e64392fdf29bc3462e5a60713158">iterCount</a> (const IterT &amp;iter)</td></tr>
<tr class="memdesc:adfb5e64392fdf29bc3462e5a60713158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count up the number of times the iterator can iterate.  <br /></td></tr>
<tr class="memitem:ab79ffb24dc5aee12a75d1507966164bc" id="r_ab79ffb24dc5aee12a75d1507966164bc"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT, typename VelGridT, typename AdvectFilterT = NullFilter, typename FilterT = NullFilter&gt; </td></tr>
<tr class="memitem:ab79ffb24dc5aee12a75d1507966164bc template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab79ffb24dc5aee12a75d1507966164bc">advectPoints</a> (PointDataGridT &amp;points, const VelGridT &amp;velocity, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> integrationOrder, const double dt, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> timeSteps, const AdvectFilterT &amp;advectFilter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool cached=true)</td></tr>
<tr class="memdesc:ab79ffb24dc5aee12a75d1507966164bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advect points in a <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> through a velocity grid.  <br /></td></tr>
<tr class="memitem:a9f8216e14812f6a9c9aaf1af5b2ad36b" id="r_a9f8216e14812f6a9c9aaf1af5b2ad36b"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a9f8216e14812f6a9c9aaf1af5b2ad36b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f8216e14812f6a9c9aaf1af5b2ad36b">appendAttribute</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;name, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a3907786c2430dbab9f198bfd5b31ff7c">NamePair</a> &amp;type, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> strideOrTotalSize=1, const bool constantStride=true, const <a class="el" href="classopenvdb_1_1v13__0_1_1Metadata.html">Metadata</a> *defaultValue=nullptr, const bool hidden=false, const bool transient=false)</td></tr>
<tr class="memdesc:a9f8216e14812f6a9c9aaf1af5b2ad36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new attribute to the VDB tree (this method does not require a templated AttributeType)  <br /></td></tr>
<tr class="memitem:a12af91f538ab5256ce2db4afe3b9dd31" id="r_a12af91f538ab5256ce2db4afe3b9dd31"><td class="memTemplParams" colspan="2">template&lt;typename ValueType, typename CodecType = NullCodec, typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a12af91f538ab5256ce2db4afe3b9dd31 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12af91f538ab5256ce2db4afe3b9dd31">appendAttribute</a> (PointDataTreeT &amp;tree, const std::string &amp;name, const ValueType &amp;uniformValue=point_attribute_internal::Default&lt; ValueType &gt;::value(), const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> strideOrTotalSize=1, const bool constantStride=true, const <a class="el" href="classopenvdb_1_1v13__0_1_1TypedMetadata.html">TypedMetadata</a>&lt; ValueType &gt; *defaultValue=nullptr, const bool hidden=false, const bool transient=false)</td></tr>
<tr class="memdesc:a12af91f538ab5256ce2db4afe3b9dd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new attribute to the VDB tree.  <br /></td></tr>
<tr class="memitem:a6b46b75155cc394f4ad4b540f167523a" id="r_a6b46b75155cc394f4ad4b540f167523a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType, typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a6b46b75155cc394f4ad4b540f167523a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b46b75155cc394f4ad4b540f167523a">collapseAttribute</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;name, const ValueType &amp;uniformValue=point_attribute_internal::Default&lt; ValueType &gt;::value())</td></tr>
<tr class="memdesc:a6b46b75155cc394f4ad4b540f167523a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse the attribute into a uniform value.  <br /></td></tr>
<tr class="memitem:aaaa22577ec29a353a700c9a3fa03906f" id="r_aaaa22577ec29a353a700c9a3fa03906f"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:aaaa22577ec29a353a700c9a3fa03906f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaa22577ec29a353a700c9a3fa03906f">dropAttributes</a> (PointDataTreeT &amp;tree, const std::vector&lt; size_t &gt; &amp;indices)</td></tr>
<tr class="memdesc:aaaa22577ec29a353a700c9a3fa03906f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops attributes from the VDB tree.  <br /></td></tr>
<tr class="memitem:aaa8ee0b505384ce90253b77516cedce4" id="r_aaa8ee0b505384ce90253b77516cedce4"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:aaa8ee0b505384ce90253b77516cedce4 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa8ee0b505384ce90253b77516cedce4">dropAttributes</a> (PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;names)</td></tr>
<tr class="memdesc:aaa8ee0b505384ce90253b77516cedce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops attributes from the VDB tree.  <br /></td></tr>
<tr class="memitem:a630071eb13957e9c9683fafb845ec9ce" id="r_a630071eb13957e9c9683fafb845ec9ce"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a630071eb13957e9c9683fafb845ec9ce template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a630071eb13957e9c9683fafb845ec9ce">dropAttribute</a> (PointDataTreeT &amp;tree, const size_t &amp;index)</td></tr>
<tr class="memdesc:a630071eb13957e9c9683fafb845ec9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop one attribute from the VDB tree (convenience method).  <br /></td></tr>
<tr class="memitem:acd25e23091c52fb8da4fcb50369ad45b" id="r_acd25e23091c52fb8da4fcb50369ad45b"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:acd25e23091c52fb8da4fcb50369ad45b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd25e23091c52fb8da4fcb50369ad45b">dropAttribute</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;name)</td></tr>
<tr class="memdesc:acd25e23091c52fb8da4fcb50369ad45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop one attribute from the VDB tree (convenience method).  <br /></td></tr>
<tr class="memitem:aceb82e6282deeaa12012efbe386ce564" id="r_aceb82e6282deeaa12012efbe386ce564"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:aceb82e6282deeaa12012efbe386ce564 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aceb82e6282deeaa12012efbe386ce564">renameAttributes</a> (PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;oldNames, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;newNames)</td></tr>
<tr class="memdesc:aceb82e6282deeaa12012efbe386ce564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename attributes in a VDB tree.  <br /></td></tr>
<tr class="memitem:aeb60e92fdbb25ad5822945cc30b3e8b2" id="r_aeb60e92fdbb25ad5822945cc30b3e8b2"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:aeb60e92fdbb25ad5822945cc30b3e8b2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb60e92fdbb25ad5822945cc30b3e8b2">renameAttribute</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;oldName, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;newName)</td></tr>
<tr class="memdesc:aeb60e92fdbb25ad5822945cc30b3e8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename an attribute in a VDB tree.  <br /></td></tr>
<tr class="memitem:a467b8eefb87ca02fa0f017c40c08d674" id="r_a467b8eefb87ca02fa0f017c40c08d674"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a467b8eefb87ca02fa0f017c40c08d674 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a467b8eefb87ca02fa0f017c40c08d674">compactAttributes</a> (PointDataTreeT &amp;tree)</td></tr>
<tr class="memdesc:a467b8eefb87ca02fa0f017c40c08d674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact attributes in a VDB tree (if possible).  <br /></td></tr>
<tr class="memitem:ab15a1ee82d506999536458071ba44299" id="r_ab15a1ee82d506999536458071ba44299"><td class="memTemplParams" colspan="2">template&lt;typename CompressionT, typename PointDataGridT, typename PositionArrayT, typename PointIndexGridT&gt; </td></tr>
<tr class="memitem:ab15a1ee82d506999536458071ba44299 template"><td class="memItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab15a1ee82d506999536458071ba44299">createPointDataGrid</a> (const PointIndexGridT &amp;pointIndexGrid, const PositionArrayT &amp;positions, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> &amp;xform, const <a class="el" href="classopenvdb_1_1v13__0_1_1Metadata.html">Metadata</a> *positionDefaultValue=nullptr)</td></tr>
<tr class="memdesc:ab15a1ee82d506999536458071ba44299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Localises points with position into a <code><a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a></code> into two stages: allocation of the leaf attribute data and population of the positions.  <br /></td></tr>
<tr class="memitem:a07c2da02df6fb329b2684f56617c39b9" id="r_a07c2da02df6fb329b2684f56617c39b9"><td class="memTemplParams" colspan="2">template&lt;typename CompressionT, typename PointDataGridT, typename ValueT&gt; </td></tr>
<tr class="memitem:a07c2da02df6fb329b2684f56617c39b9 template"><td class="memItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07c2da02df6fb329b2684f56617c39b9">createPointDataGrid</a> (const std::vector&lt; ValueT &gt; &amp;positions, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> &amp;xform, const <a class="el" href="classopenvdb_1_1v13__0_1_1Metadata.html">Metadata</a> *positionDefaultValue=nullptr)</td></tr>
<tr class="memdesc:a07c2da02df6fb329b2684f56617c39b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to create a <code><a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a></code> from a std::vector of point positions.  <br /></td></tr>
<tr class="memitem:ad7557b731e5392e4448f933a84139950" id="r_ad7557b731e5392e4448f933a84139950"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT, typename PointIndexTreeT, typename PointArrayT&gt; </td></tr>
<tr class="memitem:ad7557b731e5392e4448f933a84139950 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7557b731e5392e4448f933a84139950">populateAttribute</a> (PointDataTreeT &amp;tree, const PointIndexTreeT &amp;pointIndexTree, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">openvdb::Name</a> &amp;attributeName, const PointArrayT &amp;data, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> stride=1, const bool insertMetadata=true)</td></tr>
<tr class="memdesc:ad7557b731e5392e4448f933a84139950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores point attribute data in an existing <code><a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a></code> attribute.  <br /></td></tr>
<tr class="memitem:acf905ca86b725954bf900e3caf6b431a" id="r_acf905ca86b725954bf900e3caf6b431a"><td class="memTemplParams" colspan="2">template&lt;typename PositionAttribute, typename PointDataGridT, typename FilterT = NullFilter&gt; </td></tr>
<tr class="memitem:acf905ca86b725954bf900e3caf6b431a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf905ca86b725954bf900e3caf6b431a">convertPointDataGridPosition</a> (PositionAttribute &amp;positionAttribute, const PointDataGridT &amp;grid, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;<a class="el" href="#a639be5922b4acf36c519e88f9ea8ff7d">pointOffsets</a>, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> startOffset, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false)</td></tr>
<tr class="memdesc:acf905ca86b725954bf900e3caf6b431a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the position attribute from a Point Data <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata.">Grid</a>.  <br /></td></tr>
<tr class="memitem:ac91e520838e75f17a4e0a3505c128931" id="r_ac91e520838e75f17a4e0a3505c128931"><td class="memTemplParams" colspan="2">template&lt;typename TypedAttribute, typename PointDataTreeT, typename FilterT = NullFilter&gt; </td></tr>
<tr class="memitem:ac91e520838e75f17a4e0a3505c128931 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac91e520838e75f17a4e0a3505c128931">convertPointDataGridAttribute</a> (TypedAttribute &amp;attribute, const PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;<a class="el" href="#a639be5922b4acf36c519e88f9ea8ff7d">pointOffsets</a>, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> startOffset, const unsigned arrayIndex, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> stride=1, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false)</td></tr>
<tr class="memdesc:ac91e520838e75f17a4e0a3505c128931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the attribute from a <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a>.  <br /></td></tr>
<tr class="memitem:a4875034852344d7f676c955bb764d9c1" id="r_a4875034852344d7f676c955bb764d9c1"><td class="memTemplParams" colspan="2">template&lt;typename Group, typename PointDataTreeT, typename FilterT = NullFilter&gt; </td></tr>
<tr class="memitem:a4875034852344d7f676c955bb764d9c1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4875034852344d7f676c955bb764d9c1">convertPointDataGridGroup</a> (Group &amp;group, const PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;<a class="el" href="#a639be5922b4acf36c519e88f9ea8ff7d">pointOffsets</a>, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> startOffset, const <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeSet_1_1Descriptor.html#a0decda39ae55f7cf0a11bf16c61b270c">AttributeSet::Descriptor::GroupIndex</a> index, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false)</td></tr>
<tr class="memdesc:a4875034852344d7f676c955bb764d9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the group from a <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a>.  <br /></td></tr>
<tr class="memitem:a85baad70404957c0b435068440ae1c0f" id="r_a85baad70404957c0b435068440ae1c0f"><td class="memTemplParams" colspan="2">template&lt;typename PositionWrapper, typename InterrupterT = openvdb::util::NullInterrupter, typename VecT = typename internal::ValueTypeTraits&lt;PositionWrapper&gt;::Type&gt; </td></tr>
<tr class="memitem:a85baad70404957c0b435068440ae1c0f template"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85baad70404957c0b435068440ae1c0f">computeVoxelSize</a> (const PositionWrapper &amp;positions, const uint32_t pointsPerVoxel, const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#abaf7f913bf1752b9157259ffa32704ca">math::Mat4d</a> transform=<a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Mat4.html#a594d71e30b0571fd84ca639822459a1e">math::Mat4d::identity</a>(), const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> decimalPlaces=5, InterrupterT *const interrupter=nullptr)</td></tr>
<tr class="memitem:a8dbfd50108bbe665a6e1a0607335a5df" id="r_a8dbfd50108bbe665a6e1a0607335a5df"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT, typename FilterT = NullFilter&gt; </td></tr>
<tr class="memitem:a8dbfd50108bbe665a6e1a0607335a5df template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dbfd50108bbe665a6e1a0607335a5df">pointCount</a> (const PointDataTreeT &amp;tree, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false, const bool threaded=true)</td></tr>
<tr class="memdesc:a8dbfd50108bbe665a6e1a0607335a5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the total number of points in a <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a>.  <br /></td></tr>
<tr class="memitem:a639be5922b4acf36c519e88f9ea8ff7d" id="r_a639be5922b4acf36c519e88f9ea8ff7d"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT, typename FilterT = NullFilter&gt; </td></tr>
<tr class="memitem:a639be5922b4acf36c519e88f9ea8ff7d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a639be5922b4acf36c519e88f9ea8ff7d">pointOffsets</a> (std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;pointOffsets, const PointDataTreeT &amp;tree, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false, const bool threaded=true)</td></tr>
<tr class="memdesc:a639be5922b4acf36c519e88f9ea8ff7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate an array of cumulative point offsets per leaf node.  <br /></td></tr>
<tr class="memitem:a90464075cf4382ab74a75288eebfce02" id="r_a90464075cf4382ab74a75288eebfce02"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT, typename GridT = typename PointDataGridT::template ValueConverter&lt;Int32&gt;::Type, typename FilterT = NullFilter&gt; </td></tr>
<tr class="memitem:a90464075cf4382ab74a75288eebfce02 template"><td class="memItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90464075cf4382ab74a75288eebfce02">pointCountGrid</a> (const PointDataGridT &amp;grid, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>())</td></tr>
<tr class="memdesc:a90464075cf4382ab74a75288eebfce02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a new grid with voxel values to store the number of points per voxel.  <br /></td></tr>
<tr class="memitem:a2159bcf1fea38531ec493459f3b37857" id="r_a2159bcf1fea38531ec493459f3b37857"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT, typename GridT = typename PointDataGridT::template ValueConverter&lt;Int32&gt;::Type, typename FilterT = NullFilter&gt; </td></tr>
<tr class="memitem:a2159bcf1fea38531ec493459f3b37857 template"><td class="memItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2159bcf1fea38531ec493459f3b37857">pointCountGrid</a> (const PointDataGridT &amp;grid, const openvdb::math::Transform &amp;transform, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>())</td></tr>
<tr class="memdesc:a2159bcf1fea38531ec493459f3b37857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a new grid that uses the supplied transform with voxel values to store the number of points per voxel.  <br /></td></tr>
<tr class="memitem:af351ce8e812595d5fede2fd73ce96420" id="r_af351ce8e812595d5fede2fd73ce96420"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:af351ce8e812595d5fede2fd73ce96420 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeSet_1_1Descriptor.html#a94ff3417324fe637256bfe9e0cb68304">AttributeSet::Descriptor::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af351ce8e812595d5fede2fd73ce96420">makeDescriptorUnique</a> (PointDataTreeT &amp;tree)</td></tr>
<tr class="memdesc:af351ce8e812595d5fede2fd73ce96420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy the descriptor across all leaf nodes.  <br /></td></tr>
<tr class="memitem:a0d85a4b1b93c26f69ecf71e75017275b" id="r_a0d85a4b1b93c26f69ecf71e75017275b"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a0d85a4b1b93c26f69ecf71e75017275b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d85a4b1b93c26f69ecf71e75017275b">setStreamingMode</a> (PointDataTreeT &amp;tree, bool on=true)</td></tr>
<tr class="memdesc:a0d85a4b1b93c26f69ecf71e75017275b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the streaming mode on all attributes in the tree to collapse the attributes after deconstructing a bound <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeHandle.html">AttributeHandle</a> to each array. This results in better memory efficiency when the data is streamed into another data structure (typically for rendering).  <br /></td></tr>
<tr class="memitem:a2205d8c5a7c5fd2e24145a9df5ad6485" id="r_a2205d8c5a7c5fd2e24145a9df5ad6485"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a2205d8c5a7c5fd2e24145a9df5ad6485 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2205d8c5a7c5fd2e24145a9df5ad6485">prefetch</a> (PointDataTreeT &amp;tree, bool position=true, bool otherAttributes=true)</td></tr>
<tr class="memdesc:a2205d8c5a7c5fd2e24145a9df5ad6485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequentially pre-fetch all delayed-load voxel and attribute data from disk in order to accelerate subsequent random access.  <br /></td></tr>
<tr class="memitem:a6b9d921b422e929c3786e77c8d4c811f" id="r_a6b9d921b422e929c3786e77c8d4c811f"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a6b9d921b422e929c3786e77c8d4c811f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b9d921b422e929c3786e77c8d4c811f">deleteFromGroups</a> (PointDataTreeT &amp;pointTree, const std::vector&lt; std::string &gt; &amp;groups, bool invert=false, bool drop=true)</td></tr>
<tr class="memdesc:a6b9d921b422e929c3786e77c8d4c811f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete points that are members of specific groups.  <br /></td></tr>
<tr class="memitem:afdbd30a3741affcd2b2434124a34149d" id="r_afdbd30a3741affcd2b2434124a34149d"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:afdbd30a3741affcd2b2434124a34149d template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdbd30a3741affcd2b2434124a34149d">deleteFromGroup</a> (PointDataTreeT &amp;pointTree, const std::string &amp;group, bool invert=false, bool drop=true)</td></tr>
<tr class="memdesc:afdbd30a3741affcd2b2434124a34149d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete points that are members of a group.  <br /></td></tr>
<tr class="memitem:a5e318d6bae7846125e0ac39c66024fc2" id="r_a5e318d6bae7846125e0ac39c66024fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e318d6bae7846125e0ac39c66024fc2">deleteMissingPointGroups</a> (std::vector&lt; std::string &gt; &amp;groups, const <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeSet_1_1Descriptor.html">AttributeSet::Descriptor</a> &amp;descriptor)</td></tr>
<tr class="memdesc:a5e318d6bae7846125e0ac39c66024fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete any group that is not present in the Descriptor.  <br /></td></tr>
<tr class="memitem:a6df5f0462ae9d328e4987971cda4c7ee" id="r_a6df5f0462ae9d328e4987971cda4c7ee"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a6df5f0462ae9d328e4987971cda4c7ee template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6df5f0462ae9d328e4987971cda4c7ee">appendGroup</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group)</td></tr>
<tr class="memdesc:a6df5f0462ae9d328e4987971cda4c7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new empty group to the VDB tree.  <br /></td></tr>
<tr class="memitem:aad2483abeddd3034b01b946caf10f84f" id="r_aad2483abeddd3034b01b946caf10f84f"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:aad2483abeddd3034b01b946caf10f84f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad2483abeddd3034b01b946caf10f84f">appendGroups</a> (PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;groups)</td></tr>
<tr class="memdesc:aad2483abeddd3034b01b946caf10f84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends new empty groups to the VDB tree.  <br /></td></tr>
<tr class="memitem:ac1f0afec32f566e10a0a25fde4466dba" id="r_ac1f0afec32f566e10a0a25fde4466dba"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:ac1f0afec32f566e10a0a25fde4466dba template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1f0afec32f566e10a0a25fde4466dba">dropGroup</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const bool compact=true)</td></tr>
<tr class="memdesc:ac1f0afec32f566e10a0a25fde4466dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops an existing group from the VDB tree.  <br /></td></tr>
<tr class="memitem:a0c87fccd745143ae4e42c5b1f4998508" id="r_a0c87fccd745143ae4e42c5b1f4998508"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a0c87fccd745143ae4e42c5b1f4998508 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c87fccd745143ae4e42c5b1f4998508">dropGroups</a> (PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;groups)</td></tr>
<tr class="memdesc:a0c87fccd745143ae4e42c5b1f4998508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops existing groups from the VDB tree, the tree is compacted after dropping.  <br /></td></tr>
<tr class="memitem:ad7814ccafca96a095c60c6c6438b7eb2" id="r_ad7814ccafca96a095c60c6c6438b7eb2"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:ad7814ccafca96a095c60c6c6438b7eb2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7814ccafca96a095c60c6c6438b7eb2">dropGroups</a> (PointDataTreeT &amp;tree)</td></tr>
<tr class="memdesc:ad7814ccafca96a095c60c6c6438b7eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops all existing groups from the VDB tree, the tree is compacted after dropping.  <br /></td></tr>
<tr class="memitem:a6057529f97b428787a3e993ad12d3cf2" id="r_a6057529f97b428787a3e993ad12d3cf2"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a6057529f97b428787a3e993ad12d3cf2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6057529f97b428787a3e993ad12d3cf2">compactGroups</a> (PointDataTreeT &amp;tree)</td></tr>
<tr class="memdesc:a6057529f97b428787a3e993ad12d3cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compacts existing groups of a VDB Tree to use less memory if possible.  <br /></td></tr>
<tr class="memitem:a1866ee320dd051901bb7f4f49e155cee" id="r_a1866ee320dd051901bb7f4f49e155cee"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT, typename PointIndexTreeT&gt; </td></tr>
<tr class="memitem:a1866ee320dd051901bb7f4f49e155cee template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1866ee320dd051901bb7f4f49e155cee">setGroup</a> (PointDataTreeT &amp;tree, const PointIndexTreeT &amp;indexTree, const std::vector&lt; short &gt; &amp;membership, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const bool remove=false)</td></tr>
<tr class="memdesc:a1866ee320dd051901bb7f4f49e155cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets group membership from a PointIndexTree-ordered vector.  <br /></td></tr>
<tr class="memitem:a522af44dcf8da3f9e6c7b747e075f155" id="r_a522af44dcf8da3f9e6c7b747e075f155"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a522af44dcf8da3f9e6c7b747e075f155 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a522af44dcf8da3f9e6c7b747e075f155">setGroup</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const bool member=true)</td></tr>
<tr class="memdesc:a522af44dcf8da3f9e6c7b747e075f155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets membership for the specified group for all points (on/off).  <br /></td></tr>
<tr class="memitem:ab5ce5ef333b529b92e4acb1bddeec93c" id="r_ab5ce5ef333b529b92e4acb1bddeec93c"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT, typename FilterT&gt; </td></tr>
<tr class="memitem:ab5ce5ef333b529b92e4acb1bddeec93c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5ce5ef333b529b92e4acb1bddeec93c">setGroupByFilter</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const FilterT &amp;filter)</td></tr>
<tr class="memdesc:ab5ce5ef333b529b92e4acb1bddeec93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets group membership based on a provided filter.  <br /></td></tr>
<tr class="memitem:a3bc4fb5488537e98b49bf52140166947" id="r_a3bc4fb5488537e98b49bf52140166947"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT, typename MaskTreeT = typename PointDataTreeT::template ValueConverter&lt;bool&gt;::Type, typename FilterT = NullFilter&gt; </td></tr>
<tr class="memitem:a3bc4fb5488537e98b49bf52140166947 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#acbcb5f84dd5976c2bb8d02c10017d060">TreeBase</a>, PointDataTreeT &gt;::value &amp;&amp;std::is_same&lt; typenameMaskTreeT::ValueType, bool &gt;::value, typenameMaskTreeT::Ptr &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bc4fb5488537e98b49bf52140166947">convertPointsToMask</a> (const PointDataTreeT &amp;tree, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), bool threaded=true)</td></tr>
<tr class="memdesc:a3bc4fb5488537e98b49bf52140166947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a Mask Tree from a Point Data Tree.  <br /></td></tr>
<tr class="memitem:a4c532af9bac4f3e4ee0cbbb45b0f0629" id="r_a4c532af9bac4f3e4ee0cbbb45b0f0629"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT, typename MaskGridT = typename PointDataGridT::template ValueConverter&lt;bool&gt;::Type, typename FilterT = NullFilter&gt; </td></tr>
<tr class="memitem:a4c532af9bac4f3e4ee0cbbb45b0f0629 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1GridBase.html">GridBase</a>, PointDataGridT &gt;::value &amp;&amp;std::is_same&lt; typenameMaskGridT::ValueType, bool &gt;::value, typenameMaskGridT::Ptr &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c532af9bac4f3e4ee0cbbb45b0f0629">convertPointsToMask</a> (const PointDataGridT &amp;grid, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), bool threaded=true)</td></tr>
<tr class="memdesc:a4c532af9bac4f3e4ee0cbbb45b0f0629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a Mask <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata.">Grid</a> from a Point Data <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata.">Grid</a>.  <br /></td></tr>
<tr class="memitem:aedeab297ce588a62f0d22c51c5e1beff" id="r_aedeab297ce588a62f0d22c51c5e1beff"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT, typename MaskT = typename PointDataGridT::template ValueConverter&lt;bool&gt;::Type, typename FilterT = NullFilter&gt; </td></tr>
<tr class="memitem:aedeab297ce588a62f0d22c51c5e1beff template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typenameMaskT::ValueType, bool &gt;::value, typenameMaskT::Ptr &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedeab297ce588a62f0d22c51c5e1beff">convertPointsToMask</a> (const PointDataGridT &amp;grid, const openvdb::math::Transform &amp;transform, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), bool threaded=true)</td></tr>
<tr class="memdesc:aedeab297ce588a62f0d22c51c5e1beff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a Mask <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata.">Grid</a> from a Point Data <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata.">Grid</a> using a new transform.  <br /></td></tr>
<tr class="memitem:a2d0082c20c402a864700014eae174838" id="r_a2d0082c20c402a864700014eae174838"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT, typename DeformerT, typename FilterT = NullFilter&gt; </td></tr>
<tr class="memitem:a2d0082c20c402a864700014eae174838 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d0082c20c402a864700014eae174838">movePoints</a> (PointDataGridT &amp;points, DeformerT &amp;deformer, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1future_1_1Advect.html">future::Advect</a> *objectNotInUse=nullptr, bool threaded=true)</td></tr>
<tr class="memdesc:a2d0082c20c402a864700014eae174838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move points in a <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> using a custom deformer.  <br /></td></tr>
<tr class="memitem:ad0d785b238fdbdf02b903fd9ddd453f3" id="r_ad0d785b238fdbdf02b903fd9ddd453f3"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT, typename DeformerT, typename FilterT = NullFilter&gt; </td></tr>
<tr class="memitem:ad0d785b238fdbdf02b903fd9ddd453f3 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0d785b238fdbdf02b903fd9ddd453f3">movePoints</a> (PointDataGridT &amp;points, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> &amp;transform, DeformerT &amp;deformer, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1future_1_1Advect.html">future::Advect</a> *objectNotInUse=nullptr, bool threaded=true)</td></tr>
<tr class="memdesc:ad0d785b238fdbdf02b903fd9ddd453f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move points in a <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> using a custom deformer and a new transform.  <br /></td></tr>
<tr class="memitem:a7c7a41f2a2676f4525b8584962c78098" id="r_a7c7a41f2a2676f4525b8584962c78098"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT, typename SdfT = typename PointDataGridT::template ValueConverter&lt;float&gt;::Type, typename SettingsT&gt; </td></tr>
<tr class="memitem:a7c7a41f2a2676f4525b8584962c78098 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a0c9703e6ff5cc9deb6410c53412c22c3">GridPtrVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c7a41f2a2676f4525b8584962c78098">rasterizeSdf</a> (const PointDataGridT &amp;points, const SettingsT &amp;settings)</td></tr>
<tr class="memdesc:a7c7a41f2a2676f4525b8584962c78098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform point rasterzation to produce a signed distance field.  <br /></td></tr>
<tr class="memitem:a43f917f566a11a07b496f369adc7d6a4" id="r_a43f917f566a11a07b496f369adc7d6a4"><td class="memTemplParams" colspan="2">template&lt;bool Staggered, typename ValueT, typename FilterT = NullFilter, typename PointDataTreeT = PointDataTree&gt; </td></tr>
<tr class="memitem:a43f917f566a11a07b496f369adc7d6a4 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43f917f566a11a07b496f369adc7d6a4">rasterizeTrilinear</a> (const PointDataTreeT &amp;points, const std::string &amp;attribute, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>())</td></tr>
<tr class="memdesc:a43f917f566a11a07b496f369adc7d6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform weighted trilinear rasterization of all points within a voxel. This method takes and returns a tree i.e. ignores grid transformations.  <br /></td></tr>
<tr class="memitem:a0c7a04c3490272095b334a6859f9a0fb" id="r_a0c7a04c3490272095b334a6859f9a0fb"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT&gt; </td></tr>
<tr class="memitem:a0c7a04c3490272095b334a6859f9a0fb template"><td class="memItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c7a04c3490272095b334a6859f9a0fb">replicate</a> (const PointDataGridT &amp;source, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> multiplier, const std::vector&lt; std::string &gt; &amp;attributes, const std::string &amp;scaleAttribute=&quot;&quot;, const std::string &amp;replicationIndex=&quot;&quot;)</td></tr>
<tr class="memdesc:a0c7a04c3490272095b334a6859f9a0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicates points provided in a source grid into a new grid, transfering and creating attributes found in a provided attribute vector. If an attribute doesn't exist, it is ignored. Position is always replicated, leaving the new points exactly over the top of the source points.  <br /></td></tr>
<tr class="memitem:a8631d1e7a9cecd8986fe740f4d64e688" id="r_a8631d1e7a9cecd8986fe740f4d64e688"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT&gt; </td></tr>
<tr class="memitem:a8631d1e7a9cecd8986fe740f4d64e688 template"><td class="memItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8631d1e7a9cecd8986fe740f4d64e688">replicate</a> (const PointDataGridT &amp;source, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> multiplier, const std::string &amp;scaleAttribute=&quot;&quot;, const std::string &amp;replicationIndex=&quot;&quot;)</td></tr>
<tr class="memdesc:a8631d1e7a9cecd8986fe740f4d64e688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicates points provided in a source grid into a new grid, transfering and creating all attributes from the source grid. Position is always replicated, leaving the new points exactly over the top of the source points.  <br /></td></tr>
<tr class="memitem:ae7b556e743b5d3b8b336c75252264d96" id="r_ae7b556e743b5d3b8b336c75252264d96"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT, typename SourceGridT, typename FilterT = NullFilter, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ae7b556e743b5d3b8b336c75252264d96 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7b556e743b5d3b8b336c75252264d96">pointSample</a> (PointDataGridT &amp;points, const SourceGridT &amp;sourceGrid, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;targetAttribute=&quot;&quot;, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *const interrupter=nullptr)</td></tr>
<tr class="memdesc:ae7b556e743b5d3b8b336c75252264d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs closest point sampling from a VDB grid onto a VDB Points attribute.  <br /></td></tr>
<tr class="memitem:aa41bddc5c1099d146cee05b0dc3eb6ff" id="r_aa41bddc5c1099d146cee05b0dc3eb6ff"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT, typename SourceGridT, typename FilterT = NullFilter, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:aa41bddc5c1099d146cee05b0dc3eb6ff template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa41bddc5c1099d146cee05b0dc3eb6ff">boxSample</a> (PointDataGridT &amp;points, const SourceGridT &amp;sourceGrid, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;targetAttribute=&quot;&quot;, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *const interrupter=nullptr)</td></tr>
<tr class="memdesc:aa41bddc5c1099d146cee05b0dc3eb6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tri-linear sampling from a VDB grid onto a VDB Points attribute.  <br /></td></tr>
<tr class="memitem:ad694b6c2cdbcd760f327fe3fb36ae936" id="r_ad694b6c2cdbcd760f327fe3fb36ae936"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT, typename SourceGridT, typename FilterT = NullFilter, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ad694b6c2cdbcd760f327fe3fb36ae936 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad694b6c2cdbcd760f327fe3fb36ae936">quadraticSample</a> (PointDataGridT &amp;points, const SourceGridT &amp;sourceGrid, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;targetAttribute=&quot;&quot;, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *const interrupter=nullptr)</td></tr>
<tr class="memdesc:ad694b6c2cdbcd760f327fe3fb36ae936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tri-quadratic sampling from a VDB grid onto a VDB Points attribute.  <br /></td></tr>
<tr class="memitem:a5ff8951f375ddac4b685e72f486489d3" id="r_a5ff8951f375ddac4b685e72f486489d3"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT, typename SourceGridT, typename TargetValueT = DummySampleType, typename SamplerT = SampleWithRounding, typename FilterT = NullFilter, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a5ff8951f375ddac4b685e72f486489d3 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ff8951f375ddac4b685e72f486489d3">sampleGrid</a> (size_t order, PointDataGridT &amp;points, const SourceGridT &amp;sourceGrid, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;targetAttribute, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), const SamplerT &amp;sampler=<a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1SampleWithRounding.html">SampleWithRounding</a>(), InterrupterT *const interrupter=nullptr, const bool threaded=true)</td></tr>
<tr class="memdesc:a5ff8951f375ddac4b685e72f486489d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs sampling and conversion from a VDB grid onto a VDB Points attribute.  <br /></td></tr>
<tr class="memitem:abc4c70eaf37048c67356fd7189b15d95" id="r_abc4c70eaf37048c67356fd7189b15d95"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename RandGenT = std::mt19937, typename PositionArrayT = TypedAttributeArray&lt;Vec3f, NullCodec&gt;, typename PointDataGridT = Grid&lt;        typename points::TreeConverter&lt;typename GridT::TreeType&gt;::Type&gt;, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:abc4c70eaf37048c67356fd7189b15d95 template"><td class="memItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc4c70eaf37048c67356fd7189b15d95">uniformPointScatter</a> (const GridT &amp;grid, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> count, const unsigned int seed=0, const float spread=1.0f, InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:abc4c70eaf37048c67356fd7189b15d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The free functions depend on the following class:  <br /></td></tr>
<tr class="memitem:a2a35fc7cff4396e3c0fed48af7150c30" id="r_a2a35fc7cff4396e3c0fed48af7150c30"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename RandGenT = std::mt19937, typename PositionArrayT = TypedAttributeArray&lt;Vec3f, NullCodec&gt;, typename PointDataGridT = Grid&lt;        typename points::TreeConverter&lt;typename GridT::TreeType&gt;::Type&gt;, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a2a35fc7cff4396e3c0fed48af7150c30 template"><td class="memItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a35fc7cff4396e3c0fed48af7150c30">denseUniformPointScatter</a> (const GridT &amp;grid, const float pointsPerVoxel, const unsigned int seed=0, const float spread=1.0f, InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a2a35fc7cff4396e3c0fed48af7150c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniformly scatter a fixed number of points per active voxel. If the pointsPerVoxel value provided is a fractional value, each voxel calculates a delta value of how likely it is to contain an extra point.  <br /></td></tr>
<tr class="memitem:aea55ad121ac7274e8a5bb844253c695d" id="r_aea55ad121ac7274e8a5bb844253c695d"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename RandGenT = std::mt19937, typename PositionArrayT = TypedAttributeArray&lt;Vec3f, NullCodec&gt;, typename PointDataGridT = Grid&lt;        typename points::TreeConverter&lt;typename GridT::TreeType&gt;::Type&gt;, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:aea55ad121ac7274e8a5bb844253c695d template"><td class="memItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea55ad121ac7274e8a5bb844253c695d">nonUniformPointScatter</a> (const GridT &amp;grid, const float pointsPerVoxel, const unsigned int seed=0, const float spread=1.0f, InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:aea55ad121ac7274e8a5bb844253c695d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non uniformly scatter points per active voxel. The pointsPerVoxel value is used to weight each grids cell value to compute a fixed number of points for every active voxel. If the computed result is a fractional value, each voxel calculates a delta value of how likely it is to contain an extra point.  <br /></td></tr>
<tr class="memitem:a7d93f4d68e2eb70dac85a685e9b9522e" id="r_a7d93f4d68e2eb70dac85a685e9b9522e"><td class="memTemplParams" colspan="2">template&lt;typename ValueT, typename CodecT = UnknownCodec, typename FilterT = NullFilter, typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a7d93f4d68e2eb70dac85a685e9b9522e template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; ValueT, ValueT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d93f4d68e2eb70dac85a685e9b9522e">evalMinMax</a> (const PointDataTreeT &amp;points, const std::string &amp;attribute, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>())</td></tr>
<tr class="memdesc:a7d93f4d68e2eb70dac85a685e9b9522e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the minimum and maximum values of a point attribute.  <br /></td></tr>
<tr class="memitem:abee94dbff950fd1421a1f324bc5b4b2b" id="r_abee94dbff950fd1421a1f324bc5b4b2b"><td class="memTemplParams" colspan="2">template&lt;typename ValueT, typename CodecT = UnknownCodec, typename FilterT = NullFilter, typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:abee94dbff950fd1421a1f324bc5b4b2b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1ConvertElementType.html">ConvertElementType</a>&lt; ValueT, double &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abee94dbff950fd1421a1f324bc5b4b2b">evalAverage</a> (const PointDataTreeT &amp;points, const std::string &amp;attribute, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>())</td></tr>
<tr class="memdesc:abee94dbff950fd1421a1f324bc5b4b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the average value of a point attribute.  <br /></td></tr>
<tr class="memitem:a4cc9cf4453d1c8ee7aae58fe5efd4040" id="r_a4cc9cf4453d1c8ee7aae58fe5efd4040"><td class="memTemplParams" colspan="2">template&lt;typename ValueT, typename CodecT = UnknownCodec, typename FilterT = NullFilter, typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a4cc9cf4453d1c8ee7aae58fe5efd4040 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1PromoteType.html">PromoteType</a>&lt; ValueT &gt;::Highest&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cc9cf4453d1c8ee7aae58fe5efd4040">accumulate</a> (const PointDataTreeT &amp;points, const std::string &amp;attribute, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>())</td></tr>
<tr class="memdesc:a4cc9cf4453d1c8ee7aae58fe5efd4040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the total value of a point attribute.  <br /></td></tr>
<tr class="memitem:a44690998e9733ab3498205299864e4a4" id="r_a44690998e9733ab3498205299864e4a4"><td class="memTemplParams" colspan="2">template&lt;typename ValueT, typename CodecT = UnknownCodec, typename FilterT = NullFilter, typename PointDataTreeT&gt; </td></tr>
<tr class="memitem:a44690998e9733ab3498205299864e4a4 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44690998e9733ab3498205299864e4a4">evalMinMax</a> (const PointDataTreeT &amp;points, const std::string &amp;attribute, ValueT &amp;min, ValueT &amp;max, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), typename PointDataTreeT::template ValueConverter&lt; ValueT &gt;::Type *minTree=nullptr, typename PointDataTreeT::template ValueConverter&lt; ValueT &gt;::Type *maxTree=nullptr)</td></tr>
<tr class="memdesc:a44690998e9733ab3498205299864e4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the minimum and maximum values of a point attribute and returns whether the values are valid. Optionally constructs localised min and max value trees.  <br /></td></tr>
<tr class="memitem:a2ca703db5f875505c22c5d2c142441a2" id="r_a2ca703db5f875505c22c5d2c142441a2"><td class="memTemplParams" colspan="2">template&lt;typename ValueT, typename CodecT = UnknownCodec, typename FilterT = NullFilter, typename PointDataTreeT, typename ResultTreeT = typename ConvertElementType&lt;ValueT, double&gt;::Type&gt; </td></tr>
<tr class="memitem:a2ca703db5f875505c22c5d2c142441a2 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ca703db5f875505c22c5d2c142441a2">evalAverage</a> (const PointDataTreeT &amp;points, const std::string &amp;attribute, typename <a class="el" href="structopenvdb_1_1v13__0_1_1ConvertElementType.html">ConvertElementType</a>&lt; ValueT, double &gt;::Type &amp;average, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), typename PointDataTreeT::template ValueConverter&lt; ResultTreeT &gt;::Type *averageTree=nullptr)</td></tr>
<tr class="memdesc:a2ca703db5f875505c22c5d2c142441a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the average value of a point attribute and returns whether the value is valid. Optionally constructs localised average value trees.  <br /></td></tr>
<tr class="memitem:a9a92590037c00b856a13e368400575c3" id="r_a9a92590037c00b856a13e368400575c3"><td class="memTemplParams" colspan="2">template&lt;typename ValueT, typename CodecT = UnknownCodec, typename FilterT = NullFilter, typename PointDataTreeT, typename ResultTreeT = typename PromoteType&lt;ValueT&gt;::Highest&gt; </td></tr>
<tr class="memitem:a9a92590037c00b856a13e368400575c3 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a92590037c00b856a13e368400575c3">accumulate</a> (const PointDataTreeT &amp;points, const std::string &amp;attribute, typename <a class="el" href="structopenvdb_1_1v13__0_1_1PromoteType.html">PromoteType</a>&lt; ValueT &gt;::Highest &amp;total, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), typename PointDataTreeT::template ValueConverter&lt; ResultTreeT &gt;::Type *totalTree=nullptr)</td></tr>
<tr class="memdesc:a9a92590037c00b856a13e368400575c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the total value of a point attribute and returns whether the value is valid. Optionally constructs localised total value trees.  <br /></td></tr>
<tr class="memitem:ad9cf203d8735a1fe1174de1810104833" id="r_ad9cf203d8735a1fe1174de1810104833"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeOrGridT, typename TransferT&gt; </td></tr>
<tr class="memitem:ad9cf203d8735a1fe1174de1810104833 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9cf203d8735a1fe1174de1810104833">rasterize</a> (const PointDataTreeOrGridT &amp;points, TransferT &amp;transfer)</td></tr>
<tr class="memdesc:ad9cf203d8735a1fe1174de1810104833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform potentially complex rasterization from a user defined transfer scheme. See below comments for the transfer scheme API.  <br /></td></tr>
<tr class="memitem:a74fa733452dea2d0ee1d99c9583fd30d" id="r_a74fa733452dea2d0ee1d99c9583fd30d"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT&gt; </td></tr>
<tr class="memitem:a74fa733452dea2d0ee1d99c9583fd30d template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74fa733452dea2d0ee1d99c9583fd30d">pca</a> (PointDataGridT &amp;points, const <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1PcaSettings.html">PcaSettings</a> &amp;settings, const <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1PcaAttributes.html">PcaAttributes</a> &amp;attrs)</td></tr>
<tr class="memdesc:a74fa733452dea2d0ee1d99c9583fd30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate ellipsoid transformations from the local point distributions as described in Yu and Turk's 'Reconstructing Fluid Surfaces with Anisotropic Kernels'. The results are stored on the attributes pointed to by the <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1PcaAttributes.html" title="The persistent attributes created by the PCA methods.">PcaAttributes</a>. See the <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1PcaSettings.html" title="Various settings for the neighborhood analysis of point distributions.">PcaSettings</a> and <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1PcaAttributes.html" title="The persistent attributes created by the PCA methods.">PcaAttributes</a> structs for more details.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a8954944cf980f1f874a6510497568338" name="a8954944cf980f1f874a6510497568338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8954944cf980f1f874a6510497568338">&#9670;&#160;</a></span>ActiveFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8954944cf980f1f874a6510497568338">ActiveFilter</a> = <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bc95058fb208e9baa08dab77d98c5fa" name="a9bc95058fb208e9baa08dab77d98c5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc95058fb208e9baa08dab77d98c5fa">&#9670;&#160;</a></span>GroupAttributeArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9bc95058fb208e9baa08dab77d98c5fa">GroupAttributeArray</a> = <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a>&lt;<a class="el" href="#a714bfd681b0e82019a95174ecdb6a889">GroupType</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1GroupCodec.html">GroupCodec</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a714bfd681b0e82019a95174ecdb6a889" name="a714bfd681b0e82019a95174ecdb6a889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714bfd681b0e82019a95174ecdb6a889">&#9670;&#160;</a></span>GroupType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a714bfd681b0e82019a95174ecdb6a889">GroupType</a> = uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8273cc7bb48dded419013b35a6491bc0" name="a8273cc7bb48dded419013b35a6491bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8273cc7bb48dded419013b35a6491bc0">&#9670;&#160;</a></span>InactiveFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8273cc7bb48dded419013b35a6491bc0">InactiveFilter</a> = <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf438a63a8a41ec38b6d7ceae6467678" name="acf438a63a8a41ec38b6d7ceae6467678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf438a63a8a41ec38b6d7ceae6467678">&#9670;&#160;</a></span>PointDataGrid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678">PointDataGrid</a> = <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html">Grid</a>&lt;<a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df">PointDataTree</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Point data grid. </p>

</div>
</div>
<a id="a7fa856a8e82a8ff9db585d9429d2c5df" name="a7fa856a8e82a8ff9db585d9429d2c5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa856a8e82a8ff9db585d9429d2c5df">&#9670;&#160;</a></span>PointDataTree</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df">PointDataTree</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1tree_1_1Tree.html">tree::Tree</a>&lt;<a class="code hl_class" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">tree::RootNode</a>&lt;tree::InternalNode&lt;tree::InternalNode</div>
<div class="line">    &lt;<a class="code hl_class" href="classopenvdb_1_1v13__0_1_1points_1_1PointDataLeafNode.html">PointDataLeafNode&lt;PointDataIndex32, 3&gt;</a>, 4&gt;, 5&gt;&gt;&gt;</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1points_1_1PointDataLeafNode_html"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1points_1_1PointDataLeafNode.html">openvdb::v13_0::points::PointDataLeafNode</a></div><div class="ttdef"><b>Definition</b> PointDataGrid.h:240</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1tree_1_1RootNode_html"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">openvdb::v13_0::tree::RootNode</a></div><div class="ttdef"><b>Definition</b> RootNode.h:40</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1tree_1_1Tree_html"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1tree_1_1Tree.html">openvdb::v13_0::tree::Tree</a></div><div class="ttdef"><b>Definition</b> Tree.h:195</div></div>
</div><!-- fragment -->
<p>Point index tree configured to match the default VDB configurations. </p>

</div>
</div>
<a id="af44fac5036c56999ca811116b73eca72" name="af44fac5036c56999ca811116b73eca72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44fac5036c56999ca811116b73eca72">&#9670;&#160;</a></span>StringAttributeArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af44fac5036c56999ca811116b73eca72">StringAttributeArray</a> = <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a>&lt;<a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1StringCodec.html">StringCodec</a>&lt;false&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="ae71b1a4d4abc6a321046036c37ae645e" name="ae71b1a4d4abc6a321046036c37ae645e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71b1a4d4abc6a321046036c37ae645e">&#9670;&#160;</a></span>RasterMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ae71b1a4d4abc6a321046036c37ae645e">RasterMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How to composite points into a volume. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae71b1a4d4abc6a321046036c37ae645eac5d2a98a2112d89452e04fe14de91b91" name="ae71b1a4d4abc6a321046036c37ae645eac5d2a98a2112d89452e04fe14de91b91"></a>ACCUMULATE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae71b1a4d4abc6a321046036c37ae645ea115f17a28532bbd6f0f5ec83ed20692a" name="ae71b1a4d4abc6a321046036c37ae645ea115f17a28532bbd6f0f5ec83ed20692a"></a>MAXIMUM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae71b1a4d4abc6a321046036c37ae645ea16de38737a9f8366e9b2042b4e9b6290" name="ae71b1a4d4abc6a321046036c37ae645ea16de38737a9f8366e9b2042b4e9b6290"></a>AVERAGE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a4cc9cf4453d1c8ee7aae58fe5efd4040" name="a4cc9cf4453d1c8ee7aae58fe5efd4040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc9cf4453d1c8ee7aae58fe5efd4040">&#9670;&#160;</a></span>accumulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, typename CodecT = UnknownCodec, typename FilterT = NullFilter, typename PointDataTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1PromoteType.html">PromoteType</a>&lt; ValueT &gt;::Highest accumulate </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the total value of a point attribute. </p>
<p>Performs parallel reduction by summing all values. The reduction arithmetic and return value precision evaluates to: <a class="el" href="structopenvdb_1_1v13__0_1_1PromoteType.html#af1df57fa72e33748fb29c44bbaefdffa">PromoteType&lt;ValueT&gt;::Highest</a> which, for POD and VDB math types, is ValueT at its highest bit precision. If the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> is empty or the filter evalutes to empty, <a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b" title="Return the value of type T that corresponds to zero.">zeroVal&lt;ValueT&gt;()</a> is returned. </p><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structopenvdb_1_1v13__0_1_1PromoteType.html" title="Promotion classes which provide an interface for elevating and demoting a scalar or VDB type to a hig...">PromoteType</a> of the attribute must be copy constructible, support the same type + operator. This method will throw if ValueT does not match the given attribute. The function is deterministic. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if "P" is provided, the result is undefined. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point tree </td></tr>
    <tr><td class="paramname">attribute</td><td>the attribute to reduce </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total value </dd></dl>

</div>
</div>
<a id="a9a92590037c00b856a13e368400575c3" name="a9a92590037c00b856a13e368400575c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a92590037c00b856a13e368400575c3">&#9670;&#160;</a></span>accumulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, typename CodecT = UnknownCodec, typename FilterT = NullFilter, typename PointDataTreeT, typename ResultTreeT = typename PromoteType&lt;ValueT&gt;::Highest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool accumulate </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structopenvdb_1_1v13__0_1_1PromoteType.html">PromoteType</a>&lt; ValueT &gt;::Highest &amp;</td>          <td class="paramname"><span class="paramname"><em>total</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PointDataTreeT::template ValueConverter&lt; ResultTreeT &gt;::Type *</td>          <td class="paramname"><span class="paramname"><em>totalTree</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the total value of a point attribute and returns whether the value is valid. Optionally constructs localised total value trees. </p>
<p>Performs parallel reduction by summing all values. The reduction arithmetic and return value precision evaluates to: <a class="el" href="structopenvdb_1_1v13__0_1_1PromoteType.html#af1df57fa72e33748fb29c44bbaefdffa">PromoteType&lt;ValueT&gt;::Highest</a> which, for POD and VDB math types, is ValueT at its highest bit precision. This method will return true total has been set, false otherwise (when no points existed or a filter evaluated to empty). </p><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structopenvdb_1_1v13__0_1_1PromoteType.html" title="Promotion classes which provide an interface for elevating and demoting a scalar or VDB type to a hig...">PromoteType</a> of the attribute must be copy constructible, support the same type + operator. This method will throw if ValueT does not match the given attribute. The function is deterministic. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if "P" is provided, the result is undefined. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point tree </td></tr>
    <tr><td class="paramname">attribute</td><td>the attribute to reduce </td></tr>
    <tr><td class="paramname">total</td><td>the computed total value </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
    <tr><td class="paramname">totalTree</td><td>if provided, builds a tiled tree of localised total results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if total has been set, false otherwise. Can be false if no points were processed or if the tree was empty. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceopenvdb.html">openvdb</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1points.html">openvdb::points</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// accumulate and store per leaf values in a new tree</span></div>
<div class="line"><a class="code hl_typedef" href="structopenvdb_1_1v13__0_1_1PromoteType.html#af1df57fa72e33748fb29c44bbaefdffa">PromoteType&lt;uint8_t&gt;::Highest</a> total;  <span class="comment">// evaluates to uint64_t</span></div>
<div class="line">PointDataTree::ValueConverter&lt;<span class="keyword">decltype</span>(total)&gt;::Type totalTree; <span class="comment">// uint64_t tree of totals</span></div>
<div class="line"><span class="keywordtype">bool</span> success = <a class="code hl_function" href="#a4cc9cf4453d1c8ee7aae58fe5efd4040">accumulate&lt;uint8_t&gt;</a>(<a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1tree.html">tree</a>, <span class="stringliteral">&quot;attrib&quot;</span>, total, <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), &amp;totalTree);</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1points_1_1NullFilter_html"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">openvdb::v13_0::points::NullFilter</a></div><div class="ttdoc">A no-op filter that can be used when iterating over all indices.</div><div class="ttdef"><b>Definition</b> IndexIterator.h:52</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1points_html"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0_1_1points.html">openvdb::v13_0::points</a></div><div class="ttdef"><b>Definition</b> AttributeArray.h:42</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1points_html_a4cc9cf4453d1c8ee7aae58fe5efd4040"><div class="ttname"><a href="#a4cc9cf4453d1c8ee7aae58fe5efd4040">openvdb::v13_0::points::accumulate</a></div><div class="ttdeci">PromoteType&lt; ValueT &gt;::Highest accumulate(const PointDataTreeT &amp;points, const std::string &amp;attribute, const FilterT &amp;filter=NullFilter())</div><div class="ttdoc">Evaluates the total value of a point attribute.</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tree_html"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0_1_1tree.html">openvdb::v13_0::tree</a></div><div class="ttdef"><b>Definition</b> PointDataGrid.h:170</div></div>
<div class="ttc" id="anamespaceopenvdb_html"><div class="ttname"><a href="namespaceopenvdb.html">openvdb</a></div><div class="ttdef"><b>Definition</b> Exceptions.h:13</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1PromoteType_html_af1df57fa72e33748fb29c44bbaefdffa"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1PromoteType.html#af1df57fa72e33748fb29c44bbaefdffa">openvdb::v13_0::PromoteType::Highest</a></div><div class="ttdeci">typename TypeT&lt; 64ul &gt;::type Highest</div><div class="ttdef"><b>Definition</b> Types.h:427</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab79ffb24dc5aee12a75d1507966164bc" name="ab79ffb24dc5aee12a75d1507966164bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79ffb24dc5aee12a75d1507966164bc">&#9670;&#160;</a></span>advectPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT, typename VelGridT, typename AdvectFilterT = NullFilter, typename FilterT = NullFilter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void advectPoints </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VelGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>velocity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>integrationOrder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>dt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>timeSteps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AdvectFilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>advectFilter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>cached</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advect points in a <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> through a velocity grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> containing the points to be advected. </td></tr>
    <tr><td class="paramname">velocity</td><td>a velocity grid to be sampled. </td></tr>
    <tr><td class="paramname">integrationOrder</td><td>the integration scheme to use (1 is forward euler, 4 is runge-kutta 4th) </td></tr>
    <tr><td class="paramname">dt</td><td>delta time. </td></tr>
    <tr><td class="paramname">timeSteps</td><td>number of advection steps to perform. </td></tr>
    <tr><td class="paramname">advectFilter</td><td>an optional advection index filter (moves a subset of the points) </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter (deletes a subset of the points) </td></tr>
    <tr><td class="paramname">cached</td><td>caches velocity interpolation for faster performance, disable to use less memory (default is on). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f8216e14812f6a9c9aaf1af5b2ad36b" name="a9f8216e14812f6a9c9aaf1af5b2ad36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8216e14812f6a9c9aaf1af5b2ad36b">&#9670;&#160;</a></span>appendAttribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void appendAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a3907786c2430dbab9f198bfd5b31ff7c">NamePair</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>strideOrTotalSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>constantStride</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1Metadata.html">Metadata</a> *</td>          <td class="paramname"><span class="paramname"><em>defaultValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>hidden</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>transient</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new attribute to the VDB tree (this method does not require a templated AttributeType) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to be appended to. </td></tr>
    <tr><td class="paramname">name</td><td>name for the new attribute. </td></tr>
    <tr><td class="paramname">type</td><td>the type of the attibute. </td></tr>
    <tr><td class="paramname">strideOrTotalSize</td><td>the stride of the attribute </td></tr>
    <tr><td class="paramname">constantStride</td><td>if <code>false</code>, stride is interpreted as total size of the array </td></tr>
    <tr><td class="paramname">defaultValue</td><td>metadata default attribute value </td></tr>
    <tr><td class="paramname">hidden</td><td>mark attribute as hidden </td></tr>
    <tr><td class="paramname">transient</td><td>mark attribute as transient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12af91f538ab5256ce2db4afe3b9dd31" name="a12af91f538ab5256ce2db4afe3b9dd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12af91f538ab5256ce2db4afe3b9dd31">&#9670;&#160;</a></span>appendAttribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType, typename CodecType = NullCodec, typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void appendAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>uniformValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">point_attribute_internal::Default&lt;&#160;ValueType&#160;&gt;::value()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>strideOrTotalSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>constantStride</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1TypedMetadata.html">TypedMetadata</a>&lt; ValueType &gt; *</td>          <td class="paramname"><span class="paramname"><em>defaultValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>hidden</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>transient</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new attribute to the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to be appended to. </td></tr>
    <tr><td class="paramname">name</td><td>name for the new attribute </td></tr>
    <tr><td class="paramname">uniformValue</td><td>the initial value of the attribute </td></tr>
    <tr><td class="paramname">strideOrTotalSize</td><td>the stride of the attribute </td></tr>
    <tr><td class="paramname">constantStride</td><td>if <code>false</code>, stride is interpreted as total size of the array </td></tr>
    <tr><td class="paramname">defaultValue</td><td>metadata default attribute value </td></tr>
    <tr><td class="paramname">hidden</td><td>mark attribute as hidden </td></tr>
    <tr><td class="paramname">transient</td><td>mark attribute as transient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6df5f0462ae9d328e4987971cda4c7ee" name="a6df5f0462ae9d328e4987971cda4c7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df5f0462ae9d328e4987971cda4c7ee">&#9670;&#160;</a></span>appendGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void appendGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new empty group to the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to be appended to. </td></tr>
    <tr><td class="paramname">group</td><td>name of the new group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad2483abeddd3034b01b946caf10f84f" name="aad2483abeddd3034b01b946caf10f84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2483abeddd3034b01b946caf10f84f">&#9670;&#160;</a></span>appendGroups()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void appendGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>groups</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends new empty groups to the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to be appended to. </td></tr>
    <tr><td class="paramname">groups</td><td>names of the new groups. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa41bddc5c1099d146cee05b0dc3eb6ff" name="aa41bddc5c1099d146cee05b0dc3eb6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41bddc5c1099d146cee05b0dc3eb6ff">&#9670;&#160;</a></span>boxSample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT, typename SourceGridT, typename FilterT = NullFilter, typename InterrupterT = util::NullInterrupter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boxSample </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>targetAttribute</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs tri-linear sampling from a VDB grid onto a VDB Points attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> whose points will be sampled on to </td></tr>
    <tr><td class="paramname">sourceGrid</td><td>VDB grid which will be sampled </td></tr>
    <tr><td class="paramname">targetAttribute</td><td>a target attribute on the points which will hold samples. This attribute will be created with the source grid type if it does not exist, and with the source grid name if the name is empty </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The target attribute may exist provided it can be cast to the SourceGridT ValueType </dd></dl>

</div>
</div>
<a id="a6b46b75155cc394f4ad4b540f167523a" name="a6b46b75155cc394f4ad4b540f167523a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b46b75155cc394f4ad4b540f167523a">&#9670;&#160;</a></span>collapseAttribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType, typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void collapseAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>uniformValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">point_attribute_internal::Default&lt;&#160;ValueType&#160;&gt;::value()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collapse the attribute into a uniform value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> in which to collapse the attribute. </td></tr>
    <tr><td class="paramname">name</td><td>name for the attribute. </td></tr>
    <tr><td class="paramname">uniformValue</td><td>value of the attribute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a467b8eefb87ca02fa0f017c40c08d674" name="a467b8eefb87ca02fa0f017c40c08d674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467b8eefb87ca02fa0f017c40c08d674">&#9670;&#160;</a></span>compactAttributes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compactAttributes </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compact attributes in a VDB tree (if possible). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6057529f97b428787a3e993ad12d3cf2" name="a6057529f97b428787a3e993ad12d3cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6057529f97b428787a3e993ad12d3cf2">&#9670;&#160;</a></span>compactGroups()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compactGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compacts existing groups of a VDB Tree to use less memory if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to be compacted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85baad70404957c0b435068440ae1c0f" name="a85baad70404957c0b435068440ae1c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85baad70404957c0b435068440ae1c0f">&#9670;&#160;</a></span>computeVoxelSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PositionWrapper, typename InterrupterT = openvdb::util::NullInterrupter, typename VecT = typename internal::ValueTypeTraits&lt;PositionWrapper&gt;::Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float computeVoxelSize </td>
          <td>(</td>
          <td class="paramtype">const PositionWrapper &amp;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>pointsPerVoxel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#abaf7f913bf1752b9157259ffa32704ca">math::Mat4d</a></td>          <td class="paramname"><span class="paramname"><em>transform</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Mat4.html#a594d71e30b0571fd84ca639822459a1e">math::Mat4d::identity</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>decimalPlaces</em></span><span class="paramdefsep"> = </span><span class="paramdefval">5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@ brief Given a container of world space positions and a target points per voxel, compute a uniform voxel size that would best represent the storage of the points in a grid. This voxel size is typically used for conversion of the points into a <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positions</td><td>array of world space positions </td></tr>
    <tr><td class="paramname">pointsPerVoxel</td><td>the target number of points per voxel, must be positive and non-zero </td></tr>
    <tr><td class="paramname">transform</td><td>voxel size will be computed using this optional transform if provided </td></tr>
    <tr><td class="paramname">decimalPlaces</td><td>for readability, truncate voxel size to this number of decimals </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>VecT will be PositionWrapper::value_type or <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab8753c49a176ce809a70ac12896682e3">Vec3R</a> (if there is no value_type defined)</dd>
<dd>
if none or one point provided in positions, the default voxel size of 0.1 will be returned </dd></dl>

</div>
</div>
<a id="ac91e520838e75f17a4e0a3505c128931" name="ac91e520838e75f17a4e0a3505c128931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91e520838e75f17a4e0a3505c128931">&#9670;&#160;</a></span>convertPointDataGridAttribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypedAttribute, typename PointDataTreeT, typename FilterT = NullFilter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void convertPointDataGridAttribute </td>
          <td>(</td>
          <td class="paramtype">TypedAttribute &amp;</td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pointOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a></td>          <td class="paramname"><span class="paramname"><em>startOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned</td>          <td class="paramname"><span class="paramname"><em>arrayIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>stride</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>inCoreOnly</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the attribute from a <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>the attribute to be populated. </td></tr>
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to be converted. </td></tr>
    <tr><td class="paramname">pointOffsets</td><td>a vector of cumulative point offsets for each leaf. </td></tr>
    <tr><td class="paramname">startOffset</td><td>a value to shift all the point offsets by </td></tr>
    <tr><td class="paramname">arrayIndex</td><td>the index in the Descriptor of the array to be converted. </td></tr>
    <tr><td class="paramname">stride</td><td>the stride of the attribute </td></tr>
    <tr><td class="paramname">filter</td><td>an index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>true if out-of-core leaf nodes are to be ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4875034852344d7f676c955bb764d9c1" name="a4875034852344d7f676c955bb764d9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4875034852344d7f676c955bb764d9c1">&#9670;&#160;</a></span>convertPointDataGridGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Group, typename PointDataTreeT, typename FilterT = NullFilter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void convertPointDataGridGroup </td>
          <td>(</td>
          <td class="paramtype">Group &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pointOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a></td>          <td class="paramname"><span class="paramname"><em>startOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeSet_1_1Descriptor.html#a0decda39ae55f7cf0a11bf16c61b270c">AttributeSet::Descriptor::GroupIndex</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>inCoreOnly</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the group from a <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group to be populated. </td></tr>
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to be converted. </td></tr>
    <tr><td class="paramname">pointOffsets</td><td>a vector of cumulative point offsets for each leaf </td></tr>
    <tr><td class="paramname">startOffset</td><td>a value to shift all the point offsets by </td></tr>
    <tr><td class="paramname">index</td><td>the group index to be converted. </td></tr>
    <tr><td class="paramname">filter</td><td>an index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>true if out-of-core leaf nodes are to be ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf905ca86b725954bf900e3caf6b431a" name="acf905ca86b725954bf900e3caf6b431a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf905ca86b725954bf900e3caf6b431a">&#9670;&#160;</a></span>convertPointDataGridPosition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PositionAttribute, typename PointDataGridT, typename FilterT = NullFilter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void convertPointDataGridPosition </td>
          <td>(</td>
          <td class="paramtype">PositionAttribute &amp;</td>          <td class="paramname"><span class="paramname"><em>positionAttribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pointOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a></td>          <td class="paramname"><span class="paramname"><em>startOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>inCoreOnly</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the position attribute from a Point Data <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata.">Grid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positionAttribute</td><td>the position attribute to be populated. </td></tr>
    <tr><td class="paramname">grid</td><td>the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> to be converted. </td></tr>
    <tr><td class="paramname">pointOffsets</td><td>a vector of cumulative point offsets for each leaf </td></tr>
    <tr><td class="paramname">startOffset</td><td>a value to shift all the point offsets by </td></tr>
    <tr><td class="paramname">filter</td><td>an index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>true if out-of-core leaf nodes are to be ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c532af9bac4f3e4ee0cbbb45b0f0629" name="a4c532af9bac4f3e4ee0cbbb45b0f0629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c532af9bac4f3e4ee0cbbb45b0f0629">&#9670;&#160;</a></span>convertPointsToMask() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT, typename MaskGridT = typename PointDataGridT::template ValueConverter&lt;bool&gt;::Type, typename FilterT = NullFilter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1GridBase.html">GridBase</a>, PointDataGridT &gt;::value &amp;&amp;std::is_same&lt; typenameMaskGridT::ValueType, bool &gt;::value, typenameMaskGridT::Ptr &gt;::type convertPointsToMask </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a Mask <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata.">Grid</a> from a Point Data <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata.">Grid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> to extract the mask from. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this method is only available for Bool Grids and Mask Grids </dd></dl>

</div>
</div>
<a id="aedeab297ce588a62f0d22c51c5e1beff" name="aedeab297ce588a62f0d22c51c5e1beff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedeab297ce588a62f0d22c51c5e1beff">&#9670;&#160;</a></span>convertPointsToMask() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT, typename MaskT = typename PointDataGridT::template ValueConverter&lt;bool&gt;::Type, typename FilterT = NullFilter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; typenameMaskT::ValueType, bool &gt;::value, typenameMaskT::Ptr &gt;::type convertPointsToMask </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a Mask <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata.">Grid</a> from a Point Data <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata.">Grid</a> using a new transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> to extract the mask from. </td></tr>
    <tr><td class="paramname">transform</td><td>target transform for the mask. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this method is only available for Bool Grids and Mask Grids </dd></dl>

</div>
</div>
<a id="a3bc4fb5488537e98b49bf52140166947" name="a3bc4fb5488537e98b49bf52140166947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc4fb5488537e98b49bf52140166947">&#9670;&#160;</a></span>convertPointsToMask() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT, typename MaskTreeT = typename PointDataTreeT::template ValueConverter&lt;bool&gt;::Type, typename FilterT = NullFilter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#acbcb5f84dd5976c2bb8d02c10017d060">TreeBase</a>, PointDataTreeT &gt;::value &amp;&amp;std::is_same&lt; typenameMaskTreeT::ValueType, bool &gt;::value, typenameMaskTreeT::Ptr &gt;::type convertPointsToMask </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a Mask Tree from a Point Data Tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to extract the mask from. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab15a1ee82d506999536458071ba44299" name="ab15a1ee82d506999536458071ba44299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15a1ee82d506999536458071ba44299">&#9670;&#160;</a></span>createPointDataGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompressionT, typename PointDataGridT, typename PositionArrayT, typename PointIndexGridT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr createPointDataGrid </td>
          <td>(</td>
          <td class="paramtype">const PointIndexGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>pointIndexGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionArrayT &amp;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1Metadata.html">Metadata</a> *</td>          <td class="paramname"><span class="paramname"><em>positionDefaultValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Localises points with position into a <code><a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a></code> into two stages: allocation of the leaf attribute data and population of the positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointIndexGrid</td><td>a PointIndexGrid into the points. </td></tr>
    <tr><td class="paramname">positions</td><td>list of world space point positions. </td></tr>
    <tr><td class="paramname">xform</td><td>world to index space transform. </td></tr>
    <tr><td class="paramname">positionDefaultValue</td><td>metadata default position value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The position data must be supplied in a Point-Partitioner compatible data structure. A convenience <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1PointAttributeVector.html" title="Point-partitioner compatible STL vector attribute wrapper for convenience.">PointAttributeVector</a> class is offered.</dd>
<dd>
The position data is populated separately to perform world space to voxel space conversion and apply quantisation.</dd>
<dd>
A <code>PointIndexGrid</code> to the points must be supplied to perform this operation. Typically this is built implicitly by the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> constructor. </dd></dl>

</div>
</div>
<a id="a07c2da02df6fb329b2684f56617c39b9" name="a07c2da02df6fb329b2684f56617c39b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c2da02df6fb329b2684f56617c39b9">&#9670;&#160;</a></span>createPointDataGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompressionT, typename PointDataGridT, typename ValueT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr createPointDataGrid </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ValueT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1Metadata.html">Metadata</a> *</td>          <td class="paramname"><span class="paramname"><em>positionDefaultValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method to create a <code><a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a></code> from a std::vector of point positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positions</td><td>list of world space point positions. </td></tr>
    <tr><td class="paramname">xform</td><td>world to index space transform. </td></tr>
    <tr><td class="paramname">positionDefaultValue</td><td>metadata default position value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method implicitly wraps the std::vector for a Point-Partitioner compatible data structure and creates the required <code>PointIndexGrid</code> to the points. </dd></dl>

</div>
</div>
<a id="afdbd30a3741affcd2b2434124a34149d" name="afdbd30a3741affcd2b2434124a34149d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbd30a3741affcd2b2434124a34149d">&#9670;&#160;</a></span>deleteFromGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deleteFromGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>pointTree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invert</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>drop</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete points that are members of a group. </p>
<p>This method will delete points which are members of the supplied group and will optionally drop the group from the tree. An invert flag can be used to delete points that belong to none of the groups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointTree</td><td>the point tree with the group to delete </td></tr>
    <tr><td class="paramname">group</td><td>the name of the group to delete </td></tr>
    <tr><td class="paramname">invert</td><td>if enabled, points not belonging to any of the groups will be deleted </td></tr>
    <tr><td class="paramname">drop</td><td>if enabled and invert is disabled, the group will be dropped from the tree</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the invert flag is true, the group will not be dropped after deleting points regardless of the value of the drop parameter. </dd></dl>

</div>
</div>
<a id="a6b9d921b422e929c3786e77c8d4c811f" name="a6b9d921b422e929c3786e77c8d4c811f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9d921b422e929c3786e77c8d4c811f">&#9670;&#160;</a></span>deleteFromGroups()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deleteFromGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>pointTree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>groups</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invert</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>drop</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete points that are members of specific groups. </p>
<p>This method will delete points which are members of any of the supplied groups and will optionally drop the groups from the tree. An invert flag can be used to delete points that belong to none of the groups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointTree</td><td>the point tree </td></tr>
    <tr><td class="paramname">groups</td><td>the groups from which to delete points </td></tr>
    <tr><td class="paramname">invert</td><td>if enabled, points not belonging to any of the groups will be deleted </td></tr>
    <tr><td class="paramname">drop</td><td>if enabled and invert is disabled, the groups will be dropped from the tree</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the invert flag is true, none of the groups will be dropped after deleting points regardless of the value of the drop parameter. </dd></dl>

</div>
</div>
<a id="a5e318d6bae7846125e0ac39c66024fc2" name="a5e318d6bae7846125e0ac39c66024fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e318d6bae7846125e0ac39c66024fc2">&#9670;&#160;</a></span>deleteMissingPointGroups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deleteMissingPointGroups </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>groups</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeSet_1_1Descriptor.html">AttributeSet::Descriptor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>descriptor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete any group that is not present in the Descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>the vector of group names. </td></tr>
    <tr><td class="paramname">descriptor</td><td>the descriptor that holds the group map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a35fc7cff4396e3c0fed48af7150c30" name="a2a35fc7cff4396e3c0fed48af7150c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a35fc7cff4396e3c0fed48af7150c30">&#9670;&#160;</a></span>denseUniformPointScatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename RandGenT = std::mt19937, typename PositionArrayT = TypedAttributeArray&lt;Vec3f, NullCodec&gt;, typename PointDataGridT = Grid&lt;        typename points::TreeConverter&lt;typename GridT::TreeType&gt;::Type&gt;, typename InterrupterT = util::NullInterrupter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr denseUniformPointScatter </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float</td>          <td class="paramname"><span class="paramname"><em>pointsPerVoxel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float</td>          <td class="paramname"><span class="paramname"><em>spread</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uniformly scatter a fixed number of points per active voxel. If the pointsPerVoxel value provided is a fractional value, each voxel calculates a delta value of how likely it is to contain an extra point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>A source grid. The resulting <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> will copy this grids transform and scatter in its active voxelized topology. </td></tr>
    <tr><td class="paramname">pointsPerVoxel</td><td>The number of points to scatter per voxel </td></tr>
    <tr><td class="paramname">seed</td><td>A seed for the RandGenT </td></tr>
    <tr><td class="paramname">spread</td><td>The spread of points as a scale from each voxels center. A value of 1.0f indicates points can be placed anywhere within the voxel, where as a value of 0.0f will force all points to be created exactly at the centers of each voxel. </td></tr>
    <tr><td class="paramname">interrupter</td><td>An optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns the scattered <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> </dd></dl>

</div>
</div>
<a id="acd25e23091c52fb8da4fcb50369ad45b" name="acd25e23091c52fb8da4fcb50369ad45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd25e23091c52fb8da4fcb50369ad45b">&#9670;&#160;</a></span>dropAttribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop one attribute from the VDB tree (convenience method). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to be dropped from. </td></tr>
    <tr><td class="paramname">name</td><td>name of the attribute to drop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a630071eb13957e9c9683fafb845ec9ce" name="a630071eb13957e9c9683fafb845ec9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630071eb13957e9c9683fafb845ec9ce">&#9670;&#160;</a></span>dropAttribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop one attribute from the VDB tree (convenience method). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to be dropped from. </td></tr>
    <tr><td class="paramname">index</td><td>index of the attribute to drop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa8ee0b505384ce90253b77516cedce4" name="aaa8ee0b505384ce90253b77516cedce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8ee0b505384ce90253b77516cedce4">&#9670;&#160;</a></span>dropAttributes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropAttributes </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>names</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops attributes from the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to be dropped from. </td></tr>
    <tr><td class="paramname">names</td><td>names of the attributes to drop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaaa22577ec29a353a700c9a3fa03906f" name="aaaa22577ec29a353a700c9a3fa03906f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa22577ec29a353a700c9a3fa03906f">&#9670;&#160;</a></span>dropAttributes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropAttributes </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops attributes from the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to be dropped from. </td></tr>
    <tr><td class="paramname">indices</td><td>indices of the attributes to drop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1f0afec32f566e10a0a25fde4466dba" name="ac1f0afec32f566e10a0a25fde4466dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f0afec32f566e10a0a25fde4466dba">&#9670;&#160;</a></span>dropGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>compact</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops an existing group from the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to be dropped from. </td></tr>
    <tr><td class="paramname">group</td><td>name of the group. </td></tr>
    <tr><td class="paramname">compact</td><td>compact attributes if possible to reduce memory - if dropping more than one group, compacting once at the end will be faster </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7814ccafca96a095c60c6c6438b7eb2" name="ad7814ccafca96a095c60c6c6438b7eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7814ccafca96a095c60c6c6438b7eb2">&#9670;&#160;</a></span>dropGroups() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops all existing groups from the VDB tree, the tree is compacted after dropping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to be dropped from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c87fccd745143ae4e42c5b1f4998508" name="a0c87fccd745143ae4e42c5b1f4998508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c87fccd745143ae4e42c5b1f4998508">&#9670;&#160;</a></span>dropGroups() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>groups</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops existing groups from the VDB tree, the tree is compacted after dropping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> to be dropped from. </td></tr>
    <tr><td class="paramname">groups</td><td>names of the groups. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abee94dbff950fd1421a1f324bc5b4b2b" name="abee94dbff950fd1421a1f324bc5b4b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee94dbff950fd1421a1f324bc5b4b2b">&#9670;&#160;</a></span>evalAverage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, typename CodecT = UnknownCodec, typename FilterT = NullFilter, typename PointDataTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1ConvertElementType.html">ConvertElementType</a>&lt; ValueT, double &gt;::Type evalAverage </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the average value of a point attribute. </p>
<p>Performs parallel reduction by cumulative moving average. The reduction arithmetic and return value precision evaluates to: <a class="el" href="structopenvdb_1_1v13__0_1_1ConvertElementType.html#a801364d20664a6d2df467fcc266ed7c8">ConvertElementType&lt;ValueT, double&gt;::Type</a> which, for POD and VDB math types, is ValueT at double precision. If the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> is empty or the filter evalutes to empty, <a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b" title="Return the value of type T that corresponds to zero.">zeroVal&lt;ValueT&gt;()</a> is returned. </p><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structopenvdb_1_1v13__0_1_1ConvertElementType.html" title="Conversion classes for changing the underlying type of VDB types.">ConvertElementType</a> of the attribute must be copy constructible, support the same type + - * operators and * / operators from a double. This method will throw if ValueT does not match the given attribute. The function is deterministic. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if "P" is provided, the result is undefined. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point tree </td></tr>
    <tr><td class="paramname">attribute</td><td>the attribute to reduce </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the average value </dd></dl>

</div>
</div>
<a id="a2ca703db5f875505c22c5d2c142441a2" name="a2ca703db5f875505c22c5d2c142441a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca703db5f875505c22c5d2c142441a2">&#9670;&#160;</a></span>evalAverage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, typename CodecT = UnknownCodec, typename FilterT = NullFilter, typename PointDataTreeT, typename ResultTreeT = typename ConvertElementType&lt;ValueT, double&gt;::Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool evalAverage </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structopenvdb_1_1v13__0_1_1ConvertElementType.html">ConvertElementType</a>&lt; ValueT, double &gt;::Type &amp;</td>          <td class="paramname"><span class="paramname"><em>average</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PointDataTreeT::template ValueConverter&lt; ResultTreeT &gt;::Type *</td>          <td class="paramname"><span class="paramname"><em>averageTree</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the average value of a point attribute and returns whether the value is valid. Optionally constructs localised average value trees. </p>
<p>Performs parallel reduction by cumulative moving average. The reduction arithmetic and return value precision evaluates to: <a class="el" href="structopenvdb_1_1v13__0_1_1ConvertElementType.html#a801364d20664a6d2df467fcc266ed7c8">ConvertElementType&lt;ValueT, double&gt;::Type</a> which, for POD and VDB math types, is ValueT at double precision. This method will return true average has been set, false otherwise (when no points existed or a filter evaluated to empty). </p><dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structopenvdb_1_1v13__0_1_1ConvertElementType.html" title="Conversion classes for changing the underlying type of VDB types.">ConvertElementType</a> of the attribute must be copy constructible, support the same type + - * operators and * / operators from a double. This method will throw if ValueT does not match the given attribute. The function is deterministic. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if "P" is provided, the result is undefined. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point tree </td></tr>
    <tr><td class="paramname">attribute</td><td>the attribute to reduce </td></tr>
    <tr><td class="paramname">average</td><td>the computed averaged value at double precision </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
    <tr><td class="paramname">averageTree</td><td>if provided, builds a tiled tree of localised avg results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if average has been set, false otherwise. Can be false if no points were processed or if the tree was empty. </dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceopenvdb.html">openvdb</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1points.html">openvdb::points</a></div>
<div class="line"> </div>
<div class="line"><span class="comment">// average and store per leaf values in a new tree</span></div>
<div class="line"><a class="code hl_typedef" href="structopenvdb_1_1v13__0_1_1ConvertElementType.html#a801364d20664a6d2df467fcc266ed7c8">ConvertElementType&lt;uint8_t, double&gt;::Type</a> avg;  <span class="comment">// evaluates to double</span></div>
<div class="line">PointDataTree::ValueConverter&lt;<span class="keyword">decltype</span>(avg)&gt;::Type avgTree; <span class="comment">// double tree of averages</span></div>
<div class="line"><span class="keywordtype">bool</span> success = <a class="code hl_function" href="#abee94dbff950fd1421a1f324bc5b4b2b">evalAverage&lt;uint8_t&gt;</a>(<a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1tree.html">tree</a>, <span class="stringliteral">&quot;attrib&quot;</span>, avg, <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>(), &amp;avgTree);</div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1points_html_abee94dbff950fd1421a1f324bc5b4b2b"><div class="ttname"><a href="#abee94dbff950fd1421a1f324bc5b4b2b">openvdb::v13_0::points::evalAverage</a></div><div class="ttdeci">ConvertElementType&lt; ValueT, double &gt;::Type evalAverage(const PointDataTreeT &amp;points, const std::string &amp;attribute, const FilterT &amp;filter=NullFilter())</div><div class="ttdoc">Evaluates the average value of a point attribute.</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1ConvertElementType_html_a801364d20664a6d2df467fcc266ed7c8"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1ConvertElementType.html#a801364d20664a6d2df467fcc266ed7c8">openvdb::v13_0::ConvertElementType::Type</a></div><div class="ttdeci">SubT Type</div><div class="ttdef"><b>Definition</b> Types.h:372</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a7d93f4d68e2eb70dac85a685e9b9522e" name="a7d93f4d68e2eb70dac85a685e9b9522e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d93f4d68e2eb70dac85a685e9b9522e">&#9670;&#160;</a></span>evalMinMax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, typename CodecT = UnknownCodec, typename FilterT = NullFilter, typename PointDataTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; ValueT, ValueT &gt; evalMinMax </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the minimum and maximum values of a point attribute. </p>
<p>Performs parallel reduction by comparing values using their less than and greater than operators. If the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> is empty or the filter evalutes to empty, <a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b" title="Return the value of type T that corresponds to zero.">zeroVal&lt;ValueT&gt;()</a> is returned for both values. </p><dl class="section note"><dt>Note</dt><dd>The ValueT of the attribute must be copy constructible. This method will throw if the templated ValueT does not match the given attribute. For vectors and matrices, this results in per component comparisons. See evalExtents for magnitudes or more custom control. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if "P" is provided, the result is undefined. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point tree </td></tr>
    <tr><td class="paramname">attribute</td><td>the attribute to reduce </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>min,max value pair </dd></dl>

</div>
</div>
<a id="a44690998e9733ab3498205299864e4a4" name="a44690998e9733ab3498205299864e4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44690998e9733ab3498205299864e4a4">&#9670;&#160;</a></span>evalMinMax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, typename CodecT = UnknownCodec, typename FilterT = NullFilter, typename PointDataTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool evalMinMax </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PointDataTreeT::template ValueConverter&lt; ValueT &gt;::Type *</td>          <td class="paramname"><span class="paramname"><em>minTree</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PointDataTreeT::template ValueConverter&lt; ValueT &gt;::Type *</td>          <td class="paramname"><span class="paramname"><em>maxTree</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the minimum and maximum values of a point attribute and returns whether the values are valid. Optionally constructs localised min and max value trees. </p>
<p>Performs parallel reduction by comparing values using their less than and greater than operators. This method will return true if min and max have been set, false otherwise (when no points existed or a filter evaluated to empty). </p><dl class="section note"><dt>Note</dt><dd>The ValueT of the attribute must also be copy constructible. This method will throw if the templated ValueT does not match the given attribute. For vectors and matrices, this results in per component comparisons. See evalExtents for magnitudes or more custom control. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if "P" is provided, the result is undefined. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point tree </td></tr>
    <tr><td class="paramname">attribute</td><td>the attribute to reduce </td></tr>
    <tr><td class="paramname">min</td><td>the computed min value </td></tr>
    <tr><td class="paramname">max</td><td>the computed max value </td></tr>
    <tr><td class="paramname">filter</td><td>a filter to apply to points </td></tr>
    <tr><td class="paramname">minTree</td><td>if provided, builds a tiled tree of localised min results </td></tr>
    <tr><td class="paramname">maxTree</td><td>if provided, builds a tiled tree of localised max results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if min and max have been set, false otherwise. Can be false if no points were processed or if the tree was empty. </dd></dl>

</div>
</div>
<a id="a9462e09e2caf64d1c8aa6438e55d8d90" name="a9462e09e2caf64d1c8aa6438e55d8d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9462e09e2caf64d1c8aa6438e55d8d90">&#9670;&#160;</a></span>fixedPointToFloatingPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatT, typename IntegerT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT fixedPointToFloatingPoint </td>
          <td>(</td>
          <td class="paramtype">const IntegerT</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a203a4416f7a5d8877eb65027015d700a" name="a203a4416f7a5d8877eb65027015d700a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203a4416f7a5d8877eb65027015d700a">&#9670;&#160;</a></span>fixedPointToFloatingPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatVectorT, typename IntegerT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatVectorT fixedPointToFloatingPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; IntegerT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac237583ca1f8ce413b0c2fcf531f5c4f" name="ac237583ca1f8ce413b0c2fcf531f5c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac237583ca1f8ce413b0c2fcf531f5c4f">&#9670;&#160;</a></span>floatingPointToFixedPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerT, typename FloatT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerT floatingPointToFixedPoint </td>
          <td>(</td>
          <td class="paramtype">const FloatT</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f77e99a8e388f3166e57550570299d2" name="a1f77e99a8e388f3166e57550570299d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f77e99a8e388f3166e57550570299d2">&#9670;&#160;</a></span>floatingPointToFixedPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerVectorT, typename FloatT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVectorT floatingPointToFixedPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; FloatT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a95b9808c9991f5e067d27f62fa598756" name="a95b9808c9991f5e067d27f62fa598756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b9808c9991f5e067d27f62fa598756">&#9670;&#160;</a></span>isGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeArray.html">AttributeArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a119b709e5eeb5608faeea2de42e54637" name="a119b709e5eeb5608faeea2de42e54637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119b709e5eeb5608faeea2de42e54637">&#9670;&#160;</a></span>isString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeArray.html">AttributeArray</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adfb5e64392fdf29bc3462e5a60713158" name="adfb5e64392fdf29bc3462e5a60713158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb5e64392fdf29bc3462e5a60713158">&#9670;&#160;</a></span>iterCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> iterCount </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count up the number of times the iterator can iterate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>the iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>counting by iteration only performed where a dynamic filter is in use, </dd></dl>

</div>
</div>
<a id="af351ce8e812595d5fede2fd73ce96420" name="af351ce8e812595d5fede2fd73ce96420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af351ce8e812595d5fede2fd73ce96420">&#9670;&#160;</a></span>makeDescriptorUnique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeSet_1_1Descriptor.html#a94ff3417324fe637256bfe9e0cb68304">AttributeSet::Descriptor::Ptr</a> makeDescriptorUnique </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy the descriptor across all leaf nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new descriptor.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method will fail if the Descriptors in the tree are not all identical. </dd></dl>

</div>
</div>
<a id="ad0d785b238fdbdf02b903fd9ddd453f3" name="ad0d785b238fdbdf02b903fd9ddd453f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d785b238fdbdf02b903fd9ddd453f3">&#9670;&#160;</a></span>movePoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT, typename DeformerT, typename FilterT = NullFilter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void movePoints </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeformerT &amp;</td>          <td class="paramname"><span class="paramname"><em>deformer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1future_1_1Advect.html">future::Advect</a> *</td>          <td class="paramname"><span class="paramname"><em>objectNotInUse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move points in a <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> using a custom deformer and a new transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> containing the points to be moved. </td></tr>
    <tr><td class="paramname">transform</td><td>target transform to use for the resulting points. </td></tr>
    <tr><td class="paramname">deformer</td><td>a custom deformer that defines how to move the points. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">objectNotInUse</td><td>for future use, this object is currently ignored </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d0082c20c402a864700014eae174838" name="a2d0082c20c402a864700014eae174838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0082c20c402a864700014eae174838">&#9670;&#160;</a></span>movePoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT, typename DeformerT, typename FilterT = NullFilter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void movePoints </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeformerT &amp;</td>          <td class="paramname"><span class="paramname"><em>deformer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1future_1_1Advect.html">future::Advect</a> *</td>          <td class="paramname"><span class="paramname"><em>objectNotInUse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move points in a <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> using a custom deformer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> containing the points to be moved. </td></tr>
    <tr><td class="paramname">deformer</td><td>a custom deformer that defines how to move the points. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">objectNotInUse</td><td>for future use, this object is currently ignored </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea55ad121ac7274e8a5bb844253c695d" name="aea55ad121ac7274e8a5bb844253c695d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea55ad121ac7274e8a5bb844253c695d">&#9670;&#160;</a></span>nonUniformPointScatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename RandGenT = std::mt19937, typename PositionArrayT = TypedAttributeArray&lt;Vec3f, NullCodec&gt;, typename PointDataGridT = Grid&lt;        typename points::TreeConverter&lt;typename GridT::TreeType&gt;::Type&gt;, typename InterrupterT = util::NullInterrupter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr nonUniformPointScatter </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float</td>          <td class="paramname"><span class="paramname"><em>pointsPerVoxel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float</td>          <td class="paramname"><span class="paramname"><em>spread</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non uniformly scatter points per active voxel. The pointsPerVoxel value is used to weight each grids cell value to compute a fixed number of points for every active voxel. If the computed result is a fractional value, each voxel calculates a delta value of how likely it is to contain an extra point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>A source grid. The resulting <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> will copy this grids transform, voxelized topology and use its values to compute a target points per voxel. The grids ValueType must be convertible to a scalar value. Only active and larger than zero values will contain points. </td></tr>
    <tr><td class="paramname">pointsPerVoxel</td><td>The number of points to scatter per voxel </td></tr>
    <tr><td class="paramname">seed</td><td>A seed for the RandGenT </td></tr>
    <tr><td class="paramname">spread</td><td>The spread of points as a scale from each voxels center. A value of 1.0f indicates points can be placed anywhere within the voxel, where as a value of 0.0f will force all points to be created exactly at the centers of each voxel. </td></tr>
    <tr><td class="paramname">interrupter</td><td>An optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns the scattered <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> </dd></dl>

</div>
</div>
<a id="a74fa733452dea2d0ee1d99c9583fd30d" name="a74fa733452dea2d0ee1d99c9583fd30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fa733452dea2d0ee1d99c9583fd30d">&#9670;&#160;</a></span>pca()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pca </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1PcaSettings.html">PcaSettings</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>settings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1PcaAttributes.html">PcaAttributes</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>attrs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate ellipsoid transformations from the local point distributions as described in Yu and Turk's 'Reconstructing Fluid Surfaces with Anisotropic Kernels'. The results are stored on the attributes pointed to by the <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1PcaAttributes.html" title="The persistent attributes created by the PCA methods.">PcaAttributes</a>. See the <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1PcaSettings.html" title="Various settings for the neighborhood analysis of point distributions.">PcaSettings</a> and <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1PcaAttributes.html" title="The persistent attributes created by the PCA methods.">PcaAttributes</a> structs for more details. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method will throw if the 'strech', 'xform' or 'pws' attributes already exist on this input point set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The point data grid to analyses </td></tr>
    <tr><td class="paramname">settings</td><td>The PCA settings for controlling the behavior of the neighborhood searches and the resulting ellipsoidal values </td></tr>
    <tr><td class="paramname">attrs</td><td>The PCA attributes to create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dbfd50108bbe665a6e1a0607335a5df" name="a8dbfd50108bbe665a6e1a0607335a5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbfd50108bbe665a6e1a0607335a5df">&#9670;&#160;</a></span>pointCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT, typename FilterT = NullFilter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> pointCount </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>inCoreOnly</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the total number of points in a <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> in which to count the points </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>if true, points in out-of-core leaf nodes are not counted </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90464075cf4382ab74a75288eebfce02" name="a90464075cf4382ab74a75288eebfce02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90464075cf4382ab74a75288eebfce02">&#9670;&#160;</a></span>pointCountGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT, typename GridT = typename PointDataGridT::template ValueConverter&lt;Int32&gt;::Type, typename FilterT = NullFilter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr pointCountGrid </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a new grid with voxel values to store the number of points per voxel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> to use to compute the count grid </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The return type of the grid must be an integer or floating-point scalar grid. </dd></dl>

</div>
</div>
<a id="a2159bcf1fea38531ec493459f3b37857" name="a2159bcf1fea38531ec493459f3b37857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2159bcf1fea38531ec493459f3b37857">&#9670;&#160;</a></span>pointCountGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT, typename GridT = typename PointDataGridT::template ValueConverter&lt;Int32&gt;::Type, typename FilterT = NullFilter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr pointCountGrid </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a new grid that uses the supplied transform with voxel values to store the number of points per voxel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> to use to compute the count grid </td></tr>
    <tr><td class="paramname">transform</td><td>the transform to use to compute the count grid </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The return type of the grid must be an integer or floating-point scalar grid. </dd></dl>

</div>
</div>
<a id="a639be5922b4acf36c519e88f9ea8ff7d" name="a639be5922b4acf36c519e88f9ea8ff7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639be5922b4acf36c519e88f9ea8ff7d">&#9670;&#160;</a></span>pointOffsets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT, typename FilterT = NullFilter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> pointOffsets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pointOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>inCoreOnly</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate an array of cumulative point offsets per leaf node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointOffsets</td><td>array of offsets to be populated </td></tr>
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a> from which to populate the offsets </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>if true, points in out-of-core leaf nodes are ignored </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final cumulative point offset. </dd></dl>

</div>
</div>
<a id="ae7b556e743b5d3b8b336c75252264d96" name="ae7b556e743b5d3b8b336c75252264d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b556e743b5d3b8b336c75252264d96">&#9670;&#160;</a></span>pointSample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT, typename SourceGridT, typename FilterT = NullFilter, typename InterrupterT = util::NullInterrupter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pointSample </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>targetAttribute</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs closest point sampling from a VDB grid onto a VDB Points attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> whose points will be sampled on to </td></tr>
    <tr><td class="paramname">sourceGrid</td><td>VDB grid which will be sampled </td></tr>
    <tr><td class="paramname">targetAttribute</td><td>a target attribute on the points which will hold samples. This attribute will be created with the source grid type if it does not exist, and with the source grid name if the name is empty </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The target attribute may exist provided it can be cast to the SourceGridT ValueType </dd></dl>

</div>
</div>
<a id="ad7557b731e5392e4448f933a84139950" name="ad7557b731e5392e4448f933a84139950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7557b731e5392e4448f933a84139950">&#9670;&#160;</a></span>populateAttribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT, typename PointIndexTreeT, typename PointArrayT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void populateAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointIndexTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>pointIndexTree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">openvdb::Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>attributeName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointArrayT &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>stride</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>insertMetadata</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores point attribute data in an existing <code><a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a></code> attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> to be populated. </td></tr>
    <tr><td class="paramname">pointIndexTree</td><td>a PointIndexTree into the points. </td></tr>
    <tr><td class="paramname">attributeName</td><td>the name of the VDB Points attribute to be populated. </td></tr>
    <tr><td class="paramname">data</td><td>a wrapper to the attribute data. </td></tr>
    <tr><td class="paramname">stride</td><td>the stride of the attribute </td></tr>
    <tr><td class="paramname">insertMetadata</td><td>true if strings are to be automatically inserted as metadata.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A <code>PointIndexGrid</code> to the points must be supplied to perform this operation. This is required to ensure the same point index ordering. </dd></dl>

</div>
</div>
<a id="a2205d8c5a7c5fd2e24145a9df5ad6485" name="a2205d8c5a7c5fd2e24145a9df5ad6485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2205d8c5a7c5fd2e24145a9df5ad6485">&#9670;&#160;</a></span>prefetch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void prefetch </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>position</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>otherAttributes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sequentially pre-fetch all delayed-load voxel and attribute data from disk in order to accelerate subsequent random access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a>. </td></tr>
    <tr><td class="paramname">position</td><td>if enabled, prefetch the position attribute (default is on) </td></tr>
    <tr><td class="paramname">otherAttributes</td><td>if enabled, prefetch all other attributes (default is on) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad694b6c2cdbcd760f327fe3fb36ae936" name="ad694b6c2cdbcd760f327fe3fb36ae936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad694b6c2cdbcd760f327fe3fb36ae936">&#9670;&#160;</a></span>quadraticSample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT, typename SourceGridT, typename FilterT = NullFilter, typename InterrupterT = util::NullInterrupter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void quadraticSample </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>targetAttribute</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs tri-quadratic sampling from a VDB grid onto a VDB Points attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> whose points will be sampled on to </td></tr>
    <tr><td class="paramname">sourceGrid</td><td>VDB grid which will be sampled </td></tr>
    <tr><td class="paramname">targetAttribute</td><td>a target attribute on the points which will hold samples. This attribute will be created with the source grid type if it does not exist, and with the source grid name if the name is empty </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The target attribute may exist provided it can be cast to the SourceGridT ValueType </dd></dl>

</div>
</div>
<a id="ad9cf203d8735a1fe1174de1810104833" name="ad9cf203d8735a1fe1174de1810104833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cf203d8735a1fe1174de1810104833">&#9670;&#160;</a></span>rasterize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeOrGridT, typename TransferT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rasterize </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeOrGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransferT &amp;</td>          <td class="paramname"><span class="paramname"><em>transfer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform potentially complex rasterization from a user defined transfer scheme. See below comments for the transfer scheme API. </p>
<p>The method works by looping over a single Tree topology, looking up point data at a position relative to that topology and passing that data to a transfer scheme TransferT. </p><dl class="section note"><dt>Note</dt><dd>Each thread receives a copy of the transfer scheme object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point data grid or tree to rasterize </td></tr>
    <tr><td class="paramname">transfer</td><td>the transfer scheme </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c7a41f2a2676f4525b8584962c78098" name="a7c7a41f2a2676f4525b8584962c78098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7a41f2a2676f4525b8584962c78098">&#9670;&#160;</a></span>rasterizeSdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT, typename SdfT = typename PointDataGridT::template ValueConverter&lt;float&gt;::Type, typename SettingsT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a0c9703e6ff5cc9deb6410c53412c22c3">GridPtrVec</a> rasterizeSdf </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SettingsT &amp;</td>          <td class="paramname"><span class="paramname"><em>settings</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform point rasterzation to produce a signed distance field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point data grid to rasterize </td></tr>
    <tr><td class="paramname">settings</td><td>one of the available transfer setting schemes found below in this file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of grids. The signed distance field is guaranteed to be first and at the type specified by SdfT. Successive grids are the closest point attribute grids. These grids are guaranteed to have a topology and transform equal to the surface.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="#acf438a63a8a41ec38b6d7ceae6467678">points::PointDataGrid</a> g = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// default settings for sphere stamping with a world space radius of 1</span></div>
<div class="line"><a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1points_1_1SphereSettings.html">SphereSettings&lt;&gt;</a> spheres;</div>
<div class="line"><a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">FloatGrid::Ptr</a> sdf = <a class="code hl_function" href="namespaceopenvdb_1_1v13__0.html#aef5b211479d3ffb3a0bcd4fc8e010ee3">StaticPtrCast&lt;FloatGrid&gt;</a>(<a class="code hl_function" href="#a7c7a41f2a2676f4525b8584962c78098">points::rasterizeSdf</a>(g, spheres)[0]);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// custom linear transform of target sdf, world space radius of 5</span></div>
<div class="line">spheres.<a class="code hl_variable" href="structopenvdb_1_1v13__0_1_1points_1_1SphereSettings.html#a43cb5ef9753b2669cef52ac1edfaae99">transform</a> = <a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html#ae35abe5d5592d24a97725f90eb3ce3f1">math::Transform::createLinearTransform</a>(0.3);</div>
<div class="line">spheres.<a class="code hl_variable" href="structopenvdb_1_1v13__0_1_1points_1_1SphereSettings.html#a8068379784b96ffd344ac5da580a11ba">radiusScale</a> = 5;</div>
<div class="line"><a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">FloatGrid::Ptr</a> sdf = <a class="code hl_function" href="namespaceopenvdb_1_1v13__0.html#aef5b211479d3ffb3a0bcd4fc8e010ee3">StaticPtrCast&lt;FloatGrid&gt;</a>(<a class="code hl_function" href="#a7c7a41f2a2676f4525b8584962c78098">points::rasterizeSdf</a>(g, spheres)[0]);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// smooth sphere rasterization with variable double precision radius</span></div>
<div class="line"><span class="comment">// attribute &quot;pscale&quot; scaled by 2</span></div>
<div class="line"><a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1points_1_1SmoothSphereSettings.html">SmoothSphereSettings&lt;TypeList&lt;&gt;</a>, <span class="keywordtype">double</span>&gt; smooth;</div>
<div class="line">smooth.<a class="code hl_variable" href="structopenvdb_1_1v13__0_1_1points_1_1SmoothSphereSettings.html#ae000837070c3f223000ee300b37cc0d2">radius</a> = <span class="stringliteral">&quot;pscale&quot;</span>;</div>
<div class="line">smooth.<a class="code hl_variable" href="structopenvdb_1_1v13__0_1_1points_1_1SmoothSphereSettings.html#a8068379784b96ffd344ac5da580a11ba">radiusScale</a> = 2;</div>
<div class="line">smooth.<a class="code hl_variable" href="structopenvdb_1_1v13__0_1_1points_1_1SmoothSphereSettings.html#ab4c8838d583855468e9a1652cb99b991">searchRadius</a> = 3;</div>
<div class="line"><a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">FloatGrid::Ptr</a> sdf = <a class="code hl_function" href="namespaceopenvdb_1_1v13__0.html#aef5b211479d3ffb3a0bcd4fc8e010ee3">StaticPtrCast&lt;FloatGrid&gt;</a>(<a class="code hl_function" href="#a7c7a41f2a2676f4525b8584962c78098">points::rasterizeSdf</a>(g, smooth)[0]);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// anisotropic/ellipsoid rasterization with attribute transferring.</span></div>
<div class="line"><span class="comment">// requires pca attributes to be initialized using points::pca() first</span></div>
<div class="line"><a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1points_1_1PcaSettings.html">PcaSettings</a> settings;</div>
<div class="line"><a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1points_1_1PcaAttributes.html">PcaAttributes</a> attribs;</div>
<div class="line"><a class="code hl_function" href="#a74fa733452dea2d0ee1d99c9583fd30d">points::pca</a>(g, settings, attribs);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings.html">EllipsoidSettings&lt;TypeList&lt;int32_t, Vec3f&gt;</a>&gt; ellips;</div>
<div class="line">ellips.<a class="code hl_variable" href="structopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings.html#ae62fd2810b9160873f27e3a452b705f1">xform</a> = attribs.<a class="code hl_variable" href="structopenvdb_1_1v13__0_1_1points_1_1PcaAttributes.html#ae62fd2810b9160873f27e3a452b705f1">xform</a>;</div>
<div class="line">ellips.<a class="code hl_variable" href="structopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings.html#ae000837070c3f223000ee300b37cc0d2">radius</a> = attribs.<a class="code hl_variable" href="structopenvdb_1_1v13__0_1_1points_1_1PcaAttributes.html#a713f968f2be98263546ec2b16f184f78">stretch</a>;</div>
<div class="line">ellips.<a class="code hl_variable" href="structopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings.html#a17352329b20b1bd35910df60545bc9d2">attributes</a>.emplace_back(<span class="stringliteral">&quot;id&quot;</span>);</div>
<div class="line">ellips.<a class="code hl_variable" href="structopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings.html#a17352329b20b1bd35910df60545bc9d2">attributes</a>.emplace_back(<span class="stringliteral">&quot;v&quot;</span>);</div>
<div class="line"><a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0.html#a0c9703e6ff5cc9deb6410c53412c22c3">GridPtrVec</a> grids = <a class="code hl_function" href="#a7c7a41f2a2676f4525b8584962c78098">points::rasterizeSdf</a>(g, ellips);</div>
<div class="line"><a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">FloatGrid::Ptr</a> sdf = <a class="code hl_function" href="namespaceopenvdb_1_1v13__0.html#aef5b211479d3ffb3a0bcd4fc8e010ee3">StaticPtrCast&lt;FloatGrid&gt;</a>(grids[0]);</div>
<div class="line"><a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">Int32Grid::Ptr</a> <span class="keywordtype">id</span>  = <a class="code hl_function" href="namespaceopenvdb_1_1v13__0.html#aef5b211479d3ffb3a0bcd4fc8e010ee3">StaticPtrCast&lt;Int32Grid&gt;</a>(grids[1]);</div>
<div class="line"><a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">Vec3fGrid::Ptr</a> vel = <a class="code hl_function" href="namespaceopenvdb_1_1v13__0.html#aef5b211479d3ffb3a0bcd4fc8e010ee3">StaticPtrCast&lt;Vec3fGrid&gt;</a>(grids[2]);</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1Grid_html_afc0f397bf0d1638f08250c19bc02d39e"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::v13_0::Grid&lt; FloatTree &gt;::Ptr</a></div><div class="ttdeci">SharedPtr&lt; Grid &gt; Ptr</div><div class="ttdef"><b>Definition</b> Grid.h:573</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1Transform_html_ae35abe5d5592d24a97725f90eb3ce3f1"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html#ae35abe5d5592d24a97725f90eb3ce3f1">openvdb::v13_0::math::Transform::createLinearTransform</a></div><div class="ttdeci">static Transform::Ptr createLinearTransform(double voxelSize=1.0)</div><div class="ttdoc">Create and return a shared pointer to a new transform.</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1points_html_a74fa733452dea2d0ee1d99c9583fd30d"><div class="ttname"><a href="#a74fa733452dea2d0ee1d99c9583fd30d">openvdb::v13_0::points::pca</a></div><div class="ttdeci">void pca(PointDataGridT &amp;points, const PcaSettings &amp;settings, const PcaAttributes &amp;attrs)</div><div class="ttdoc">Calculate ellipsoid transformations from the local point distributions as described in Yu and Turk&#39;s ...</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1points_html_a7c7a41f2a2676f4525b8584962c78098"><div class="ttname"><a href="#a7c7a41f2a2676f4525b8584962c78098">openvdb::v13_0::points::rasterizeSdf</a></div><div class="ttdeci">GridPtrVec rasterizeSdf(const PointDataGridT &amp;points, const SettingsT &amp;settings)</div><div class="ttdoc">Perform point rasterzation to produce a signed distance field.</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1points_html_acf438a63a8a41ec38b6d7ceae6467678"><div class="ttname"><a href="#acf438a63a8a41ec38b6d7ceae6467678">openvdb::v13_0::points::PointDataGrid</a></div><div class="ttdeci">Grid&lt; PointDataTree &gt; PointDataGrid</div><div class="ttdoc">Point data grid.</div><div class="ttdef"><b>Definition</b> PointDataGrid.h:195</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_html_a0c9703e6ff5cc9deb6410c53412c22c3"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0.html#a0c9703e6ff5cc9deb6410c53412c22c3">openvdb::v13_0::GridPtrVec</a></div><div class="ttdeci">std::vector&lt; GridBase::Ptr &gt; GridPtrVec</div><div class="ttdef"><b>Definition</b> Grid.h:508</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_html_aef5b211479d3ffb3a0bcd4fc8e010ee3"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0.html#aef5b211479d3ffb3a0bcd4fc8e010ee3">openvdb::v13_0::StaticPtrCast</a></div><div class="ttdeci">SharedPtr&lt; T &gt; StaticPtrCast(const SharedPtr&lt; U &gt; &amp;ptr)</div><div class="ttdoc">Return a new shared pointer that points to the same object as the given pointer after a static_cast.</div><div class="ttdef"><b>Definition</b> Types.h:127</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings_html"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings.html">openvdb::v13_0::points::EllipsoidSettings</a></div><div class="ttdoc">Anisotropic point rasterization based on the principal component analysis of point neighbours....</div><div class="ttdef"><b>Definition</b> PointRasterizeSDF.h:291</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings_html_a17352329b20b1bd35910df60545bc9d2"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings.html#a17352329b20b1bd35910df60545bc9d2">openvdb::v13_0::points::EllipsoidSettings::attributes</a></div><div class="ttdeci">std::vector&lt; std::string &gt; attributes</div><div class="ttdef"><b>Definition</b> PointRasterizeSDF.h:217</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings_html_ae000837070c3f223000ee300b37cc0d2"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings.html#ae000837070c3f223000ee300b37cc0d2">openvdb::v13_0::points::EllipsoidSettings::radius</a></div><div class="ttdeci">std::string radius</div><div class="ttdef"><b>Definition</b> PointRasterizeSDF.h:170</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings_html_ae62fd2810b9160873f27e3a452b705f1"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1EllipsoidSettings.html#ae62fd2810b9160873f27e3a452b705f1">openvdb::v13_0::points::EllipsoidSettings::xform</a></div><div class="ttdeci">std::string xform</div><div class="ttdef"><b>Definition</b> PointRasterizeSDF.h:315</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1PcaAttributes_html"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1PcaAttributes.html">openvdb::v13_0::points::PcaAttributes</a></div><div class="ttdoc">The persistent attributes created by the PCA methods.</div><div class="ttdef"><b>Definition</b> PrincipalComponentAnalysis.h:164</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1PcaAttributes_html_a713f968f2be98263546ec2b16f184f78"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1PcaAttributes.html#a713f968f2be98263546ec2b16f184f78">openvdb::v13_0::points::PcaAttributes::stretch</a></div><div class="ttdeci">std::string stretch</div><div class="ttdef"><b>Definition</b> PrincipalComponentAnalysis.h:190</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1PcaAttributes_html_ae62fd2810b9160873f27e3a452b705f1"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1PcaAttributes.html#ae62fd2810b9160873f27e3a452b705f1">openvdb::v13_0::points::PcaAttributes::xform</a></div><div class="ttdeci">std::string xform</div><div class="ttdef"><b>Definition</b> PrincipalComponentAnalysis.h:197</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1PcaSettings_html"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1PcaSettings.html">openvdb::v13_0::points::PcaSettings</a></div><div class="ttdoc">Various settings for the neighborhood analysis of point distributions.</div><div class="ttdef"><b>Definition</b> PrincipalComponentAnalysis.h:67</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1SmoothSphereSettings_html"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1SmoothSphereSettings.html">openvdb::v13_0::points::SmoothSphereSettings</a></div><div class="ttdoc">Smoothed point distribution based sphere stamping with a uniform radius or varying radius and optiona...</div><div class="ttdef"><b>Definition</b> PointRasterizeSDF.h:238</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1SmoothSphereSettings_html_a8068379784b96ffd344ac5da580a11ba"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1SmoothSphereSettings.html#a8068379784b96ffd344ac5da580a11ba">openvdb::v13_0::points::SmoothSphereSettings::radiusScale</a></div><div class="ttdeci">RadiusScaleT radiusScale</div><div class="ttdef"><b>Definition</b> PointRasterizeSDF.h:181</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1SmoothSphereSettings_html_ab4c8838d583855468e9a1652cb99b991"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1SmoothSphereSettings.html#ab4c8838d583855468e9a1652cb99b991">openvdb::v13_0::points::SmoothSphereSettings::searchRadius</a></div><div class="ttdeci">Real searchRadius</div><div class="ttdef"><b>Definition</b> PointRasterizeSDF.h:267</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1SmoothSphereSettings_html_ae000837070c3f223000ee300b37cc0d2"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1SmoothSphereSettings.html#ae000837070c3f223000ee300b37cc0d2">openvdb::v13_0::points::SmoothSphereSettings::radius</a></div><div class="ttdeci">std::string radius</div><div class="ttdef"><b>Definition</b> PointRasterizeSDF.h:170</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1SphereSettings_html"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1SphereSettings.html">openvdb::v13_0::points::SphereSettings</a></div><div class="ttdoc">Generic settings for narrow band spherical stamping with a uniform or varying radius and optionally w...</div><div class="ttdef"><b>Definition</b> PointRasterizeSDF.h:158</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1SphereSettings_html_a43cb5ef9753b2669cef52ac1edfaae99"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1SphereSettings.html#a43cb5ef9753b2669cef52ac1edfaae99">openvdb::v13_0::points::SphereSettings::transform</a></div><div class="ttdeci">math::Transform::Ptr transform</div><div class="ttdef"><b>Definition</b> PointRasterizeSDF.h:188</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1points_1_1SphereSettings_html_a8068379784b96ffd344ac5da580a11ba"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1points_1_1SphereSettings.html#a8068379784b96ffd344ac5da580a11ba">openvdb::v13_0::points::SphereSettings::radiusScale</a></div><div class="ttdeci">RadiusScaleT radiusScale</div><div class="ttdef"><b>Definition</b> PointRasterizeSDF.h:181</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a43f917f566a11a07b496f369adc7d6a4" name="a43f917f566a11a07b496f369adc7d6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f917f566a11a07b496f369adc7d6a4">&#9670;&#160;</a></span>rasterizeTrilinear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Staggered, typename ValueT, typename FilterT = NullFilter, typename PointDataTreeT = PointDataTree&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto rasterizeTrilinear </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform weighted trilinear rasterization of all points within a voxel. This method takes and returns a tree i.e. ignores grid transformations. </p>
<p>Accumulates values and weights according to a simple 0-1-0 weighted hat function. This algorithm is an exact inverse of a trilinear interpolation and thus a key method used in PIC/FLIP style simulations. Returns a tree of the same precision as the input source attribute, but may be of a different math type depending on the value of the Staggered template attribute. If Staggered is true, this method produces values at each voxels negative faces, causing scalar attributes to produce <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3&lt;ValueT&gt;</a> tree types. The result Tree type is equal to: TrilinearTraits&lt;ValueT, Staggered&gt;::template TreeT&lt;PointDataTreeT&gt; </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Staggered</td><td>whether to perform a staggered or collocated rasterization </td></tr>
    <tr><td class="paramname">ValueT</td><td>the value type of the point attribute to rasterize </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the point tree to be rasterized </td></tr>
    <tr><td class="paramname">attribute</td><td>the name of the attribute to rasterize. Must be a scalar or Vec3 attribute. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional point filter to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb60e92fdbb25ad5822945cc30b3e8b2" name="aeb60e92fdbb25ad5822945cc30b3e8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb60e92fdbb25ad5822945cc30b3e8b2">&#9670;&#160;</a></span>renameAttribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void renameAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>oldName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>newName</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename an attribute in a VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a>. </td></tr>
    <tr><td class="paramname">oldName</td><td>the old attribute name to rename from. </td></tr>
    <tr><td class="paramname">newName</td><td>the new attribute name to rename to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>newName must not already exist and must not be a group attribute. </dd></dl>

</div>
</div>
<a id="aceb82e6282deeaa12012efbe386ce564" name="aceb82e6282deeaa12012efbe386ce564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb82e6282deeaa12012efbe386ce564">&#9670;&#160;</a></span>renameAttributes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void renameAttributes </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>oldNames</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>newNames</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename attributes in a VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a>. </td></tr>
    <tr><td class="paramname">oldNames</td><td>a list of old attribute names to rename from. </td></tr>
    <tr><td class="paramname">newNames</td><td>a list of new attribute names to rename to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Number of oldNames must match the number of newNames.</dd>
<dd>
Duplicate names and renaming group attributes are not allowed. </dd></dl>

</div>
</div>
<a id="a8631d1e7a9cecd8986fe740f4d64e688" name="a8631d1e7a9cecd8986fe740f4d64e688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8631d1e7a9cecd8986fe740f4d64e688">&#9670;&#160;</a></span>replicate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr replicate </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>multiplier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>scaleAttribute</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>replicationIndex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replicates points provided in a source grid into a new grid, transfering and creating all attributes from the source grid. Position is always replicated, leaving the new points exactly over the top of the source points. </p>
<dl class="section note"><dt>Note</dt><dd>The position attribute must exist </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source grid to replicate points from </td></tr>
    <tr><td class="paramname">multiplier</td><td>The base number of points to replicate per point </td></tr>
    <tr><td class="paramname">scaleAttribute</td><td>A scale float attribute which multiplies the base multiplier to vary the point count per point. </td></tr>
    <tr><td class="paramname">replicationIndex</td><td>When provided, creates a replication attribute of the given name which holds the replication index. This can be subsequently used to modify the replicated points as a post process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c7a04c3490272095b334a6859f9a0fb" name="a0c7a04c3490272095b334a6859f9a0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7a04c3490272095b334a6859f9a0fb">&#9670;&#160;</a></span>replicate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr replicate </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>multiplier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>attributes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>scaleAttribute</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>replicationIndex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replicates points provided in a source grid into a new grid, transfering and creating attributes found in a provided attribute vector. If an attribute doesn't exist, it is ignored. Position is always replicated, leaving the new points exactly over the top of the source points. </p>
<dl class="section note"><dt>Note</dt><dd>The position attribute must exist </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source grid to replicate points from </td></tr>
    <tr><td class="paramname">multiplier</td><td>The base number of points to replicate per point </td></tr>
    <tr><td class="paramname">attributes</td><td>Attributes to transfer to the new grid </td></tr>
    <tr><td class="paramname">scaleAttribute</td><td>A scale float attribute which multiplies the base multiplier to vary the point count per point. </td></tr>
    <tr><td class="paramname">replicationIndex</td><td>When provided, creates a replication attribute of the given name which holds the replication index. This can be subsequently used to modify the replicated points as a post process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ff8951f375ddac4b685e72f486489d3" name="a5ff8951f375ddac4b685e72f486489d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff8951f375ddac4b685e72f486489d3">&#9670;&#160;</a></span>sampleGrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataGridT, typename SourceGridT, typename TargetValueT = DummySampleType, typename SamplerT = SampleWithRounding, typename FilterT = NullFilter, typename InterrupterT = util::NullInterrupter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sampleGrid </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointDataGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>sourceGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>targetAttribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1NullFilter.html">NullFilter</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SamplerT &amp;</td>          <td class="paramname"><span class="paramname"><em>sampler</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1SampleWithRounding.html">SampleWithRounding</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs sampling and conversion from a VDB grid onto a VDB Points attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the sampling order - 0 = closest-point, 1 = trilinear, 2 = triquadratic </td></tr>
    <tr><td class="paramname">points</td><td>the <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> whose points will be sampled on to </td></tr>
    <tr><td class="paramname">sourceGrid</td><td>VDB grid which will be sampled </td></tr>
    <tr><td class="paramname">targetAttribute</td><td>a target attribute on the points which will hold samples. This attribute will be created with the source grid type if it does not exist, and with the source grid name if the name is empty </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">sampler</td><td>handles sampling and conversion into the target attribute type, which by default this uses the <a class="el" href="structopenvdb_1_1v13__0_1_1points_1_1SampleWithRounding.html">SampleWithRounding</a> struct. </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The target attribute may exist provided it can be cast to the SourceGridT ValueType </dd></dl>

</div>
</div>
<a id="a522af44dcf8da3f9e6c7b747e075f155" name="a522af44dcf8da3f9e6c7b747e075f155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522af44dcf8da3f9e6c7b747e075f155">&#9670;&#160;</a></span>setGroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>member</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets membership for the specified group for all points (on/off). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a>. </td></tr>
    <tr><td class="paramname">group</td><td>the name of the group. </td></tr>
    <tr><td class="paramname">member</td><td>true / false for membership of the group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1866ee320dd051901bb7f4f49e155cee" name="a1866ee320dd051901bb7f4f49e155cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1866ee320dd051901bb7f4f49e155cee">&#9670;&#160;</a></span>setGroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT, typename PointIndexTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointIndexTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>indexTree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; short &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>membership</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>remove</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets group membership from a PointIndexTree-ordered vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a>. </td></tr>
    <tr><td class="paramname">indexTree</td><td>the PointIndexTree. </td></tr>
    <tr><td class="paramname">membership</td><td><code>1</code> if the point is in the group, 0 otherwise. </td></tr>
    <tr><td class="paramname">group</td><td>the name of the group. </td></tr>
    <tr><td class="paramname">remove</td><td>if <code>true</code> also perform removal of points from the group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>vector&lt;bool&gt; is not thread-safe on concurrent write, so use vector&lt;short&gt; instead </dd></dl>

</div>
</div>
<a id="ab5ce5ef333b529b92e4acb1bddeec93c" name="ab5ce5ef333b529b92e4acb1bddeec93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ce5ef333b529b92e4acb1bddeec93c">&#9670;&#160;</a></span>setGroupByFilter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT, typename FilterT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setGroupByFilter </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets group membership based on a provided filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a>. </td></tr>
    <tr><td class="paramname">group</td><td>the name of the group. </td></tr>
    <tr><td class="paramname">filter</td><td>filter data that is used to create a per-leaf filter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d85a4b1b93c26f69ecf71e75017275b" name="a0d85a4b1b93c26f69ecf71e75017275b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d85a4b1b93c26f69ecf71e75017275b">&#9670;&#160;</a></span>setStreamingMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointDataTreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setStreamingMode </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>on</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle the streaming mode on all attributes in the tree to collapse the attributes after deconstructing a bound <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeHandle.html">AttributeHandle</a> to each array. This results in better memory efficiency when the data is streamed into another data structure (typically for rendering). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the <a class="el" href="#a7fa856a8e82a8ff9db585d9429d2c5df" title="Point index tree configured to match the default VDB configurations.">PointDataTree</a>. </td></tr>
    <tr><td class="paramname">on</td><td><code>true</code> to enable streaming</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Multiple threads cannot safely access the same <a class="el" href="classopenvdb_1_1v13__0_1_1points_1_1AttributeArray.html" title="Base class for storing attribute data.">AttributeArray</a> when using streaming. </dd></dl>

</div>
</div>
<a id="abc4c70eaf37048c67356fd7189b15d95" name="abc4c70eaf37048c67356fd7189b15d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4c70eaf37048c67356fd7189b15d95">&#9670;&#160;</a></span>uniformPointScatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename RandGenT = std::mt19937, typename PositionArrayT = TypedAttributeArray&lt;Vec3f, NullCodec&gt;, typename PointDataGridT = Grid&lt;        typename points::TreeConverter&lt;typename GridT::TreeType&gt;::Type&gt;, typename InterrupterT = util::NullInterrupter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr uniformPointScatter </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float</td>          <td class="paramname"><span class="paramname"><em>spread</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The free functions depend on the following class: </p>
<p>The <code>InterrupterT</code> template argument below refers to any class with the following interface: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>Interrupter {</div>
<div class="line">   ...</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">   <span class="keywordtype">void</span> start(<span class="keyword">const</span> <span class="keywordtype">char</span>* name = <span class="keyword">nullptr</span>) <span class="comment">// called when computations begin</span></div>
<div class="line">   void end()                             <span class="comment">// called when computations end</span></div>
<div class="line">   <span class="keywordtype">bool</span> wasInterrupted(<span class="keywordtype">int</span> percent=-1)    <span class="comment">// return true to break computation</span></div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If no template argument is provided for this InterrupterT the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> is used which implies that all interrupter calls are no-ops (i.e. incurs no computational overhead).</dd></dl>
<p>Uniformly scatter a total amount of points in active regions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>A source grid. The resulting <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> will copy this grids transform and scatter in its active voxelized topology. </td></tr>
    <tr><td class="paramname">count</td><td>The total number of points to scatter </td></tr>
    <tr><td class="paramname">seed</td><td>A seed for the RandGenT </td></tr>
    <tr><td class="paramname">spread</td><td>The spread of points as a scale from each voxels center. A value of 1.0f indicates points can be placed anywhere within the voxel, where as a value of 0.0f will force all points to be created exactly at the centers of each voxel. </td></tr>
    <tr><td class="paramname">interrupter</td><td>An optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns the scattered <a class="el" href="#acf438a63a8a41ec38b6d7ceae6467678" title="Point data grid.">PointDataGrid</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1points.html">points</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
