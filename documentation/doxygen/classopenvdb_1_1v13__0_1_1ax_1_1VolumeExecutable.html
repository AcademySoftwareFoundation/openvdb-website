<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: VolumeExecutable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable.html','','classopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">VolumeExecutable Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Object that encapsulates compiled AX code which can be executed on a collection of VDB volume grids. Executables are created by the compiler and hold the final immutable JIT compiled function and context.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VolumeExecutable_8h_source.html">openvdb_ax/compiler/VolumeExecutable.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:CLI" id="r_CLI"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable_1_1CLI.html">CLI</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command Line Interface handling for the <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable.html" title="Object that encapsulates compiled AX code which can be executed on a collection of VDB volume grids....">VolumeExecutable</a>.  <a href="structopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable_1_1CLI.html#details">More...</a><br /></td></tr>
<tr class="memitem:Settings" id="r_Settings"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable_1_1Settings.html">Settings</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ade0a25d0d6ba0e0a4d939aedcbb8fae0" id="r_ade0a25d0d6ba0e0a4d939aedcbb8fae0"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a> { <a class="el" href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0a90651ebea9a35ec4e018c8157492e17c">ON</a>
, <a class="el" href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0a88559a0cfd8250c9d65970cc145c92d4">OFF</a>
, <a class="el" href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0ae1f2d5134ed2543d38a0de9751cf75d9">AUTO</a>
 }</td></tr>
<tr class="memdesc:ade0a25d0d6ba0e0a4d939aedcbb8fae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The streaming type of active tiles during execution.  <a href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0">More...</a><br /></td></tr>
<tr class="memitem:af607f22e4873b3369e942d9ebb3e72b1" id="r_af607f22e4873b3369e942d9ebb3e72b1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af607f22e4873b3369e942d9ebb3e72b1">IterType</a> { <a class="el" href="#af607f22e4873b3369e942d9ebb3e72b1a90651ebea9a35ec4e018c8157492e17c">ON</a>
, <a class="el" href="#af607f22e4873b3369e942d9ebb3e72b1a88559a0cfd8250c9d65970cc145c92d4">OFF</a>
, <a class="el" href="#af607f22e4873b3369e942d9ebb3e72b1a5fb1f955b45e38e31789286a1790398d">ALL</a>
 }</td></tr>
<tr class="memitem:a81b90227a9ef31b90a812f9f751cda33" id="r_a81b90227a9ef31b90a812f9f751cda33"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81b90227a9ef31b90a812f9f751cda33">Ptr</a> = std::shared_ptr&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a>&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad814a17f6ae499ae481cd4593c5f4533" id="r_ad814a17f6ae499ae481cd4593c5f4533"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad814a17f6ae499ae481cd4593c5f4533">~VolumeExecutable</a> ()</td></tr>
<tr class="memitem:afecf152485d4534c5386e7244d15930b" id="r_afecf152485d4534c5386e7244d15930b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afecf152485d4534c5386e7244d15930b">VolumeExecutable</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a> &amp;other)</td></tr>
<tr class="memdesc:afecf152485d4534c5386e7244d15930b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Shares the LLVM constructs but deep copies the settings. Multiple copies of an executor can be used at the same time safely.  <br /></td></tr>
<tr class="memitem:a1ca28d3bd69799bef5435081d8ca285c" id="r_a1ca28d3bd69799bef5435081d8ca285c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ca28d3bd69799bef5435081d8ca285c">setCreateMissing</a> (const bool flag)</td></tr>
<tr class="memdesc:a1ca28d3bd69799bef5435081d8ca285c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the behaviour when missing grids are accessed. Default behaviour is true, which creates them with default transforms and background values.  <br /></td></tr>
<tr class="memitem:adef286c6a39859d3e27d182f85f91460" id="r_adef286c6a39859d3e27d182f85f91460"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adef286c6a39859d3e27d182f85f91460">getCreateMissing</a> () const</td></tr>
<tr class="memitem:aa585cfdd56bad735e5b95b165862b223" id="r_aa585cfdd56bad735e5b95b165862b223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa585cfdd56bad735e5b95b165862b223">setTreeExecutionLevel</a> (const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> min, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> max)</td></tr>
<tr class="memdesc:aa585cfdd56bad735e5b95b165862b223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the execution level for this executable. This controls what nodes are processed when execute is called. Possible values depend on the OpenVDB configuration in use, however a value of 0 will always correspond to the lowest level (leaf-level). By default, the min level is zero (LeafNodeType::LEVEL) and the max level is the root node's level (RootNodeType::LEVEL). In other words, the default execution level settings process the whole of the tree.  <br /></td></tr>
<tr class="memitem:aeeba4e1c6cedbfda3fb609f8a9817ffe" id="r_aeeba4e1c6cedbfda3fb609f8a9817ffe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeeba4e1c6cedbfda3fb609f8a9817ffe">setTreeExecutionLevel</a> (const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> level)</td></tr>
<tr class="memitem:a7188ef4811a0a0feecb0687def1099ae" id="r_a7188ef4811a0a0feecb0687def1099ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7188ef4811a0a0feecb0687def1099ae">getTreeExecutionLevel</a> (<a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &amp;min, <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &amp;max) const</td></tr>
<tr class="memdesc:a7188ef4811a0a0feecb0687def1099ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tree execution levels.  <br /></td></tr>
<tr class="memitem:a8e14a8daa02c1cd03f4718f58f378adb" id="r_a8e14a8daa02c1cd03f4718f58f378adb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e14a8daa02c1cd03f4718f58f378adb">setActiveTileStreaming</a> (const <a class="el" href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a> &amp;s)</td></tr>
<tr class="memdesc:a8e14a8daa02c1cd03f4718f58f378adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the behaviour of expansion of active tiles.  <br /></td></tr>
<tr class="memitem:a7816f72b5227861fcdd9254642d36b57" id="r_a7816f72b5227861fcdd9254642d36b57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7816f72b5227861fcdd9254642d36b57">getActiveTileStreaming</a> () const</td></tr>
<tr class="memitem:a9c3f5a2eefd7a7df23081c4a3f25f355" id="r_a9c3f5a2eefd7a7df23081c4a3f25f355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c3f5a2eefd7a7df23081c4a3f25f355">getActiveTileStreaming</a> (const std::string &amp;name, const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a> &amp;type) const</td></tr>
<tr class="memitem:a89b2029c94153119e4d28d21126e597c" id="r_a89b2029c94153119e4d28d21126e597c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89b2029c94153119e4d28d21126e597c">setValueIterator</a> (const <a class="el" href="#af607f22e4873b3369e942d9ebb3e72b1">IterType</a> &amp;iter)</td></tr>
<tr class="memdesc:a89b2029c94153119e4d28d21126e597c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value iterator type to use with this executable. Options are ON, OFF, ALL. Default is ON.  <br /></td></tr>
<tr class="memitem:a7e152ea2ce683b6df8b1ab90402a409a" id="r_a7e152ea2ce683b6df8b1ab90402a409a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af607f22e4873b3369e942d9ebb3e72b1">IterType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e152ea2ce683b6df8b1ab90402a409a">getValueIterator</a> () const</td></tr>
<tr class="memitem:afd4fde77c8d382cfa72bf9a0622222c5" id="r_afd4fde77c8d382cfa72bf9a0622222c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd4fde77c8d382cfa72bf9a0622222c5">setAttributeBindings</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1AttributeBindings.html">AttributeBindings</a> &amp;bindings)</td></tr>
<tr class="memdesc:afd4fde77c8d382cfa72bf9a0622222c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set attribute bindings.  <br /></td></tr>
<tr class="memitem:a2f426e3a0c85cfe75fcbdb3c949bf1c7" id="r_a2f426e3a0c85cfe75fcbdb3c949bf1c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1AttributeBindings.html">AttributeBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f426e3a0c85cfe75fcbdb3c949bf1c7">getAttributeBindings</a> () const</td></tr>
<tr class="memitem:a2153ec6bf69ce734f8eddcf64c1487e1" id="r_a2153ec6bf69ce734f8eddcf64c1487e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2153ec6bf69ce734f8eddcf64c1487e1">getTreeExecutionLevel</a> () const</td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afa5b1b17f79a43463f5aeeb546913350" id="r_afa5b1b17f79a43463f5aeeb546913350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa5b1b17f79a43463f5aeeb546913350">execute</a> (<a class="el" href="namespaceopenvdb_1_1v13__0.html#a0c9703e6ff5cc9deb6410c53412c22c3">openvdb::GridPtrVec</a> &amp;grids) const</td></tr>
<tr class="memdesc:afa5b1b17f79a43463f5aeeb546913350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run this volume executable binary on target volumes.  <br /></td></tr>
<tr class="memitem:a326b3d09e594df0558a30e4b08458e51" id="r_a326b3d09e594df0558a30e4b08458e51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a326b3d09e594df0558a30e4b08458e51">execute</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1GridBase.html">openvdb::GridBase</a> &amp;grids) const</td></tr>
<tr class="memdesc:a326b3d09e594df0558a30e4b08458e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run this volume executable binary on target volumes.  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8f3948ab8d869447c5f585c45ed2086b" id="r_a8f3948ab8d869447c5f585c45ed2086b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f3948ab8d869447c5f585c45ed2086b">setGrainSize</a> (const size_t g1)</td></tr>
<tr class="memdesc:a8f3948ab8d869447c5f585c45ed2086b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the threading grain sizes used when iterating over nodes in a VDB.  <br /></td></tr>
<tr class="memitem:a12cfbf4433635944ec76268cea607562" id="r_a12cfbf4433635944ec76268cea607562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12cfbf4433635944ec76268cea607562">setActiveTileStreamingGrainSize</a> (const size_t g2)</td></tr>
<tr class="memdesc:a12cfbf4433635944ec76268cea607562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the threading grain sizes used when iterating over nodes in a VDB.  <br /></td></tr>
<tr class="memitem:aa0d4d60c7203c32277a16f97e6b6daf0" id="r_aa0d4d60c7203c32277a16f97e6b6daf0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0d4d60c7203c32277a16f97e6b6daf0">getGrainSize</a> () const</td></tr>
<tr class="memitem:afd55bb4909155856edbfb536ff201591" id="r_afd55bb4909155856edbfb536ff201591"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd55bb4909155856edbfb536ff201591">getActiveTileStreamingGrainSize</a> () const</td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:add86d578eaeb94d2b29abd5ca2c56987" id="r_add86d578eaeb94d2b29abd5ca2c56987"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add86d578eaeb94d2b29abd5ca2c56987">setSettingsFromCLI</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable_1_1CLI.html">CLI</a> &amp;cli)</td></tr>
<tr class="memdesc:add86d578eaeb94d2b29abd5ca2c56987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intialize the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable_1_1Settings.html">Settings</a> of this executables from the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable_1_1CLI.html" title="Command Line Interface handling for the VolumeExecutable.">CLI</a> object.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5f904e96618a83d59208fb22cdf11ff5" id="r_a5f904e96618a83d59208fb22cdf11ff5"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f904e96618a83d59208fb22cdf11ff5">Compiler</a></td></tr>
<tr class="memitem:a05bfde7168d80e33821dfb0a9d85ea09" id="r_a05bfde7168d80e33821dfb0a9d85ea09"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05bfde7168d80e33821dfb0a9d85ea09">::TestVolumeExecutableAcc</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Object that encapsulates compiled AX code which can be executed on a collection of VDB volume grids. Executables are created by the compiler and hold the final immutable JIT compiled function and context. </p>
<p>The <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable.html" title="Object that encapsulates compiled AX code which can be executed on a collection of VDB volume grids....">VolumeExecutable</a> is returned from the <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Compiler.html" title="The compiler class. This holds a set of compiler options and constructs executable objects (e....">ax::Compiler</a> when compiling AX code for volume execution. The class represents a typical AX executable object; immutable except for execution settings and implements 'execute' functions which can be called multiple times for arbitrary sets of inputs. The intended usage of these executables is to configure their runtime arguments and then call <a class="el" href="#afa5b1b17f79a43463f5aeeb546913350" title="Run this volume executable binary on target volumes.">VolumeExecutable::execute</a> with your VDBs. For example: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="#a81b90227a9ef31b90a812f9f751cda33">VolumeExecutable::Ptr</a> exe = compiler.compile&lt;<a class="code hl_function" href="#afecf152485d4534c5386e7244d15930b">VolumeExecutable</a>&gt;(<span class="stringliteral">&quot;@a += 1&quot;</span>);</div>
<div class="line">exe-&gt;setTreeExecutionLevel(0); <span class="comment">// only process leaf nodes</span></div>
<div class="line">exe-&gt;setValueIterator(<a class="code hl_enumvalue" href="#af607f22e4873b3369e942d9ebb3e72b1a5fb1f955b45e38e31789286a1790398d">VolumeExecutable::IterType::ALL</a>); <span class="comment">// process all values</span></div>
<div class="line">exe-&gt;execute(vdbs); <span class="comment">// run on a set of vdbs</span></div>
<div class="line">exe-&gt;execute(grid); <span class="comment">// run on a single vdb</span></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable_html_a81b90227a9ef31b90a812f9f751cda33"><div class="ttname"><a href="#a81b90227a9ef31b90a812f9f751cda33">openvdb::v13_0::ax::VolumeExecutable::Ptr</a></div><div class="ttdeci">std::shared_ptr&lt; VolumeExecutable &gt; Ptr</div><div class="ttdef"><b>Definition</b> VolumeExecutable.h:89</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable_html_af607f22e4873b3369e942d9ebb3e72b1a5fb1f955b45e38e31789286a1790398d"><div class="ttname"><a href="#af607f22e4873b3369e942d9ebb3e72b1a5fb1f955b45e38e31789286a1790398d">openvdb::v13_0::ax::VolumeExecutable::IterType::ALL</a></div><div class="ttdeci">@ ALL</div><div class="ttdef"><b>Definition</b> VolumeExecutable.h:217</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable_html_afecf152485d4534c5386e7244d15930b"><div class="ttname"><a href="#afecf152485d4534c5386e7244d15930b">openvdb::v13_0::ax::VolumeExecutable::VolumeExecutable</a></div><div class="ttdeci">VolumeExecutable(const VolumeExecutable &amp;other)</div><div class="ttdoc">Copy constructor. Shares the LLVM constructs but deep copies the settings. Multiple copies of an exec...</div></div>
</div><!-- fragment --><p>The Volume executable is initialised with specific configurable settings:</p><ul>
<li>Iteration Level: min=0, max=RootNode::Level. By default, processes the entire VDB tree hierarchy. <dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa585cfdd56bad735e5b95b165862b223" title="Set the execution level for this executable. This controls what nodes are processed when execute is c...">setTreeExecutionLevel</a></dd></dl>
</li>
<li>Iteration Type: ON By default, processes ACTIVE values. <dl class="section see"><dt>See also</dt><dd><a class="el" href="#a89b2029c94153119e4d28d21126e597c" title="Set the value iterator type to use with this executable. Options are ON, OFF, ALL....">setValueIterator</a></dd></dl>
</li>
<li>Active Tile <a class="el" href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0" title="The streaming type of active tiles during execution.">Streaming</a>: ON, OFF or AUTO depending on AX code. By default, if AX detects that the AX program may produce unique values for leaf level voxels that would otherwise comprise a given active tile, this setting is set to ON or AUTO. Otherwise it is set to OFF. <dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8e14a8daa02c1cd03f4718f58f378adb" title="Controls the behaviour of expansion of active tiles.">setActiveTileStreaming</a></dd></dl>
</li>
<li>Grain sizes: 1:32 The default grain sizes passed to the tbb partitioner for leaf level processing and active tile processing. <dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8f3948ab8d869447c5f585c45ed2086b" title="Set the threading grain sizes used when iterating over nodes in a VDB.">setGrainSize</a> </dd>
<dd>
<a class="el" href="#a12cfbf4433635944ec76268cea607562" title="Set the threading grain sizes used when iterating over nodes in a VDB.">setActiveTileStreamingGrainSize</a></dd></dl>
</li>
<li><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1AttributeBindings.html" title="This class wraps an interface for a map of attribute bindings. These map attributes in AX code to con...">AttributeBindings</a>: None Whether to indriect any AX accesses to different grid names. <dl class="section see"><dt>See also</dt><dd><a class="el" href="#afd4fde77c8d382cfa72bf9a0622222c5" title="Set attribute bindings.">setAttributeBindings</a></dd></dl>
For more in depth information, see the <a class="el" href="axcplusplus.html#vdbaxcompilerexe">Executables</a> documentation. </li>
</ul>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a81b90227a9ef31b90a812f9f751cda33" name="a81b90227a9ef31b90a812f9f751cda33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b90227a9ef31b90a812f9f751cda33">&#9670;&#160;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a81b90227a9ef31b90a812f9f751cda33">Ptr</a> = std::shared_ptr&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="af607f22e4873b3369e942d9ebb3e72b1" name="af607f22e4873b3369e942d9ebb3e72b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af607f22e4873b3369e942d9ebb3e72b1">&#9670;&#160;</a></span>IterType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#af607f22e4873b3369e942d9ebb3e72b1">IterType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af607f22e4873b3369e942d9ebb3e72b1a90651ebea9a35ec4e018c8157492e17c" name="af607f22e4873b3369e942d9ebb3e72b1a90651ebea9a35ec4e018c8157492e17c"></a>ON&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af607f22e4873b3369e942d9ebb3e72b1a88559a0cfd8250c9d65970cc145c92d4" name="af607f22e4873b3369e942d9ebb3e72b1a88559a0cfd8250c9d65970cc145c92d4"></a>OFF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af607f22e4873b3369e942d9ebb3e72b1a5fb1f955b45e38e31789286a1790398d" name="af607f22e4873b3369e942d9ebb3e72b1a5fb1f955b45e38e31789286a1790398d"></a>ALL&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ade0a25d0d6ba0e0a4d939aedcbb8fae0" name="ade0a25d0d6ba0e0a4d939aedcbb8fae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0">&#9670;&#160;</a></span>Streaming</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The streaming type of active tiles during execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ON</td><td>active tiles are temporarily densified (converted to leaf level voxels) on an "as needed" basis and the subsequent voxel values are processed. The temporarily densified node is added to the tree only if a non constant voxel buffer is produced. Otherwise a child tile may be created or the original tile's value may simply be modified. </td></tr>
    <tr><td class="paramname">OFF</td><td>tile topologies are left unchanged and their single value is processed. </td></tr>
    <tr><td class="paramname">AUTO</td><td>the volume executable analyzes the compiled kernel and attempts to determine if expansion of active tiles would lead to different, non-constant values in the respective voxels. This is done on a per grid basis; ultimately each execution will be set to ON or OFF. This option will always fall back to ON if there is any chance the kernel may produce child nodes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The volume executable always runs an AUTO check on creation and will set itself to ON (if all grids always need child nodes), OFF (if grids never need child nodes) or remains as AUTO (if this depends on which grid is being processed).</dd></dl>
<p>When an AX kernel is run over coarser levels of the tree (i.e. not leaf voxels), it is often desirable to densify these areas into unique voxels such that they can each receive a unique value. For example, consider the following AX code which assigns a vector volume to the world space position of each voxel: </p><div class="fragment"><div class="line">v@v = getvoxelpws();</div>
</div><!-- fragment --><p> Active tiles hold a single value but comprise an area greater than that of a single voxel. As the above kernel varies with respect to a nodes position, we'd need to replace these tiles with leaf voxels to get unique per node values. The stream flag is initialised to ON in this case.</p>
<p>This behaviour, however, is not always desirable .i.e: </p><div class="fragment"><div class="line">v@v = {1,2,3};</div>
</div><!-- fragment --><p> In this instance, all values within a volume receive the same value and are not dependent on any spatially or iteratively varying metrics. The stream flag is set to OFF.</p>
<p>The AUTO flag is set in cases where the runtime access pattern of the inputs determines streaming: </p><div class="fragment"><div class="line">f@density = f@mask;</div>
<div class="line">f@mask = 0;</div>
</div><!-- fragment --><p> In this instance, the runtime topology and values of @mask determines whether child topology needs to be created in @density, but @mask itself does not need streaming. <a class="el" href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0" title="The streaming type of active tiles during execution.">Streaming</a> will be set to ON for density but OFF for mask.</p>
<dl class="section note"><dt>Note</dt><dd>This behaviour is only applied to active tiles. If the value iterator is set to OFF, this option is ignored. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This option can generate large amounts of leaf level voxels. It is recommended to use a good concurrent memory allocator (such as jemalloc) for the best performance. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ade0a25d0d6ba0e0a4d939aedcbb8fae0a90651ebea9a35ec4e018c8157492e17c" name="ade0a25d0d6ba0e0a4d939aedcbb8fae0a90651ebea9a35ec4e018c8157492e17c"></a>ON&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ade0a25d0d6ba0e0a4d939aedcbb8fae0a88559a0cfd8250c9d65970cc145c92d4" name="ade0a25d0d6ba0e0a4d939aedcbb8fae0a88559a0cfd8250c9d65970cc145c92d4"></a>OFF&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ade0a25d0d6ba0e0a4d939aedcbb8fae0ae1f2d5134ed2543d38a0de9751cf75d9" name="ade0a25d0d6ba0e0a4d939aedcbb8fae0ae1f2d5134ed2543d38a0de9751cf75d9"></a>AUTO&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad814a17f6ae499ae481cd4593c5f4533" name="ad814a17f6ae499ae481cd4593c5f4533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad814a17f6ae499ae481cd4593c5f4533">&#9670;&#160;</a></span>~VolumeExecutable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afecf152485d4534c5386e7244d15930b" name="afecf152485d4534c5386e7244d15930b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afecf152485d4534c5386e7244d15930b">&#9670;&#160;</a></span>VolumeExecutable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. Shares the LLVM constructs but deep copies the settings. Multiple copies of an executor can be used at the same time safely. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a326b3d09e594df0558a30e4b08458e51" name="a326b3d09e594df0558a30e4b08458e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326b3d09e594df0558a30e4b08458e51">&#9670;&#160;</a></span>execute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1GridBase.html">openvdb::GridBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grids</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run this volume executable binary on target volumes. </p>
<p>This method reads from the stored settings on the executable to determine certain behaviour and runs the JIT compiled function across every valid VDB value. Topology may be changed, deleted or created.</p>
<p>This method is thread safe; it can be run concurrently from the same <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable.html" title="Object that encapsulates compiled AX code which can be executed on a collection of VDB volume grids....">VolumeExecutable</a> instance on different inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grids</td><td>The VDB Volumes to process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa5b1b17f79a43463f5aeeb546913350" name="afa5b1b17f79a43463f5aeeb546913350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5b1b17f79a43463f5aeeb546913350">&#9670;&#160;</a></span>execute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a0c9703e6ff5cc9deb6410c53412c22c3">openvdb::GridPtrVec</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grids</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run this volume executable binary on target volumes. </p>
<p>This method reads from the stored settings on the executable to determine certain behaviour and runs the JIT compiled function across every valid VDB value. Topology may be changed, deleted or created.</p>
<p>This method is thread safe; it can be run concurrently from the same <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable.html" title="Object that encapsulates compiled AX code which can be executed on a collection of VDB volume grids....">VolumeExecutable</a> instance on different inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grids</td><td>The VDB Volumes to process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7816f72b5227861fcdd9254642d36b57" name="a7816f72b5227861fcdd9254642d36b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7816f72b5227861fcdd9254642d36b57">&#9670;&#160;</a></span>getActiveTileStreaming() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a> getActiveTileStreaming </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current stream behaviour. </dd></dl>

</div>
</div>
<a id="a9c3f5a2eefd7a7df23081c4a3f25f355" name="a9c3f5a2eefd7a7df23081c4a3f25f355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3f5a2eefd7a7df23081c4a3f25f355">&#9670;&#160;</a></span>getActiveTileStreaming() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a> getActiveTileStreaming </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">ast::tokens::CoreType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current stream behaviour for a particular grid. This is either ON or OFF. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the grid to query </td></tr>
    <tr><td class="paramname">type</td><td>The grids type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd55bb4909155856edbfb536ff201591" name="afd55bb4909155856edbfb536ff201591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd55bb4909155856edbfb536ff201591">&#9670;&#160;</a></span>getActiveTileStreamingGrainSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t getActiveTileStreamingGrainSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current g2 grain size </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a12cfbf4433635944ec76268cea607562" title="Set the threading grain sizes used when iterating over nodes in a VDB.">setActiveTileStreamingGrainSize</a> </dd></dl>

</div>
</div>
<a id="a2f426e3a0c85cfe75fcbdb3c949bf1c7" name="a2f426e3a0c85cfe75fcbdb3c949bf1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f426e3a0c85cfe75fcbdb3c949bf1c7">&#9670;&#160;</a></span>getAttributeBindings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1AttributeBindings.html">AttributeBindings</a> &amp; getAttributeBindings </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current attribute bindings map </dd></dl>

</div>
</div>
<a id="adef286c6a39859d3e27d182f85f91460" name="adef286c6a39859d3e27d182f85f91460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef286c6a39859d3e27d182f85f91460">&#9670;&#160;</a></span>getCreateMissing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getCreateMissing </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether this executable will generate new grids. </dd></dl>

</div>
</div>
<a id="aa0d4d60c7203c32277a16f97e6b6daf0" name="aa0d4d60c7203c32277a16f97e6b6daf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d4d60c7203c32277a16f97e6b6daf0">&#9670;&#160;</a></span>getGrainSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t getGrainSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current g1 grain size </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8f3948ab8d869447c5f585c45ed2086b" title="Set the threading grain sizes used when iterating over nodes in a VDB.">setGrainSize</a> </dd></dl>

</div>
</div>
<a id="a2153ec6bf69ce734f8eddcf64c1487e1" name="a2153ec6bf69ce734f8eddcf64c1487e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2153ec6bf69ce734f8eddcf64c1487e1">&#9670;&#160;</a></span>getTreeExecutionLevel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getTreeExecutionLevel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The tree execution level. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated</a></b></dt><dd>"Use getTreeExecutionLevel(Index&amp;, Index&amp;)" <br  />
 </dd></dl>

</div>
</div>
<a id="a7188ef4811a0a0feecb0687def1099ae" name="a7188ef4811a0a0feecb0687def1099ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7188ef4811a0a0feecb0687def1099ae">&#9670;&#160;</a></span>getTreeExecutionLevel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getTreeExecutionLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tree execution levels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The minimum tree execution level </td></tr>
    <tr><td class="paramname">max</td><td>The maximum tree execution level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e152ea2ce683b6df8b1ab90402a409a" name="a7e152ea2ce683b6df8b1ab90402a409a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e152ea2ce683b6df8b1ab90402a409a">&#9670;&#160;</a></span>getValueIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af607f22e4873b3369e942d9ebb3e72b1">IterType</a> getValueIterator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The current value iterator type </dd></dl>

</div>
</div>
<a id="a8e14a8daa02c1cd03f4718f58f378adb" name="a8e14a8daa02c1cd03f4718f58f378adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e14a8daa02c1cd03f4718f58f378adb">&#9670;&#160;</a></span>setActiveTileStreaming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setActiveTileStreaming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ade0a25d0d6ba0e0a4d939aedcbb8fae0">Streaming</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls the behaviour of expansion of active tiles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The behaviour to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12cfbf4433635944ec76268cea607562" name="a12cfbf4433635944ec76268cea607562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12cfbf4433635944ec76268cea607562">&#9670;&#160;</a></span>setActiveTileStreamingGrainSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setActiveTileStreamingGrainSize </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>g2</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the threading grain sizes used when iterating over nodes in a VDB. </p>
<p>Two grain sizes are provided, the first of which (g1) is used to determine the chunk size of nodes which are not being streamed (see setActiveTileStream). Leaf node execution always uses this grain size. The default value for g1 is 1 which is typically appropriate for most AX kernels. The second grain size is used when streaming execution over active tiles in a VDB. This execution model differs significantly from typical leaf node execution due to the potential for substantially more memory to be allocated. The default value is 32, which works well for the default configuration of OpenVDB. If streaming is disabled, this value has no effect. </p><dl class="section note"><dt>Note</dt><dd>Setting g1 or g2 to zero has the effect of disabling multi-threading for the respective node executions. Setting both to zero will disable all multi-threading performed by the execute method. </dd></dl>

</div>
</div>
<a id="afd4fde77c8d382cfa72bf9a0622222c5" name="afd4fde77c8d382cfa72bf9a0622222c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4fde77c8d382cfa72bf9a0622222c5">&#9670;&#160;</a></span>setAttributeBindings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setAttributeBindings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1AttributeBindings.html">AttributeBindings</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bindings</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set attribute bindings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindings</td><td>A map of attribute bindings to expected names on the geometry to be executed over. By default the AX attributes will be bound to volumes of the same name. Supplying bindings for a subset of the attributes will leave the others unchanged. AX attributes can only bind to a single volume and vice versa. However, in a single set call these can be swapped e.g. a -&gt; b and b -&gt; a. When bindings are overriden through subsequent calls to this function, any dangling volumes will be automatically bound by name. To reset these bindings call get function and create a target set of bindings for each attribute of name -&gt; name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ca28d3bd69799bef5435081d8ca285c" name="a1ca28d3bd69799bef5435081d8ca285c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca28d3bd69799bef5435081d8ca285c">&#9670;&#160;</a></span>setCreateMissing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setCreateMissing </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the behaviour when missing grids are accessed. Default behaviour is true, which creates them with default transforms and background values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Enables or disables the creation of missing attributes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f3948ab8d869447c5f585c45ed2086b" name="a8f3948ab8d869447c5f585c45ed2086b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3948ab8d869447c5f585c45ed2086b">&#9670;&#160;</a></span>setGrainSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setGrainSize </td>
          <td>(</td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>g1</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the threading grain sizes used when iterating over nodes in a VDB. </p>
<p>Two grain sizes are provided, the first of which (g1) is used to determine the chunk size of nodes which are not being streamed (see setActiveTileStream). Leaf node execution always uses this grain size. The default value for g1 is 1 which is typically appropriate for most AX kernels. The second grain size is used when streaming execution over active tiles in a VDB. This execution model differs significantly from typical leaf node execution due to the potential for substantially more memory to be allocated. The default value is 32, which works well for the default configuration of OpenVDB. If streaming is disabled, this value has no effect. </p><dl class="section note"><dt>Note</dt><dd>Setting g1 or g2 to zero has the effect of disabling multi-threading for the respective node executions. Setting both to zero will disable all multi-threading performed by the execute method. </dd></dl>

</div>
</div>
<a id="add86d578eaeb94d2b29abd5ca2c56987" name="add86d578eaeb94d2b29abd5ca2c56987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add86d578eaeb94d2b29abd5ca2c56987">&#9670;&#160;</a></span>setSettingsFromCLI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSettingsFromCLI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable_1_1CLI.html">CLI</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cli</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intialize the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable_1_1Settings.html">Settings</a> of this executables from the <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable_1_1CLI.html" title="Command Line Interface handling for the VolumeExecutable.">CLI</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cli</td><td>The <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable_1_1CLI.html" title="Command Line Interface handling for the VolumeExecutable.">CLI</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeeba4e1c6cedbfda3fb609f8a9817ffe" name="aeeba4e1c6cedbfda3fb609f8a9817ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeba4e1c6cedbfda3fb609f8a9817ffe">&#9670;&#160;</a></span>setTreeExecutionLevel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setTreeExecutionLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>level</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The tree execution level to set. Calls setTreeExecutionLevel with min and max arguments as level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa585cfdd56bad735e5b95b165862b223" name="aa585cfdd56bad735e5b95b165862b223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa585cfdd56bad735e5b95b165862b223">&#9670;&#160;</a></span>setTreeExecutionLevel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setTreeExecutionLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the execution level for this executable. This controls what nodes are processed when execute is called. Possible values depend on the OpenVDB configuration in use, however a value of 0 will always correspond to the lowest level (leaf-level). By default, the min level is zero (LeafNodeType::LEVEL) and the max level is the root node's level (RootNodeType::LEVEL). In other words, the default execution level settings process the whole of the tree. </p>
<dl class="section note"><dt>Note</dt><dd>A value larger that the number of levels in the tree (i.e. larger than the root node's level) will cause this method to throw a runtime error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The minimum tree execution level to set </td></tr>
    <tr><td class="paramname">max</td><td>The maximum tree execution level to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89b2029c94153119e4d28d21126e597c" name="a89b2029c94153119e4d28d21126e597c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b2029c94153119e4d28d21126e597c">&#9670;&#160;</a></span>setValueIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setValueIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#af607f22e4873b3369e942d9ebb3e72b1">IterType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value iterator type to use with this executable. Options are ON, OFF, ALL. Default is ON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The value iterator type to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a05bfde7168d80e33821dfb0a9d85ea09" name="a05bfde7168d80e33821dfb0a9d85ea09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bfde7168d80e33821dfb0a9d85ea09">&#9670;&#160;</a></span>::TestVolumeExecutableAcc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::TestVolumeExecutableAcc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f904e96618a83d59208fb22cdf11ff5" name="a5f904e96618a83d59208fb22cdf11ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f904e96618a83d59208fb22cdf11ff5">&#9670;&#160;</a></span>Compiler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Compiler.html">Compiler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax.html">ax</a></li><li class="navelem"><a href="classopenvdb_1_1v13__0_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
