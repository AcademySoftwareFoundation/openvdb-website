<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: Value Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html','','classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Value Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Intermediate representation wrapper for supported value types in AX as immutable instances.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Value_8h_source.html">openvdb_ax/codegen/Value.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af08f4618c6e6924e828f93f0ef4cbf70" id="r_af08f4618c6e6924e828f93f0ef4cbf70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af08f4618c6e6924e828f93f0ef4cbf70">Value</a> (llvm::Value *val, llvm::Type *utype)</td></tr>
<tr class="memdesc:af08f4618c6e6924e828f93f0ef4cbf70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> with a provided underlying type.  <br /></td></tr>
<tr class="memitem:a6af300c9eb8edc988919e6c24d440e36" id="r_a6af300c9eb8edc988919e6c24d440e36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6af300c9eb8edc988919e6c24d440e36">Value</a> (llvm::Constant *costant)</td></tr>
<tr class="memdesc:a6af300c9eb8edc988919e6c24d440e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize from a constant value.  <br /></td></tr>
<tr class="memitem:a697ba78bdd3098f0fef21049ba09de5f" id="r_a697ba78bdd3098f0fef21049ba09de5f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a697ba78bdd3098f0fef21049ba09de5f">Value</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp;)=default</td></tr>
<tr class="memitem:a5a8c739009623e1b23f2894713d5e76a" id="r_a5a8c739009623e1b23f2894713d5e76a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a8c739009623e1b23f2894713d5e76a">Value</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp;&amp;)=default</td></tr>
<tr class="memitem:a6c7270f705a7c86fbc34de656d7fad96" id="r_a6c7270f705a7c86fbc34de656d7fad96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c7270f705a7c86fbc34de656d7fad96">operator=</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp;)=default</td></tr>
<tr class="memitem:aa8740147fc9b7c56de2381f3b668e8d2" id="r_aa8740147fc9b7c56de2381f3b668e8d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8740147fc9b7c56de2381f3b668e8d2">operator=</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp;&amp;)=default</td></tr>
<tr class="memitem:ae70dc3edb7f43c70d23625a2f9b1491e" id="r_ae70dc3edb7f43c70d23625a2f9b1491e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae70dc3edb7f43c70d23625a2f9b1491e">Zero</a> () const</td></tr>
<tr class="memdesc:ae70dc3edb7f43c70d23625a2f9b1491e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new zero scalar <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> using the underlying scalar precision of this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a>. Does not generate IR, however will return an invalid constant if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is a string.  <br /></td></tr>
<tr class="memitem:aa5e4ba05990e316ee90cfae290b20ff1" id="r_aa5e4ba05990e316ee90cfae290b20ff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5e4ba05990e316ee90cfae290b20ff1">One</a> () const</td></tr>
<tr class="memdesc:aa5e4ba05990e316ee90cfae290b20ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new one scalar <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> using the underlying scalar precision of this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a>. Does not generate IR, however will return an invalid constant if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is a string.  <br /></td></tr>
<tr class="memitem:a67b76affb3b5d35fa419ac234144038b" id="r_a67b76affb3b5d35fa419ac234144038b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67b76affb3b5d35fa419ac234144038b">operator bool</a> () const</td></tr>
<tr class="memdesc:a67b76affb3b5d35fa419ac234144038b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> contains an active underlying llvm Value/Type. When asserts are enabled. This method strictly checks all possible valid combination types of a <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a>.  <br /></td></tr>
<tr class="memitem:a61efd4196a96540ee018fee8791f3f10" id="r_a61efd4196a96540ee018fee8791f3f10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61efd4196a96540ee018fee8791f3f10">operator!</a> () const</td></tr>
<tr class="memdesc:a61efd4196a96540ee018fee8791f3f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">See bool operator.  <br /></td></tr>
<tr class="memitem:a570248cd9330baed655617a941f0de1f" id="r_a570248cd9330baed655617a941f0de1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a570248cd9330baed655617a941f0de1f">IsVoid</a> () const</td></tr>
<tr class="memdesc:a570248cd9330baed655617a941f0de1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this value represents a void type. This is typically only possible for void function returns.  <br /></td></tr>
<tr class="memitem:aec3bdef27fa2d4de29db82d2334ad2d8" id="r_aec3bdef27fa2d4de29db82d2334ad2d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec3bdef27fa2d4de29db82d2334ad2d8">IsBool</a> () const</td></tr>
<tr class="memdesc:aec3bdef27fa2d4de29db82d2334ad2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the underlying type is a bool type.  <br /></td></tr>
<tr class="memitem:af494171df1c635b5a9f298e8c29c2fc1" id="r_af494171df1c635b5a9f298e8c29c2fc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af494171df1c635b5a9f298e8c29c2fc1">IsScalar</a> () const</td></tr>
<tr class="memdesc:af494171df1c635b5a9f298e8c29c2fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the underlying type is a scalar type (bool, int or float).  <br /></td></tr>
<tr class="memitem:a8543c359835d7977b96446aaef126344" id="r_a8543c359835d7977b96446aaef126344"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8543c359835d7977b96446aaef126344">IsInteger</a> () const</td></tr>
<tr class="memdesc:a8543c359835d7977b96446aaef126344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the underlying type is an integer type.  <br /></td></tr>
<tr class="memitem:aec0a6f81c7581924db00ea960358d91b" id="r_aec0a6f81c7581924db00ea960358d91b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec0a6f81c7581924db00ea960358d91b">IsFloat</a> () const</td></tr>
<tr class="memdesc:aec0a6f81c7581924db00ea960358d91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the underlying type is an floating point type (float or double).  <br /></td></tr>
<tr class="memitem:aebef9889d05411b93c68c9a7d9d773cf" id="r_aebef9889d05411b93c68c9a7d9d773cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebef9889d05411b93c68c9a7d9d773cf">IsArray</a> () const</td></tr>
<tr class="memdesc:aebef9889d05411b93c68c9a7d9d773cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the underlying type is an array type.  <br /></td></tr>
<tr class="memitem:a788925e7d55dc45e3a12e30996af89b0" id="r_a788925e7d55dc45e3a12e30996af89b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a788925e7d55dc45e3a12e30996af89b0">IsVector</a> () const</td></tr>
<tr class="memdesc:a788925e7d55dc45e3a12e30996af89b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the underlying type is an vector 2/3/4 type.  <br /></td></tr>
<tr class="memitem:a67bbed67c4fb5ea68910d94436586c15" id="r_a67bbed67c4fb5ea68910d94436586c15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67bbed67c4fb5ea68910d94436586c15">IsMatrix</a> () const</td></tr>
<tr class="memdesc:a67bbed67c4fb5ea68910d94436586c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the underlying type is an matrix 3/4 type.  <br /></td></tr>
<tr class="memitem:a7c412f98489e7d252ef40ed053a3908c" id="r_a7c412f98489e7d252ef40ed053a3908c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c412f98489e7d252ef40ed053a3908c">IsString</a> () const</td></tr>
<tr class="memdesc:a7c412f98489e7d252ef40ed053a3908c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the underlying type is a string type.  <br /></td></tr>
<tr class="memitem:a09d6e9ac47124e88096e798870d5f0b0" id="r_a09d6e9ac47124e88096e798870d5f0b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09d6e9ac47124e88096e798870d5f0b0">IsPtr</a> () const</td></tr>
<tr class="memdesc:a09d6e9ac47124e88096e798870d5f0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is a pointer type.  <br /></td></tr>
<tr class="memitem:a945263e85c27f3216a8323cfc16d8919" id="r_a945263e85c27f3216a8323cfc16d8919"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a945263e85c27f3216a8323cfc16d8919">IsConstant</a> () const</td></tr>
<tr class="memdesc:a945263e85c27f3216a8323cfc16d8919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is a constant.  <br /></td></tr>
<tr class="memitem:a1669a4540307c54cf3a3f2acd0d348a3" id="r_a1669a4540307c54cf3a3f2acd0d348a3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1669a4540307c54cf3a3f2acd0d348a3">GetArrayNumElements</a> () const</td></tr>
<tr class="memdesc:a1669a4540307c54cf3a3f2acd0d348a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in this array type.  <br /></td></tr>
<tr class="memitem:a54b329322e112db3aba13759f17e34b7" id="r_a54b329322e112db3aba13759f17e34b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54b329322e112db3aba13759f17e34b7">IsNan</a> (llvm::IRBuilder&lt;&gt; &amp;B) const</td></tr>
<tr class="memdesc:a54b329322e112db3aba13759f17e34b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to check whether this value is NaN. Only works on Float types and will generate invalid IR if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is not a Float instance.  <br /></td></tr>
<tr class="memitem:a4cf2984de21731f80e61fba108bea320" id="r_a4cf2984de21731f80e61fba108bea320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cf2984de21731f80e61fba108bea320">Load</a> (llvm::IRBuilder&lt;&gt; &amp;B) const</td></tr>
<tr class="memdesc:a4cf2984de21731f80e61fba108bea320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to load the current value. Not typically required to call directly. Will generate invalid IR if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is not a Ptr.  <br /></td></tr>
<tr class="memitem:ac08ee3d13ecdc8fde09a16dae84ef212" id="r_ac08ee3d13ecdc8fde09a16dae84ef212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac08ee3d13ecdc8fde09a16dae84ef212">LoadIfPtr</a> (llvm::IRBuilder&lt;&gt; &amp;B) const</td></tr>
<tr class="memdesc:ac08ee3d13ecdc8fde09a16dae84ef212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to load the current value if it is a ptr. Not typically required to call directly.  <br /></td></tr>
<tr class="memitem:a01e6d74c0e36fd0090cd7f6d082e52c3" id="r_a01e6d74c0e36fd0090cd7f6d082e52c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01e6d74c0e36fd0090cd7f6d082e52c3">GetArrayElement</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> idx) const</td></tr>
<tr class="memdesc:a01e6d74c0e36fd0090cd7f6d082e52c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to return a scalar at the provided index from this array value. Will generate invalid IR if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is not an array or if idx is not an integer.  <br /></td></tr>
<tr class="memitem:af47f186e20fc927517899eecfc8d480c" id="r_af47f186e20fc927517899eecfc8d480c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af47f186e20fc927517899eecfc8d480c">GetArrayElement</a> (llvm::IRBuilder&lt;&gt; &amp;B, uint64_t idx) const</td></tr>
<tr class="memdesc:af47f186e20fc927517899eecfc8d480c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to return a scalar at the provided index from this array value. Will generate invalid IR if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is not an array.  <br /></td></tr>
<tr class="memitem:a446dfba84acc20078ac67ccfe27a87d0" id="r_a446dfba84acc20078ac67ccfe27a87d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a446dfba84acc20078ac67ccfe27a87d0">ArrayToScalars</a> (llvm::IRBuilder&lt;&gt; &amp;B, std::vector&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &gt; &amp;elements, const bool load=false) const</td></tr>
<tr class="memdesc:a446dfba84acc20078ac67ccfe27a87d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to extract scalar values from the elements in this array and populate the provided vector with them. The scalars are additionally loaded if load is true. Will generate invalid IR if this is not an array.  <br /></td></tr>
<tr class="memitem:a28b787433abc7269a6661d21c87441fc" id="r_a28b787433abc7269a6661d21c87441fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28b787433abc7269a6661d21c87441fc">ScalarToArray</a> (llvm::IRBuilder&lt;&gt; &amp;B, size_t size) const</td></tr>
<tr class="memdesc:a28b787433abc7269a6661d21c87441fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to broadcast this scalar to a new array. Will generated invalid IR if this is not a scalar or if size is zero.  <br /></td></tr>
<tr class="memitem:a8fdbf6698b8a5fb5e79feb9bdc9f7db9" id="r_a8fdbf6698b8a5fb5e79feb9bdc9f7db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fdbf6698b8a5fb5e79feb9bdc9f7db9">ScalarToIdentMatrix3</a> (llvm::IRBuilder&lt;&gt; &amp;B) const</td></tr>
<tr class="memdesc:a8fdbf6698b8a5fb5e79feb9bdc9f7db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to create a new 3x3 matrix from this scalar value, adhering to scalar-&gt;matrix promotion rules. Will generate invalid IR if this is not a scalar value.  <br /></td></tr>
<tr class="memitem:a3154dacc5465cf42b991cab1c47574ff" id="r_a3154dacc5465cf42b991cab1c47574ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3154dacc5465cf42b991cab1c47574ff">ScalarToIdentMatrix4</a> (llvm::IRBuilder&lt;&gt; &amp;B) const</td></tr>
<tr class="memdesc:a3154dacc5465cf42b991cab1c47574ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to create a new 4x4 matrix from this scalar value, adhering to scalar-&gt;matrix promotion rules. Will generate invalid IR if this is not a scalar value.  <br /></td></tr>
<tr class="memitem:a5af32cfeabe460233bde112b23f419cc" id="r_a5af32cfeabe460233bde112b23f419cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af32cfeabe460233bde112b23f419cc">ScalarBoolComparison</a> (llvm::IRBuilder&lt;&gt; &amp;B) const</td></tr>
<tr class="memdesc:a5af32cfeabe460233bde112b23f419cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform standard boolean comparison on this scalar i.e. bool(scalar) or bool(scalar == 0). Returns a <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> of type bool. Will return <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> if this is not a bool/int/float.  <br /></td></tr>
<tr class="memitem:ac5bee25f9934e25f8fab05516b604b1a" id="r_ac5bee25f9934e25f8fab05516b604b1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5bee25f9934e25f8fab05516b604b1a">Select</a> (llvm::IRBuilder&lt;&gt; &amp;B, const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp;trueval, const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp;falseval) const</td></tr>
<tr class="memdesc:ac5bee25f9934e25f8fab05516b604b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to select a value based on this boolean scalar value. Will generate invalid IR if this is not a boolean value, or if trueval and falseval have different types.  <br /></td></tr>
<tr class="memitem:aefe1a237abd20c1826c6b82f7c935c5b" id="r_aefe1a237abd20c1826c6b82f7c935c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefe1a237abd20c1826c6b82f7c935c5b">CastToPrecision</a> (llvm::IRBuilder&lt;&gt; &amp;B, llvm::Type *precision) const</td></tr>
<tr class="memdesc:aefe1a237abd20c1826c6b82f7c935c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to cast this scalar or array to a new value of the provided scalar precision. Returns a new value of the same class type (scalar or array) but with a new precision. Will generate invalid IR if the precision is not an integer or floating point precision type. If this is not an array or scalar, no IR is emitted and <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> is returned. Additionally, if the provided precision is the same as this scalar/array's underlying precision, no IR is emitted and no new value is created.  <br /></td></tr>
<tr class="memitem:aa04abd82dc75046b8a80253c02d45891" id="r_aa04abd82dc75046b8a80253c02d45891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa04abd82dc75046b8a80253c02d45891">Not</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:aa04abd82dc75046b8a80253c02d45891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to create a unary not instruction on this scalar or integer array (i.e. !value). If the value is not a int/float/integer array, no IR is emitted, a warning is logged (if a logger is provided) and <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid</a> is returned.  <br /></td></tr>
<tr class="memitem:a0562e2fdc5f7da6d748bcbcbaede761d" id="r_a0562e2fdc5f7da6d748bcbcbaede761d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0562e2fdc5f7da6d748bcbcbaede761d">BitNot</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:a0562e2fdc5f7da6d748bcbcbaede761d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to create a unary not instruction on this integer or integer array (i.e. ~value). If the value is not a int/integer array, no IR is emitted, a warning is logged (if a logger is provided) and <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid</a> is returned.  <br /></td></tr>
<tr class="memitem:aa1bac88ea89ac7d7ab76c568840dd3b7" id="r_aa1bac88ea89ac7d7ab76c568840dd3b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1bac88ea89ac7d7ab76c568840dd3b7">Negate</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:aa1bac88ea89ac7d7ab76c568840dd3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to create a unary not instruction on this scalar or array (i.e. -value). If the value is not a int/float/array, no IR is is emitted, a warning is logged (if a logger is provided) and <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid</a> is returned.  <br /></td></tr>
<tr class="memitem:a647b84b424b76ec07b16fad6c9d87592" id="r_a647b84b424b76ec07b16fad6c9d87592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a647b84b424b76ec07b16fad6c9d87592">Increment</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:a647b84b424b76ec07b16fad6c9d87592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to increment this scalar (i.e. value + 1). Will return <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> and report a message to a logger (if provided) if this is not an integer (non-bool) or float scalar.  <br /></td></tr>
<tr class="memitem:ae2e4dd183b8b00d081d3536046ee53db" id="r_ae2e4dd183b8b00d081d3536046ee53db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2e4dd183b8b00d081d3536046ee53db">Decrement</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:ae2e4dd183b8b00d081d3536046ee53db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to increment this scalar (i.e. value - 1). Will return <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> and report a message to a logger (if provided) if this is not an integer (non-bool) or float scalar.  <br /></td></tr>
<tr class="memitem:aaa37b4db92402576bba08faf028401f3" id="r_aaa37b4db92402576bba08faf028401f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa37b4db92402576bba08faf028401f3">Binary</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">ast::tokens::OperatorToken</a> &amp;op, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:aaa37b4db92402576bba08faf028401f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a binary operation on this LHS value and a provided RHS value. If the operation is not a valid binary operation, <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> is returned. Defer to the explicit binary methods on this class for more details.  <br /></td></tr>
<tr class="memitem:ac5abe6272262ae7001b4c140baad8dfa" id="r_ac5abe6272262ae7001b4c140baad8dfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5abe6272262ae7001b4c140baad8dfa">And</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:ac5abe6272262ae7001b4c140baad8dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a &amp;&amp; operation on two scalars. Assumes both inputs are scalars (this checking is currently done in the ComputeGenerator) and will cause undefined behaviour if they are not.  <br /></td></tr>
<tr class="memitem:a10a3f2e805d445de43cb5f8c03d2d637" id="r_a10a3f2e805d445de43cb5f8c03d2d637"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10a3f2e805d445de43cb5f8c03d2d637">Or</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:a10a3f2e805d445de43cb5f8c03d2d637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a || operation on two scalars. Assumes both inputs are scalars (this checking is currently done in the ComputeGenerator) and will cause undefined behaviour if they are not.  <br /></td></tr>
<tr class="memitem:ae951ed43692c661313ddb45dfd6a5d36" id="r_ae951ed43692c661313ddb45dfd6a5d36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae951ed43692c661313ddb45dfd6a5d36">Add</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:ae951ed43692c661313ddb45dfd6a5d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a + operation on two values.  <br /></td></tr>
<tr class="memitem:adb71bd1d9d83020b64181f5fdd1c66d0" id="r_adb71bd1d9d83020b64181f5fdd1c66d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb71bd1d9d83020b64181f5fdd1c66d0">Subtract</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:adb71bd1d9d83020b64181f5fdd1c66d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a - operation on two values.  <br /></td></tr>
<tr class="memitem:aa97f96c9dcb69b91b156f60770a90d52" id="r_aa97f96c9dcb69b91b156f60770a90d52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa97f96c9dcb69b91b156f60770a90d52">Multiply</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:aa97f96c9dcb69b91b156f60770a90d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a * operation on two values.  <br /></td></tr>
<tr class="memitem:a86c9f3eee0a212a23bd946d6833524c6" id="r_a86c9f3eee0a212a23bd946d6833524c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86c9f3eee0a212a23bd946d6833524c6">Divide</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:a86c9f3eee0a212a23bd946d6833524c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a / operation on two values If the denominator is constant and zero, returns <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a>  <br /></td></tr>
<tr class="memitem:a5c90353181d6b0613e3aee380ca7bbcc" id="r_a5c90353181d6b0613e3aee380ca7bbcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c90353181d6b0613e3aee380ca7bbcc">Modulo</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:a5c90353181d6b0613e3aee380ca7bbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a FLOORED % operation on two values.  <br /></td></tr>
<tr class="memitem:ae1defcb5aafeb4c68cbc012bb579fd18" id="r_ae1defcb5aafeb4c68cbc012bb579fd18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1defcb5aafeb4c68cbc012bb579fd18">TruncatedModulo</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs) const</td></tr>
<tr class="memdesc:ae1defcb5aafeb4c68cbc012bb579fd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a TRUNCATED % operation on two values.  <br /></td></tr>
<tr class="memitem:ad09bc2b2dbd51767ef7ddf18b01d312b" id="r_ad09bc2b2dbd51767ef7ddf18b01d312b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad09bc2b2dbd51767ef7ddf18b01d312b">Equals</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:ad09bc2b2dbd51767ef7ddf18b01d312b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a == operation on two values.  <br /></td></tr>
<tr class="memitem:a70115eb7e06126610ff309fff9ade3ae" id="r_a70115eb7e06126610ff309fff9ade3ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70115eb7e06126610ff309fff9ade3ae">NotEquals</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:a70115eb7e06126610ff309fff9ade3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a != operation on two values.  <br /></td></tr>
<tr class="memitem:af334275aeeeed6256f2b22d5edce27d7" id="r_af334275aeeeed6256f2b22d5edce27d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af334275aeeeed6256f2b22d5edce27d7">GreaterThan</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:af334275aeeeed6256f2b22d5edce27d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a &gt; operation on two values.  <br /></td></tr>
<tr class="memitem:ad3c9b52e02125d4331c9ef6b60360668" id="r_ad3c9b52e02125d4331c9ef6b60360668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3c9b52e02125d4331c9ef6b60360668">GreaterThanEquals</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:ad3c9b52e02125d4331c9ef6b60360668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a &gt;= operation on two values.  <br /></td></tr>
<tr class="memitem:a756e30464eb00e5c9630b6fcf1f28911" id="r_a756e30464eb00e5c9630b6fcf1f28911"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a756e30464eb00e5c9630b6fcf1f28911">LessThan</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:a756e30464eb00e5c9630b6fcf1f28911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a &lt; operation on two values.  <br /></td></tr>
<tr class="memitem:a1b99718710acf558aeb45a147a35766d" id="r_a1b99718710acf558aeb45a147a35766d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b99718710acf558aeb45a147a35766d">LessThanEquals</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:a1b99718710acf558aeb45a147a35766d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a &lt;= operation on two values.  <br /></td></tr>
<tr class="memitem:a44512bd52c394f54fb30fa98cbc71fa7" id="r_a44512bd52c394f54fb30fa98cbc71fa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44512bd52c394f54fb30fa98cbc71fa7">ShiftLeft</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:a44512bd52c394f54fb30fa98cbc71fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a &lt;&lt; operation. Both values must be integers.  <br /></td></tr>
<tr class="memitem:a9b7d3966549d7c90bf7d0d288ddc84ab" id="r_a9b7d3966549d7c90bf7d0d288ddc84ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b7d3966549d7c90bf7d0d288ddc84ab">ShiftRight</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:a9b7d3966549d7c90bf7d0d288ddc84ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a &gt;&gt; operation. Both values must be integers.  <br /></td></tr>
<tr class="memitem:a16a9f63ec998d16b9898095e60f1350e" id="r_a16a9f63ec998d16b9898095e60f1350e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16a9f63ec998d16b9898095e60f1350e">BitAnd</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:a16a9f63ec998d16b9898095e60f1350e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a &amp; operation. Both values must be integers.  <br /></td></tr>
<tr class="memitem:a3788fb3dd10656de026bd4771f112648" id="r_a3788fb3dd10656de026bd4771f112648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3788fb3dd10656de026bd4771f112648">BitOr</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:a3788fb3dd10656de026bd4771f112648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a | operation. Both values must be integers.  <br /></td></tr>
<tr class="memitem:a64d79cc8c7b3fd985896764a34098cc0" id="r_a64d79cc8c7b3fd985896764a34098cc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64d79cc8c7b3fd985896764a34098cc0">BitXor</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:a64d79cc8c7b3fd985896764a34098cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to perform a ^ operation. Both values must be integers.  <br /></td></tr>
<tr class="memitem:a31046661d86a650eec988ff8d785719a" id="r_a31046661d86a650eec988ff8d785719a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31046661d86a650eec988ff8d785719a">Assign</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> rhs, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *log=nullptr, const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *node=nullptr) const</td></tr>
<tr class="memdesc:a31046661d86a650eec988ff8d785719a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to assign the provided rhs to this value.  <br /></td></tr>
<tr class="memitem:ad93edbe885499a712129356f1ffd506b" id="r_ad93edbe885499a712129356f1ffd506b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad93edbe885499a712129356f1ffd506b">Print</a> () const</td></tr>
<tr class="memdesc:ad93edbe885499a712129356f1ffd506b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump this value/type to llvm::errs.  <br /></td></tr>
<tr class="memitem:a6577cd1121c4c1a75a34f180c1791b5d" id="r_a6577cd1121c4c1a75a34f180c1791b5d"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6577cd1121c4c1a75a34f180c1791b5d">GetValue</a> () const</td></tr>
<tr class="memdesc:a6577cd1121c4c1a75a34f180c1791b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the underlying llvm <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a>.  <br /></td></tr>
<tr class="memitem:ada60346a0c2d80cd2129b87c43abde1b" id="r_ada60346a0c2d80cd2129b87c43abde1b"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada60346a0c2d80cd2129b87c43abde1b">GetUnderlyingType</a> () const</td></tr>
<tr class="memdesc:ada60346a0c2d80cd2129b87c43abde1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the underlying llvm Type.  <br /></td></tr>
<tr class="memitem:a30e280dd2280c559f768ecb54369f17c" id="r_a30e280dd2280c559f768ecb54369f17c"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30e280dd2280c559f768ecb54369f17c">GetUnderlyingScalarType</a> () const</td></tr>
<tr class="memdesc:a30e280dd2280c559f768ecb54369f17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the underlying scalar type. This method assumes the current value is a scalar or array.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae7b37f5a2cdb54151612f3cf5660ee95" id="r_ae7b37f5a2cdb54151612f3cf5660ee95"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95">Invalid</a> ()</td></tr>
<tr class="memdesc:ae7b37f5a2cdb54151612f3cf5660ee95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an invalid <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a>. This is used to represent various fail cases. Note that the operator bool(Value) will return false in for <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid</a>.  <br /></td></tr>
<tr class="memitem:a29d65e623bdd57321ee9d210b45d35d2" id="r_a29d65e623bdd57321ee9d210b45d35d2"><td class="memTemplParams" colspan="2">template&lt;typename ValueType&gt; </td></tr>
<tr class="memitem:a29d65e623bdd57321ee9d210b45d35d2 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29d65e623bdd57321ee9d210b45d35d2">Create</a> (llvm::LLVMContext &amp;C, const ValueType &amp;value)</td></tr>
<tr class="memdesc:a29d65e623bdd57321ee9d210b45d35d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an arithmetic literal.  <br /></td></tr>
<tr class="memitem:a9bc815b938a9a0202ed72b12b8ee4659" id="r_a9bc815b938a9a0202ed72b12b8ee4659"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bc815b938a9a0202ed72b12b8ee4659">Return</a> (llvm::IRBuilder&lt;&gt; &amp;B, <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> *ret=nullptr)</td></tr>
<tr class="memdesc:a9bc815b938a9a0202ed72b12b8ee4659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a value that represents a return value from a function. Really only intended to be used by the function framework. If ret is not provided, a void return is created.  <br /></td></tr>
<tr class="memitem:afe3641dcd176e38147ea7f36baaa62ab" id="r_afe3641dcd176e38147ea7f36baaa62ab"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe3641dcd176e38147ea7f36baaa62ab">Supports</a> (llvm::Type *utype)</td></tr>
<tr class="memdesc:afe3641dcd176e38147ea7f36baaa62ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the underlying type held by utype is supported via the interface of this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> class.  <br /></td></tr>
<tr class="memitem:a2499d12d9750bad55c82cd392efe9b48" id="r_a2499d12d9750bad55c82cd392efe9b48"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2499d12d9750bad55c82cd392efe9b48">Alloc</a> (llvm::IRBuilder&lt;&gt; &amp;B, llvm::Type *type, llvm::Value *size=nullptr)</td></tr>
<tr class="memdesc:a2499d12d9750bad55c82cd392efe9b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR inserting an allocation at the front of the BasicBlock pointed to by the provided IRBuilder. The type is expected to be a supported utype.  <br /></td></tr>
<tr class="memitem:a48ea2ec06adecb5c46b19e9445674b52" id="r_a48ea2ec06adecb5c46b19e9445674b52"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48ea2ec06adecb5c46b19e9445674b52">ScalarsToArray</a> (llvm::IRBuilder&lt;&gt; &amp;B, const std::vector&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a48ea2ec06adecb5c46b19e9445674b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit IR to create an array from a set of scalar values. Will generate invalid IR if the values are not all scalar or are of different precision. values cannot be empty.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Intermediate representation wrapper for supported value types in AX as immutable instances. </p>
<p>This class allows you to generate LLVM IR for common operations supported by the AX grammar whilst abstracting away a lot of the complexity of the underlying LLVM state. This class is not meant as a definitive representation of all possible LLVM IR instructions that can be emitted, more as a strict helper translation layer for some supported AX instructions to LLVM IR. More generally, this is intended to be used for all arithmetic operations and less so for program control flow (branches, loops, etc). Importantly, this class abstracts away the concept of ptr/loaded instructions. That is, users of this API usually do not need to worry about explicitly loading or querying the state of LLVM IR allocations when calling methods. Instances of <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> types also ensure that the required underlying type information is retained, necessary from LLVM 15 onwards (due to the introduction of LLVM's opaque ptr changes).</p>
<p>The subset of possible types this class supports are</p><ul>
<li>void types (for function returns)</li>
<li>AX scalar values (bool, ints, floats)</li>
<li>AX array values (element types of ints or floats)</li>
<li>AX string values</li>
</ul>
<p>Note that a <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> can have a variety of arithmetic type/precision states. The API of this class does not guaranteed compatibility between all states. Some failure cases may report a log message and return <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> or generate invalid IR/result in undefined behaviour if the inputs are not correct. Refer to individual API methods for more details. </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af08f4618c6e6924e828f93f0ef4cbf70" name="af08f4618c6e6924e828f93f0ef4cbf70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08f4618c6e6924e828f93f0ef4cbf70">&#9670;&#160;</a></span>Value() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>utype</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> with a provided underlying type. </p>
<dl class="section warning"><dt>Warning</dt><dd>This constructor assumes that the underlying type is correct. This cannot be asserted from LLVM 15 onwards. This should be used sparingly and currently only exists to support some holes in the compute generator. This constructor should eventually be removed as these get closed, in favour of the static create/alloc methods. </dd></dl>

</div>
</div>
<a id="a6af300c9eb8edc988919e6c24d440e36" name="a6af300c9eb8edc988919e6c24d440e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af300c9eb8edc988919e6c24d440e36">&#9670;&#160;</a></span>Value() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> </td>
          <td>(</td>
          <td class="paramtype">llvm::Constant *</td>          <td class="paramname"><span class="paramname"><em>costant</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize from a constant value. </p>

</div>
</div>
<a id="a697ba78bdd3098f0fef21049ba09de5f" name="a697ba78bdd3098f0fef21049ba09de5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697ba78bdd3098f0fef21049ba09de5f">&#9670;&#160;</a></span>Value() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a8c739009623e1b23f2894713d5e76a" name="a5a8c739009623e1b23f2894713d5e76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8c739009623e1b23f2894713d5e76a">&#9670;&#160;</a></span>Value() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ae951ed43692c661313ddb45dfd6a5d36" name="ae951ed43692c661313ddb45dfd6a5d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae951ed43692c661313ddb45dfd6a5d36">&#9670;&#160;</a></span>Add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Add </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to perform a + operation on two values. </p>

</div>
</div>
<a id="a2499d12d9750bad55c82cd392efe9b48" name="a2499d12d9750bad55c82cd392efe9b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2499d12d9750bad55c82cd392efe9b48">&#9670;&#160;</a></span>Alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Alloc </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *</td>          <td class="paramname"><span class="paramname"><em>size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR inserting an allocation at the front of the BasicBlock pointed to by the provided IRBuilder. The type is expected to be a supported utype. </p>

</div>
</div>
<a id="ac5abe6272262ae7001b4c140baad8dfa" name="ac5abe6272262ae7001b4c140baad8dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5abe6272262ae7001b4c140baad8dfa">&#9670;&#160;</a></span>And()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> And </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to perform a &amp;&amp; operation on two scalars. Assumes both inputs are scalars (this checking is currently done in the ComputeGenerator) and will cause undefined behaviour if they are not. </p>
<dl class="section warning"><dt>Warning</dt><dd>This does not perform short circuiting. See: ComputeGenerator::visit(const ast::BinaryOperator*) </dd></dl>

</div>
</div>
<a id="a446dfba84acc20078ac67ccfe27a87d0" name="a446dfba84acc20078ac67ccfe27a87d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446dfba84acc20078ac67ccfe27a87d0">&#9670;&#160;</a></span>ArrayToScalars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ArrayToScalars </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>elements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>load</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to extract scalar values from the elements in this array and populate the provided vector with them. The scalars are additionally loaded if load is true. Will generate invalid IR if this is not an array. </p>

</div>
</div>
<a id="a31046661d86a650eec988ff8d785719a" name="a31046661d86a650eec988ff8d785719a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31046661d86a650eec988ff8d785719a">&#9670;&#160;</a></span>Assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Assign </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to assign the provided rhs to this value. </p>

</div>
</div>
<a id="aaa37b4db92402576bba08faf028401f3" name="aaa37b4db92402576bba08faf028401f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa37b4db92402576bba08faf028401f3">&#9670;&#160;</a></span>Binary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Binary </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">ast::tokens::OperatorToken</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to perform a binary operation on this LHS value and a provided RHS value. If the operation is not a valid binary operation, <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> is returned. Defer to the explicit binary methods on this class for more details. </p>
<dl class="section note"><dt>Note</dt><dd>For all methods, performing type promotion/casting where necessary or return <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> on incompatible inputs and report a message to the log, if provided. </dd></dl>

</div>
</div>
<a id="a16a9f63ec998d16b9898095e60f1350e" name="a16a9f63ec998d16b9898095e60f1350e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a9f63ec998d16b9898095e60f1350e">&#9670;&#160;</a></span>BitAnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> BitAnd </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to perform a &amp; operation. Both values must be integers. </p>

</div>
</div>
<a id="a0562e2fdc5f7da6d748bcbcbaede761d" name="a0562e2fdc5f7da6d748bcbcbaede761d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0562e2fdc5f7da6d748bcbcbaede761d">&#9670;&#160;</a></span>BitNot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> BitNot </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to create a unary not instruction on this integer or integer array (i.e. ~value). If the value is not a int/integer array, no IR is emitted, a warning is logged (if a logger is provided) and <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid</a> is returned. </p>

</div>
</div>
<a id="a3788fb3dd10656de026bd4771f112648" name="a3788fb3dd10656de026bd4771f112648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3788fb3dd10656de026bd4771f112648">&#9670;&#160;</a></span>BitOr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> BitOr </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to perform a | operation. Both values must be integers. </p>

</div>
</div>
<a id="a64d79cc8c7b3fd985896764a34098cc0" name="a64d79cc8c7b3fd985896764a34098cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d79cc8c7b3fd985896764a34098cc0">&#9670;&#160;</a></span>BitXor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> BitXor </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to perform a ^ operation. Both values must be integers. </p>

</div>
</div>
<a id="aefe1a237abd20c1826c6b82f7c935c5b" name="aefe1a237abd20c1826c6b82f7c935c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe1a237abd20c1826c6b82f7c935c5b">&#9670;&#160;</a></span>CastToPrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> CastToPrecision </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>precision</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to cast this scalar or array to a new value of the provided scalar precision. Returns a new value of the same class type (scalar or array) but with a new precision. Will generate invalid IR if the precision is not an integer or floating point precision type. If this is not an array or scalar, no IR is emitted and <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> is returned. Additionally, if the provided precision is the same as this scalar/array's underlying precision, no IR is emitted and no new value is created. </p>

</div>
</div>
<a id="a29d65e623bdd57321ee9d210b45d35d2" name="a29d65e623bdd57321ee9d210b45d35d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d65e623bdd57321ee9d210b45d35d2">&#9670;&#160;</a></span>Create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Create </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an arithmetic literal. </p>

</div>
</div>
<a id="ae2e4dd183b8b00d081d3536046ee53db" name="ae2e4dd183b8b00d081d3536046ee53db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e4dd183b8b00d081d3536046ee53db">&#9670;&#160;</a></span>Decrement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Decrement </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to increment this scalar (i.e. value - 1). Will return <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> and report a message to a logger (if provided) if this is not an integer (non-bool) or float scalar. </p>

</div>
</div>
<a id="a86c9f3eee0a212a23bd946d6833524c6" name="a86c9f3eee0a212a23bd946d6833524c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c9f3eee0a212a23bd946d6833524c6">&#9670;&#160;</a></span>Divide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Divide </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to perform a / operation on two values If the denominator is constant and zero, returns <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> </p>

</div>
</div>
<a id="ad09bc2b2dbd51767ef7ddf18b01d312b" name="ad09bc2b2dbd51767ef7ddf18b01d312b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09bc2b2dbd51767ef7ddf18b01d312b">&#9670;&#160;</a></span>Equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Equals </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to perform a == operation on two values. </p>

</div>
</div>
<a id="af47f186e20fc927517899eecfc8d480c" name="af47f186e20fc927517899eecfc8d480c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47f186e20fc927517899eecfc8d480c">&#9670;&#160;</a></span>GetArrayElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> GetArrayElement </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to return a scalar at the provided index from this array value. Will generate invalid IR if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is not an array. </p>

</div>
</div>
<a id="a01e6d74c0e36fd0090cd7f6d082e52c3" name="a01e6d74c0e36fd0090cd7f6d082e52c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e6d74c0e36fd0090cd7f6d082e52c3">&#9670;&#160;</a></span>GetArrayElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> GetArrayElement </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to return a scalar at the provided index from this array value. Will generate invalid IR if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is not an array or if idx is not an integer. </p>

</div>
</div>
<a id="a1669a4540307c54cf3a3f2acd0d348a3" name="a1669a4540307c54cf3a3f2acd0d348a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1669a4540307c54cf3a3f2acd0d348a3">&#9670;&#160;</a></span>GetArrayNumElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t GetArrayNumElements </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements in this array type. </p>

</div>
</div>
<a id="a30e280dd2280c559f768ecb54369f17c" name="a30e280dd2280c559f768ecb54369f17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e280dd2280c559f768ecb54369f17c">&#9670;&#160;</a></span>GetUnderlyingScalarType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * GetUnderlyingScalarType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the underlying scalar type. This method assumes the current value is a scalar or array. </p>

</div>
</div>
<a id="ada60346a0c2d80cd2129b87c43abde1b" name="ada60346a0c2d80cd2129b87c43abde1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada60346a0c2d80cd2129b87c43abde1b">&#9670;&#160;</a></span>GetUnderlyingType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type * GetUnderlyingType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the underlying llvm Type. </p>

</div>
</div>
<a id="a6577cd1121c4c1a75a34f180c1791b5d" name="a6577cd1121c4c1a75a34f180c1791b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6577cd1121c4c1a75a34f180c1791b5d">&#9670;&#160;</a></span>GetValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * GetValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the underlying llvm <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a>. </p>

</div>
</div>
<a id="af334275aeeeed6256f2b22d5edce27d7" name="af334275aeeeed6256f2b22d5edce27d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af334275aeeeed6256f2b22d5edce27d7">&#9670;&#160;</a></span>GreaterThan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> GreaterThan </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to perform a &gt; operation on two values. </p>

</div>
</div>
<a id="ad3c9b52e02125d4331c9ef6b60360668" name="ad3c9b52e02125d4331c9ef6b60360668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c9b52e02125d4331c9ef6b60360668">&#9670;&#160;</a></span>GreaterThanEquals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> GreaterThanEquals </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to perform a &gt;= operation on two values. </p>

</div>
</div>
<a id="a647b84b424b76ec07b16fad6c9d87592" name="a647b84b424b76ec07b16fad6c9d87592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647b84b424b76ec07b16fad6c9d87592">&#9670;&#160;</a></span>Increment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Increment </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to increment this scalar (i.e. value + 1). Will return <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> and report a message to a logger (if provided) if this is not an integer (non-bool) or float scalar. </p>

</div>
</div>
<a id="ae7b37f5a2cdb54151612f3cf5660ee95" name="ae7b37f5a2cdb54151612f3cf5660ee95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b37f5a2cdb54151612f3cf5660ee95">&#9670;&#160;</a></span>Invalid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Invalid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an invalid <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a>. This is used to represent various fail cases. Note that the operator bool(Value) will return false in for <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid</a>. </p>

</div>
</div>
<a id="aebef9889d05411b93c68c9a7d9d773cf" name="aebef9889d05411b93c68c9a7d9d773cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebef9889d05411b93c68c9a7d9d773cf">&#9670;&#160;</a></span>IsArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsArray </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the underlying type is an array type. </p>
<dl class="section note"><dt>Note</dt><dd>An array type's state is only ever a pointer to an array allocation </dd></dl>

</div>
</div>
<a id="aec3bdef27fa2d4de29db82d2334ad2d8" name="aec3bdef27fa2d4de29db82d2334ad2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3bdef27fa2d4de29db82d2334ad2d8">&#9670;&#160;</a></span>IsBool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsBool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the underlying type is a bool type. </p>
<dl class="section note"><dt>Note</dt><dd>A bool's underlying state can be either as a pointer or loaded. This method returns true in both instances if the underlying type is a bool. </dd></dl>

</div>
</div>
<a id="a945263e85c27f3216a8323cfc16d8919" name="a945263e85c27f3216a8323cfc16d8919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945263e85c27f3216a8323cfc16d8919">&#9670;&#160;</a></span>IsConstant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsConstant </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is a constant. </p>

</div>
</div>
<a id="aec0a6f81c7581924db00ea960358d91b" name="aec0a6f81c7581924db00ea960358d91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0a6f81c7581924db00ea960358d91b">&#9670;&#160;</a></span>IsFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsFloat </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the underlying type is an floating point type (float or double). </p>
<dl class="section note"><dt>Note</dt><dd>A float's underlying state can be either as a pointer or loaded. This method returns true in both instances if the underlying type is a float/double. </dd></dl>

</div>
</div>
<a id="a8543c359835d7977b96446aaef126344" name="a8543c359835d7977b96446aaef126344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8543c359835d7977b96446aaef126344">&#9670;&#160;</a></span>IsInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsInteger </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the underlying type is an integer type. </p>
<dl class="section note"><dt>Note</dt><dd>A integer's underlying state can be either as a pointer or loaded. This method returns true in both instances if the underlying type is a integer. </dd></dl>

</div>
</div>
<a id="a67bbed67c4fb5ea68910d94436586c15" name="a67bbed67c4fb5ea68910d94436586c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67bbed67c4fb5ea68910d94436586c15">&#9670;&#160;</a></span>IsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the underlying type is an matrix 3/4 type. </p>
<dl class="section note"><dt>Note</dt><dd>An matrix type's state is only ever a pointer to a matrix allocation </dd></dl>

</div>
</div>
<a id="a54b329322e112db3aba13759f17e34b7" name="a54b329322e112db3aba13759f17e34b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b329322e112db3aba13759f17e34b7">&#9670;&#160;</a></span>IsNan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> IsNan </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to check whether this value is NaN. Only works on Float types and will generate invalid IR if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is not a Float instance. </p>

</div>
</div>
<a id="a09d6e9ac47124e88096e798870d5f0b0" name="a09d6e9ac47124e88096e798870d5f0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d6e9ac47124e88096e798870d5f0b0">&#9670;&#160;</a></span>IsPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsPtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is a pointer type. </p>

</div>
</div>
<a id="af494171df1c635b5a9f298e8c29c2fc1" name="af494171df1c635b5a9f298e8c29c2fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af494171df1c635b5a9f298e8c29c2fc1">&#9670;&#160;</a></span>IsScalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsScalar </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the underlying type is a scalar type (bool, int or float). </p>
<dl class="section note"><dt>Note</dt><dd>A scalar's underlying state can be either as a pointer or loaded. This method returns true in both instances if the underlying type is a scalar. </dd></dl>

</div>
</div>
<a id="a7c412f98489e7d252ef40ed053a3908c" name="a7c412f98489e7d252ef40ed053a3908c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c412f98489e7d252ef40ed053a3908c">&#9670;&#160;</a></span>IsString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the underlying type is a string type. </p>
<dl class="section note"><dt>Note</dt><dd>An string type's state is only ever a pointer to a string allocation </dd></dl>

</div>
</div>
<a id="a788925e7d55dc45e3a12e30996af89b0" name="a788925e7d55dc45e3a12e30996af89b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788925e7d55dc45e3a12e30996af89b0">&#9670;&#160;</a></span>IsVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsVector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the underlying type is an vector 2/3/4 type. </p>
<dl class="section note"><dt>Note</dt><dd>An vector type's state is only ever a pointer to a vector allocation </dd></dl>

</div>
</div>
<a id="a570248cd9330baed655617a941f0de1f" name="a570248cd9330baed655617a941f0de1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570248cd9330baed655617a941f0de1f">&#9670;&#160;</a></span>IsVoid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsVoid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this value represents a void type. This is typically only possible for void function returns. </p>
<dl class="section note"><dt>Note</dt><dd>Void types are only ever explicitly void, never pointers to void </dd></dl>

</div>
</div>
<a id="a756e30464eb00e5c9630b6fcf1f28911" name="a756e30464eb00e5c9630b6fcf1f28911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756e30464eb00e5c9630b6fcf1f28911">&#9670;&#160;</a></span>LessThan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> LessThan </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to perform a &lt; operation on two values. </p>

</div>
</div>
<a id="a1b99718710acf558aeb45a147a35766d" name="a1b99718710acf558aeb45a147a35766d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b99718710acf558aeb45a147a35766d">&#9670;&#160;</a></span>LessThanEquals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> LessThanEquals </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to perform a &lt;= operation on two values. </p>

</div>
</div>
<a id="a4cf2984de21731f80e61fba108bea320" name="a4cf2984de21731f80e61fba108bea320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf2984de21731f80e61fba108bea320">&#9670;&#160;</a></span>Load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Load </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to load the current value. Not typically required to call directly. Will generate invalid IR if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is not a Ptr. </p>
<dl class="section warning"><dt>Warning</dt><dd>Should only ever be called for ptrs to scalar types </dd></dl>

</div>
</div>
<a id="ac08ee3d13ecdc8fde09a16dae84ef212" name="ac08ee3d13ecdc8fde09a16dae84ef212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08ee3d13ecdc8fde09a16dae84ef212">&#9670;&#160;</a></span>LoadIfPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> LoadIfPtr </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to load the current value if it is a ptr. Not typically required to call directly. </p>
<dl class="section warning"><dt>Warning</dt><dd>Should only ever be called for ptrs to scalar types </dd></dl>

</div>
</div>
<a id="a5c90353181d6b0613e3aee380ca7bbcc" name="a5c90353181d6b0613e3aee380ca7bbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c90353181d6b0613e3aee380ca7bbcc">&#9670;&#160;</a></span>Modulo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Modulo </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to perform a FLOORED % operation on two values. </p>

</div>
</div>
<a id="aa97f96c9dcb69b91b156f60770a90d52" name="aa97f96c9dcb69b91b156f60770a90d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97f96c9dcb69b91b156f60770a90d52">&#9670;&#160;</a></span>Multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Multiply </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to perform a * operation on two values. </p>

</div>
</div>
<a id="aa1bac88ea89ac7d7ab76c568840dd3b7" name="aa1bac88ea89ac7d7ab76c568840dd3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1bac88ea89ac7d7ab76c568840dd3b7">&#9670;&#160;</a></span>Negate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Negate </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to create a unary not instruction on this scalar or array (i.e. -value). If the value is not a int/float/array, no IR is is emitted, a warning is logged (if a logger is provided) and <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid</a> is returned. </p>

</div>
</div>
<a id="aa04abd82dc75046b8a80253c02d45891" name="aa04abd82dc75046b8a80253c02d45891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04abd82dc75046b8a80253c02d45891">&#9670;&#160;</a></span>Not()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Not </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to create a unary not instruction on this scalar or integer array (i.e. !value). If the value is not a int/float/integer array, no IR is emitted, a warning is logged (if a logger is provided) and <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid</a> is returned. </p>

</div>
</div>
<a id="a70115eb7e06126610ff309fff9ade3ae" name="a70115eb7e06126610ff309fff9ade3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70115eb7e06126610ff309fff9ade3ae">&#9670;&#160;</a></span>NotEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> NotEquals </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to perform a != operation on two values. </p>

</div>
</div>
<a id="aa5e4ba05990e316ee90cfae290b20ff1" name="aa5e4ba05990e316ee90cfae290b20ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e4ba05990e316ee90cfae290b20ff1">&#9670;&#160;</a></span>One()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> One </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new one scalar <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> using the underlying scalar precision of this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a>. Does not generate IR, however will return an invalid constant if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is a string. </p>

</div>
</div>
<a id="a67b76affb3b5d35fa419ac234144038b" name="a67b76affb3b5d35fa419ac234144038b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b76affb3b5d35fa419ac234144038b">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operator bool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> contains an active underlying llvm Value/Type. When asserts are enabled. This method strictly checks all possible valid combination types of a <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a>. </p>

</div>
</div>
<a id="a61efd4196a96540ee018fee8791f3f10" name="a61efd4196a96540ee018fee8791f3f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61efd4196a96540ee018fee8791f3f10">&#9670;&#160;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator! </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See bool operator. </p>

</div>
</div>
<a id="a6c7270f705a7c86fbc34de656d7fad96" name="a6c7270f705a7c86fbc34de656d7fad96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7270f705a7c86fbc34de656d7fad96">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8740147fc9b7c56de2381f3b668e8d2" name="aa8740147fc9b7c56de2381f3b668e8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8740147fc9b7c56de2381f3b668e8d2">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10a3f2e805d445de43cb5f8c03d2d637" name="a10a3f2e805d445de43cb5f8c03d2d637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a3f2e805d445de43cb5f8c03d2d637">&#9670;&#160;</a></span>Or()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Or </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to perform a || operation on two scalars. Assumes both inputs are scalars (this checking is currently done in the ComputeGenerator) and will cause undefined behaviour if they are not. </p>
<dl class="section warning"><dt>Warning</dt><dd>This does not perform short circuiting. See: ComputeGenerator::visit(const ast::BinaryOperator*) </dd></dl>

</div>
</div>
<a id="ad93edbe885499a712129356f1ffd506b" name="ad93edbe885499a712129356f1ffd506b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93edbe885499a712129356f1ffd506b">&#9670;&#160;</a></span>Print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Print </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump this value/type to llvm::errs. </p>

</div>
</div>
<a id="a9bc815b938a9a0202ed72b12b8ee4659" name="a9bc815b938a9a0202ed72b12b8ee4659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc815b938a9a0202ed72b12b8ee4659">&#9670;&#160;</a></span>Return()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Return </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> *</td>          <td class="paramname"><span class="paramname"><em>ret</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a value that represents a return value from a function. Really only intended to be used by the function framework. If ret is not provided, a void return is created. </p>

</div>
</div>
<a id="a5af32cfeabe460233bde112b23f419cc" name="a5af32cfeabe460233bde112b23f419cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af32cfeabe460233bde112b23f419cc">&#9670;&#160;</a></span>ScalarBoolComparison()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> ScalarBoolComparison </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to perform standard boolean comparison on this scalar i.e. bool(scalar) or bool(scalar == 0). Returns a <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> of type bool. Will return <a class="el" href="#ae7b37f5a2cdb54151612f3cf5660ee95" title="Return an invalid Value. This is used to represent various fail cases. Note that the operator bool(Va...">Value::Invalid()</a> if this is not a bool/int/float. </p>

</div>
</div>
<a id="a48ea2ec06adecb5c46b19e9445674b52" name="a48ea2ec06adecb5c46b19e9445674b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ea2ec06adecb5c46b19e9445674b52">&#9670;&#160;</a></span>ScalarsToArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> ScalarsToArray </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to create an array from a set of scalar values. Will generate invalid IR if the values are not all scalar or are of different precision. values cannot be empty. </p>

</div>
</div>
<a id="a28b787433abc7269a6661d21c87441fc" name="a28b787433abc7269a6661d21c87441fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b787433abc7269a6661d21c87441fc">&#9670;&#160;</a></span>ScalarToArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> ScalarToArray </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to broadcast this scalar to a new array. Will generated invalid IR if this is not a scalar or if size is zero. </p>
<dl class="section warning"><dt>Warning</dt><dd>This fills the array with the current scalar value. It does NOT do scalar-&gt;matrix promotion. </dd></dl>

</div>
</div>
<a id="a8fdbf6698b8a5fb5e79feb9bdc9f7db9" name="a8fdbf6698b8a5fb5e79feb9bdc9f7db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fdbf6698b8a5fb5e79feb9bdc9f7db9">&#9670;&#160;</a></span>ScalarToIdentMatrix3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> ScalarToIdentMatrix3 </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to create a new 3x3 matrix from this scalar value, adhering to scalar-&gt;matrix promotion rules. Will generate invalid IR if this is not a scalar value. </p>

</div>
</div>
<a id="a3154dacc5465cf42b991cab1c47574ff" name="a3154dacc5465cf42b991cab1c47574ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3154dacc5465cf42b991cab1c47574ff">&#9670;&#160;</a></span>ScalarToIdentMatrix4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> ScalarToIdentMatrix4 </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to create a new 4x4 matrix from this scalar value, adhering to scalar-&gt;matrix promotion rules. Will generate invalid IR if this is not a scalar value. </p>

</div>
</div>
<a id="ac5bee25f9934e25f8fab05516b604b1a" name="ac5bee25f9934e25f8fab05516b604b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bee25f9934e25f8fab05516b604b1a">&#9670;&#160;</a></span>Select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Select </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>trueval</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>falseval</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to select a value based on this boolean scalar value. Will generate invalid IR if this is not a boolean value, or if trueval and falseval have different types. </p>

</div>
</div>
<a id="a44512bd52c394f54fb30fa98cbc71fa7" name="a44512bd52c394f54fb30fa98cbc71fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44512bd52c394f54fb30fa98cbc71fa7">&#9670;&#160;</a></span>ShiftLeft()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> ShiftLeft </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to perform a &lt;&lt; operation. Both values must be integers. </p>

</div>
</div>
<a id="a9b7d3966549d7c90bf7d0d288ddc84ab" name="a9b7d3966549d7c90bf7d0d288ddc84ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7d3966549d7c90bf7d0d288ddc84ab">&#9670;&#160;</a></span>ShiftRight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> ShiftRight </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit IR to perform a &gt;&gt; operation. Both values must be integers. </p>

</div>
</div>
<a id="adb71bd1d9d83020b64181f5fdd1c66d0" name="adb71bd1d9d83020b64181f5fdd1c66d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb71bd1d9d83020b64181f5fdd1c66d0">&#9670;&#160;</a></span>Subtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Subtract </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1Logger.html">Logger</a> *</td>          <td class="paramname"><span class="paramname"><em>log</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1ax_1_1ast_1_1Node.html">ax::ast::Node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to perform a - operation on two values. </p>

</div>
</div>
<a id="afe3641dcd176e38147ea7f36baaa62ab" name="afe3641dcd176e38147ea7f36baaa62ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3641dcd176e38147ea7f36baaa62ab">&#9670;&#160;</a></span>Supports()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Supports </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *</td>          <td class="paramname"><span class="paramname"><em>utype</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the underlying type held by utype is supported via the interface of this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> class. </p>

</div>
</div>
<a id="ae1defcb5aafeb4c68cbc012bb579fd18" name="ae1defcb5aafeb4c68cbc012bb579fd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1defcb5aafeb4c68cbc012bb579fd18">&#9670;&#160;</a></span>TruncatedModulo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> TruncatedModulo </td>
          <td>(</td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit IR to perform a TRUNCATED % operation on two values. </p>

</div>
</div>
<a id="ae70dc3edb7f43c70d23625a2f9b1491e" name="ae70dc3edb7f43c70d23625a2f9b1491e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70dc3edb7f43c70d23625a2f9b1491e">&#9670;&#160;</a></span>Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a> Zero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new zero scalar <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> using the underlying scalar precision of this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a>. Does not generate IR, however will return an invalid constant if this <a class="el" href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html" title="Intermediate representation wrapper for supported value types in AX as immutable instances.">Value</a> is a string. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax.html">ax</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1ax_1_1codegen.html">codegen</a></li><li class="navelem"><a href="classopenvdb_1_1v13__0_1_1ax_1_1codegen_1_1Value.html">Value</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
