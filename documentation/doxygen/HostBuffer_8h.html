<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: nanovdb/HostBuffer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('HostBuffer_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">HostBuffer.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>HostBuffer - a buffer that contains a shared or private bump pool to either externally or internally managed host memory.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="NanoVDB_8h_source.html">nanovdb/NanoVDB.h</a>&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;cstdio&gt;</code><br />
<code>#include &lt;cstdlib&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;mutex&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
</div>
<p><a href="HostBuffer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:BufferTraits_3C_20BufferT_20_3E" id="r_BufferTraits_3C_20BufferT_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1BufferTraits.html">BufferTraits&lt; BufferT &gt;</a></td></tr>
<tr class="memitem:HostBuffer" id="r_HostBuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnanovdb_1_1HostBuffer.html">HostBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a buffer that contains a shared or private pool to either externally or internally managed host memory.  <a href="classnanovdb_1_1HostBuffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:HostBuffer_3A_3APool" id="r_HostBuffer_3A_3APool"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnanovdb_1_1HostBuffer_1_1Pool.html">HostBuffer::Pool</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:nanovdb" id="r_nanovdb"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenanovdb.html">nanovdb</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aff2830fced928188855df8b9366e031f" id="r_aff2830fced928188855df8b9366e031f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff2830fced928188855df8b9366e031f">checkPtr</a>(ptr,  msg)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>HostBuffer - a buffer that contains a shared or private bump pool to either externally or internally managed host memory. </p>
<dl class="section date"><dt>Date</dt><dd>April 20, 2021</dd></dl>
<p>This HostBuffer can be used in multiple ways, most of which are demonstrated in the examples below. Memory in the pool can be managed or unmanged (e.g. internal or external) and can be shared between multiple buffers or belong to a single buffer.</p>
<p>Example that uses HostBuffer::create inside io::readGrids to create a full self-managed buffer, i.e. not shared and without padding, per grid in the file. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> handles = nanovdb::io::readGrids(<span class="stringliteral">&quot;file.nvdb&quot;</span>);</div>
</div><!-- fragment --><p>Example that uses HostBuffer::createFull. Assuming you have a raw pointer to a NanoVDB grid of unknown type, this examples shows how to create its GridHandle which can be used to enquire about the grid type and meta data. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span>    *data;<span class="comment">// pointer to a NanoVDB grid of unknown type</span></div>
<div class="line">uint64_t size;<span class="comment">// byte size of NanoVDB grid of unknown type</span></div>
<div class="line"><span class="keyword">auto</span> buffer = <a class="code hl_function" href="classnanovdb_1_1HostBuffer.html#a659568e91cdae3848f81aace40620554">nanovdb::HostBuffer::createFull</a>(size, data);</div>
<div class="line"><a class="code hl_class" href="classnanovdb_1_1GridHandle.html">nanovdb::GridHandle&lt;&gt;</a> gridHandle(std::move(buffer));</div>
<div class="ttc" id="aclassnanovdb_1_1GridHandle_html"><div class="ttname"><a href="classnanovdb_1_1GridHandle.html">nanovdb::GridHandle</a></div><div class="ttdoc">This class serves to manage a buffer containing one or more NanoVDB Grids.</div><div class="ttdef"><b>Definition</b> GridHandle.h:38</div></div>
<div class="ttc" id="aclassnanovdb_1_1HostBuffer_html_a659568e91cdae3848f81aace40620554"><div class="ttname"><a href="classnanovdb_1_1HostBuffer.html#a659568e91cdae3848f81aace40620554">nanovdb::HostBuffer::createFull</a></div><div class="ttdeci">static HostBuffer createFull(uint64_t bufferSize, void *data=nullptr)</div><div class="ttdoc">Return a full buffer which satisfies: buffer.size == bufferSize, buffer.poolSize() == bufferSize,...</div><div class="ttdef"><b>Definition</b> HostBuffer.h:537</div></div>
</div><!-- fragment --><p>Example that uses HostBuffer::createPool for internally managed host memory. Suppose you want to read multiple grids in multiple files, but reuse the same fixed sized memory buffer to both avoid memory fragmentation as well as exceeding the fixed memory ceiling! </p><div class="fragment"><div class="line"><span class="keyword">auto</span> pool = <a class="code hl_function" href="classnanovdb_1_1HostBuffer.html#aef4c6ec0920591bf597e2d3a37f2ef1e">nanovdb::HostBuffer::createPool</a>(1 &lt;&lt; 30);<span class="comment">// 1 GB memory pool</span></div>
<div class="line">std::vector&lt;std::string&gt;&gt; frames;<span class="comment">// vector of grid names</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;frames.size(); ++i) {</div>
<div class="line">    <span class="keyword">auto</span> handles = nanovdb::io::readGrids(frames[i], 0, pool);<span class="comment">// throws if grids in file exceed 1 GB</span></div>
<div class="line">    ...</div>
<div class="line">    pool.reset();<span class="comment">// clears all handles and resets the memory pool for reuse</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassnanovdb_1_1HostBuffer_html_aef4c6ec0920591bf597e2d3a37f2ef1e"><div class="ttname"><a href="classnanovdb_1_1HostBuffer.html#aef4c6ec0920591bf597e2d3a37f2ef1e">nanovdb::HostBuffer::createPool</a></div><div class="ttdeci">static HostBuffer createPool(uint64_t poolSize, void *data=nullptr)</div><div class="ttdoc">Return a pool buffer which satisfies: buffer.size == 0, buffer.poolSize() == poolSize,...</div><div class="ttdef"><b>Definition</b> HostBuffer.h:524</div></div>
</div><!-- fragment --><p>Example that uses HostBuffer::createPool for externally managed host memory. Note that in this example <code>handles</code> are allowed to outlive <code>pool</code> since they internally store a shared pointer to the memory pool. However <code>data</code> MUST outlive <code>handles</code> since the pool does not own its memory in this example. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> poolSize = 1 &lt;&lt; 30;<span class="comment">// 1 GB</span></div>
<div class="line"><span class="keywordtype">void</span> *data = std::malloc(size + <a class="code hl_define" href="NanoVDB_8h.html#a54db29617e4e954de4af9721a183f789">NANOVDB_DATA_ALIGNMENT</a>);<span class="comment">// 1 GB pool with padding</span></div>
<div class="line"><span class="keywordtype">void</span> *buffer = <a class="code hl_function" href="namespacenanovdb.html#accecca045f04c7971c65022455b29d93">nanovdb::alignPtr</a>(data);<span class="comment">// 32B aligned buffer</span></div>
<div class="line"><span class="comment">//void *buffer = std::aligned_alloc(NANOVDB_DATA_ALIGNMENT, poolSize);// in C++17</span></div>
<div class="line"><span class="keyword">auto</span> pool = <a class="code hl_function" href="classnanovdb_1_1HostBuffer.html#aef4c6ec0920591bf597e2d3a37f2ef1e">nanovdb::HostBuffer::createPool</a>(poolSize, buffer);</div>
<div class="line"><span class="keyword">auto</span> handles1 = nanovdb::io::readGrids(<span class="stringliteral">&quot;file1.nvdb&quot;</span>, 0, pool);</div>
<div class="line"><span class="keyword">auto</span> handles2 = nanovdb::io::readGrids(<span class="stringliteral">&quot;file2.nvdb&quot;</span>, 0, pool);</div>
<div class="line">....</div>
<div class="line">std::free(data);</div>
<div class="line"><span class="comment">//std::free(buffer);</span></div>
<div class="ttc" id="aNanoVDB_8h_html_a54db29617e4e954de4af9721a183f789"><div class="ttname"><a href="NanoVDB_8h.html#a54db29617e4e954de4af9721a183f789">NANOVDB_DATA_ALIGNMENT</a></div><div class="ttdeci">#define NANOVDB_DATA_ALIGNMENT</div><div class="ttdef"><b>Definition</b> NanoVDB.h:133</div></div>
<div class="ttc" id="anamespacenanovdb_html_accecca045f04c7971c65022455b29d93"><div class="ttname"><a href="namespacenanovdb.html#accecca045f04c7971c65022455b29d93">nanovdb::alignPtr</a></div><div class="ttdeci">static __hostdev__ T * alignPtr(T *p)</div><div class="ttdoc">offset the specified pointer so it is 32 byte aligned. Works with both const and non-const pointers.</div><div class="ttdef"><b>Definition</b> NanoVDB.h:590</div></div>
</div><!-- fragment --><p>Example that uses HostBuffer::createPool for externally managed host memory. Note that in this example <code>handles</code> are allowed to outlive <code>pool</code> since they internally store a shared pointer to the memory pool. However <code>array</code> MUST outlive <code>handles</code> since the pool does not own its memory in this example. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> poolSize = 1 &lt;&lt; 30;<span class="comment">// 1 GB</span></div>
<div class="line">std::unique_ptr&lt;char[]&gt; array(<span class="keyword">new</span> <span class="keywordtype">char</span>[size + <a class="code hl_define" href="NanoVDB_8h.html#a54db29617e4e954de4af9721a183f789">NANOVDB_DATA_ALIGNMENT</a>]);<span class="comment">// scoped pool of 1 GB with padding</span></div>
<div class="line"><span class="keywordtype">void</span> *buffer = <a class="code hl_function" href="namespacenanovdb.html#accecca045f04c7971c65022455b29d93">nanovdb::alignPtr</a>(array.get());<span class="comment">// 32B aligned buffer</span></div>
<div class="line"><span class="keyword">auto</span> pool = <a class="code hl_function" href="classnanovdb_1_1HostBuffer.html#aef4c6ec0920591bf597e2d3a37f2ef1e">nanovdb::HostBuffer::createPool</a>(poolSize, buffer);</div>
<div class="line"><span class="keyword">auto</span> handles = nanovdb::io::readGrids(<span class="stringliteral">&quot;file.nvdb&quot;</span>, 0, pool);</div>
</div><!-- fragment --> </div><a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="aff2830fced928188855df8b9366e031f" name="aff2830fced928188855df8b9366e031f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2830fced928188855df8b9366e031f">&#9670;&#160;</a></span>checkPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define checkPtr</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>msg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    { \</div>
<div class="line">        ptrAssert((ptr), (msg), __FILE__, __LINE__); \</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_9862d8700dece0becc08811a9cb1ac22.html">nanovdb</a></li><li class="navelem"><a href="HostBuffer_8h.html">HostBuffer.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
