<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVDB: openvdb::v13_0::tools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="openvdb.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="openvdb_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">OpenVDB<span id="projectnumber">&#160;13.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespaceopenvdb_1_1v13__0_1_1tools.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">openvdb::v13_0::tools Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:composite" id="r_composite"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tools_1_1composite.html">composite</a></td></tr>
<tr class="memitem:ds" id="r_ds"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tools_1_1ds.html">ds</a></td></tr>
<tr class="memitem:gridop" id="r_gridop"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tools_1_1gridop.html">gridop</a></td></tr>
<tr class="memitem:local_5Futil" id="r_local_5Futil"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tools_1_1local__util.html">local_util</a></td></tr>
<tr class="memitem:lstrack" id="r_lstrack"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tools_1_1lstrack.html">lstrack</a></td></tr>
<tr class="memitem:morphology" id="r_morphology"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tools_1_1morphology.html">morphology</a></td></tr>
<tr class="memitem:poisson" id="r_poisson"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tools_1_1poisson.html">poisson</a></td></tr>
<tr class="memitem:Scheme" id="r_Scheme"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tools_1_1Scheme.html">Scheme</a></td></tr>
<tr class="memitem:valxform" id="r_valxform"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1tools_1_1valxform.html">valxform</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:ABTransform" id="r_ABTransform"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ABTransform.html">ABTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the Transformer functor interface (specifically, the <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ABTransform.html#a4c722ad515e5131a4c2ea6db32fd1bc8">isAffine()</a>, <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ABTransform.html#a13761cb66925063fa49b4f0e9ab218db">transform()</a> and <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ABTransform.html#adab86fc65973b11b9582fdccd9442b2f">invTransform()</a> methods) for a transform that maps an A grid into a B grid's index space such that, after resampling, A's index space and transform match B's index space and transform.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1ABTransform.html#details">More...</a><br /></td></tr>
<tr class="memitem:AlphaMask" id="r_AlphaMask"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1AlphaMask.html">AlphaMask</a></td></tr>
<tr class="memitem:BaseCamera" id="r_BaseCamera"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1BaseCamera.html">BaseCamera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for the perspective and orthographic cameras.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1BaseCamera.html#details">More...</a><br /></td></tr>
<tr class="memitem:BasePointScatter" id="r_BasePointScatter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1BasePointScatter.html">BasePointScatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of base class.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1BasePointScatter.html#details">More...</a><br /></td></tr>
<tr class="memitem:BaseShader" id="r_BaseShader"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1BaseShader.html">BaseShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for the shaders.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1BaseShader.html#details">More...</a><br /></td></tr>
<tr class="memitem:BoxSampler" id="r_BoxSampler"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1BoxSampler.html">BoxSampler</a></td></tr>
<tr class="memitem:ChangeBackgroundOp" id="r_ChangeBackgroundOp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ChangeBackgroundOp.html">ChangeBackgroundOp</a></td></tr>
<tr class="memitem:ChangeLevelSetBackgroundOp" id="r_ChangeLevelSetBackgroundOp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ChangeLevelSetBackgroundOp.html">ChangeLevelSetBackgroundOp</a></td></tr>
<tr class="memitem:CheckDivergence" id="r_CheckDivergence"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CheckDivergence.html">CheckDivergence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the divergence against a range.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1CheckDivergence.html#details">More...</a><br /></td></tr>
<tr class="memitem:CheckEikonal" id="r_CheckEikonal"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CheckEikonal.html">CheckEikonal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the norm of the gradient at zero-crossing voxels against a range.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1CheckEikonal.html#details">More...</a><br /></td></tr>
<tr class="memitem:CheckFinite" id="r_CheckFinite"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CheckFinite.html">CheckFinite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for both NaN and inf values, i.e. any value that is not finite.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1CheckFinite.html#details">More...</a><br /></td></tr>
<tr class="memitem:CheckFogVolume" id="r_CheckFogVolume"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1CheckFogVolume.html">CheckFogVolume</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that performs various types of checks on fog volumes.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1CheckFogVolume.html#details">More...</a><br /></td></tr>
<tr class="memitem:CheckInf" id="r_CheckInf"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CheckInf.html">CheckInf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for infinite values, e.g. 1/0 or -1/0.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1CheckInf.html#details">More...</a><br /></td></tr>
<tr class="memitem:CheckLevelSet" id="r_CheckLevelSet"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1CheckLevelSet.html">CheckLevelSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that performs various types of checks on narrow-band level sets.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1CheckLevelSet.html#details">More...</a><br /></td></tr>
<tr class="memitem:CheckMagnitude" id="r_CheckMagnitude"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CheckMagnitude.html">CheckMagnitude</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the magnitude of a value, a, is close to a fixed magnitude, b, given a fixed tolerance c. That is | |a| - |b| | &lt;= c.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1CheckMagnitude.html#details">More...</a><br /></td></tr>
<tr class="memitem:CheckMax" id="r_CheckMax"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CheckMax.html">CheckMax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a value against a maximum.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1CheckMax.html#details">More...</a><br /></td></tr>
<tr class="memitem:CheckMin" id="r_CheckMin"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CheckMin.html">CheckMin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a value against a minimum.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1CheckMin.html#details">More...</a><br /></td></tr>
<tr class="memitem:CheckNan" id="r_CheckNan"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CheckNan.html">CheckNan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks NaN values.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1CheckNan.html#details">More...</a><br /></td></tr>
<tr class="memitem:CheckNormGrad" id="r_CheckNormGrad"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CheckNormGrad.html">CheckNormGrad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the norm of the gradient against a range, i.e., |&nabla;&Phi;| &isin; [min, max].  <a href="structopenvdb_1_1v13__0_1_1tools_1_1CheckNormGrad.html#details">More...</a><br /></td></tr>
<tr class="memitem:CheckRange" id="r_CheckRange"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CheckRange.html">CheckRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a value against a range.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1CheckRange.html#details">More...</a><br /></td></tr>
<tr class="memitem:ClosestPointProjector" id="r_ClosestPointProjector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ClosestPointProjector.html">ClosestPointProjector</a></td></tr>
<tr class="memitem:ClosestSurfacePoint" id="r_ClosestSurfacePoint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ClosestSurfacePoint.html">ClosestSurfacePoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accelerated closest surface point queries for narrow band level sets.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1ClosestSurfacePoint.html#details">More...</a><br /></td></tr>
<tr class="memitem:CompReplaceOp" id="r_CompReplaceOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CompReplaceOp.html">CompReplaceOp</a></td></tr>
<tr class="memitem:ConstrainedPointAdvect" id="r_ConstrainedPointAdvect"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ConstrainedPointAdvect.html">ConstrainedPointAdvect</a></td></tr>
<tr class="memitem:ContiguousOp" id="r_ContiguousOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ContiguousOp.html">ContiguousOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a wrapper struct used to avoid unnecessary computation of memory access from <code><a class="el" href="classopenvdb_1_1v13__0_1_1Coord.html" title="Signed (x, y, z) 32-bit integer coordinates.">Coord</a></code> when all offsets are guaranteed to be within the dense grid.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1ContiguousOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:CopyFromDense" id="r_CopyFromDense"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1CopyFromDense.html">CopyFromDense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the values from a dense grid into an OpenVDB tree.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1CopyFromDense.html#details">More...</a><br /></td></tr>
<tr class="memitem:CopyToDense" id="r_CopyToDense"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1CopyToDense.html">CopyToDense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an OpenVDB tree into an existing dense grid.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1CopyToDense.html#details">More...</a><br /></td></tr>
<tr class="memitem:Cpt" id="r_Cpt"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Cpt.html">Cpt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the closest-point transform of a scalar grid.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1Cpt.html#details">More...</a><br /></td></tr>
<tr class="memitem:CsgDifferenceOp" id="r_CsgDifferenceOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CsgDifferenceOp.html">CsgDifferenceOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DynamicNodeManager operator to merge two trees using a CSG difference.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1CsgDifferenceOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:CsgUnionOrIntersectionOp" id="r_CsgUnionOrIntersectionOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CsgUnionOrIntersectionOp.html">CsgUnionOrIntersectionOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DynamicNodeManager operator to merge trees using a CSG union or intersection.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1CsgUnionOrIntersectionOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:Curl" id="r_Curl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Curl.html">Curl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the curl of a vector grid.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1Curl.html#details">More...</a><br /></td></tr>
<tr class="memitem:Dense" id="r_Dense"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Dense.html">Dense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Dense.html" title="Dense is a simple dense grid API used by the CopyToDense and CopyFromDense classes defined below.">Dense</a> is a simple dense grid API used by the <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1CopyToDense.html" title="Copy an OpenVDB tree into an existing dense grid.">CopyToDense</a> and <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1CopyFromDense.html" title="Copy the values from a dense grid into an OpenVDB tree.">CopyFromDense</a> classes defined below.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1Dense.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseBase" id="r_DenseBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1DenseBase.html">DenseBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Dense.html" title="Dense is a simple dense grid API used by the CopyToDense and CopyFromDense classes defined below.">Dense</a> which is defined below.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1DenseBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseBase_3C_20ValueT_2C_20LayoutXYZ_20_3E" id="r_DenseBase_3C_20ValueT_2C_20LayoutXYZ_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1DenseBase_3_01ValueT_00_01LayoutXYZ_01_4.html">DenseBase&lt; ValueT, LayoutXYZ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial template specialization of <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1DenseBase.html" title="Base class for Dense which is defined below.">DenseBase</a>.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1DenseBase_3_01ValueT_00_01LayoutXYZ_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseBase_3C_20ValueT_2C_20LayoutZYX_20_3E" id="r_DenseBase_3C_20ValueT_2C_20LayoutZYX_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1DenseBase_3_01ValueT_00_01LayoutZYX_01_4.html">DenseBase&lt; ValueT, LayoutZYX &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial template specialization of <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1DenseBase.html" title="Base class for Dense which is defined below.">DenseBase</a>.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1DenseBase_3_01ValueT_00_01LayoutZYX_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseTransformer" id="r_DenseTransformer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1DenseTransformer.html">DenseTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that applies a functor to the index space intersection of a prescribed bounding box and the dense grid. NB: This class only supports DenseGrids with ZYX memory layout.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1DenseTransformer.html#details">More...</a><br /></td></tr>
<tr class="memitem:DenseUniformPointScatter" id="r_DenseUniformPointScatter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1DenseUniformPointScatter.html">DenseUniformPointScatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters a fixed (and integer) number of points in all active voxels and tiles.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1DenseUniformPointScatter.html#details">More...</a><br /></td></tr>
<tr class="memitem:DepthFirstNodeVisitor" id="r_DepthFirstNodeVisitor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1DepthFirstNodeVisitor.html">DepthFirstNodeVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit all nodes that are downstream of a specific node in depth-first order and apply a user-supplied functor to each node.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1DepthFirstNodeVisitor.html#details">More...</a><br /></td></tr>
<tr class="memitem:DepthFirstNodeVisitor_3C_20NodeT_2C_200_20_3E" id="r_DepthFirstNodeVisitor_3C_20NodeT_2C_200_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1DepthFirstNodeVisitor_3_01NodeT_00_010_01_4.html">DepthFirstNodeVisitor&lt; NodeT, 0 &gt;</a></td></tr>
<tr class="memitem:Diagnose" id="r_Diagnose"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Diagnose.html">Diagnose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs multithreaded diagnostics of a grid.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1Diagnose.html#details">More...</a><br /></td></tr>
<tr class="memitem:DiffuseShader" id="r_DiffuseShader"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1DiffuseShader.html">DiffuseShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple diffuse Lambertian surface shader.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1DiffuseShader.html#details">More...</a><br /></td></tr>
<tr class="memitem:DiffuseShader_3C_20Film_3A_3ARGBA_2C_20SamplerType_20_3E" id="r_DiffuseShader_3C_20Film_3A_3ARGBA_2C_20SamplerType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1DiffuseShader_3_01Film_1_1RGBA_00_01SamplerType_01_4.html">DiffuseShader&lt; Film::RGBA, SamplerType &gt;</a></td></tr>
<tr class="memitem:DiracDelta" id="r_DiracDelta"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1DiracDelta.html">DiracDelta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smeared-out and continuous Dirac Delta function.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1DiracDelta.html#details">More...</a><br /></td></tr>
<tr class="memitem:DiscreteField" id="r_DiscreteField"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1DiscreteField.html">DiscreteField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thin wrapper class for a velocity grid.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1DiscreteField.html#details">More...</a><br /></td></tr>
<tr class="memitem:Divergence" id="r_Divergence"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Divergence.html">Divergence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the divergence of a vector grid.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1Divergence.html#details">More...</a><br /></td></tr>
<tr class="memitem:DSConverter" id="r_DSConverter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1DSConverter.html">DSConverter</a></td></tr>
<tr class="memitem:DualGridSampler" id="r_DualGridSampler"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1DualGridSampler.html">DualGridSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple convenience class that allows for sampling from a source grid into the index space of a target grid. At construction the source and target grids are checked for alignment which potentially renders interpolation unnecessary. Else interpolation is performed according to the templated <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler.html" title="Provises a unified interface for sampling, i.e. interpolation.">Sampler</a> type.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1DualGridSampler.html#details">More...</a><br /></td></tr>
<tr class="memitem:DualGridSampler_3C_20tree_3A_3AValueAccessor_3C_20TreeT_20_3E_2C_20SamplerT_20_3E" id="r_DualGridSampler_3C_20tree_3A_3AValueAccessor_3C_20TreeT_20_3E_2C_20SamplerT_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1DualGridSampler_3_01tree_1_1ValueAccessor_3_01TreeT_01_4_00_01SamplerT_01_4.html">DualGridSampler&lt; tree::ValueAccessor&lt; TreeT &gt;, SamplerT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1DualGridSampler.html" title="This is a simple convenience class that allows for sampling from a source grid into the index space o...">DualGridSampler</a> for construction from a ValueAccessor type.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1DualGridSampler_3_01tree_1_1ValueAccessor_3_01TreeT_01_4_00_01SamplerT_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:EnrightField" id="r_EnrightField"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1EnrightField.html">EnrightField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analytical, divergence-free and periodic velocity field.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1EnrightField.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExtractAll" id="r_ExtractAll"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ExtractAll.html">ExtractAll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple utility class used by <code>extractSparseTreeWithMask</code>  <a href="structopenvdb_1_1v13__0_1_1tools_1_1ExtractAll.html#details">More...</a><br /></td></tr>
<tr class="memitem:FastSweeping" id="r_FastSweeping"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1FastSweeping.html">FastSweeping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes signed distance values from an initial iso-surface and optionally performs velocity extension at the same time. This is done by means of a novel sparse and parallel fast sweeping algorithm based on a first order Godunov's scheme.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1FastSweeping.html#details">More...</a><br /></td></tr>
<tr class="memitem:Film" id="r_Film"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Film.html">Film</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class that allows for concurrent writes to pixels in an image, background initialization of the image, and PPM file output.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1Film.html#details">More...</a><br /></td></tr>
<tr class="memitem:Filter" id="r_Filter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Filter.html">Filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume filtering (e.g., diffusion) with optional alpha masking.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1Filter.html#details">More...</a><br /></td></tr>
<tr class="memitem:FindActiveValues" id="r_FindActiveValues"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1FindActiveValues.html">FindActiveValues</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the active values in a tree which intersects a bounding box.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1FindActiveValues.html#details">More...</a><br /></td></tr>
<tr class="memitem:Gradient" id="r_Gradient"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Gradient.html">Gradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of a scalar grid.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1Gradient.html#details">More...</a><br /></td></tr>
<tr class="memitem:GridResampler" id="r_GridResampler"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1GridResampler.html">GridResampler</a></td></tr>
<tr class="memitem:GridSampler" id="r_GridSampler"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1GridSampler.html">GridSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides the interface for continuous sampling of values in a tree.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1GridSampler.html#details">More...</a><br /></td></tr>
<tr class="memitem:GridSampler_3C_20tree_3A_3AValueAccessor_3C_20TreeT_20_3E_2C_20SamplerType_20_3E" id="r_GridSampler_3C_20tree_3A_3AValueAccessor_3C_20TreeT_20_3E_2C_20SamplerType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1GridSampler_3_01tree_1_1ValueAccessor_3_01TreeT_01_4_00_01SamplerType_01_4.html">GridSampler&lt; tree::ValueAccessor&lt; TreeT &gt;, SamplerType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1GridSampler.html" title="Class that provides the interface for continuous sampling of values in a tree.">GridSampler</a> for construction from a ValueAccessor type.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1GridSampler_3_01tree_1_1ValueAccessor_3_01TreeT_01_4_00_01SamplerType_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:GridTransformer" id="r_GridTransformer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1GridTransformer.html">GridTransformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1GridTransformer.html" title="A GridTransformer applies a geometric transformation to an input grid using one of several sampling s...">GridTransformer</a> applies a geometric transformation to an input grid using one of several sampling schemes, and stores the result in an output grid.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1GridTransformer.html#details">More...</a><br /></td></tr>
<tr class="memitem:HalfWidthOp" id="r_HalfWidthOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1HalfWidthOp.html">HalfWidthOp</a></td></tr>
<tr class="memitem:HalfWidthOp_3C_20bool_20_3E" id="r_HalfWidthOp_3C_20bool_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1HalfWidthOp_3_01bool_01_4.html">HalfWidthOp&lt; bool &gt;</a></td></tr>
<tr class="memitem:HomogeneousMatMul" id="r_HomogeneousMatMul"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1HomogeneousMatMul.html">HomogeneousMatMul</a></td></tr>
<tr class="memitem:InactivePruneOp" id="r_InactivePruneOp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1InactivePruneOp.html">InactivePruneOp</a></td></tr>
<tr class="memitem:Laplacian" id="r_Laplacian"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Laplacian.html">Laplacian</a></td></tr>
<tr class="memitem:LevelSetAdvection" id="r_LevelSetAdvection"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetAdvection.html">LevelSetAdvection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic advection of narrow-band level sets in an external velocity field.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetAdvection.html#details">More...</a><br /></td></tr>
<tr class="memitem:LevelSetFilter" id="r_LevelSetFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetFilter.html">LevelSetFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filtering (e.g. diffusion) of narrow-band level sets. An optional scalar field can be used to produce a (smooth) alpha mask for the filtering.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetFilter.html#details">More...</a><br /></td></tr>
<tr class="memitem:LevelSetFracture" id="r_LevelSetFracture"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetFracture.html">LevelSetFracture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level set fracturing.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetFracture.html#details">More...</a><br /></td></tr>
<tr class="memitem:LevelSetMeasure" id="r_LevelSetMeasure"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetMeasure.html">LevelSetMeasure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-threaded computation of surface area, volume and average mean-curvature for narrow band level sets.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetMeasure.html#details">More...</a><br /></td></tr>
<tr class="memitem:LevelSetMorphing" id="r_LevelSetMorphing"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetMorphing.html">LevelSetMorphing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape morphology of level sets. Morphing from a source narrow-band level sets to a target narrow-band level set.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetMorphing.html#details">More...</a><br /></td></tr>
<tr class="memitem:LevelSetPruneOp" id="r_LevelSetPruneOp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetPruneOp.html">LevelSetPruneOp</a></td></tr>
<tr class="memitem:LevelSetRayIntersector" id="r_LevelSetRayIntersector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetRayIntersector.html">LevelSetRayIntersector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the public API for intersecting a ray with a narrow-band level set.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetRayIntersector.html#details">More...</a><br /></td></tr>
<tr class="memitem:LevelSetRayTracer" id="r_LevelSetRayTracer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetRayTracer.html">LevelSetRayTracer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (very) simple multithreaded ray tracer specifically for narrow-band level sets.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetRayTracer.html#details">More...</a><br /></td></tr>
<tr class="memitem:LevelSetSphere" id="r_LevelSetSphere"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetSphere.html">LevelSetSphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a signed distance field (or narrow band level set) to a single sphere.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetSphere.html#details">More...</a><br /></td></tr>
<tr class="memitem:LevelSetTracker" id="r_LevelSetTracker"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetTracker.html">LevelSetTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs multi-threaded interface tracking of narrow band level sets.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetTracker.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinearSearchImpl" id="r_LinearSearchImpl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1LinearSearchImpl.html">LinearSearchImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements linear iterative search for an iso-value of the level set along the direction of the ray.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1LinearSearchImpl.html#details">More...</a><br /></td></tr>
<tr class="memitem:Magnitude" id="r_Magnitude"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Magnitude.html">Magnitude</a></td></tr>
<tr class="memitem:MatMul" id="r_MatMul"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1MatMul.html">MatMul</a></td></tr>
<tr class="memitem:MatMulNormalize" id="r_MatMulNormalize"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1MatMulNormalize.html">MatMulNormalize</a></td></tr>
<tr class="memitem:MatteShader" id="r_MatteShader"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1MatteShader.html">MatteShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shader that produces a simple matte.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1MatteShader.html#details">More...</a><br /></td></tr>
<tr class="memitem:MatteShader_3C_20Film_3A_3ARGBA_2C_20SamplerType_20_3E" id="r_MatteShader_3C_20Film_3A_3ARGBA_2C_20SamplerType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1MatteShader_3_01Film_1_1RGBA_00_01SamplerType_01_4.html">MatteShader&lt; Film::RGBA, SamplerType &gt;</a></td></tr>
<tr class="memitem:MeanCurvature" id="r_MeanCurvature"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1MeanCurvature.html">MeanCurvature</a></td></tr>
<tr class="memitem:MeshToVoxelEdgeData" id="r_MeshToVoxelEdgeData"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1MeshToVoxelEdgeData.html">MeshToVoxelEdgeData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts and stores voxel edge intersection data from a mesh.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1MeshToVoxelEdgeData.html#details">More...</a><br /></td></tr>
<tr class="memitem:MultiResGrid" id="r_MultiResGrid"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1MultiResGrid.html">MultiResGrid</a></td></tr>
<tr class="memitem:NonUniformPointScatter" id="r_NonUniformPointScatter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1NonUniformPointScatter.html">NonUniformPointScatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-uniform scatters of point in the active voxels. The local point count is implicitly defined as a product of of a global density (called pointsPerVolume) and the local voxel (or tile) value.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1NonUniformPointScatter.html#details">More...</a><br /></td></tr>
<tr class="memitem:Normalize" id="r_Normalize"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Normalize.html">Normalize</a></td></tr>
<tr class="memitem:NormalShader" id="r_NormalShader"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1NormalShader.html">NormalShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color shader that treats the surface normal (x, y, z) as an RGB color.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1NormalShader.html#details">More...</a><br /></td></tr>
<tr class="memitem:NormalShader_3C_20Film_3A_3ARGBA_2C_20SamplerType_20_3E" id="r_NormalShader_3C_20Film_3A_3ARGBA_2C_20SamplerType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1NormalShader_3_01Film_1_1RGBA_00_01SamplerType_01_4.html">NormalShader&lt; Film::RGBA, SamplerType &gt;</a></td></tr>
<tr class="memitem:OrthographicCamera" id="r_OrthographicCamera"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1OrthographicCamera.html">OrthographicCamera</a></td></tr>
<tr class="memitem:ParticleAtlas" id="r_ParticleAtlas"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ParticleAtlas.html">ParticleAtlas</a></td></tr>
<tr class="memitem:ParticlesToLevelSet" id="r_ParticlesToLevelSet"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ParticlesToLevelSet.html">ParticlesToLevelSet</a></td></tr>
<tr class="memitem:PerspectiveCamera" id="r_PerspectiveCamera"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1PerspectiveCamera.html">PerspectiveCamera</a></td></tr>
<tr class="memitem:PointAdvect" id="r_PointAdvect"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1PointAdvect.html">PointAdvect</a></td></tr>
<tr class="memitem:PointIndexFilter" id="r_PointIndexFilter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1PointIndexFilter.html">PointIndexFilter</a></td></tr>
<tr class="memitem:PointIndexIterator" id="r_PointIndexIterator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1PointIndexIterator.html">PointIndexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accelerated range and nearest-neighbor searches for point index grids.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1PointIndexIterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:PointIndexLeafNode" id="r_PointIndexLeafNode"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1PointIndexLeafNode.html">PointIndexLeafNode</a></td></tr>
<tr class="memitem:PointPartitioner" id="r_PointPartitioner"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1PointPartitioner.html">PointPartitioner</a></td></tr>
<tr class="memitem:PointSampler" id="r_PointSampler"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1PointSampler.html">PointSampler</a></td></tr>
<tr class="memitem:PointsToMask" id="r_PointsToMask"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1PointsToMask.html">PointsToMask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes every voxel of a grid active if it contains a point.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1PointsToMask.html#details">More...</a><br /></td></tr>
<tr class="memitem:PolygonPool" id="r_PolygonPool"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1PolygonPool.html">PolygonPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of quads and triangles.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1PolygonPool.html#details">More...</a><br /></td></tr>
<tr class="memitem:PositionShader" id="r_PositionShader"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1PositionShader.html">PositionShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color shader that treats position (x, y, z) as an RGB color in a cube defined from an axis-aligned bounding box in world space.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1PositionShader.html#details">More...</a><br /></td></tr>
<tr class="memitem:PositionShader_3C_20Film_3A_3ARGBA_2C_20SamplerType_20_3E" id="r_PositionShader_3C_20Film_3A_3ARGBA_2C_20SamplerType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1PositionShader_3_01Film_1_1RGBA_00_01SamplerType_01_4.html">PositionShader&lt; Film::RGBA, SamplerType &gt;</a></td></tr>
<tr class="memitem:QuadAndTriangleDataAdapter" id="r_QuadAndTriangleDataAdapter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1QuadAndTriangleDataAdapter.html">QuadAndTriangleDataAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contiguous quad and triangle data adapter class.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1QuadAndTriangleDataAdapter.html#details">More...</a><br /></td></tr>
<tr class="memitem:QuadraticSampler" id="r_QuadraticSampler"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1QuadraticSampler.html">QuadraticSampler</a></td></tr>
<tr class="memitem:Sampler" id="r_Sampler"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler.html">Sampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provises a unified interface for sampling, i.e. interpolation.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler.html#details">More...</a><br /></td></tr>
<tr class="memitem:Sampler_3C_200_2C_20false_20_3E" id="r_Sampler_3C_200_2C_20false_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler_3_010_00_01false_01_4.html">Sampler&lt; 0, false &gt;</a></td></tr>
<tr class="memitem:Sampler_3C_200_2C_20true_20_3E" id="r_Sampler_3C_200_2C_20true_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler_3_010_00_01true_01_4.html">Sampler&lt; 0, true &gt;</a></td></tr>
<tr class="memitem:Sampler_3C_201_2C_20false_20_3E" id="r_Sampler_3C_201_2C_20false_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler_3_011_00_01false_01_4.html">Sampler&lt; 1, false &gt;</a></td></tr>
<tr class="memitem:Sampler_3C_201_2C_20true_20_3E" id="r_Sampler_3C_201_2C_20true_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler_3_011_00_01true_01_4.html">Sampler&lt; 1, true &gt;</a></td></tr>
<tr class="memitem:Sampler_3C_202_2C_20false_20_3E" id="r_Sampler_3C_202_2C_20false_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler_3_012_00_01false_01_4.html">Sampler&lt; 2, false &gt;</a></td></tr>
<tr class="memitem:Sampler_3C_202_2C_20true_20_3E" id="r_Sampler_3C_202_2C_20true_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler_3_012_00_01true_01_4.html">Sampler&lt; 2, true &gt;</a></td></tr>
<tr class="memitem:ScalarToVectorConverter" id="r_ScalarToVectorConverter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html#a8b727e6fbafe29f45e41f6dd34442324">ScalarToVectorConverter&lt;ScalarGridType&gt;::Type</a> is the type of a grid having the same tree configuration as ScalarGridType but value type Vec3&lt;T&gt; where T is ScalarGridType::ValueType.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html#details">More...</a><br /></td></tr>
<tr class="memitem:SignedFloodFillOp" id="r_SignedFloodFillOp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1SignedFloodFillOp.html">SignedFloodFillOp</a></td></tr>
<tr class="memitem:SparseExtractor" id="r_SparseExtractor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1SparseExtractor.html">SparseExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor-based class used to extract data that satisfies some criteria defined by the embedded <code>OpType</code> functor. The <code>extractSparseTree</code> function wraps this class.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1SparseExtractor.html#details">More...</a><br /></td></tr>
<tr class="memitem:SparseMaskedExtractor" id="r_SparseMaskedExtractor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1SparseMaskedExtractor.html">SparseMaskedExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor-based class used to extract data from a dense grid, at the index-space intersection with a supplied mask in the form of a sparse tree. The <code>extractSparseTreeWithMask</code> function wraps this class.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1SparseMaskedExtractor.html#details">More...</a><br /></td></tr>
<tr class="memitem:SparseToDenseCompositor" id="r_SparseToDenseCompositor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1SparseToDenseCompositor.html">SparseToDenseCompositor</a></td></tr>
<tr class="memitem:StaggeredBoxSampler" id="r_StaggeredBoxSampler"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1StaggeredBoxSampler.html">StaggeredBoxSampler</a></td></tr>
<tr class="memitem:StaggeredPointSampler" id="r_StaggeredPointSampler"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1StaggeredPointSampler.html">StaggeredPointSampler</a></td></tr>
<tr class="memitem:StaggeredQuadraticSampler" id="r_StaggeredQuadraticSampler"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1StaggeredQuadraticSampler.html">StaggeredQuadraticSampler</a></td></tr>
<tr class="memitem:SumMergeOp" id="r_SumMergeOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1SumMergeOp.html">SumMergeOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DynamicNodeManager operator to merge trees using a sum operation.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1SumMergeOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:TileData" id="r_TileData"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1TileData.html">TileData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that encodes a bounding box, value and level of a tile.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1TileData.html#details">More...</a><br /></td></tr>
<tr class="memitem:TolerancePruneOp" id="r_TolerancePruneOp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1TolerancePruneOp.html">TolerancePruneOp</a></td></tr>
<tr class="memitem:TreeToMerge" id="r_TreeToMerge"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1TreeToMerge.html">TreeToMerge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience class that contains a pointer to a tree to be stolen or deep copied depending on the tag dispatch class used and a subset of methods to retrieve data from the tree.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1TreeToMerge.html#details">More...</a><br /></td></tr>
<tr class="memitem:UniformPointScatter" id="r_UniformPointScatter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1UniformPointScatter.html">UniformPointScatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The two point scatters <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1UniformPointScatter.html" title="The two point scatters UniformPointScatter and NonUniformPointScatter depend on the following two cla...">UniformPointScatter</a> and <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1NonUniformPointScatter.html" title="Non-uniform scatters of point in the active voxels. The local point count is implicitly defined as a ...">NonUniformPointScatter</a> depend on the following two classes:  <a href="classopenvdb_1_1v13__0_1_1tools_1_1UniformPointScatter.html#details">More...</a><br /></td></tr>
<tr class="memitem:VectorToScalarConverter" id="r_VectorToScalarConverter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html#a11740aac462a0be7c37c692175a28e3a">VectorToScalarConverter&lt;VectorGridType&gt;::Type</a> is the type of a grid having the same tree configuration as VectorGridType but a scalar value type, T, where T is the type of the original vector components.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html#details">More...</a><br /></td></tr>
<tr class="memitem:VectorToScalarGrid" id="r_VectorToScalarGrid"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarGrid.html">VectorToScalarGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to convert a vector-valued grid type to a scalar grid type.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarGrid.html#details">More...</a><br /></td></tr>
<tr class="memitem:VelocityIntegrator" id="r_VelocityIntegrator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1VelocityIntegrator.html">VelocityIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Runge-Kutta time integration of variable order in a static velocity field.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1VelocityIntegrator.html#details">More...</a><br /></td></tr>
<tr class="memitem:VelocitySampler" id="r_VelocitySampler"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1VelocitySampler.html">VelocitySampler</a></td></tr>
<tr class="memitem:VolumeAdvection" id="r_VolumeAdvection"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1VolumeAdvection.html">VolumeAdvection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs advections of an arbitrary type of volume in a static velocity field. The advections are performed by means of various derivatives of Semi-Lagrangian integration, i.e. backwards tracking along the hyperbolic characteristics followed by interpolation.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1VolumeAdvection.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeRayIntersector" id="r_VolumeRayIntersector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1VolumeRayIntersector.html">VolumeRayIntersector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the public API for intersecting a ray with a generic (e.g. density) volume.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1VolumeRayIntersector.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeRender" id="r_VolumeRender"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1VolumeRender.html">VolumeRender</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (very) simple multithreaded volume render specifically for scalar density.  <a href="classopenvdb_1_1v13__0_1_1tools_1_1VolumeRender.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeToMesh" id="r_VolumeToMesh"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VolumeToMesh.html">VolumeToMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh any scalar grid that has a continuous isosurface.  <a href="structopenvdb_1_1v13__0_1_1tools_1_1VolumeToMesh.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa2bd678647ee7c097628900599ecd911" id="r_aa2bd678647ee7c097628900599ecd911"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:aa2bd678647ee7c097628900599ecd911 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2bd678647ee7c097628900599ecd911">CsgUnionOp</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CsgUnionOrIntersectionOp.html">CsgUnionOrIntersectionOp</a>&lt;TreeT, true&gt;</td></tr>
<tr class="memitem:a15acb14744ad597506ab2c876df1e3c0" id="r_a15acb14744ad597506ab2c876df1e3c0"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a15acb14744ad597506ab2c876df1e3c0 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15acb14744ad597506ab2c876df1e3c0">CsgIntersectionOp</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CsgUnionOrIntersectionOp.html">CsgUnionOrIntersectionOp</a>&lt;TreeT, false&gt;</td></tr>
<tr class="memitem:ae0b5eb564884170a157dd5ea34c183f5" id="r_ae0b5eb564884170a157dd5ea34c183f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0b5eb564884170a157dd5ea34c183f5">ParticleIndexAtlas</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ParticleAtlas.html">ParticleAtlas</a>&lt;<a class="el" href="#acfb828103bf471f9c51ea65d156e4498">PointIndexGrid</a>&gt;</td></tr>
<tr class="memitem:aa8f0da3a97a2a253d68f2ab76545121c" id="r_aa8f0da3a97a2a253d68f2ab76545121c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8f0da3a97a2a253d68f2ab76545121c">PointIndexTree</a></td></tr>
<tr class="memdesc:aa8f0da3a97a2a253d68f2ab76545121c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point index tree configured to match the default OpenVDB tree configuration.  <br /></td></tr>
<tr class="memitem:acfb828103bf471f9c51ea65d156e4498" id="r_acfb828103bf471f9c51ea65d156e4498"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfb828103bf471f9c51ea65d156e4498">PointIndexGrid</a> = <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html">Grid</a>&lt;<a class="el" href="#aa8f0da3a97a2a253d68f2ab76545121c">PointIndexTree</a>&gt;</td></tr>
<tr class="memdesc:acfb828103bf471f9c51ea65d156e4498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point index grid.  <br /></td></tr>
<tr class="memitem:a52bc789f19484fd8102225765173f548" id="r_a52bc789f19484fd8102225765173f548"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52bc789f19484fd8102225765173f548">UInt32PointPartitioner</a> = <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1PointPartitioner.html">PointPartitioner</a>&lt;uint32_t, 3&gt;</td></tr>
<tr id="typedef-members-0" class="groupHeader"><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a48d92c3835e9c28ed5fd3c9a416d3585" id="r_a48d92c3835e9c28ed5fd3c9a416d3585"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48d92c3835e9c28ed5fd3c9a416d3585">PointList</a> = std::unique_ptr&lt;<a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">openvdb::Vec3s</a>[]&gt;</td></tr>
<tr class="memdesc:a48d92c3835e9c28ed5fd3c9a416d3585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point and primitive list types.  <br /></td></tr>
<tr class="memitem:aa4c6e4a427196ef80116eb8fd76a62b6" id="r_aa4c6e4a427196ef80116eb8fd76a62b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4c6e4a427196ef80116eb8fd76a62b6">PolygonPoolList</a> = std::unique_ptr&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1PolygonPool.html">PolygonPool</a>[]&gt;</td></tr>
<tr class="memdesc:aa4c6e4a427196ef80116eb8fd76a62b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point and primitive list types.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8206a04f26f57965d9cb369acafa33d7" id="r_a8206a04f26f57965d9cb369acafa33d7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8206a04f26f57965d9cb369acafa33d7">MemoryLayout</a> { <a class="el" href="#a8206a04f26f57965d9cb369acafa33d7a696de54548c230cf353790fc1f73117f">LayoutXYZ</a>
, <a class="el" href="#a8206a04f26f57965d9cb369acafa33d7ac4b2238a60f4ee86d9ed5a72a13fe814">LayoutZYX</a>
 }</td></tr>
<tr class="memitem:a4af148611e5ef140a0121ee996fb8321" id="r_a4af148611e5ef140a0121ee996fb8321"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4af148611e5ef140a0121ee996fb8321">DSCompositeOp</a> { <br />
&#160;&#160;<a class="el" href="#a4af148611e5ef140a0121ee996fb8321a812485f135c6cee2586b34b814cddc6a">DS_OVER</a>
, <a class="el" href="#a4af148611e5ef140a0121ee996fb8321a8d4beb09c71b751771158b53d1cf99c3">DS_ADD</a>
, <a class="el" href="#a4af148611e5ef140a0121ee996fb8321afa18e1086c47d6d467d2ca6e708f739b">DS_SUB</a>
, <a class="el" href="#a4af148611e5ef140a0121ee996fb8321a85f583b7144fce0c85930f1a01c25a72">DS_MIN</a>
, <br />
&#160;&#160;<a class="el" href="#a4af148611e5ef140a0121ee996fb8321abab98682392bb93a93278797f8db5d75">DS_MAX</a>
, <a class="el" href="#a4af148611e5ef140a0121ee996fb8321a697b1fa695bcb46b82bc1f22ff61855a">DS_MULT</a>
, <a class="el" href="#a4af148611e5ef140a0121ee996fb8321ab5356cf273f92049213e30c3444f149b">DS_SET</a>
<br />
 }</td></tr>
<tr class="memitem:a6416fa916f48d91455ce7bad5b0a33bf" id="r_a6416fa916f48d91455ce7bad5b0a33bf"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bf">FastSweepingDomain</a> { <a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bfa3203264a0a3fd2d90d15ee76eeb62f40">SWEEP_ALL</a>
, <a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bfa245516447de3b999aeb0a36124ca6b70">SWEEP_GREATER_THAN_ISOVALUE</a>
, <a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bfa38b255d809f149cd5ae87b46c45905e6">SWEEP_LESS_THAN_ISOVALUE</a>
 }</td></tr>
<tr class="memdesc:a6416fa916f48d91455ce7bad5b0a33bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast Sweeping update mode. This is useful to determine narrow-band extension or field extension in one side of a signed distance field.  <a href="#a6416fa916f48d91455ce7bad5b0a33bf">More...</a><br /></td></tr>
<tr class="memitem:ada7a0b56d443666f8e378e9df7a9a5df" id="r_ada7a0b56d443666f8e378e9df7a9a5df"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada7a0b56d443666f8e378e9df7a9a5df">TubeRadiiPolicy</a> { <a class="el" href="#ada7a0b56d443666f8e378e9df7a9a5dfa1564590332bb2919066afe3cd01eacc7">TUBE_AUTOMATIC</a> = 0
, <a class="el" href="#ada7a0b56d443666f8e378e9df7a9a5dfa067b6aa26d743b55e1338178e41b7ece">TUBE_VERTEX_RADII</a>
, <a class="el" href="#ada7a0b56d443666f8e378e9df7a9a5dfa9eeb65784dfcf77b0b4101a184d4dda9">TUBE_SEGMENT_RADII</a>
 }</td></tr>
<tr class="memdesc:ada7a0b56d443666f8e378e9df7a9a5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different policies when creating a tube complex with varying radii.  <a href="#ada7a0b56d443666f8e378e9df7a9a5df">More...</a><br /></td></tr>
<tr class="memitem:a2623bf4797b966b29fbe45c87e60481c" id="r_a2623bf4797b966b29fbe45c87e60481c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2623bf4797b966b29fbe45c87e60481c">MeshToVolumeFlags</a> { <a class="el" href="#a2623bf4797b966b29fbe45c87e60481ca99d80e217668e63e75cbd0591f034f70">UNSIGNED_DISTANCE_FIELD</a> = 0x1
, <a class="el" href="#a2623bf4797b966b29fbe45c87e60481ca145012afd1cbb669fe4c8c94b041abc4">DISABLE_INTERSECTING_VOXEL_REMOVAL</a> = 0x2
, <a class="el" href="#a2623bf4797b966b29fbe45c87e60481ca414a054233ec27d0ec60800ea7e73332">DISABLE_RENORMALIZATION</a> = 0x4
, <a class="el" href="#a2623bf4797b966b29fbe45c87e60481ca4d48077f5cf6edf9cb34cf66d4d88505">DISABLE_NARROW_BAND_TRIMMING</a> = 0x8
 }</td></tr>
<tr class="memdesc:a2623bf4797b966b29fbe45c87e60481c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mesh to volume conversion flags.  <a href="#a2623bf4797b966b29fbe45c87e60481c">More...</a><br /></td></tr>
<tr class="memitem:af9f5e36eb8e66aa36883fc3ef727e687" id="r_af9f5e36eb8e66aa36883fc3ef727e687"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687">InteriorTestStrategy</a> { <a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687a4db3075e87b5663df255817c35275e4d">EVAL_EVERY_VOXEL</a> = 0
, <a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687aa02d9d741becb09d7aaeb8f32bdb2338">EVAL_EVERY_TILE</a> = 1
 }</td></tr>
<tr class="memdesc:af9f5e36eb8e66aa36883fc3ef727e687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different staregies how to determine sign of an SDF when using interior test.  <a href="#af9f5e36eb8e66aa36883fc3ef727e687">More...</a><br /></td></tr>
<tr class="memitem:a31d3cd59d1264144ae21e5250166cfc2" id="r_a31d3cd59d1264144ae21e5250166cfc2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a> { <a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a> = 6
, <a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2a6d84698cb77f59ae061433cbb1313bbf">NN_FACE_EDGE</a> = 18
, <a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2a2cbda8f22b738858b06cb668117278ee">NN_FACE_EDGE_VERTEX</a> = 26
 }</td></tr>
<tr class="memdesc:a31d3cd59d1264144ae21e5250166cfc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Voxel topology of nearest neighbors.  <a href="#a31d3cd59d1264144ae21e5250166cfc2">More...</a><br /></td></tr>
<tr class="memitem:ac7a17ca003c7f18f411cab4e8b4f6e74" id="r_ac7a17ca003c7f18f411cab4e8b4f6e74"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7a17ca003c7f18f411cab4e8b4f6e74">TilePolicy</a> { <a class="el" href="#ac7a17ca003c7f18f411cab4e8b4f6e74ab6e5cc3f7167ba290c413016ae105d99">IGNORE_TILES</a>
, <a class="el" href="#ac7a17ca003c7f18f411cab4e8b4f6e74ab3c4d64060dcfe7f0949fb11f8ad789c">EXPAND_TILES</a>
, <a class="el" href="#ac7a17ca003c7f18f411cab4e8b4f6e74ab963e977b12771992aceaf779527c26f">PRESERVE_TILES</a>
 }</td></tr>
<tr class="memdesc:ac7a17ca003c7f18f411cab4e8b4f6e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different policies when dilating trees with active tiles.  <a href="#ac7a17ca003c7f18f411cab4e8b4f6e74">More...</a><br /></td></tr>
<tr class="memitem:a4135bb0acbab0219a18f9ee33c079475" id="r_a4135bb0acbab0219a18f9ee33c079475"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="#a4135bb0acbab0219a18f9ee33c079475aa911a2c909b228a84da11c9e7ec8d6f4">POLYFLAG_EXTERIOR</a> = 0x1
, <a class="el" href="#a4135bb0acbab0219a18f9ee33c079475a6162751648b85f251927667c2b51ca67">POLYFLAG_FRACTURE_SEAM</a> = 0x2
, <a class="el" href="#a4135bb0acbab0219a18f9ee33c079475acbee21124fa14157f6c0c992c4728c7b">POLYFLAG_SUBDIVIDED</a> = 0x4
 }</td></tr>
<tr class="memdesc:a4135bb0acbab0219a18f9ee33c079475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polygon flags, used for reference based meshing.  <a href="#a4135bb0acbab0219a18f9ee33c079475">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afbad51b90ae8354757fa735b4d2058b0" id="r_afbad51b90ae8354757fa735b4d2058b0"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTree&gt; </td></tr>
<tr class="memitem:afbad51b90ae8354757fa735b4d2058b0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbad51b90ae8354757fa735b4d2058b0">activate</a> (GridOrTree &amp;, const typename GridOrTree::ValueType &amp;value, const typename GridOrTree::ValueType &amp;tolerance=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b">zeroVal</a>&lt; typename GridOrTree::ValueType &gt;(), const bool threaded=true)</td></tr>
<tr class="memdesc:afbad51b90ae8354757fa735b4d2058b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark as active any inactive tiles or voxels in the given grid or tree whose values are equal to <em class="arg">value</em> (optionally to within the given <em class="arg">tolerance</em>).  <br /></td></tr>
<tr class="memitem:a95818e0902bf2d721182aea060c98a39" id="r_a95818e0902bf2d721182aea060c98a39"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTree&gt; </td></tr>
<tr class="memitem:a95818e0902bf2d721182aea060c98a39 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95818e0902bf2d721182aea060c98a39">deactivate</a> (GridOrTree &amp;, const typename GridOrTree::ValueType &amp;value, const typename GridOrTree::ValueType &amp;tolerance=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b">zeroVal</a>&lt; typename GridOrTree::ValueType &gt;(), const bool threaded=true)</td></tr>
<tr class="memdesc:a95818e0902bf2d721182aea060c98a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark as inactive any active tiles or voxels in the given grid or tree whose values are equal to <em class="arg">value</em> (optionally to within the given <em class="arg">tolerance</em>).  <br /></td></tr>
<tr class="memitem:ad795f2f3910144753a5e03d12f4703de" id="r_ad795f2f3910144753a5e03d12f4703de"><td class="memTemplParams" colspan="2">template&lt;typename TreeOrLeafManagerT&gt; </td></tr>
<tr class="memitem:ad795f2f3910144753a5e03d12f4703de template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad795f2f3910144753a5e03d12f4703de">changeBackground</a> (TreeOrLeafManagerT &amp;tree, const typename TreeOrLeafManagerT::ValueType &amp;background, bool threaded=true, size_t grainSize=32)</td></tr>
<tr class="memdesc:ad795f2f3910144753a5e03d12f4703de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the background value in all the nodes of a tree.  <br /></td></tr>
<tr class="memitem:ae9b9e9c02f534160f2571613f2d67ef5" id="r_ae9b9e9c02f534160f2571613f2d67ef5"><td class="memTemplParams" colspan="2">template&lt;typename TreeOrLeafManagerT&gt; </td></tr>
<tr class="memitem:ae9b9e9c02f534160f2571613f2d67ef5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9b9e9c02f534160f2571613f2d67ef5">changeLevelSetBackground</a> (TreeOrLeafManagerT &amp;tree, const typename TreeOrLeafManagerT::ValueType &amp;halfWidth, bool threaded=true, size_t grainSize=32)</td></tr>
<tr class="memdesc:ae9b9e9c02f534160f2571613f2d67ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the background value in all the nodes of a floating-point tree containing a symmetric narrow-band level set.  <br /></td></tr>
<tr class="memitem:a7573006df5786ba9cd6c564e4bd589ac" id="r_a7573006df5786ba9cd6c564e4bd589ac"><td class="memTemplParams" colspan="2">template&lt;typename TreeOrLeafManagerT&gt; </td></tr>
<tr class="memitem:a7573006df5786ba9cd6c564e4bd589ac template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7573006df5786ba9cd6c564e4bd589ac">changeAsymmetricLevelSetBackground</a> (TreeOrLeafManagerT &amp;tree, const typename TreeOrLeafManagerT::ValueType &amp;outsideWidth, const typename TreeOrLeafManagerT::ValueType &amp;insideWidth, bool threaded=true, size_t grainSize=32)</td></tr>
<tr class="memdesc:a7573006df5786ba9cd6c564e4bd589ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the background values in all the nodes of a floating-point tree containing a possibly asymmetric narrow-band level set.  <br /></td></tr>
<tr class="memitem:a9a2667c6fe1ab087fded41b3b3f1fa4b" id="r_a9a2667c6fe1ab087fded41b3b3f1fa4b"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a9a2667c6fe1ab087fded41b3b3f1fa4b template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a2667c6fe1ab087fded41b3b3f1fa4b">clip</a> (const GridType &amp;grid, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#aa7e17f708810f66dc1d195abaf1e9dbf">BBoxd</a> &amp;bbox, bool keepInterior=true)</td></tr>
<tr class="memdesc:a9a2667c6fe1ab087fded41b3b3f1fa4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip the given grid against a world-space bounding box and return a new grid containing the result.  <br /></td></tr>
<tr class="memitem:a92b28ca7a4cb9e950e833fac3988a28b" id="r_a92b28ca7a4cb9e950e833fac3988a28b"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a92b28ca7a4cb9e950e833fac3988a28b template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92b28ca7a4cb9e950e833fac3988a28b">clip</a> (const GridType &amp;grid, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1NonlinearFrustumMap.html">math::NonlinearFrustumMap</a> &amp;frustum, bool keepInterior=true)</td></tr>
<tr class="memdesc:a92b28ca7a4cb9e950e833fac3988a28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip the given grid against a frustum and return a new grid containing the result.  <br /></td></tr>
<tr class="memitem:aec14940922fdf39c1fb55f83b017a721" id="r_aec14940922fdf39c1fb55f83b017a721"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskTreeType&gt; </td></tr>
<tr class="memitem:aec14940922fdf39c1fb55f83b017a721 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec14940922fdf39c1fb55f83b017a721">clip</a> (const GridType &amp;grid, const <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html">Grid</a>&lt; MaskTreeType &gt; &amp;mask, bool keepInterior=true)</td></tr>
<tr class="memdesc:aec14940922fdf39c1fb55f83b017a721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip a grid against the active voxels of another grid and return a new grid containing the result.  <br /></td></tr>
<tr class="memitem:ae37591a3bab226d3b1be74030d1fcc21" id="r_ae37591a3bab226d3b1be74030d1fcc21"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT&gt; </td></tr>
<tr class="memitem:ae37591a3bab226d3b1be74030d1fcc21 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae37591a3bab226d3b1be74030d1fcc21">csgUnion</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b, bool <a class="el" href="#a8057e1165c928a37703f90eb9496083c">prune</a>=true, bool pruneCancelledTiles=false)</td></tr>
<tr class="memdesc:ae37591a3bab226d3b1be74030d1fcc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two level set grids, replace the A grid with the union of A and B.  <br /></td></tr>
<tr class="memitem:aaf596141cf503b859d1feb5dd8445086" id="r_aaf596141cf503b859d1feb5dd8445086"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT&gt; </td></tr>
<tr class="memitem:aaf596141cf503b859d1feb5dd8445086 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf596141cf503b859d1feb5dd8445086">csgIntersection</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b, bool <a class="el" href="#a8057e1165c928a37703f90eb9496083c">prune</a>=true, bool pruneCancelledTiles=false)</td></tr>
<tr class="memdesc:aaf596141cf503b859d1feb5dd8445086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two level set grids, replace the A grid with the intersection of A and B.  <br /></td></tr>
<tr class="memitem:a5036d3edb7e1ed7d23072b179e5dd190" id="r_a5036d3edb7e1ed7d23072b179e5dd190"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT&gt; </td></tr>
<tr class="memitem:a5036d3edb7e1ed7d23072b179e5dd190 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5036d3edb7e1ed7d23072b179e5dd190">csgDifference</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b, bool <a class="el" href="#a8057e1165c928a37703f90eb9496083c">prune</a>=true, bool pruneCancelledTiles=false)</td></tr>
<tr class="memdesc:a5036d3edb7e1ed7d23072b179e5dd190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two level set grids, replace the A grid with the difference A / B.  <br /></td></tr>
<tr class="memitem:a99a3bda1cab85509556b73d1467a004f" id="r_a99a3bda1cab85509556b73d1467a004f"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT&gt; </td></tr>
<tr class="memitem:a99a3bda1cab85509556b73d1467a004f template"><td class="memItemLeft" align="right" valign="top">GridOrTreeT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99a3bda1cab85509556b73d1467a004f">csgUnionCopy</a> (const GridOrTreeT &amp;a, const GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:a99a3bda1cab85509556b73d1467a004f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded CSG union operation that produces a new grid or tree from immutable inputs.  <br /></td></tr>
<tr class="memitem:add41b6c432f26145649e640fa76dc25d" id="r_add41b6c432f26145649e640fa76dc25d"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT&gt; </td></tr>
<tr class="memitem:add41b6c432f26145649e640fa76dc25d template"><td class="memItemLeft" align="right" valign="top">GridOrTreeT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add41b6c432f26145649e640fa76dc25d">csgIntersectionCopy</a> (const GridOrTreeT &amp;a, const GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:add41b6c432f26145649e640fa76dc25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded CSG intersection operation that produces a new grid or tree from immutable inputs.  <br /></td></tr>
<tr class="memitem:a7029f32f9814fd95e23d202c37b8da5b" id="r_a7029f32f9814fd95e23d202c37b8da5b"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT&gt; </td></tr>
<tr class="memitem:a7029f32f9814fd95e23d202c37b8da5b template"><td class="memItemLeft" align="right" valign="top">GridOrTreeT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7029f32f9814fd95e23d202c37b8da5b">csgDifferenceCopy</a> (const GridOrTreeT &amp;a, const GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:a7029f32f9814fd95e23d202c37b8da5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded CSG difference operation that produces a new grid or tree from immutable inputs.  <br /></td></tr>
<tr class="memitem:ab89a5ef4e61074f401e72aef834afda1" id="r_ab89a5ef4e61074f401e72aef834afda1"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT&gt; </td></tr>
<tr class="memitem:ab89a5ef4e61074f401e72aef834afda1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab89a5ef4e61074f401e72aef834afda1">compMax</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:ab89a5ef4e61074f401e72aef834afda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given grids A and B, compute max(a, b) per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty.  <br /></td></tr>
<tr class="memitem:ad0f06ce463a63898a09fea378ac6912e" id="r_ad0f06ce463a63898a09fea378ac6912e"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT&gt; </td></tr>
<tr class="memitem:ad0f06ce463a63898a09fea378ac6912e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0f06ce463a63898a09fea378ac6912e">compMin</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:ad0f06ce463a63898a09fea378ac6912e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given grids A and B, compute min(a, b) per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty.  <br /></td></tr>
<tr class="memitem:ab3e57293906eddd0c42c4df3e64cc800" id="r_ab3e57293906eddd0c42c4df3e64cc800"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT&gt; </td></tr>
<tr class="memitem:ab3e57293906eddd0c42c4df3e64cc800 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3e57293906eddd0c42c4df3e64cc800">compSum</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:ab3e57293906eddd0c42c4df3e64cc800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given grids A and B, compute a + b per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty.  <br /></td></tr>
<tr class="memitem:abdd7d6918702cd795e831789812c9ac1" id="r_abdd7d6918702cd795e831789812c9ac1"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT&gt; </td></tr>
<tr class="memitem:abdd7d6918702cd795e831789812c9ac1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdd7d6918702cd795e831789812c9ac1">compMul</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:abdd7d6918702cd795e831789812c9ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given grids A and B, compute a * b per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty.  <br /></td></tr>
<tr class="memitem:a001d3e901a369bb50ed1b4e78e57b303" id="r_a001d3e901a369bb50ed1b4e78e57b303"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT&gt; </td></tr>
<tr class="memitem:a001d3e901a369bb50ed1b4e78e57b303 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a001d3e901a369bb50ed1b4e78e57b303">compDiv</a> (GridOrTreeT &amp;a, GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:a001d3e901a369bb50ed1b4e78e57b303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given grids A and B, compute a / b per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty.  <br /></td></tr>
<tr class="memitem:a0a7784bcd2c95e7b015e6fc2c3c9d5d9" id="r_a0a7784bcd2c95e7b015e6fc2c3c9d5d9"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeT&gt; </td></tr>
<tr class="memitem:a0a7784bcd2c95e7b015e6fc2c3c9d5d9 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a7784bcd2c95e7b015e6fc2c3c9d5d9">compReplace</a> (GridOrTreeT &amp;a, const GridOrTreeT &amp;b)</td></tr>
<tr class="memdesc:a0a7784bcd2c95e7b015e6fc2c3c9d5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the active voxels of B into A.  <br /></td></tr>
<tr class="memitem:ac447a41bd0a7eedf0cf3401300b09fcd" id="r_ac447a41bd0a7eedf0cf3401300b09fcd"><td class="memTemplParams" colspan="2">template&lt;typename TreeT, typename OpT = composite::CopyOp&lt;TreeT&gt;&gt; </td></tr>
<tr class="memitem:ac447a41bd0a7eedf0cf3401300b09fcd template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac447a41bd0a7eedf0cf3401300b09fcd">compActiveLeafVoxels</a> (TreeT &amp;srcTree, TreeT &amp;dstTree, OpT op=composite::CopyOp&lt; TreeT &gt;())</td></tr>
<tr class="memdesc:ac447a41bd0a7eedf0cf3401300b09fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite the active values in leaf nodes, i.e. active voxels, of a source tree into a destination tree.  <br /></td></tr>
<tr class="memitem:a9cbb0a8d7e0521cc4165bb7e2d1081d3" id="r_a9cbb0a8d7e0521cc4165bb7e2d1081d3"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a9cbb0a8d7e0521cc4165bb7e2d1081d3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cbb0a8d7e0521cc4165bb7e2d1081d3">countActiveVoxels</a> (const TreeT &amp;tree, bool threaded=true)</td></tr>
<tr class="memdesc:a9cbb0a8d7e0521cc4165bb7e2d1081d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of active voxels in the tree.  <br /></td></tr>
<tr class="memitem:a98cf0abafb6bb3dbaeefcd10f319aa71" id="r_a98cf0abafb6bb3dbaeefcd10f319aa71"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a98cf0abafb6bb3dbaeefcd10f319aa71 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98cf0abafb6bb3dbaeefcd10f319aa71">countActiveVoxels</a> (const TreeT &amp;tree, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox, bool threaded=true)</td></tr>
<tr class="memdesc:a98cf0abafb6bb3dbaeefcd10f319aa71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of active voxels in the tree that intersects a bounding box.  <br /></td></tr>
<tr class="memitem:a073b47486ac79130a4de5210a44cc022" id="r_a073b47486ac79130a4de5210a44cc022"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a073b47486ac79130a4de5210a44cc022 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a073b47486ac79130a4de5210a44cc022">countActiveLeafVoxels</a> (const TreeT &amp;tree, bool threaded=true)</td></tr>
<tr class="memdesc:a073b47486ac79130a4de5210a44cc022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of active voxels stored in leaf nodes.  <br /></td></tr>
<tr class="memitem:aaec2cca19ae239e38c2424709547eac5" id="r_aaec2cca19ae239e38c2424709547eac5"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:aaec2cca19ae239e38c2424709547eac5 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaec2cca19ae239e38c2424709547eac5">countActiveLeafVoxels</a> (const TreeT &amp;tree, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox, bool threaded=true)</td></tr>
<tr class="memdesc:aaec2cca19ae239e38c2424709547eac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of active voxels stored in leaf nodes that intersects a bounding box.  <br /></td></tr>
<tr class="memitem:a4d6ddf0e0a760645d2590f9b2be1c4de" id="r_a4d6ddf0e0a760645d2590f9b2be1c4de"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a4d6ddf0e0a760645d2590f9b2be1c4de template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d6ddf0e0a760645d2590f9b2be1c4de">countInactiveVoxels</a> (const TreeT &amp;tree, bool threaded=true)</td></tr>
<tr class="memdesc:a4d6ddf0e0a760645d2590f9b2be1c4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of inactive voxels in the tree.  <br /></td></tr>
<tr class="memitem:ae97f0db6ef147e3f02a5ebec9f360e3d" id="r_ae97f0db6ef147e3f02a5ebec9f360e3d"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:ae97f0db6ef147e3f02a5ebec9f360e3d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae97f0db6ef147e3f02a5ebec9f360e3d">countInactiveLeafVoxels</a> (const TreeT &amp;tree, bool threaded=true)</td></tr>
<tr class="memdesc:ae97f0db6ef147e3f02a5ebec9f360e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of inactive voxels stored in leaf nodes.  <br /></td></tr>
<tr class="memitem:af3ce5e60836ad5cd560c698266e2104b" id="r_af3ce5e60836ad5cd560c698266e2104b"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:af3ce5e60836ad5cd560c698266e2104b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3ce5e60836ad5cd560c698266e2104b">countActiveTiles</a> (const TreeT &amp;tree, bool threaded=true)</td></tr>
<tr class="memdesc:af3ce5e60836ad5cd560c698266e2104b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of active tiles in the tree.  <br /></td></tr>
<tr class="memitem:ad03704a13261822b75a2d5385bffbf41" id="r_ad03704a13261822b75a2d5385bffbf41"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:ad03704a13261822b75a2d5385bffbf41 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad03704a13261822b75a2d5385bffbf41">memUsage</a> (const TreeT &amp;tree, bool threaded=true)</td></tr>
<tr class="memdesc:ad03704a13261822b75a2d5385bffbf41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total amount of memory in bytes occupied by this tree.  <br /></td></tr>
<tr class="memitem:a81a7af5b71d8a4c94feaaff3b70b1418" id="r_a81a7af5b71d8a4c94feaaff3b70b1418"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a81a7af5b71d8a4c94feaaff3b70b1418 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81a7af5b71d8a4c94feaaff3b70b1418">memUsageIfLoaded</a> (const TreeT &amp;tree, bool threaded=true)</td></tr>
<tr class="memdesc:a81a7af5b71d8a4c94feaaff3b70b1418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the deserialized memory usage of this tree. This is not necessarily equal to the current memory usage (returned by <a class="el" href="#ad03704a13261822b75a2d5385bffbf41" title="Return the total amount of memory in bytes occupied by this tree.">tools::memUsage</a>) if delay-loading is enabled. See File::open.  <br /></td></tr>
<tr class="memitem:a36ee086a1c07bfb390ebe92257e266ec" id="r_a36ee086a1c07bfb390ebe92257e266ec"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a36ee086a1c07bfb390ebe92257e266ec template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1MinMax.html">math::MinMax</a>&lt; typename TreeT::ValueType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36ee086a1c07bfb390ebe92257e266ec">minMax</a> (const TreeT &amp;tree, bool threaded=true)</td></tr>
<tr class="memdesc:a36ee086a1c07bfb390ebe92257e266ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum and maximum active values in this tree.  <br /></td></tr>
<tr class="memitem:acbd41a08ed8ea7c1a7d33146b8d17ce1" id="r_acbd41a08ed8ea7c1a7d33146b8d17ce1"><td class="memTemplParams" colspan="2">template&lt;typename DenseT, typename GridOrTreeT&gt; </td></tr>
<tr class="memitem:acbd41a08ed8ea7c1a7d33146b8d17ce1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbd41a08ed8ea7c1a7d33146b8d17ce1">copyToDense</a> (const GridOrTreeT &amp;sparse, DenseT &amp;dense, bool serial=false)</td></tr>
<tr class="memdesc:acbd41a08ed8ea7c1a7d33146b8d17ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a dense grid with the values of voxels from a sparse grid, where the sparse grid intersects the dense grid.  <br /></td></tr>
<tr class="memitem:a718fc3e33310680728f4fbf04db240c0" id="r_a718fc3e33310680728f4fbf04db240c0"><td class="memTemplParams" colspan="2">template&lt;typename DenseT, typename GridOrTreeT&gt; </td></tr>
<tr class="memitem:a718fc3e33310680728f4fbf04db240c0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a718fc3e33310680728f4fbf04db240c0">copyFromDense</a> (const DenseT &amp;dense, GridOrTreeT &amp;sparse, const typename GridOrTreeT::ValueType &amp;tolerance, bool serial=false)</td></tr>
<tr class="memdesc:a718fc3e33310680728f4fbf04db240c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a sparse grid with the values of all of the voxels of a dense grid.  <br /></td></tr>
<tr class="memitem:a586a786ed67c81b31e7bcc11c70df047" id="r_a586a786ed67c81b31e7bcc11c70df047"><td class="memTemplParams" colspan="2">template&lt;typename OpType, typename DenseType&gt; </td></tr>
<tr class="memitem:a586a786ed67c81b31e7bcc11c70df047 template"><td class="memItemLeft" align="right" valign="top">OpType::ResultTreeType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a586a786ed67c81b31e7bcc11c70df047">extractSparseTree</a> (const DenseType &amp;dense, const OpType &amp;functor, const typename OpType::ResultValueType &amp;background, bool threaded=true)</td></tr>
<tr class="memdesc:a586a786ed67c81b31e7bcc11c70df047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selectively extract and transform data from a dense grid, producing a sparse tree with leaf nodes only (e.g. create a tree from the square of values greater than a cutoff.)  <br /></td></tr>
<tr class="memitem:ae1e62f3b18a1d40b3195c83b4d76c1e5" id="r_ae1e62f3b18a1d40b3195c83b4d76c1e5"><td class="memTemplParams" colspan="2">template&lt;typename DenseType, typename MaskTreeType&gt; </td></tr>
<tr class="memitem:ae1e62f3b18a1d40b3195c83b4d76c1e5 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1DSConverter.html">DSConverter</a>&lt; DenseType, MaskTreeType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1e62f3b18a1d40b3195c83b4d76c1e5">extractSparseTreeWithMask</a> (const DenseType &amp;dense, const MaskTreeType &amp;mask, const typename DenseType::ValueType &amp;background, bool threaded=true)</td></tr>
<tr class="memdesc:ae1e62f3b18a1d40b3195c83b4d76c1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from the intersection of a sparse tree and a dense input grid. The resulting tree has the same configuration as the sparse tree, but holds the data type specified by the dense input.  <br /></td></tr>
<tr class="memitem:a920d389abe08e3a0f9638390702e370a" id="r_a920d389abe08e3a0f9638390702e370a"><td class="memTemplParams" colspan="2">template&lt;typename ValueT, typename OpType&gt; </td></tr>
<tr class="memitem:a920d389abe08e3a0f9638390702e370a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a920d389abe08e3a0f9638390702e370a">transformDense</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Dense.html">Dense</a>&lt; ValueT, openvdb::tools::LayoutZYX &gt; &amp;dense, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">openvdb::CoordBBox</a> &amp;bbox, const OpType &amp;op, bool parallel=true)</td></tr>
<tr class="memitem:ac53b377981f3baf29cef347335e3588b" id="r_ac53b377981f3baf29cef347335e3588b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a4af148611e5ef140a0121ee996fb8321">DSCompositeOp</a>, typename TreeT&gt; </td></tr>
<tr class="memitem:ac53b377981f3baf29cef347335e3588b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac53b377981f3baf29cef347335e3588b">compositeToDense</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Dense.html">Dense</a>&lt; typename TreeT::ValueType, <a class="el" href="#a8206a04f26f57965d9cb369acafa33d7ac4b2238a60f4ee86d9ed5a72a13fe814">LayoutZYX</a> &gt; &amp;dense, const TreeT &amp;source, const TreeT &amp;alpha, const typename TreeT::ValueType beta, const typename TreeT::ValueType strength, bool threaded=true)</td></tr>
<tr class="memdesc:ac53b377981f3baf29cef347335e3588b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite data from a sparse tree into a dense array of the same value type.  <br /></td></tr>
<tr class="memitem:a26f3ee890378845af008e8acfb9783fd" id="r_a26f3ee890378845af008e8acfb9783fd"><td class="memTemplParams" colspan="2">template&lt;typename ValueT, typename PointwiseOpT&gt; </td></tr>
<tr class="memitem:a26f3ee890378845af008e8acfb9783fd template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26f3ee890378845af008e8acfb9783fd">transformDense</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Dense.html">Dense</a>&lt; ValueT, openvdb::tools::LayoutZYX &gt; &amp;dense, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">openvdb::CoordBBox</a> &amp;bbox, const PointwiseOpT &amp;functor, bool parallel)</td></tr>
<tr class="memdesc:a26f3ee890378845af008e8acfb9783fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a point-wise functor to the intersection of a dense grid and a given bounding box.  <br /></td></tr>
<tr class="memitem:ae07091e4e6f1cfb869111d233da6d9b9" id="r_ae07091e4e6f1cfb869111d233da6d9b9"><td class="memTemplParams" colspan="2">template&lt;class GridType&gt; </td></tr>
<tr class="memitem:ae07091e4e6f1cfb869111d233da6d9b9 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae07091e4e6f1cfb869111d233da6d9b9">checkLevelSet</a> (const GridType &amp;grid, size_t number=9)</td></tr>
<tr class="memdesc:ae07091e4e6f1cfb869111d233da6d9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform checks on a grid to see if it is a valid symmetric, narrow-band level set.  <br /></td></tr>
<tr class="memitem:ab03bd92afef729f144e63f37f417c96d" id="r_ab03bd92afef729f144e63f37f417c96d"><td class="memTemplParams" colspan="2">template&lt;class GridType&gt; </td></tr>
<tr class="memitem:ab03bd92afef729f144e63f37f417c96d template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab03bd92afef729f144e63f37f417c96d">checkFogVolume</a> (const GridType &amp;grid, size_t number=6)</td></tr>
<tr class="memdesc:ab03bd92afef729f144e63f37f417c96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform checks on a grid to see if it is a valid fog volume.  <br /></td></tr>
<tr class="memitem:a136006bbdda1e616071dba827c34be79" id="r_a136006bbdda1e616071dba827c34be79"><td class="memTemplParams" colspan="2">template&lt;class GridType&gt; </td></tr>
<tr class="memitem:a136006bbdda1e616071dba827c34be79 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a136006bbdda1e616071dba827c34be79">uniqueInactiveValues</a> (const GridType &amp;grid, std::vector&lt; typename GridType::ValueType &gt; &amp;values, size_t numValues)</td></tr>
<tr class="memdesc:a136006bbdda1e616071dba827c34be79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded method to find unique inactive values.  <br /></td></tr>
<tr class="memitem:a09b0661a0aaa5a3b5badaf557459dcc8" id="r_a09b0661a0aaa5a3b5badaf557459dcc8"><td class="memTemplParams" colspan="2">template&lt;typename GridT&gt; </td></tr>
<tr class="memitem:a09b0661a0aaa5a3b5badaf557459dcc8 template"><td class="memItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09b0661a0aaa5a3b5badaf557459dcc8">fogToSdf</a> (const GridT &amp;fogGrid, typename GridT::ValueType isoValue, int nIter=1)</td></tr>
<tr class="memdesc:a09b0661a0aaa5a3b5badaf557459dcc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a scalar fog volume into a signed distance function. Active input voxels with scalar values above the given isoValue will have NEGATIVE distance values on output, i.e. they are assumed to be INSIDE the iso-surface.  <br /></td></tr>
<tr class="memitem:a5ec6859a45f6b4fa6c0beb9687eabacd" id="r_a5ec6859a45f6b4fa6c0beb9687eabacd"><td class="memTemplParams" colspan="2">template&lt;typename GridT&gt; </td></tr>
<tr class="memitem:a5ec6859a45f6b4fa6c0beb9687eabacd template"><td class="memItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ec6859a45f6b4fa6c0beb9687eabacd">sdfToSdf</a> (const GridT &amp;sdfGrid, typename GridT::ValueType isoValue=0, int nIter=1)</td></tr>
<tr class="memdesc:a5ec6859a45f6b4fa6c0beb9687eabacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an existing approximate SDF it solves the Eikonal equation for all its active voxels. Active input voxels with a signed distance value above the given isoValue will have POSITIVE distance values on output, i.e. they are assumed to be OUTSIDE the iso-surface.  <br /></td></tr>
<tr class="memitem:ab8ed1bbf2e2647988fbc7eed71bed073" id="r_ab8ed1bbf2e2647988fbc7eed71bed073"><td class="memTemplParams" colspan="2">template&lt;typename FogGridT, typename ExtOpT, typename ExtValueT&gt; </td></tr>
<tr class="memitem:ab8ed1bbf2e2647988fbc7eed71bed073 template"><td class="memItemLeft" align="right" valign="top">FogGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8ed1bbf2e2647988fbc7eed71bed073">fogToExt</a> (const FogGridT &amp;fogGrid, const ExtOpT &amp;op, const ExtValueT &amp;background, typename FogGridT::ValueType isoValue, int nIter=1, <a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bf">FastSweepingDomain</a> mode=<a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bfa3203264a0a3fd2d90d15ee76eeb62f40">FastSweepingDomain::SWEEP_ALL</a>, const typename FogGridT::template ValueConverter&lt; ExtValueT &gt;::Type::ConstPtr extGrid=nullptr)</td></tr>
<tr class="memdesc:ab8ed1bbf2e2647988fbc7eed71bed073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the extension of a field (scalar, vector, or int are supported), defined by the specified functor, off an iso-surface from an input FOG volume.  <br /></td></tr>
<tr class="memitem:a3760ea31156ab4cb20897041e37c22b7" id="r_a3760ea31156ab4cb20897041e37c22b7"><td class="memTemplParams" colspan="2">template&lt;typename SdfGridT, typename ExtOpT, typename ExtValueT&gt; </td></tr>
<tr class="memitem:a3760ea31156ab4cb20897041e37c22b7 template"><td class="memItemLeft" align="right" valign="top">SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3760ea31156ab4cb20897041e37c22b7">sdfToExt</a> (const SdfGridT &amp;sdfGrid, const ExtOpT &amp;op, const ExtValueT &amp;background, typename SdfGridT::ValueType isoValue=0, int nIter=1, <a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bf">FastSweepingDomain</a> mode=<a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bfa3203264a0a3fd2d90d15ee76eeb62f40">FastSweepingDomain::SWEEP_ALL</a>, const typename SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::ConstPtr extGrid=nullptr)</td></tr>
<tr class="memdesc:a3760ea31156ab4cb20897041e37c22b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the extension of a field (scalar, vector, or int are supported), defined by the specified functor, off an iso-surface from an input SDF volume.  <br /></td></tr>
<tr class="memitem:a8e07459625611ff0d4f386f601aa1e3e" id="r_a8e07459625611ff0d4f386f601aa1e3e"><td class="memTemplParams" colspan="2">template&lt;typename FogGridT, typename ExtOpT, typename ExtValueT&gt; </td></tr>
<tr class="memitem:a8e07459625611ff0d4f386f601aa1e3e template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename FogGridT::Ptr, typename FogGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e07459625611ff0d4f386f601aa1e3e">fogToSdfAndExt</a> (const FogGridT &amp;fogGrid, const ExtOpT &amp;op, const ExtValueT &amp;background, typename FogGridT::ValueType isoValue, int nIter=1, <a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bf">FastSweepingDomain</a> mode=<a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bfa3203264a0a3fd2d90d15ee76eeb62f40">FastSweepingDomain::SWEEP_ALL</a>, const typename FogGridT::template ValueConverter&lt; ExtValueT &gt;::Type::ConstPtr extGrid=nullptr)</td></tr>
<tr class="memdesc:a8e07459625611ff0d4f386f601aa1e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the signed distance field and the extension of a field (scalar, vector, or int are supported), defined by the specified functor, off an iso-surface from an input FOG volume.  <br /></td></tr>
<tr class="memitem:a27d97ccaebf36560da30e5c9c5389d48" id="r_a27d97ccaebf36560da30e5c9c5389d48"><td class="memTemplParams" colspan="2">template&lt;typename SdfGridT, typename ExtOpT, typename ExtValueT&gt; </td></tr>
<tr class="memitem:a27d97ccaebf36560da30e5c9c5389d48 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename SdfGridT::Ptr, typename SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27d97ccaebf36560da30e5c9c5389d48">sdfToSdfAndExt</a> (const SdfGridT &amp;sdfGrid, const ExtOpT &amp;op, const ExtValueT &amp;background, typename SdfGridT::ValueType isoValue=0, int nIter=1, <a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bf">FastSweepingDomain</a> mode=<a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bfa3203264a0a3fd2d90d15ee76eeb62f40">FastSweepingDomain::SWEEP_ALL</a>, const typename SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::ConstPtr extGrid=nullptr)</td></tr>
<tr class="memdesc:a27d97ccaebf36560da30e5c9c5389d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the signed distance field and the extension of a field (scalar, vector, or int are supported), defined by the specified functor, off an iso-surface from an input SDF volume.  <br /></td></tr>
<tr class="memitem:a3ae8e943f814b22fa057d8e4e4f82e30" id="r_a3ae8e943f814b22fa057d8e4e4f82e30"><td class="memTemplParams" colspan="2">template&lt;typename GridT&gt; </td></tr>
<tr class="memitem:a3ae8e943f814b22fa057d8e4e4f82e30 template"><td class="memItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ae8e943f814b22fa057d8e4e4f82e30">dilateSdf</a> (const GridT &amp;sdfGrid, int dilation, <a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a> nn=<a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a>, int nIter=1, <a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bf">FastSweepingDomain</a> mode=<a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bfa3203264a0a3fd2d90d15ee76eeb62f40">FastSweepingDomain::SWEEP_ALL</a>)</td></tr>
<tr class="memdesc:a3ae8e943f814b22fa057d8e4e4f82e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dilates the narrow band of an existing signed distance field by a specified number of voxels (like adding "onion-rings").  <br /></td></tr>
<tr class="memitem:aa310f2f224f5b386b70dd8645b39b133" id="r_aa310f2f224f5b386b70dd8645b39b133"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename MaskTreeT&gt; </td></tr>
<tr class="memitem:aa310f2f224f5b386b70dd8645b39b133 template"><td class="memItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa310f2f224f5b386b70dd8645b39b133">maskSdf</a> (const GridT &amp;sdfGrid, const <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html">Grid</a>&lt; MaskTreeT &gt; &amp;mask, bool ignoreActiveTiles=false, int nIter=1)</td></tr>
<tr class="memdesc:aa310f2f224f5b386b70dd8645b39b133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills mask by extending an existing signed distance field into the active values of this input ree of arbitrary value type.  <br /></td></tr>
<tr class="memitem:aebd5f9aa2d3c6e190a88f46e43590105" id="r_aebd5f9aa2d3c6e190a88f46e43590105"><td class="memTemplParams" colspan="2">template&lt;typename SdfGridT, typename OpT, typename ExtValueT&gt; </td></tr>
<tr class="memitem:aebd5f9aa2d3c6e190a88f46e43590105 template"><td class="memItemLeft" align="right" valign="top">SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebd5f9aa2d3c6e190a88f46e43590105">sdfToExt</a> (const SdfGridT &amp;sdfGrid, const OpT &amp;op, const ExtValueT &amp;background, typename SdfGridT::ValueType isoValue, int nIter, <a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bf">FastSweepingDomain</a> mode, const typename SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::ConstPtr extGrid)</td></tr>
<tr class="memitem:a1562d5f6c1e6d39636666756be0234a3" id="r_a1562d5f6c1e6d39636666756be0234a3"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a1562d5f6c1e6d39636666756be0234a3 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1562d5f6c1e6d39636666756be0234a3">anyActiveValues</a> (const TreeT &amp;tree, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox)</td></tr>
<tr class="memdesc:a1562d5f6c1e6d39636666756be0234a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the bounding box intersects any of the active values in a tree, i.e. either active voxels or active tiles.  <br /></td></tr>
<tr class="memitem:a8ddfbc3ca506b15623bcffd355f2e749" id="r_a8ddfbc3ca506b15623bcffd355f2e749"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a8ddfbc3ca506b15623bcffd355f2e749 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ddfbc3ca506b15623bcffd355f2e749">anyActiveVoxels</a> (const TreeT &amp;tree, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox)</td></tr>
<tr class="memdesc:a8ddfbc3ca506b15623bcffd355f2e749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the bounding box intersects any of the active voxels in a tree, i.e. ignores active tile values.  <br /></td></tr>
<tr class="memitem:a7b0a2e1f38b296a8dd5f1494efb51bed" id="r_a7b0a2e1f38b296a8dd5f1494efb51bed"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a7b0a2e1f38b296a8dd5f1494efb51bed template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b0a2e1f38b296a8dd5f1494efb51bed">anyActiveTiles</a> (const TreeT &amp;tree, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox)</td></tr>
<tr class="memdesc:a7b0a2e1f38b296a8dd5f1494efb51bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the bounding box intersects any of the active tiles in a tree, i.e. ignores active leaf values.  <br /></td></tr>
<tr class="memitem:add8ca0caf60c323917088490510fa8e8" id="r_add8ca0caf60c323917088490510fa8e8"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:add8ca0caf60c323917088490510fa8e8 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add8ca0caf60c323917088490510fa8e8">noActiveValues</a> (const TreeT &amp;tree, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox)</td></tr>
<tr class="memdesc:add8ca0caf60c323917088490510fa8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the bounding box intersects none of the active values in a tree, i.e. neither active voxels or active tiles.  <br /></td></tr>
<tr class="memitem:a0d05f8d7abe330825f886373991c52e3" id="r_a0d05f8d7abe330825f886373991c52e3"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a0d05f8d7abe330825f886373991c52e3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d05f8d7abe330825f886373991c52e3">countActiveValues</a> (const TreeT &amp;tree, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox)</td></tr>
<tr class="memdesc:a0d05f8d7abe330825f886373991c52e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of active values that intersects a bounding box intersects, i.e. the count includes both active voxels and virtual voxels in active tiles.  <br /></td></tr>
<tr class="memitem:a5662e54e5608edc934c09c8bac2ec3ea" id="r_a5662e54e5608edc934c09c8bac2ec3ea"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a5662e54e5608edc934c09c8bac2ec3ea template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1TileData.html">TileData</a>&lt; typename TreeT::ValueType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5662e54e5608edc934c09c8bac2ec3ea">activeTiles</a> (const TreeT &amp;tree, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;bbox)</td></tr>
<tr class="memdesc:a5662e54e5608edc934c09c8bac2ec3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with bounding boxes that represents all the intersections between active tiles in the tree and the specified bounding box.  <br /></td></tr>
<tr class="memitem:aea23457a3376d6fb611bd3f46fdffd61" id="r_aea23457a3376d6fb611bd3f46fdffd61"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:aea23457a3376d6fb611bd3f46fdffd61 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea23457a3376d6fb611bd3f46fdffd61">cpt</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:aea23457a3376d6fb611bd3f46fdffd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Closest-Point Transform (CPT) from a distance field.  <br /></td></tr>
<tr class="memitem:a0a4a7dc00308e20a77a2dfd6cb598fb4" id="r_a0a4a7dc00308e20a77a2dfd6cb598fb4"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </td></tr>
<tr class="memitem:a0a4a7dc00308e20a77a2dfd6cb598fb4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a4a7dc00308e20a77a2dfd6cb598fb4">cpt</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memitem:af4a1df11b58f53666af405f1c0d08f6a" id="r_af4a1df11b58f53666af405f1c0d08f6a"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:af4a1df11b58f53666af405f1c0d08f6a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4a1df11b58f53666af405f1c0d08f6a">cpt</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="memitem:ae3106d65068cff4ee14dcd7197065b11" id="r_ae3106d65068cff4ee14dcd7197065b11"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT&gt; </td></tr>
<tr class="memitem:ae3106d65068cff4ee14dcd7197065b11 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3106d65068cff4ee14dcd7197065b11">cpt</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="memitem:a1d7270767850c4f3241bce09b730d84a" id="r_a1d7270767850c4f3241bce09b730d84a"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:a1d7270767850c4f3241bce09b730d84a template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d7270767850c4f3241bce09b730d84a">curl</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:a1d7270767850c4f3241bce09b730d84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the curl of the given vector-valued grid.  <br /></td></tr>
<tr class="memitem:a8b2279de4cd703914497d7733aefbb6e" id="r_a8b2279de4cd703914497d7733aefbb6e"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </td></tr>
<tr class="memitem:a8b2279de4cd703914497d7733aefbb6e template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b2279de4cd703914497d7733aefbb6e">curl</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memitem:afadb45bd23efe58eba201eb0d6c3ef82" id="r_afadb45bd23efe58eba201eb0d6c3ef82"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:afadb45bd23efe58eba201eb0d6c3ef82 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afadb45bd23efe58eba201eb0d6c3ef82">curl</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="memitem:a72a59fb29e19148b3554c0700509356d" id="r_a72a59fb29e19148b3554c0700509356d"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT&gt; </td></tr>
<tr class="memitem:a72a59fb29e19148b3554c0700509356d template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72a59fb29e19148b3554c0700509356d">curl</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="memitem:ad9d4adc505e30de4684d20efdcb66512" id="r_ad9d4adc505e30de4684d20efdcb66512"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:ad9d4adc505e30de4684d20efdcb66512 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9d4adc505e30de4684d20efdcb66512">divergence</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:ad9d4adc505e30de4684d20efdcb66512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the divergence of the given vector-valued grid.  <br /></td></tr>
<tr class="memitem:ab4342922999466ca1d2481c6c0d083b1" id="r_ab4342922999466ca1d2481c6c0d083b1"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </td></tr>
<tr class="memitem:ab4342922999466ca1d2481c6c0d083b1 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4342922999466ca1d2481c6c0d083b1">divergence</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memitem:a0e9b692b04d219b618f0079fea6565cc" id="r_a0e9b692b04d219b618f0079fea6565cc"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a0e9b692b04d219b618f0079fea6565cc template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e9b692b04d219b618f0079fea6565cc">divergence</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="memitem:af934f12048c3caff364d2dab06d3801e" id="r_af934f12048c3caff364d2dab06d3801e"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT&gt; </td></tr>
<tr class="memitem:af934f12048c3caff364d2dab06d3801e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af934f12048c3caff364d2dab06d3801e">divergence</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="memitem:a61d4d89cd34db1794e9a615dec11dc0f" id="r_a61d4d89cd34db1794e9a615dec11dc0f"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:a61d4d89cd34db1794e9a615dec11dc0f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61d4d89cd34db1794e9a615dec11dc0f">gradient</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:a61d4d89cd34db1794e9a615dec11dc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the given scalar grid.  <br /></td></tr>
<tr class="memitem:a8cad07124b4f4d6a7b15021ee86b2c2f" id="r_a8cad07124b4f4d6a7b15021ee86b2c2f"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </td></tr>
<tr class="memitem:a8cad07124b4f4d6a7b15021ee86b2c2f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cad07124b4f4d6a7b15021ee86b2c2f">gradient</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memitem:a137349cb5217d39ad7a961d7dec8e499" id="r_a137349cb5217d39ad7a961d7dec8e499"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a137349cb5217d39ad7a961d7dec8e499 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a137349cb5217d39ad7a961d7dec8e499">gradient</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="memitem:a446af08bc16b4a82e996a4111a2f3c19" id="r_a446af08bc16b4a82e996a4111a2f3c19"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT&gt; </td></tr>
<tr class="memitem:a446af08bc16b4a82e996a4111a2f3c19 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a446af08bc16b4a82e996a4111a2f3c19">gradient</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="memitem:af55f3361b55d27809c1da5bf33db393a" id="r_af55f3361b55d27809c1da5bf33db393a"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:af55f3361b55d27809c1da5bf33db393a template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af55f3361b55d27809c1da5bf33db393a">laplacian</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:af55f3361b55d27809c1da5bf33db393a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Laplacian.html">Laplacian</a> of the given scalar grid.  <br /></td></tr>
<tr class="memitem:a2c8b10bc1b3daa909a50c4b1a68c1c79" id="r_a2c8b10bc1b3daa909a50c4b1a68c1c79"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </td></tr>
<tr class="memitem:a2c8b10bc1b3daa909a50c4b1a68c1c79 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c8b10bc1b3daa909a50c4b1a68c1c79">laplacian</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memitem:a0c40f63d5ab24d2984f88fa28580bb57" id="r_a0c40f63d5ab24d2984f88fa28580bb57"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a0c40f63d5ab24d2984f88fa28580bb57 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c40f63d5ab24d2984f88fa28580bb57">laplacian</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="memitem:a69b1334cfe0490c146fa60e4901242d7" id="r_a69b1334cfe0490c146fa60e4901242d7"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT&gt; </td></tr>
<tr class="memitem:a69b1334cfe0490c146fa60e4901242d7 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69b1334cfe0490c146fa60e4901242d7">laplacian</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="memitem:a5ad8501c4e8a1e0f613d880f3431d6ca" id="r_a5ad8501c4e8a1e0f613d880f3431d6ca"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:a5ad8501c4e8a1e0f613d880f3431d6ca template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ad8501c4e8a1e0f613d880f3431d6ca">meanCurvature</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:a5ad8501c4e8a1e0f613d880f3431d6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean curvature of the given grid.  <br /></td></tr>
<tr class="memitem:a85e0a1a825212802a6a672420f1be648" id="r_a85e0a1a825212802a6a672420f1be648"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </td></tr>
<tr class="memitem:a85e0a1a825212802a6a672420f1be648 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85e0a1a825212802a6a672420f1be648">meanCurvature</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memitem:a9ea197a148972454409d2667cfa154d0" id="r_a9ea197a148972454409d2667cfa154d0"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a9ea197a148972454409d2667cfa154d0 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ea197a148972454409d2667cfa154d0">meanCurvature</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="memitem:ae898df07e6e473da3f66a791c384bdad" id="r_ae898df07e6e473da3f66a791c384bdad"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT&gt; </td></tr>
<tr class="memitem:ae898df07e6e473da3f66a791c384bdad template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae898df07e6e473da3f66a791c384bdad">meanCurvature</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="memitem:a9370eee6dbb6de354a68a54b9cdd1dba" id="r_a9370eee6dbb6de354a68a54b9cdd1dba"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:a9370eee6dbb6de354a68a54b9cdd1dba template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9370eee6dbb6de354a68a54b9cdd1dba">magnitude</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:a9370eee6dbb6de354a68a54b9cdd1dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the magnitudes of the vectors of the given vector-valued grid.  <br /></td></tr>
<tr class="memitem:a06fe38fb2a95969530d664ef92f7dcae" id="r_a06fe38fb2a95969530d664ef92f7dcae"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </td></tr>
<tr class="memitem:a06fe38fb2a95969530d664ef92f7dcae template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06fe38fb2a95969530d664ef92f7dcae">magnitude</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memitem:aafe157b22738d7e56d30ae3cf62c1524" id="r_aafe157b22738d7e56d30ae3cf62c1524"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:aafe157b22738d7e56d30ae3cf62c1524 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafe157b22738d7e56d30ae3cf62c1524">magnitude</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="memitem:a0f7f0791195ec365f99b2df45484bd25" id="r_a0f7f0791195ec365f99b2df45484bd25"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT&gt; </td></tr>
<tr class="memitem:a0f7f0791195ec365f99b2df45484bd25 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f7f0791195ec365f99b2df45484bd25">magnitude</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="memitem:af5c0227e6c84797a06542df58c2b564d" id="r_af5c0227e6c84797a06542df58c2b564d"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:af5c0227e6c84797a06542df58c2b564d template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5c0227e6c84797a06542df58c2b564d">normalize</a> (const GridType &amp;grid, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memdesc:af5c0227e6c84797a06542df58c2b564d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Normalize.html">Normalize</a> the vectors of the given vector-valued grid.  <br /></td></tr>
<tr class="memitem:ac1b083e3b964ba0f08ff56bf2d50981e" id="r_ac1b083e3b964ba0f08ff56bf2d50981e"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </td></tr>
<tr class="memitem:ac1b083e3b964ba0f08ff56bf2d50981e template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1b083e3b964ba0f08ff56bf2d50981e">normalize</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded, InterruptT *interrupt)</td></tr>
<tr class="memitem:a3504dc47e0cb735b8b4455fa1ab8b532" id="r_a3504dc47e0cb735b8b4455fa1ab8b532"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a3504dc47e0cb735b8b4455fa1ab8b532 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3504dc47e0cb735b8b4455fa1ab8b532">normalize</a> (const GridType &amp;grid, bool threaded=true)</td></tr>
<tr class="memitem:a5c42f6e6d04dc1d033b449cb05c4406e" id="r_a5c42f6e6d04dc1d033b449cb05c4406e"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename MaskT&gt; </td></tr>
<tr class="memitem:a5c42f6e6d04dc1d033b449cb05c4406e template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c42f6e6d04dc1d033b449cb05c4406e">normalize</a> (const GridType &amp;grid, const MaskT &amp;mask, bool threaded=true)</td></tr>
<tr class="memitem:ae190c2befe2b252b8d930bd632964ab7" id="r_ae190c2befe2b252b8d930bd632964ab7"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler.html">Sampler</a>, typename Interrupter, typename GridType&gt; </td></tr>
<tr class="memitem:ae190c2befe2b252b8d930bd632964ab7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae190c2befe2b252b8d930bd632964ab7">resampleToMatch</a> (const GridType &amp;inGrid, GridType &amp;outGrid, Interrupter &amp;interrupter)</td></tr>
<tr class="memdesc:ae190c2befe2b252b8d930bd632964ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resample an input grid into an output grid of the same type such that, after resampling, the input and output grids coincide (apart from sampling artifacts), but the output grid's transform is unchanged.  <br /></td></tr>
<tr class="memitem:af4c63aac5d546c4e73dd5f2e8bf734ca" id="r_af4c63aac5d546c4e73dd5f2e8bf734ca"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler.html">Sampler</a>, typename GridType&gt; </td></tr>
<tr class="memitem:af4c63aac5d546c4e73dd5f2e8bf734ca template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4c63aac5d546c4e73dd5f2e8bf734ca">resampleToMatch</a> (const GridType &amp;inGrid, GridType &amp;outGrid)</td></tr>
<tr class="memdesc:af4c63aac5d546c4e73dd5f2e8bf734ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resample an input grid into an output grid of the same type such that, after resampling, the input and output grids coincide (apart from sampling artifacts), but the output grid's transform is unchanged.  <br /></td></tr>
<tr class="memitem:af2c1177d6976c4d235583089b2947ba8" id="r_af2c1177d6976c4d235583089b2947ba8"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler.html">Sampler</a>, typename Interrupter, typename GridType&gt; </td></tr>
<tr class="memitem:af2c1177d6976c4d235583089b2947ba8 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2c1177d6976c4d235583089b2947ba8">doResampleToMatch</a> (const GridType &amp;inGrid, GridType &amp;outGrid, Interrupter &amp;interrupter)</td></tr>
<tr class="memitem:ad4580749f12e9c314033b414a7b9a4e8" id="r_ad4580749f12e9c314033b414a7b9a4e8"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename ScalarType, typename InterruptT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ad4580749f12e9c314033b414a7b9a4e8 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4580749f12e9c314033b414a7b9a4e8">createLevelSetDilatedMesh</a> (const std::vector&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &gt; &amp;vertices, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, ScalarType radius, float voxelSize, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), InterruptT *interrupter=nullptr)</td></tr>
<tr class="memdesc:ad4580749f12e9c314033b414a7b9a4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a dilated triangle surface mesh (dilated by a radius in all directions).  <br /></td></tr>
<tr class="memitem:ac4bc55f527507e7844b4bf94c7ffb62b" id="r_ac4bc55f527507e7844b4bf94c7ffb62b"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename ScalarType, typename InterruptT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ac4bc55f527507e7844b4bf94c7ffb62b template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4bc55f527507e7844b4bf94c7ffb62b">createLevelSetDilatedMesh</a> (const std::vector&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &gt; &amp;vertices, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, ScalarType radius, float voxelSize, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), InterruptT *interrupter=nullptr)</td></tr>
<tr class="memdesc:ac4bc55f527507e7844b4bf94c7ffb62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a dilated quad surface mesh (dilated by a radius in all directions).  <br /></td></tr>
<tr class="memitem:a9ad632e423b8d292ebea856832cd37ae" id="r_a9ad632e423b8d292ebea856832cd37ae"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename ScalarType, typename InterruptT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a9ad632e423b8d292ebea856832cd37ae template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ad632e423b8d292ebea856832cd37ae">createLevelSetDilatedMesh</a> (const std::vector&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &gt; &amp;vertices, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, ScalarType radius, float voxelSize, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), InterruptT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a9ad632e423b8d292ebea856832cd37ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a dilated triangle &amp; quad surface mesh (dilated by a radius in all directions).  <br /></td></tr>
<tr class="memitem:a193752a35b6ebe80e04dcd72e371525c" id="r_a193752a35b6ebe80e04dcd72e371525c"><td class="memTemplParams" colspan="2">template&lt;class GridType&gt; </td></tr>
<tr class="memitem:a193752a35b6ebe80e04dcd72e371525c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a193752a35b6ebe80e04dcd72e371525c">levelSetArea</a> (const GridType &amp;grid, bool useWorldSpace=true)</td></tr>
<tr class="memdesc:a193752a35b6ebe80e04dcd72e371525c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the surface area of a narrow-band level set.  <br /></td></tr>
<tr class="memitem:aca27933ae9c1d5489a5c89377b382230" id="r_aca27933ae9c1d5489a5c89377b382230"><td class="memTemplParams" colspan="2">template&lt;class GridType&gt; </td></tr>
<tr class="memitem:aca27933ae9c1d5489a5c89377b382230 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca27933ae9c1d5489a5c89377b382230">levelSetVolume</a> (const GridType &amp;grid, bool useWorldSpace=true)</td></tr>
<tr class="memdesc:aca27933ae9c1d5489a5c89377b382230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the volume of a narrow-band level set surface.  <br /></td></tr>
<tr class="memitem:ac25a1928b2ba9be46cdec2a46f5b9a10" id="r_ac25a1928b2ba9be46cdec2a46f5b9a10"><td class="memTemplParams" colspan="2">template&lt;class GridType&gt; </td></tr>
<tr class="memitem:ac25a1928b2ba9be46cdec2a46f5b9a10 template"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac25a1928b2ba9be46cdec2a46f5b9a10">levelSetEulerCharacteristic</a> (const GridType &amp;grid)</td></tr>
<tr class="memdesc:ac25a1928b2ba9be46cdec2a46f5b9a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Euler Characteristics of a narrow-band level set surface (possibly disconnected).  <br /></td></tr>
<tr class="memitem:a65b03b0e9c115b31fac31ff8cdcf9404" id="r_a65b03b0e9c115b31fac31ff8cdcf9404"><td class="memTemplParams" colspan="2">template&lt;class GridType&gt; </td></tr>
<tr class="memitem:a65b03b0e9c115b31fac31ff8cdcf9404 template"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65b03b0e9c115b31fac31ff8cdcf9404">levelSetGenus</a> (const GridType &amp;grid)</td></tr>
<tr class="memdesc:a65b03b0e9c115b31fac31ff8cdcf9404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the genus of a narrow-band level set surface.  <br /></td></tr>
<tr class="memitem:adef98c0da043876358e6ab7e671cb9a7" id="r_adef98c0da043876358e6ab7e671cb9a7"><td class="memTemplParams" colspan="2">template&lt;class GridT&gt; </td></tr>
<tr class="memitem:adef98c0da043876358e6ab7e671cb9a7 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adef98c0da043876358e6ab7e671cb9a7">levelSetArea</a> (const GridT &amp;grid, bool useWorldUnits)</td></tr>
<tr class="memitem:a874ec1fde6ce878c9a8d479e5ad67653" id="r_a874ec1fde6ce878c9a8d479e5ad67653"><td class="memTemplParams" colspan="2">template&lt;class GridT&gt; </td></tr>
<tr class="memitem:a874ec1fde6ce878c9a8d479e5ad67653 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a874ec1fde6ce878c9a8d479e5ad67653">levelSetVolume</a> (const GridT &amp;grid, bool useWorldUnits)</td></tr>
<tr class="memitem:a48ac6dfcdf9c770ae87b34ec35393ba7" id="r_a48ac6dfcdf9c770ae87b34ec35393ba7"><td class="memTemplParams" colspan="2">template&lt;class GridT&gt; </td></tr>
<tr class="memitem:a48ac6dfcdf9c770ae87b34ec35393ba7 template"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48ac6dfcdf9c770ae87b34ec35393ba7">levelSetEulerCharacteristic</a> (const GridT &amp;grid)</td></tr>
<tr class="memitem:aba001fefd40d3b10797edf0318256ecf" id="r_aba001fefd40d3b10797edf0318256ecf"><td class="memTemplParams" colspan="2">template&lt;class GridT&gt; </td></tr>
<tr class="memitem:aba001fefd40d3b10797edf0318256ecf template"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba001fefd40d3b10797edf0318256ecf">levelSetGenus</a> (const GridT &amp;grid)</td></tr>
<tr class="memitem:a55629b59f05b1a45ea3edf5f4303b7d2" id="r_a55629b59f05b1a45ea3edf5f4303b7d2"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:a55629b59f05b1a45ea3edf5f4303b7d2 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55629b59f05b1a45ea3edf5f4303b7d2">createLevelSetPlatonic</a> (int faceCount, float scale=1.0f, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;center=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f), float voxelSize=0.1f, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), InterruptT *interrupt=nullptr)</td></tr>
<tr class="memdesc:a55629b59f05b1a45ea3edf5f4303b7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a platonic solid.  <br /></td></tr>
<tr class="memitem:a567bfd74409cb75f4b724cd48b17c688" id="r_a567bfd74409cb75f4b724cd48b17c688"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a567bfd74409cb75f4b724cd48b17c688 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a567bfd74409cb75f4b724cd48b17c688">createLevelSetPlatonic</a> (int faceCount, float scale=1.0f, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;center=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f), float voxelSize=0.1f, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a567bfd74409cb75f4b724cd48b17c688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a platonic solid.  <br /></td></tr>
<tr class="memitem:a936b35f5b9d02bd416ecf9bbf9606305" id="r_a936b35f5b9d02bd416ecf9bbf9606305"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:a936b35f5b9d02bd416ecf9bbf9606305 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a936b35f5b9d02bd416ecf9bbf9606305">createLevelSetTetrahedron</a> (float scale=1.0f, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;center=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f), float voxelSize=0.1f, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), InterruptT *interrupt=nullptr)</td></tr>
<tr class="memdesc:a936b35f5b9d02bd416ecf9bbf9606305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tetrahedron.  <br /></td></tr>
<tr class="memitem:a9ff4e929ac667fa98535559637af4390" id="r_a9ff4e929ac667fa98535559637af4390"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a9ff4e929ac667fa98535559637af4390 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ff4e929ac667fa98535559637af4390">createLevelSetTetrahedron</a> (float scale=1.0f, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;center=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f), float voxelSize=0.1f, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a9ff4e929ac667fa98535559637af4390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tetrahedron.  <br /></td></tr>
<tr class="memitem:a35119954a57d54beaa1f95b9414d263f" id="r_a35119954a57d54beaa1f95b9414d263f"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:a35119954a57d54beaa1f95b9414d263f template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35119954a57d54beaa1f95b9414d263f">createLevelSetCube</a> (float scale=1.0f, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;center=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f), float voxelSize=0.1f, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), InterruptT *interrupt=nullptr)</td></tr>
<tr class="memdesc:a35119954a57d54beaa1f95b9414d263f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a cube.  <br /></td></tr>
<tr class="memitem:a61d32f576304fe36916e2a79edb7331e" id="r_a61d32f576304fe36916e2a79edb7331e"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a61d32f576304fe36916e2a79edb7331e template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61d32f576304fe36916e2a79edb7331e">createLevelSetCube</a> (float scale=1.0f, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;center=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f), float voxelSize=0.1f, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a61d32f576304fe36916e2a79edb7331e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a cube.  <br /></td></tr>
<tr class="memitem:a8452b0792a6c58796974e9d8ec16119e" id="r_a8452b0792a6c58796974e9d8ec16119e"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:a8452b0792a6c58796974e9d8ec16119e template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8452b0792a6c58796974e9d8ec16119e">createLevelSetOctahedron</a> (float scale=1.0f, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;center=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f), float voxelSize=0.1f, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), InterruptT *interrupt=nullptr)</td></tr>
<tr class="memdesc:a8452b0792a6c58796974e9d8ec16119e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an octahedron.  <br /></td></tr>
<tr class="memitem:a650cbfe748c4a60a7910d409b4481c05" id="r_a650cbfe748c4a60a7910d409b4481c05"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a650cbfe748c4a60a7910d409b4481c05 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a650cbfe748c4a60a7910d409b4481c05">createLevelSetOctahedron</a> (float scale=1.0f, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;center=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f), float voxelSize=0.1f, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a650cbfe748c4a60a7910d409b4481c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an octahedron.  <br /></td></tr>
<tr class="memitem:a404240912628b77f41fe0cae96ea9f73" id="r_a404240912628b77f41fe0cae96ea9f73"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:a404240912628b77f41fe0cae96ea9f73 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a404240912628b77f41fe0cae96ea9f73">createLevelSetDodecahedron</a> (float scale=1.0f, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;center=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f), float voxelSize=0.1f, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), InterruptT *interrupt=nullptr)</td></tr>
<tr class="memdesc:a404240912628b77f41fe0cae96ea9f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a dodecahedron.  <br /></td></tr>
<tr class="memitem:a8db01473589e28e24d730eb16917e782" id="r_a8db01473589e28e24d730eb16917e782"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a8db01473589e28e24d730eb16917e782 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8db01473589e28e24d730eb16917e782">createLevelSetDodecahedron</a> (float scale=1.0f, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;center=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f), float voxelSize=0.1f, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a8db01473589e28e24d730eb16917e782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a dodecahedron.  <br /></td></tr>
<tr class="memitem:ab31c68df3261085a0968b539e2a911c6" id="r_ab31c68df3261085a0968b539e2a911c6"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:ab31c68df3261085a0968b539e2a911c6 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab31c68df3261085a0968b539e2a911c6">createLevelSetIcosahedron</a> (float scale=1.0f, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;center=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f), float voxelSize=0.1f, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), InterruptT *interrupt=nullptr)</td></tr>
<tr class="memdesc:ab31c68df3261085a0968b539e2a911c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an icosahedron.  <br /></td></tr>
<tr class="memitem:a97e50414d14e865e6622d79afdfe0169" id="r_a97e50414d14e865e6622d79afdfe0169"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a97e50414d14e865e6622d79afdfe0169 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97e50414d14e865e6622d79afdfe0169">createLevelSetIcosahedron</a> (float scale=1.0f, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;center=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f), float voxelSize=0.1f, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a97e50414d14e865e6622d79afdfe0169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an icosahedron.  <br /></td></tr>
<tr class="memitem:af574939742ed86a148731292520c8e30" id="r_af574939742ed86a148731292520c8e30"><td class="memTemplParams" colspan="2">template&lt;class GridType&gt; </td></tr>
<tr class="memitem:af574939742ed86a148731292520c8e30 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af574939742ed86a148731292520c8e30">levelSetRebuild</a> (const GridType &amp;grid, float isovalue=0, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> *xform=nullptr)</td></tr>
<tr class="memdesc:af574939742ed86a148731292520c8e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new grid of type <code>GridType</code> that contains a narrow-band level set representation of an isosurface of a given grid.  <br /></td></tr>
<tr class="memitem:a9ce3a230f06d4e222727e1046bc6ae3c" id="r_a9ce3a230f06d4e222727e1046bc6ae3c"><td class="memTemplParams" colspan="2">template&lt;class GridType&gt; </td></tr>
<tr class="memitem:a9ce3a230f06d4e222727e1046bc6ae3c template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ce3a230f06d4e222727e1046bc6ae3c">levelSetRebuild</a> (const GridType &amp;grid, float isovalue, float exBandWidth, float inBandWidth, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> *xform=nullptr)</td></tr>
<tr class="memdesc:a9ce3a230f06d4e222727e1046bc6ae3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new grid of type <code>GridType</code> that contains a narrow-band level set representation of an isosurface of a given grid.  <br /></td></tr>
<tr class="memitem:a9b42eee5e13c85a68dfad82c21d510a1" id="r_a9b42eee5e13c85a68dfad82c21d510a1"><td class="memTemplParams" colspan="2">template&lt;class GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:a9b42eee5e13c85a68dfad82c21d510a1 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b42eee5e13c85a68dfad82c21d510a1">levelSetRebuild</a> (const GridType &amp;grid, float isovalue, float exBandWidth, float inBandWidth, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> *xform=nullptr, InterruptT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a9b42eee5e13c85a68dfad82c21d510a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new grid of type <code>GridType</code> that contains a narrow-band level set representation of an isosurface of a given grid.  <br /></td></tr>
<tr class="memitem:a47e7b3c363d0d3a15b5859c4b06e9d8b" id="r_a47e7b3c363d0d3a15b5859c4b06e9d8b"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename InterruptT&gt; </td></tr>
<tr class="memitem:a47e7b3c363d0d3a15b5859c4b06e9d8b template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47e7b3c363d0d3a15b5859c4b06e9d8b">createLevelSetSphere</a> (float radius, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">openvdb::Vec3f</a> &amp;center, float voxelSize, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), InterruptT *interrupt=nullptr, bool threaded=true)</td></tr>
<tr class="memdesc:a47e7b3c363d0d3a15b5859c4b06e9d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a sphere.  <br /></td></tr>
<tr class="memitem:a7e88a56fc4d07052e30bbd775dee066e" id="r_a7e88a56fc4d07052e30bbd775dee066e"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a7e88a56fc4d07052e30bbd775dee066e template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e88a56fc4d07052e30bbd775dee066e">createLevelSetSphere</a> (float radius, const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">openvdb::Vec3f</a> &amp;center, float voxelSize, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), bool threaded=true)</td></tr>
<tr class="memdesc:a7e88a56fc4d07052e30bbd775dee066e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a sphere.  <br /></td></tr>
<tr class="memitem:a83135743b7302d8c90a3c5c374d91d83" id="r_a83135743b7302d8c90a3c5c374d91d83"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename ScalarType, typename InterruptT&gt; </td></tr>
<tr class="memitem:a83135743b7302d8c90a3c5c374d91d83 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83135743b7302d8c90a3c5c374d91d83">createLevelSetCapsule</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;pt1, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;pt2, ScalarType radius, float voxelSize, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), InterruptT *interrupter=nullptr, bool threaded=true)</td></tr>
<tr class="memdesc:a83135743b7302d8c90a3c5c374d91d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a capsule (tube with constant radius and sphere caps).  <br /></td></tr>
<tr class="memitem:a3616c88603aae7a8b19056b2af5dffcf" id="r_a3616c88603aae7a8b19056b2af5dffcf"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename ScalarType&gt; </td></tr>
<tr class="memitem:a3616c88603aae7a8b19056b2af5dffcf template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3616c88603aae7a8b19056b2af5dffcf">createLevelSetCapsule</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;pt1, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;pt2, ScalarType radius, float voxelSize, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), bool threaded=true)</td></tr>
<tr class="memdesc:a3616c88603aae7a8b19056b2af5dffcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a capsule (tube with constant radius and sphere caps).  <br /></td></tr>
<tr class="memitem:a8d76b118f5d20d00f08363c791b5485f" id="r_a8d76b118f5d20d00f08363c791b5485f"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename ScalarType, typename InterruptT&gt; </td></tr>
<tr class="memitem:a8d76b118f5d20d00f08363c791b5485f template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d76b118f5d20d00f08363c791b5485f">createLevelSetTaperedCapsule</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;pt1, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;pt2, ScalarType radius1, ScalarType radius2, float voxelSize, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), InterruptT *interrupter=nullptr, bool threaded=true)</td></tr>
<tr class="memdesc:a8d76b118f5d20d00f08363c791b5485f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tapered capsule (tube with sphere caps and different radii at both ends, or equivalently the convex hull of two spheres with possibly different centers and radii).  <br /></td></tr>
<tr class="memitem:a9d5f0a44c56915ab82ebcbc9ac57b993" id="r_a9d5f0a44c56915ab82ebcbc9ac57b993"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename ScalarType&gt; </td></tr>
<tr class="memitem:a9d5f0a44c56915ab82ebcbc9ac57b993 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d5f0a44c56915ab82ebcbc9ac57b993">createLevelSetTaperedCapsule</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;pt1, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;pt2, ScalarType radius1, ScalarType radius2, float voxelSize, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), bool threaded=true)</td></tr>
<tr class="memdesc:a9d5f0a44c56915ab82ebcbc9ac57b993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tapered capsule (tube with sphere caps and different radii at both ends, or equivalently the convex hull of two spheres with possibly different centers and radii).  <br /></td></tr>
<tr class="memitem:ae49ac1292b6a77eb02e19d2fa056f1ee" id="r_ae49ac1292b6a77eb02e19d2fa056f1ee"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename ScalarType, typename InterruptT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ae49ac1292b6a77eb02e19d2fa056f1ee template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae49ac1292b6a77eb02e19d2fa056f1ee">createLevelSetTubeComplex</a> (const std::vector&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &gt; &amp;vertices, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a5dcf138ef7ecb1aee6f424d6f38dfc16">Vec2I</a> &gt; &amp;segments, ScalarType radius, float voxelSize, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), InterruptT *interrupter=nullptr)</td></tr>
<tr class="memdesc:ae49ac1292b6a77eb02e19d2fa056f1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tube complex (a collection of capsules defined by endpoint coordinates and segment indices).  <br /></td></tr>
<tr class="memitem:ae5b0443bbddb654773e6ce9c36ecb49f" id="r_ae5b0443bbddb654773e6ce9c36ecb49f"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename ScalarType, typename InterruptT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ae5b0443bbddb654773e6ce9c36ecb49f template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5b0443bbddb654773e6ce9c36ecb49f">createLevelSetTubeComplex</a> (const std::vector&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &gt; &amp;vertices, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a5dcf138ef7ecb1aee6f424d6f38dfc16">Vec2I</a> &gt; &amp;segments, const std::vector&lt; ScalarType &gt; &amp;radii, float voxelSize, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>), <a class="el" href="#ada7a0b56d443666f8e378e9df7a9a5df">TubeRadiiPolicy</a> radii_policy=<a class="el" href="#ada7a0b56d443666f8e378e9df7a9a5dfa1564590332bb2919066afe3cd01eacc7">TUBE_AUTOMATIC</a>, InterruptT *interrupter=nullptr)</td></tr>
<tr class="memdesc:ae5b0443bbddb654773e6ce9c36ecb49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tube complex (a collection of tubes defined by endpoint coordinates, segment indices, and radii).  <br /></td></tr>
<tr class="memitem:aad82d1b0039598209bc21cd9aa4511a0" id="r_aad82d1b0039598209bc21cd9aa4511a0"><td class="memTemplParams" colspan="2">template&lt;class GridType&gt; </td></tr>
<tr class="memitem:aad82d1b0039598209bc21cd9aa4511a0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad82d1b0039598209bc21cd9aa4511a0">sdfToFogVolume</a> (GridType &amp;grid, typename GridType::ValueType cutoffDistance=lsutilGridMax&lt; GridType &gt;())</td></tr>
<tr class="memdesc:aad82d1b0039598209bc21cd9aa4511a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded method to convert a sparse level set/SDF into a sparse fog volume.  <br /></td></tr>
<tr class="memitem:a59b83096927350f3324cba935be37717" id="r_a59b83096927350f3324cba935be37717"><td class="memTemplParams" colspan="2">template&lt;class GridOrTreeType&gt; </td></tr>
<tr class="memitem:a59b83096927350f3324cba935be37717 template"><td class="memItemLeft" align="right" valign="top">GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59b83096927350f3324cba935be37717">sdfInteriorMask</a> (const GridOrTreeType &amp;volume, typename GridOrTreeType::ValueType isovalue=lsutilGridZero&lt; GridOrTreeType &gt;())</td></tr>
<tr class="memdesc:a59b83096927350f3324cba935be37717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded method to construct a boolean mask that represents interior regions in a signed distance field.  <br /></td></tr>
<tr class="memitem:a1a3ef894d7a7eaf47a03d2508d2d95d3" id="r_a1a3ef894d7a7eaf47a03d2508d2d95d3"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeType&gt; </td></tr>
<tr class="memitem:a1a3ef894d7a7eaf47a03d2508d2d95d3 template"><td class="memItemLeft" align="right" valign="top">GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a3ef894d7a7eaf47a03d2508d2d95d3">extractEnclosedRegion</a> (const GridOrTreeType &amp;volume, typename GridOrTreeType::ValueType isovalue=lsutilGridZero&lt; GridOrTreeType &gt;(), const typename <a class="el" href="structopenvdb_1_1v13__0_1_1TreeAdapter.html">TreeAdapter</a>&lt; GridOrTreeType &gt;::TreeType::template ValueConverter&lt; bool &gt;::Type *fillMask=nullptr)</td></tr>
<tr class="memdesc:a1a3ef894d7a7eaf47a03d2508d2d95d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the interior regions of a signed distance field and topologically enclosed (watertight) regions of value greater than the <em class="arg">isovalue</em> (cavities) that can arise as the result of CSG union operations between different shapes where at least one of the shapes has a concavity that is capped.  <br /></td></tr>
<tr class="memitem:a39bfe53eeb50b4ffdc96c90af7e1de1b" id="r_a39bfe53eeb50b4ffdc96c90af7e1de1b"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeType&gt; </td></tr>
<tr class="memitem:a39bfe53eeb50b4ffdc96c90af7e1de1b template"><td class="memItemLeft" align="right" valign="top">GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39bfe53eeb50b4ffdc96c90af7e1de1b">extractIsosurfaceMask</a> (const GridOrTreeType &amp;volume, typename GridOrTreeType::ValueType isovalue)</td></tr>
<tr class="memdesc:a39bfe53eeb50b4ffdc96c90af7e1de1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mask of the voxels that intersect the implicit surface with the given <em class="arg">isovalue</em>.  <br /></td></tr>
<tr class="memitem:a3b522dd56a467487d4b16d0f1d16c0d6" id="r_a3b522dd56a467487d4b16d0f1d16c0d6"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeType&gt; </td></tr>
<tr class="memitem:a3b522dd56a467487d4b16d0f1d16c0d6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b522dd56a467487d4b16d0f1d16c0d6">extractActiveVoxelSegmentMasks</a> (const GridOrTreeType &amp;volume, std::vector&lt; typename GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr &gt; &amp;masks)</td></tr>
<tr class="memdesc:a3b522dd56a467487d4b16d0f1d16c0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mask for each connected component of the given grid's active voxels.  <br /></td></tr>
<tr class="memitem:a1cc2d4f60d561afd2fb248e386ca67d8" id="r_a1cc2d4f60d561afd2fb248e386ca67d8"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeType&gt; </td></tr>
<tr class="memitem:a1cc2d4f60d561afd2fb248e386ca67d8 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cc2d4f60d561afd2fb248e386ca67d8">segmentActiveVoxels</a> (const GridOrTreeType &amp;volume, std::vector&lt; typename GridOrTreeType::Ptr &gt; &amp;segments)</td></tr>
<tr class="memdesc:a1cc2d4f60d561afd2fb248e386ca67d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates disjoint active topology components into distinct grids or trees.  <br /></td></tr>
<tr class="memitem:ac9f4df82ed92eb746d439ce4721ea8a5" id="r_ac9f4df82ed92eb746d439ce4721ea8a5"><td class="memTemplParams" colspan="2">template&lt;typename GridOrTreeType&gt; </td></tr>
<tr class="memitem:ac9f4df82ed92eb746d439ce4721ea8a5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9f4df82ed92eb746d439ce4721ea8a5">segmentSDF</a> (const GridOrTreeType &amp;volume, std::vector&lt; typename GridOrTreeType::Ptr &gt; &amp;segments)</td></tr>
<tr class="memdesc:ac9f4df82ed92eb746d439ce4721ea8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates disjoint SDF surfaces into distinct grids or trees.  <br /></td></tr>
<tr class="memitem:a392050cd0aa310bd6dc02ff96a23f07c" id="r_a392050cd0aa310bd6dc02ff96a23f07c"><td class="memTemplParams" colspan="2">template&lt;class GridType&gt; </td></tr>
<tr class="memitem:a392050cd0aa310bd6dc02ff96a23f07c template"><td class="memItemLeft" align="right" valign="top">OPENVDB_DOCS_INTERNAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a392050cd0aa310bd6dc02ff96a23f07c">sdfToFogVolume</a> (GridType &amp;grid, typename GridType::ValueType cutoffDistance)</td></tr>
<tr class="memdesc:a392050cd0aa310bd6dc02ff96a23f07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded method to convert a sparse level set/SDF into a sparse fog volume.  <br /></td></tr>
<tr class="memitem:a5d5182249f0ff2cd4584ec24b09300a0" id="r_a5d5182249f0ff2cd4584ec24b09300a0"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a5d5182249f0ff2cd4584ec24b09300a0 template"><td class="memItemLeft" align="right" valign="top">GridType::template ValueConverter&lt; bool &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d5182249f0ff2cd4584ec24b09300a0">interiorMask</a> (const GridType &amp;grid, const double isovalue=0.0)</td></tr>
<tr class="memdesc:a5d5182249f0ff2cd4584ec24b09300a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input grid of any type, return a new, boolean grid whose active voxel topology matches the input grid's or, if the input grid is a level set, matches the input grid's interior.  <br /></td></tr>
<tr class="memitem:a981f3d490ed2b917883704da916b6994" id="r_a981f3d490ed2b917883704da916b6994"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename <a class="el" href="interfaceMeshDataAdapter.html">MeshDataAdapter</a>, typename InteriorTest = std::nullptr_t&gt; </td></tr>
<tr class="memitem:a981f3d490ed2b917883704da916b6994 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981f3d490ed2b917883704da916b6994">meshToVolume</a> (const <a class="el" href="interfaceMeshDataAdapter.html">MeshDataAdapter</a> &amp;mesh, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> &amp;transform, float exteriorBandWidth=3.0f, float interiorBandWidth=3.0f, int flags=0, typename GridType::template ValueConverter&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac524bdfeb5d781872485d9321c881920">Int32</a> &gt;::Type *polygonIndexGrid=nullptr, InteriorTest interiorTest=nullptr, <a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687">InteriorTestStrategy</a> interiorTestStrat=<a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687a4db3075e87b5663df255817c35275e4d">EVAL_EVERY_VOXEL</a>)</td></tr>
<tr class="memitem:ac0f20b1852e5a2e365191b27ac6b3e4d" id="r_ac0f20b1852e5a2e365191b27ac6b3e4d"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename <a class="el" href="interfaceMeshDataAdapter.html">MeshDataAdapter</a>, typename Interrupter, typename InteriorTest = std::nullptr_t&gt; </td></tr>
<tr class="memitem:ac0f20b1852e5a2e365191b27ac6b3e4d template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0f20b1852e5a2e365191b27ac6b3e4d">meshToVolume</a> (Interrupter &amp;interrupter, const <a class="el" href="interfaceMeshDataAdapter.html">MeshDataAdapter</a> &amp;mesh, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> &amp;transform, float exteriorBandWidth=3.0f, float interiorBandWidth=3.0f, int flags=0, typename GridType::template ValueConverter&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac524bdfeb5d781872485d9321c881920">Int32</a> &gt;::Type *polygonIndexGrid=nullptr, InteriorTest interiorTest=nullptr, <a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687">InteriorTestStrategy</a> interiorTestStrat=<a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687a4db3075e87b5663df255817c35275e4d">EVAL_EVERY_VOXEL</a>)</td></tr>
<tr class="memdesc:ac0f20b1852e5a2e365191b27ac6b3e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert polygonal meshes that consist of quads and/or triangles into signed or unsigned distance field volumes.  <br /></td></tr>
<tr class="memitem:a49d6517666da8e1ec1175651ebf12f32" id="r_a49d6517666da8e1ec1175651ebf12f32"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a49d6517666da8e1ec1175651ebf12f32 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49d6517666da8e1ec1175651ebf12f32">meshToLevelSet</a> (const openvdb::math::Transform &amp;xform, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a49d6517666da8e1ec1175651ebf12f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a triangle mesh to a level set volume.  <br /></td></tr>
<tr class="memitem:a564d13cfab9796e72f62f51f991d05af" id="r_a564d13cfab9796e72f62f51f991d05af"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename Interrupter&gt; </td></tr>
<tr class="memitem:a564d13cfab9796e72f62f51f991d05af template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a564d13cfab9796e72f62f51f991d05af">meshToLevelSet</a> (Interrupter &amp;interrupter, const openvdb::math::Transform &amp;xform, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a564d13cfab9796e72f62f51f991d05af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds support for a <em class="arg">interrupter</em> callback used to cancel the conversion.  <br /></td></tr>
<tr class="memitem:afb69abc32d73ce0e3cd67b569bed65b8" id="r_afb69abc32d73ce0e3cd67b569bed65b8"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:afb69abc32d73ce0e3cd67b569bed65b8 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb69abc32d73ce0e3cd67b569bed65b8">meshToLevelSet</a> (const openvdb::math::Transform &amp;xform, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:afb69abc32d73ce0e3cd67b569bed65b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a quad mesh to a level set volume.  <br /></td></tr>
<tr class="memitem:a6eb7e6e46e2f3d080031f499863d3ba9" id="r_a6eb7e6e46e2f3d080031f499863d3ba9"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename Interrupter&gt; </td></tr>
<tr class="memitem:a6eb7e6e46e2f3d080031f499863d3ba9 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eb7e6e46e2f3d080031f499863d3ba9">meshToLevelSet</a> (Interrupter &amp;interrupter, const openvdb::math::Transform &amp;xform, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a6eb7e6e46e2f3d080031f499863d3ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds support for a <em class="arg">interrupter</em> callback used to cancel the conversion.  <br /></td></tr>
<tr class="memitem:a88550f83eda208f6a4efd332735bb215" id="r_a88550f83eda208f6a4efd332735bb215"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a88550f83eda208f6a4efd332735bb215 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88550f83eda208f6a4efd332735bb215">meshToLevelSet</a> (const openvdb::math::Transform &amp;xform, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a88550f83eda208f6a4efd332735bb215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a triangle and quad mesh to a level set volume.  <br /></td></tr>
<tr class="memitem:a63becdf83d644c0cbc00213390201f97" id="r_a63becdf83d644c0cbc00213390201f97"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename Interrupter&gt; </td></tr>
<tr class="memitem:a63becdf83d644c0cbc00213390201f97 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63becdf83d644c0cbc00213390201f97">meshToLevelSet</a> (Interrupter &amp;interrupter, const openvdb::math::Transform &amp;xform, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float halfWidth=float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>))</td></tr>
<tr class="memdesc:a63becdf83d644c0cbc00213390201f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds support for a <em class="arg">interrupter</em> callback used to cancel the conversion.  <br /></td></tr>
<tr class="memitem:ab994dead75e3d110e11eb64dce6ca65a" id="r_ab994dead75e3d110e11eb64dce6ca65a"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:ab994dead75e3d110e11eb64dce6ca65a template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab994dead75e3d110e11eb64dce6ca65a">meshToSignedDistanceField</a> (const openvdb::math::Transform &amp;xform, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float exBandWidth, float inBandWidth)</td></tr>
<tr class="memdesc:ab994dead75e3d110e11eb64dce6ca65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a triangle and quad mesh to a signed distance field with an asymmetrical narrow band.  <br /></td></tr>
<tr class="memitem:aee8b90b4bf51a0a1d6f02a769787b415" id="r_aee8b90b4bf51a0a1d6f02a769787b415"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename Interrupter&gt; </td></tr>
<tr class="memitem:aee8b90b4bf51a0a1d6f02a769787b415 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee8b90b4bf51a0a1d6f02a769787b415">meshToSignedDistanceField</a> (Interrupter &amp;interrupter, const openvdb::math::Transform &amp;xform, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float exBandWidth, float inBandWidth)</td></tr>
<tr class="memdesc:aee8b90b4bf51a0a1d6f02a769787b415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds support for a <em class="arg">interrupter</em> callback used to cancel the conversion.  <br /></td></tr>
<tr class="memitem:a7a77a75ddf87809699a67916ea172add" id="r_a7a77a75ddf87809699a67916ea172add"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a7a77a75ddf87809699a67916ea172add template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a77a75ddf87809699a67916ea172add">meshToUnsignedDistanceField</a> (const openvdb::math::Transform &amp;xform, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float bandWidth)</td></tr>
<tr class="memdesc:a7a77a75ddf87809699a67916ea172add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a triangle and quad mesh to an unsigned distance field.  <br /></td></tr>
<tr class="memitem:aacc72d314893ef0b6ad5cda65ded5255" id="r_aacc72d314893ef0b6ad5cda65ded5255"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename Interrupter&gt; </td></tr>
<tr class="memitem:aacc72d314893ef0b6ad5cda65ded5255 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacc72d314893ef0b6ad5cda65ded5255">meshToUnsignedDistanceField</a> (Interrupter &amp;interrupter, const openvdb::math::Transform &amp;xform, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, float bandWidth)</td></tr>
<tr class="memdesc:aacc72d314893ef0b6ad5cda65ded5255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds support for a <em class="arg">interrupter</em> callback used to cancel the conversion.  <br /></td></tr>
<tr class="memitem:a9a314c42b9d506bd60c1acdd6f41aac7" id="r_a9a314c42b9d506bd60c1acdd6f41aac7"><td class="memTemplParams" colspan="2">template&lt;typename GridType, typename <a class="el" href="namespaceopenvdb_1_1v13__0.html#ae93f92d10730a52ed3b207d5811f6a6e">VecType</a>&gt; </td></tr>
<tr class="memitem:a9a314c42b9d506bd60c1acdd6f41aac7 template"><td class="memItemLeft" align="right" valign="top">GridType::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a314c42b9d506bd60c1acdd6f41aac7">createLevelSetBox</a> (const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1BBox.html">math::BBox</a>&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ae93f92d10730a52ed3b207d5811f6a6e">VecType</a> &gt; &amp;bbox, const openvdb::math::Transform &amp;xform, typename VecType::ValueType halfWidth=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</td></tr>
<tr class="memdesc:a9a314c42b9d506bd60c1acdd6f41aac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a box.  <br /></td></tr>
<tr class="memitem:a5c971c289dca66c2e8500e01aac41bdf" id="r_a5c971c289dca66c2e8500e01aac41bdf"><td class="memTemplParams" colspan="2">template&lt;typename FloatTreeT&gt; </td></tr>
<tr class="memitem:a5c971c289dca66c2e8500e01aac41bdf template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c971c289dca66c2e8500e01aac41bdf">traceExteriorBoundaries</a> (FloatTreeT &amp;tree)</td></tr>
<tr class="memdesc:a5c971c289dca66c2e8500e01aac41bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traces the exterior voxel boundary of closed objects in the input volume <em class="arg">tree</em>. Exterior voxels are marked with a negative sign, voxels with a value below <code>0.75</code> are left unchanged and act as the boundary layer.  <br /></td></tr>
<tr class="memitem:a39ed6a1f7837b590e94d1511398c924f" id="r_a39ed6a1f7837b590e94d1511398c924f"><td class="memTemplParams" colspan="2">template&lt;typename T, <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> Log2Dim, typename InteriorTest&gt; </td></tr>
<tr class="memitem:a39ed6a1f7837b590e94d1511398c924f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39ed6a1f7837b590e94d1511398c924f">floodFillLeafNode</a> (<a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html">tree::LeafNode</a>&lt; T, Log2Dim &gt; &amp;leafNode, const InteriorTest &amp;interiorTest)</td></tr>
<tr class="memitem:ae978aa770a5f2b90f560356b83fed3d1" id="r_ae978aa770a5f2b90f560356b83fed3d1"><td class="memTemplParams" colspan="2">template&lt;typename FloatTreeT, typename InteriorTest&gt; </td></tr>
<tr class="memitem:ae978aa770a5f2b90f560356b83fed3d1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae978aa770a5f2b90f560356b83fed3d1">evaluateInteriorTest</a> (FloatTreeT &amp;tree, InteriorTest interiorTest, <a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687">InteriorTestStrategy</a> interiorTestStrategy)</td></tr>
<tr class="memdesc:ae978aa770a5f2b90f560356b83fed3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the sign of voxel values of <span class="tt">tree</span> based on the <span class="tt">interiorTest</span>  <br /></td></tr>
<tr class="memitem:a81e43d965ad641e0651ac9a39fa7c722" id="r_a81e43d965ad641e0651ac9a39fa7c722"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81e43d965ad641e0651ac9a39fa7c722">operator&lt;&lt;</a> (std::ostream &amp;ostr, const <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1MeshToVoxelEdgeData_1_1EdgeData.html">MeshToVoxelEdgeData::EdgeData</a> &amp;rhs)</td></tr>
<tr class="memitem:a42ca9de20063a42244190f7ebbb68914" id="r_a42ca9de20063a42244190f7ebbb68914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1MeshToVoxelEdgeData_1_1EdgeData.html">MeshToVoxelEdgeData::EdgeData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42ca9de20063a42244190f7ebbb68914">Abs</a> (const <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1MeshToVoxelEdgeData_1_1EdgeData.html">MeshToVoxelEdgeData::EdgeData</a> &amp;x)</td></tr>
<tr class="memitem:a7eeeface33ebfe532fc9a4675e79afec" id="r_a7eeeface33ebfe532fc9a4675e79afec"><td class="memTemplParams" colspan="2">template&lt;typename TreeOrLeafManagerT&gt; </td></tr>
<tr class="memitem:a7eeeface33ebfe532fc9a4675e79afec template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eeeface33ebfe532fc9a4675e79afec">dilateActiveValues</a> (TreeOrLeafManagerT &amp;tree, const int iterations=1, const <a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a> nn=<a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a>, const <a class="el" href="#ac7a17ca003c7f18f411cab4e8b4f6e74">TilePolicy</a> mode=<a class="el" href="#ac7a17ca003c7f18f411cab4e8b4f6e74ab963e977b12771992aceaf779527c26f">PRESERVE_TILES</a>, const bool threaded=true)</td></tr>
<tr class="memdesc:a7eeeface33ebfe532fc9a4675e79afec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topologically dilate all active values (i.e. both voxels and tiles) in a tree using one of three nearest neighbor connectivity patterns.  <br /></td></tr>
<tr class="memitem:a6872c2dd6da764c5600bd8ad2a126060" id="r_a6872c2dd6da764c5600bd8ad2a126060"><td class="memTemplParams" colspan="2">template&lt;typename TreeOrLeafManagerT&gt; </td></tr>
<tr class="memitem:a6872c2dd6da764c5600bd8ad2a126060 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6872c2dd6da764c5600bd8ad2a126060">erodeActiveValues</a> (TreeOrLeafManagerT &amp;tree, const int iterations=1, const <a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a> nn=<a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a>, const <a class="el" href="#ac7a17ca003c7f18f411cab4e8b4f6e74">TilePolicy</a> mode=<a class="el" href="#ac7a17ca003c7f18f411cab4e8b4f6e74ab963e977b12771992aceaf779527c26f">PRESERVE_TILES</a>, const bool threaded=true)</td></tr>
<tr class="memdesc:a6872c2dd6da764c5600bd8ad2a126060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topologically erode all active values (i.e. both voxels and tiles) in a tree using one of three nearest neighbor connectivity patterns.  <br /></td></tr>
<tr class="memitem:ac3d8c9dd7eda32f2e44bbcdef93457bd" id="r_ac3d8c9dd7eda32f2e44bbcdef93457bd"><td class="memTemplParams" colspan="2">template&lt;typename TreeT, typename OpT&gt; </td></tr>
<tr class="memitem:ac3d8c9dd7eda32f2e44bbcdef93457bd template"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3d8c9dd7eda32f2e44bbcdef93457bd">visitNodesDepthFirst</a> (TreeT &amp;tree, OpT &amp;op, size_t idx=0)</td></tr>
<tr class="memdesc:ac3d8c9dd7eda32f2e44bbcdef93457bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit all nodes in the tree depth-first and apply a user-supplied functor to each node.  <br /></td></tr>
<tr class="memitem:ae29bb93f486d96bd91cad919e623dab0" id="r_ae29bb93f486d96bd91cad919e623dab0"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename ParticleListT, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ae29bb93f486d96bd91cad919e623dab0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae29bb93f486d96bd91cad919e623dab0">particlesToSdf</a> (const ParticleListT &amp;, GridT &amp;, InterrupterT *=nullptr)</td></tr>
<tr class="memdesc:ae29bb93f486d96bd91cad919e623dab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a scalar, floating-point grid with CSG-unioned level set spheres described by the given particle positions and radii.  <br /></td></tr>
<tr class="memitem:ad924a8ad2838440370b1c80a599794d8" id="r_ad924a8ad2838440370b1c80a599794d8"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename ParticleListT, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ad924a8ad2838440370b1c80a599794d8 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad924a8ad2838440370b1c80a599794d8">particlesToSdf</a> (const ParticleListT &amp;, GridT &amp;, <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> radius, InterrupterT *=nullptr)</td></tr>
<tr class="memdesc:ad924a8ad2838440370b1c80a599794d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a scalar, floating-point grid with fixed-size, CSG-unioned level set spheres described by the given particle positions and the specified radius.  <br /></td></tr>
<tr class="memitem:adcddfc57ef94f93ff3806a45c26ca7d0" id="r_adcddfc57ef94f93ff3806a45c26ca7d0"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename ParticleListT, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:adcddfc57ef94f93ff3806a45c26ca7d0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcddfc57ef94f93ff3806a45c26ca7d0">particleTrailsToSdf</a> (const ParticleListT &amp;, GridT &amp;, <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> delta=1, InterrupterT *=nullptr)</td></tr>
<tr class="memdesc:adcddfc57ef94f93ff3806a45c26ca7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a scalar, floating-point grid with CSG-unioned trails of level set spheres with decreasing radius, where the starting position and radius and the direction of each trail is given by particle attributes.  <br /></td></tr>
<tr class="memitem:a9feb86e4311db3ba962b9d19eb5569be" id="r_a9feb86e4311db3ba962b9d19eb5569be"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename ParticleListT, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a9feb86e4311db3ba962b9d19eb5569be template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9feb86e4311db3ba962b9d19eb5569be">particlesToMask</a> (const ParticleListT &amp;, GridT &amp;, InterrupterT *=nullptr)</td></tr>
<tr class="memdesc:a9feb86e4311db3ba962b9d19eb5569be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a boolean grid wherever it intersects the spheres described by the given particle positions and radii.  <br /></td></tr>
<tr class="memitem:a6227a77a20fcc91e570b959710b930d2" id="r_a6227a77a20fcc91e570b959710b930d2"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename ParticleListT, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a6227a77a20fcc91e570b959710b930d2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6227a77a20fcc91e570b959710b930d2">particlesToMask</a> (const ParticleListT &amp;, GridT &amp;, <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> radius, InterrupterT *=nullptr)</td></tr>
<tr class="memdesc:a6227a77a20fcc91e570b959710b930d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a boolean grid wherever it intersects the fixed-size spheres described by the given particle positions and the specified radius.  <br /></td></tr>
<tr class="memitem:af4039b2222a88a7e4ed8e3f47490eecb" id="r_af4039b2222a88a7e4ed8e3f47490eecb"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename ParticleListT, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:af4039b2222a88a7e4ed8e3f47490eecb template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4039b2222a88a7e4ed8e3f47490eecb">particleTrailsToMask</a> (const ParticleListT &amp;, GridT &amp;, <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> delta=1, InterrupterT *=nullptr)</td></tr>
<tr class="memdesc:af4039b2222a88a7e4ed8e3f47490eecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a boolean grid wherever it intersects trails of spheres with decreasing radius, where the starting position and radius and the direction of each trail is given by particle attributes.  <br /></td></tr>
<tr class="memitem:aec6960746cc5165cf6ac1252ad7bc5d4" id="r_aec6960746cc5165cf6ac1252ad7bc5d4"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename PointArrayT&gt; </td></tr>
<tr class="memitem:aec6960746cc5165cf6ac1252ad7bc5d4 template"><td class="memItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec6960746cc5165cf6ac1252ad7bc5d4">createPointIndexGrid</a> (const PointArrayT &amp;points, double voxelSize)</td></tr>
<tr class="memdesc:aec6960746cc5165cf6ac1252ad7bc5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition points into a point index grid to accelerate range and nearest-neighbor searches.  <br /></td></tr>
<tr class="memitem:a271fec55592c87ddf1f04a02207cfb34" id="r_a271fec55592c87ddf1f04a02207cfb34"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename PointArrayT&gt; </td></tr>
<tr class="memitem:a271fec55592c87ddf1f04a02207cfb34 template"><td class="memItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a271fec55592c87ddf1f04a02207cfb34">createPointIndexGrid</a> (const PointArrayT &amp;points, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> &amp;xform)</td></tr>
<tr class="memdesc:a271fec55592c87ddf1f04a02207cfb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition points into a point index grid to accelerate range and nearest-neighbor searches.  <br /></td></tr>
<tr class="memitem:af2c25ce7b65fe2e22209dce0b5eae646" id="r_af2c25ce7b65fe2e22209dce0b5eae646"><td class="memTemplParams" colspan="2">template&lt;typename PointArrayT, typename GridT&gt; </td></tr>
<tr class="memitem:af2c25ce7b65fe2e22209dce0b5eae646 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2c25ce7b65fe2e22209dce0b5eae646">isValidPartition</a> (const PointArrayT &amp;points, const GridT &amp;grid)</td></tr>
<tr class="memdesc:af2c25ce7b65fe2e22209dce0b5eae646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given point index grid represents a valid partitioning of the given point array.  <br /></td></tr>
<tr class="memitem:ab2dc20cbb018eddb5d26c53bf8cf83ab" id="r_ab2dc20cbb018eddb5d26c53bf8cf83ab"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename PointArrayT&gt; </td></tr>
<tr class="memitem:ab2dc20cbb018eddb5d26c53bf8cf83ab template"><td class="memItemLeft" align="right" valign="top">GridT::ConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2dc20cbb018eddb5d26c53bf8cf83ab">getValidPointIndexGrid</a> (const PointArrayT &amp;points, const typename GridT::ConstPtr &amp;grid)</td></tr>
<tr class="memdesc:ab2dc20cbb018eddb5d26c53bf8cf83ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repartition the <em class="arg">points</em> if needed, otherwise return the input <em class="arg">grid</em>.  <br /></td></tr>
<tr class="memitem:afb27ad923a88ee58220750ffc3914c03" id="r_afb27ad923a88ee58220750ffc3914c03"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename PointArrayT&gt; </td></tr>
<tr class="memitem:afb27ad923a88ee58220750ffc3914c03 template"><td class="memItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb27ad923a88ee58220750ffc3914c03">getValidPointIndexGrid</a> (const PointArrayT &amp;points, const typename GridT::Ptr &amp;grid)</td></tr>
<tr class="memdesc:afb27ad923a88ee58220750ffc3914c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repartition the <em class="arg">points</em> if needed, otherwise return the input <em class="arg">grid</em>.  <br /></td></tr>
<tr class="memitem:a6fffee59d3b2f6dceb2ad8e9ac53a4b7" id="r_a6fffee59d3b2f6dceb2ad8e9ac53a4b7"><td class="memTemplParams" colspan="2">template&lt;typename PointListT, typename GridT&gt; </td></tr>
<tr class="memitem:a6fffee59d3b2f6dceb2ad8e9ac53a4b7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fffee59d3b2f6dceb2ad8e9ac53a4b7">maskPoints</a> (const PointListT &amp;points, GridT &amp;grid)</td></tr>
<tr class="memdesc:a6fffee59d3b2f6dceb2ad8e9ac53a4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes every voxel of the <code>grid</code> active if it contains a point.  <br /></td></tr>
<tr class="memitem:af1a9e6032ccf9b1c6e96407559797fa3" id="r_af1a9e6032ccf9b1c6e96407559797fa3"><td class="memTemplParams" colspan="2">template&lt;typename PointListT&gt; </td></tr>
<tr class="memitem:af1a9e6032ccf9b1c6e96407559797fa3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">MaskGrid::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1a9e6032ccf9b1c6e96407559797fa3">createPointMask</a> (const PointListT &amp;points, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> &amp;xform)</td></tr>
<tr class="memdesc:af1a9e6032ccf9b1c6e96407559797fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab26e09c39606fb93509615cd9120d4b0">MaskGrid</a> where each binary voxel value is on if the voxel contains one (or more) points (i.e. the 3D position of a point is closer to this voxel than any other voxels).  <br /></td></tr>
<tr class="memitem:a1f99dbe0666280f607a4473ddf15d891" id="r_a1f99dbe0666280f607a4473ddf15d891"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename MaskT = typename GridT::template ValueConverter&lt;ValueMask&gt;::Type&gt; </td></tr>
<tr class="memitem:a1f99dbe0666280f607a4473ddf15d891 template"><td class="memItemLeft" align="right" valign="top">MaskT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f99dbe0666280f607a4473ddf15d891">createPotentialFlowMask</a> (const GridT &amp;grid, int dilation=5)</td></tr>
<tr class="memdesc:a1f99dbe0666280f607a4473ddf15d891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mask for the Potential Flow domain.  <br /></td></tr>
<tr class="memitem:a1cc4a744d5c9f2fd9c0e2a0d176861c4" id="r_a1cc4a744d5c9f2fd9c0e2a0d176861c4"><td class="memTemplParams" colspan="2">template&lt;typename Vec3T, typename GridT, typename MaskT&gt; </td></tr>
<tr class="memitem:a1cc4a744d5c9f2fd9c0e2a0d176861c4 template"><td class="memItemLeft" align="right" valign="top">GridT::template ValueConverter&lt; Vec3T &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cc4a744d5c9f2fd9c0e2a0d176861c4">createPotentialFlowNeumannVelocities</a> (const GridT &amp;collider, const MaskT &amp;domain, const typename GridT::template ValueConverter&lt; Vec3T &gt;::Type::ConstPtr boundaryVelocity, const Vec3T &amp;backgroundVelocity)</td></tr>
<tr class="memdesc:a1cc4a744d5c9f2fd9c0e2a0d176861c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Potential Flow velocities grid for the Neumann boundary.  <br /></td></tr>
<tr class="memitem:a248e7393549aaba7fcb758f85d6c4e0d" id="r_a248e7393549aaba7fcb758f85d6c4e0d"><td class="memTemplParams" colspan="2">template&lt;typename Vec3GridT, typename MaskT, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a248e7393549aaba7fcb758f85d6c4e0d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarGrid.html">VectorToScalarGrid</a>&lt; Vec3GridT &gt;::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a248e7393549aaba7fcb758f85d6c4e0d">computeScalarPotential</a> (const MaskT &amp;domain, const Vec3GridT &amp;neumann, <a class="el" href="structopenvdb_1_1v13__0_1_1math_1_1pcg_1_1State.html">math::pcg::State</a> &amp;state, InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a248e7393549aaba7fcb758f85d6c4e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Potential on the domain using the Neumann boundary conditions on solid boundaries.  <br /></td></tr>
<tr class="memitem:acec6a2371219a981e94291a793ba0685" id="r_acec6a2371219a981e94291a793ba0685"><td class="memTemplParams" colspan="2">template&lt;typename Vec3GridT&gt; </td></tr>
<tr class="memitem:acec6a2371219a981e94291a793ba0685 template"><td class="memItemLeft" align="right" valign="top">Vec3GridT::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acec6a2371219a981e94291a793ba0685">computePotentialFlow</a> (const typename <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarGrid.html">VectorToScalarGrid</a>&lt; Vec3GridT &gt;::Type &amp;potential, const Vec3GridT &amp;neumann, const typename Vec3GridT::ValueType backgroundVelocity=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b">zeroVal</a>&lt; typename Vec3GridT::TreeType::ValueType &gt;())</td></tr>
<tr class="memdesc:acec6a2371219a981e94291a793ba0685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a vector Flow Field comprising the gradient of the potential with Neumann boundary conditions applied.  <br /></td></tr>
<tr class="memitem:a8057e1165c928a37703f90eb9496083c" id="r_a8057e1165c928a37703f90eb9496083c"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a8057e1165c928a37703f90eb9496083c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8057e1165c928a37703f90eb9496083c">prune</a> (TreeT &amp;tree, typename TreeT::ValueType tolerance=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b">zeroVal</a>&lt; typename TreeT::ValueType &gt;(), bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:a8057e1165c928a37703f90eb9496083c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of a <em class="arg">tree</em> by replacing with tiles any nodes whose values are all the same (optionally to within a tolerance) and have the same active state.  <br /></td></tr>
<tr class="memitem:ab8ffdc3cdd984ae9e4c0742406cfdaee" id="r_ab8ffdc3cdd984ae9e4c0742406cfdaee"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:ab8ffdc3cdd984ae9e4c0742406cfdaee template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8ffdc3cdd984ae9e4c0742406cfdaee">pruneTiles</a> (TreeT &amp;tree, typename TreeT::ValueType tolerance=<a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b">zeroVal</a>&lt; typename TreeT::ValueType &gt;(), bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:ab8ffdc3cdd984ae9e4c0742406cfdaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of a <em class="arg">tree</em> by replacing with tiles any non-leaf nodes whose values are all the same (optionally to within a tolerance) and have the same active state.  <br /></td></tr>
<tr class="memitem:ae81e76930df0c635a4e175887352257e" id="r_ae81e76930df0c635a4e175887352257e"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:ae81e76930df0c635a4e175887352257e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae81e76930df0c635a4e175887352257e">pruneInactive</a> (TreeT &amp;tree, bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:ae81e76930df0c635a4e175887352257e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of a <em class="arg">tree</em> by replacing with background tiles any nodes whose values are all inactive.  <br /></td></tr>
<tr class="memitem:ad68447719ca38904491830b5c1caefa8" id="r_ad68447719ca38904491830b5c1caefa8"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:ad68447719ca38904491830b5c1caefa8 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad68447719ca38904491830b5c1caefa8">pruneInactiveWithValue</a> (TreeT &amp;tree, const typename TreeT::ValueType &amp;value, bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:ad68447719ca38904491830b5c1caefa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of a <em class="arg">tree</em> by replacing any nodes whose values are all inactive with tiles of the given <em class="arg">value</em>.  <br /></td></tr>
<tr class="memitem:a467d50f8a53357977d5720498a88d72c" id="r_a467d50f8a53357977d5720498a88d72c"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a467d50f8a53357977d5720498a88d72c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a467d50f8a53357977d5720498a88d72c">pruneLevelSet</a> (TreeT &amp;tree, bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:a467d50f8a53357977d5720498a88d72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of a <em class="arg">tree</em> by replacing nodes whose values are all inactive with inactive tiles having a value equal to the first value encountered in the (inactive) child.  <br /></td></tr>
<tr class="memitem:ac57eaa5cdb5f7180a68b88901e9421ad" id="r_ac57eaa5cdb5f7180a68b88901e9421ad"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:ac57eaa5cdb5f7180a68b88901e9421ad template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac57eaa5cdb5f7180a68b88901e9421ad">pruneLevelSet</a> (TreeT &amp;tree, const typename TreeT::ValueType &amp;outsideWidth, const typename TreeT::ValueType &amp;insideWidth, bool threaded=true, size_t grainSize=1)</td></tr>
<tr class="memdesc:ac57eaa5cdb5f7180a68b88901e9421ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of a <em class="arg">tree</em> by replacing nodes whose voxel values are all inactive with inactive tiles having the value -| <em class="arg">insideWidth</em> | if the voxel values are negative and | <em class="arg">outsideWidth</em> | otherwise.  <br /></td></tr>
<tr class="memitem:a8642ecf09da68f9d3d16f606be7ae301" id="r_a8642ecf09da68f9d3d16f606be7ae301"><td class="memTemplParams" colspan="2">template&lt;typename GridT&gt; </td></tr>
<tr class="memitem:a8642ecf09da68f9d3d16f606be7ae301 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8642ecf09da68f9d3d16f606be7ae301">rayTrace</a> (const GridT &amp;, const <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1BaseShader.html">BaseShader</a> &amp;, <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1BaseCamera.html">BaseCamera</a> &amp;, size_t pixelSamples=1, unsigned int seed=0, bool threaded=true)</td></tr>
<tr class="memdesc:a8642ecf09da68f9d3d16f606be7ae301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ray-trace a volume.  <br /></td></tr>
<tr class="memitem:a02be13fa85c9edfa183b39d1255ff6c4" id="r_a02be13fa85c9edfa183b39d1255ff6c4"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename IntersectorT&gt; </td></tr>
<tr class="memitem:a02be13fa85c9edfa183b39d1255ff6c4 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02be13fa85c9edfa183b39d1255ff6c4">rayTrace</a> (const GridT &amp;, const IntersectorT &amp;, const <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1BaseShader.html">BaseShader</a> &amp;, <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1BaseCamera.html">BaseCamera</a> &amp;, size_t pixelSamples=1, unsigned int seed=0, bool threaded=true)</td></tr>
<tr class="memdesc:a02be13fa85c9edfa183b39d1255ff6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ray-trace a volume using a given ray intersector.  <br /></td></tr>
<tr class="memitem:ab8c1921d688e3c65c71aac5405f155a9" id="r_ab8c1921d688e3c65c71aac5405f155a9"><td class="memTemplParams" colspan="2">template&lt;typename TreeOrLeafManagerT&gt; </td></tr>
<tr class="memitem:ab8c1921d688e3c65c71aac5405f155a9 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8c1921d688e3c65c71aac5405f155a9">signedFloodFill</a> (TreeOrLeafManagerT &amp;tree, bool threaded=true, size_t grainSize=1, <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> minLevel=0)</td></tr>
<tr class="memdesc:ab8c1921d688e3c65c71aac5405f155a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the values of all inactive voxels and tiles of a narrow-band level set from the signs of the active voxels, setting outside values to +background and inside values to -background.  <br /></td></tr>
<tr class="memitem:a059130a68dd01092e7db04afa0f2580e" id="r_a059130a68dd01092e7db04afa0f2580e"><td class="memTemplParams" colspan="2">template&lt;typename TreeOrLeafManagerT&gt; </td></tr>
<tr class="memitem:a059130a68dd01092e7db04afa0f2580e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a059130a68dd01092e7db04afa0f2580e">signedFloodFillWithValues</a> (TreeOrLeafManagerT &amp;tree, const typename TreeOrLeafManagerT::ValueType &amp;outsideWidth, const typename TreeOrLeafManagerT::ValueType &amp;insideWidth, bool threaded=true, size_t grainSize=1, <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> minLevel=0)</td></tr>
<tr class="memdesc:a059130a68dd01092e7db04afa0f2580e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the values of all inactive voxels and tiles of a narrow-band level set from the signs of the active voxels, setting exterior values to <em class="arg">outsideWidth</em> and interior values to <em class="arg">insideWidth</em>. Set the background value of this tree to <em class="arg">outsideWidth</em>.  <br /></td></tr>
<tr class="memitem:a705b035d27c69d566009424697c36a65" id="r_a705b035d27c69d566009424697c36a65"><td class="memTemplParams" colspan="2">template&lt;typename IterT&gt; </td></tr>
<tr class="memitem:a705b035d27c69d566009424697c36a65 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Histogram.html">math::Histogram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a705b035d27c69d566009424697c36a65">histogram</a> (const IterT &amp;iter, double minVal, double maxVal, size_t numBins=10, bool threaded=true)</td></tr>
<tr class="memdesc:a705b035d27c69d566009424697c36a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a scalar grid and compute a histogram of the values of the voxels that are visited, or iterate over a vector-valued grid and compute a histogram of the magnitudes of the vectors.  <br /></td></tr>
<tr class="memitem:ac6aea86a2df380225a3b3c8553efe4e3" id="r_ac6aea86a2df380225a3b3c8553efe4e3"><td class="memTemplParams" colspan="2">template&lt;typename IterT&gt; </td></tr>
<tr class="memitem:ac6aea86a2df380225a3b3c8553efe4e3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Extrema.html">math::Extrema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6aea86a2df380225a3b3c8553efe4e3">extrema</a> (const IterT &amp;iter, bool threaded=true)</td></tr>
<tr class="memdesc:ac6aea86a2df380225a3b3c8553efe4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a scalar grid and compute extrema (min/max) of the values of the voxels that are visited, or iterate over a vector-valued grid and compute extrema of the magnitudes of the vectors.  <br /></td></tr>
<tr class="memitem:a0298e9e5b5b3a443d321bd24825f1d5a" id="r_a0298e9e5b5b3a443d321bd24825f1d5a"><td class="memTemplParams" colspan="2">template&lt;typename IterT&gt; </td></tr>
<tr class="memitem:a0298e9e5b5b3a443d321bd24825f1d5a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html">math::Stats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0298e9e5b5b3a443d321bd24825f1d5a">statistics</a> (const IterT &amp;iter, bool threaded=true)</td></tr>
<tr class="memdesc:a0298e9e5b5b3a443d321bd24825f1d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a scalar grid and compute statistics (mean, variance, etc.) of the values of the voxels that are visited, or iterate over a vector-valued grid and compute statistics of the magnitudes of the vectors.  <br /></td></tr>
<tr class="memitem:aafcd95f6d9da81e339aab75465ee4e22" id="r_aafcd95f6d9da81e339aab75465ee4e22"><td class="memTemplParams" colspan="2">template&lt;typename IterT, typename ValueOp&gt; </td></tr>
<tr class="memitem:aafcd95f6d9da81e339aab75465ee4e22 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Extrema.html">math::Extrema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafcd95f6d9da81e339aab75465ee4e22">extrema</a> (const IterT &amp;iter, const ValueOp &amp;op, bool threaded)</td></tr>
<tr class="memdesc:aafcd95f6d9da81e339aab75465ee4e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a grid and compute extrema (min/max) of the values produced by applying the given functor at each voxel that is visited.  <br /></td></tr>
<tr class="memitem:ada341f0cb3d7e02cb30f563ae58d77b8" id="r_ada341f0cb3d7e02cb30f563ae58d77b8"><td class="memTemplParams" colspan="2">template&lt;typename IterT, typename ValueOp&gt; </td></tr>
<tr class="memitem:ada341f0cb3d7e02cb30f563ae58d77b8 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html">math::Stats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada341f0cb3d7e02cb30f563ae58d77b8">statistics</a> (const IterT &amp;iter, const ValueOp &amp;op, bool threaded)</td></tr>
<tr class="memdesc:ada341f0cb3d7e02cb30f563ae58d77b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a grid and compute statistics (mean, variance, etc.) of the values produced by applying the given functor at each voxel that is visited.  <br /></td></tr>
<tr class="memitem:a35876c2d474f3ed28fc6a6aa4b4f5678" id="r_a35876c2d474f3ed28fc6a6aa4b4f5678"><td class="memTemplParams" colspan="2">template&lt;typename OperatorT, typename IterT&gt; </td></tr>
<tr class="memitem:a35876c2d474f3ed28fc6a6aa4b4f5678 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html">math::Stats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35876c2d474f3ed28fc6a6aa4b4f5678">opStatistics</a> (const IterT &amp;iter, const OperatorT &amp;op=OperatorT(), bool threaded=true)</td></tr>
<tr class="memdesc:a35876c2d474f3ed28fc6a6aa4b4f5678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a grid and compute statistics (mean, variance, etc.) of the values produced by applying a given operator (see <a class="el" href="Operators_8h.html">math/Operators.h</a>) at each voxel that is visited.  <br /></td></tr>
<tr class="memitem:ab4a308e2e6c2d283bfafb3bd80c8ca43" id="r_ab4a308e2e6c2d283bfafb3bd80c8ca43"><td class="memTemplParams" colspan="2">template&lt;typename OperatorT, typename IterT&gt; </td></tr>
<tr class="memitem:ab4a308e2e6c2d283bfafb3bd80c8ca43 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Extrema.html">math::Extrema</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4a308e2e6c2d283bfafb3bd80c8ca43">opExtrema</a> (const IterT &amp;iter, const OperatorT &amp;op=OperatorT(), bool threaded=true)</td></tr>
<tr class="memdesc:ab4a308e2e6c2d283bfafb3bd80c8ca43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as opStatistics except it returns a <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Extrema.html" title="This class computes the minimum and maximum values of a population of floating-point values.">math::Extrema</a> vs a <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html" title="This class computes statistics (minimum value, maximum value, mean, variance and standard deviation) ...">math::Stats</a>.  <br /></td></tr>
<tr class="memitem:aabbae85c9cdcbfc824ca7222995f16ca" id="r_aabbae85c9cdcbfc824ca7222995f16ca"><td class="memTemplParams" colspan="2">template&lt;typename GridT&gt; </td></tr>
<tr class="memitem:aabbae85c9cdcbfc824ca7222995f16ca template"><td class="memItemLeft" align="right" valign="top">GridT::template ValueConverter&lt; float &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabbae85c9cdcbfc824ca7222995f16ca">topologyToLevelSet</a> (const GridT &amp;grid, int halfWidth=3, int closingSteps=1, int dilation=0, int smoothingSteps=0)</td></tr>
<tr class="memdesc:aabbae85c9cdcbfc824ca7222995f16ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the narrow-band signed distance to the interface between active and inactive voxels in the input grid.  <br /></td></tr>
<tr class="memitem:a07e2f42e7a8c6243963b70dece2f8113" id="r_a07e2f42e7a8c6243963b70dece2f8113"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename InterrupterT&gt; </td></tr>
<tr class="memitem:a07e2f42e7a8c6243963b70dece2f8113 template"><td class="memItemLeft" align="right" valign="top">GridT::template ValueConverter&lt; float &gt;::Type::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07e2f42e7a8c6243963b70dece2f8113">topologyToLevelSet</a> (const GridT &amp;grid, int halfWidth=3, int closingSteps=1, int dilation=0, int smoothingSteps=0, InterrupterT *interrupt=nullptr)</td></tr>
<tr class="memdesc:a07e2f42e7a8c6243963b70dece2f8113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the narrow-band signed distance to the interface between active and inactive voxels in the input grid.  <br /></td></tr>
<tr class="memitem:ada1c7e219f36d148510ce22d7599171b" id="r_ada1c7e219f36d148510ce22d7599171b"><td class="memTemplParams" colspan="2">template&lt;typename IterT, typename XformOp&gt; </td></tr>
<tr class="memitem:ada1c7e219f36d148510ce22d7599171b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada1c7e219f36d148510ce22d7599171b">foreach</a> (const IterT &amp;iter, XformOp &amp;op, bool threaded=true, bool shareOp=true)</td></tr>
<tr class="memdesc:ada1c7e219f36d148510ce22d7599171b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a grid and at each step call <code>op(iter)</code>.  <br /></td></tr>
<tr class="memitem:aa1dd9695ed106fdc71856355b0bfc1b6" id="r_aa1dd9695ed106fdc71856355b0bfc1b6"><td class="memTemplParams" colspan="2">template&lt;typename IterT, typename XformOp&gt; </td></tr>
<tr class="memitem:aa1dd9695ed106fdc71856355b0bfc1b6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1dd9695ed106fdc71856355b0bfc1b6">foreach</a> (const IterT &amp;iter, const XformOp &amp;op, bool threaded=true, bool shareOp=true)</td></tr>
<tr class="memitem:ae7aba10043b96fad10e7d79a26de0bd0" id="r_ae7aba10043b96fad10e7d79a26de0bd0"><td class="memTemplParams" colspan="2">template&lt;typename InIterT, typename OutGridT, typename XformOp&gt; </td></tr>
<tr class="memitem:ae7aba10043b96fad10e7d79a26de0bd0 template"><td class="memItemLeft" align="right" valign="top">undefined void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7aba10043b96fad10e7d79a26de0bd0">transformValues</a> (const InIterT &amp;inIter, OutGridT &amp;outGrid, XformOp &amp;op, bool threaded=true, bool shareOp=true, <a class="el" href="namespaceopenvdb_1_1v13__0.html#ade9c95ac55c647839e6f3e9b462c0575">MergePolicy</a> merge=<a class="el" href="namespaceopenvdb_1_1v13__0.html#ade9c95ac55c647839e6f3e9b462c0575a89c44945b26534bc1d5ede51c342400e">MERGE_ACTIVE_STATES</a>)</td></tr>
<tr class="memdesc:ae7aba10043b96fad10e7d79a26de0bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a grid and at each step call <span class="tt">op(iter, accessor)</span> to populate (via the accessor) the given output grid, whose <code>ValueType</code> need not be the same as the input grid's.  <br /></td></tr>
<tr class="memitem:ac86a388007dc41bc538d796f34047d45" id="r_ac86a388007dc41bc538d796f34047d45"><td class="memTemplParams" colspan="2">template&lt;typename InIterT, typename OutGridT, typename XformOp&gt; </td></tr>
<tr class="memitem:ac86a388007dc41bc538d796f34047d45 template"><td class="memItemLeft" align="right" valign="top">undefined void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac86a388007dc41bc538d796f34047d45">transformValues</a> (const InIterT &amp;inIter, OutGridT &amp;outGrid, const XformOp &amp;op, bool threaded=true, bool shareOp=true, <a class="el" href="namespaceopenvdb_1_1v13__0.html#ade9c95ac55c647839e6f3e9b462c0575">MergePolicy</a> merge=<a class="el" href="namespaceopenvdb_1_1v13__0.html#ade9c95ac55c647839e6f3e9b462c0575a89c44945b26534bc1d5ede51c342400e">MERGE_ACTIVE_STATES</a>)</td></tr>
<tr class="memitem:a8e31fdabdae973490731a7be4f31d9ad" id="r_a8e31fdabdae973490731a7be4f31d9ad"><td class="memTemplParams" colspan="2">template&lt;typename IterT, typename XformOp&gt; </td></tr>
<tr class="memitem:a8e31fdabdae973490731a7be4f31d9ad template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e31fdabdae973490731a7be4f31d9ad">accumulate</a> (const IterT &amp;iter, XformOp &amp;op, bool threaded=true)</td></tr>
<tr class="memitem:adbdcf782cb40fcb514524737e2f8e070" id="r_adbdcf782cb40fcb514524737e2f8e070"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:adbdcf782cb40fcb514524737e2f8e070 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbdcf782cb40fcb514524737e2f8e070">setValueOnMin</a> (TreeT &amp;tree, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const typename TreeT::ValueType &amp;value)</td></tr>
<tr class="memdesc:adbdcf782cb40fcb514524737e2f8e070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates in <em class="arg">tree</em> to the minimum of its current value and <em class="arg">value</em>, and mark the voxel as active.  <br /></td></tr>
<tr class="memitem:a7c76dc587d3f1735c0113f04ace2f257" id="r_a7c76dc587d3f1735c0113f04ace2f257"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a7c76dc587d3f1735c0113f04ace2f257 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c76dc587d3f1735c0113f04ace2f257">setValueOnMax</a> (TreeT &amp;tree, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const typename TreeT::ValueType &amp;value)</td></tr>
<tr class="memdesc:a7c76dc587d3f1735c0113f04ace2f257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates in <em class="arg">tree</em> to the maximum of its current value and <em class="arg">value</em>, and mark the voxel as active.  <br /></td></tr>
<tr class="memitem:a92d1e43e1896e1a7fa9548c4fd4a2988" id="r_a92d1e43e1896e1a7fa9548c4fd4a2988"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a92d1e43e1896e1a7fa9548c4fd4a2988 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92d1e43e1896e1a7fa9548c4fd4a2988">setValueOnSum</a> (TreeT &amp;tree, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const typename TreeT::ValueType &amp;value)</td></tr>
<tr class="memdesc:a92d1e43e1896e1a7fa9548c4fd4a2988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates in <em class="arg">tree</em> to the sum of its current value and <em class="arg">value</em>, and mark the voxel as active.  <br /></td></tr>
<tr class="memitem:a2fa019501d9dddd1891421935c31efba" id="r_a2fa019501d9dddd1891421935c31efba"><td class="memTemplParams" colspan="2">template&lt;typename TreeT&gt; </td></tr>
<tr class="memitem:a2fa019501d9dddd1891421935c31efba template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fa019501d9dddd1891421935c31efba">setValueOnMult</a> (TreeT &amp;tree, const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;xyz, const typename TreeT::ValueType &amp;value)</td></tr>
<tr class="memdesc:a2fa019501d9dddd1891421935c31efba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates in <em class="arg">tree</em> to the product of its current value and <em class="arg">value</em>, and mark the voxel as active.  <br /></td></tr>
<tr class="memitem:a642190ccc3febe94d8b07ac37f892349" id="r_a642190ccc3febe94d8b07ac37f892349"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a642190ccc3febe94d8b07ac37f892349 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a642190ccc3febe94d8b07ac37f892349">transformVectors</a> (GridType &amp;, const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#abaf7f913bf1752b9157259ffa32704ca">Mat4d</a> &amp;)</td></tr>
<tr class="memdesc:a642190ccc3febe94d8b07ac37f892349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an affine transform to the voxel values of a vector-valued grid in accordance with the grid's vector type (covariant, contravariant, etc.).  <br /></td></tr>
<tr class="memitem:a2641c8c08ca3ed3bf4cea4d9b52434b5" id="r_a2641c8c08ca3ed3bf4cea4d9b52434b5"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a2641c8c08ca3ed3bf4cea4d9b52434b5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2641c8c08ca3ed3bf4cea4d9b52434b5">volumeToMesh</a> (const GridType &amp;grid, std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;points, std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, double isovalue=0.0)</td></tr>
<tr class="memdesc:a2641c8c08ca3ed3bf4cea4d9b52434b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniformly mesh any scalar grid that has a continuous isosurface.  <br /></td></tr>
<tr class="memitem:a576ce1469c40253573f9c3ad65369806" id="r_a576ce1469c40253573f9c3ad65369806"><td class="memTemplParams" colspan="2">template&lt;typename GridType&gt; </td></tr>
<tr class="memitem:a576ce1469c40253573f9c3ad65369806 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a576ce1469c40253573f9c3ad65369806">volumeToMesh</a> (const GridType &amp;grid, std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;points, std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;triangles, std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;quads, double isovalue=0.0, double adaptivity=0.0, bool relaxDisorientedTriangles=true)</td></tr>
<tr class="memdesc:a576ce1469c40253573f9c3ad65369806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptively mesh any scalar grid that has a continuous isosurface.  <br /></td></tr>
<tr class="memitem:aff2004f746efe615a376354f56ae3c6e" id="r_aff2004f746efe615a376354f56ae3c6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">Vec3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff2004f746efe615a376354f56ae3c6e">findFeaturePoint</a> (const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">Vec3d</a> &gt; &amp;points, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">Vec3d</a> &gt; &amp;normals)</td></tr>
<tr class="memdesc:aff2004f746efe615a376354f56ae3c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of tangent elements, <code>points</code> with corresponding <code>normals</code>, this method returns the intersection point of all tangent elements.  <br /></td></tr>
<tr class="memitem:af3f0e9f42ab322b7dd0f54dfb5b28556" id="r_af3f0e9f42ab322b7dd0f54dfb5b28556"><td class="memTemplParams" colspan="2">template&lt;typename GridT, typename InterrupterT = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:af3f0e9f42ab322b7dd0f54dfb5b28556 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3f0e9f42ab322b7dd0f54dfb5b28556">fillWithSpheres</a> (const GridT &amp;grid, std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a5ac9cf81cc2f815e160e3ed02ff551b7">openvdb::Vec4s</a> &gt; &amp;spheres, const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a117a07b9e7c47a4975f94512a951bd73">Vec2i</a> &amp;sphereCount=<a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a117a07b9e7c47a4975f94512a951bd73">Vec2i</a>(1, 50), bool overlapping=false, float minRadius=1.0, float maxRadius=std::numeric_limits&lt; float &gt;::max(), float isovalue=0.0, int instanceCount=10000, InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:af3f0e9f42ab322b7dd0f54dfb5b28556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a closed level set or fog volume with adaptively-sized spheres.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5844baaab66cb9519db44a85d8cc0fd7" id="r_a5844baaab66cb9519db44a85d8cc0fd7"><td class="memTemplParams" colspan="2">template&lt;typename SdfGridT, typename ExtValueT&gt; </td></tr>
<tr class="memitem:a5844baaab66cb9519db44a85d8cc0fd7 template"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5844baaab66cb9519db44a85d8cc0fd7">FastSweeping&lt; SdfGridT, ExtValueT &gt;::mOffset</a> [6]</td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a15acb14744ad597506ab2c876df1e3c0" name="a15acb14744ad597506ab2c876df1e3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15acb14744ad597506ab2c876df1e3c0">&#9670;&#160;</a></span>CsgIntersectionOp</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a15acb14744ad597506ab2c876df1e3c0">CsgIntersectionOp</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CsgUnionOrIntersectionOp.html">CsgUnionOrIntersectionOp</a>&lt;TreeT, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2bd678647ee7c097628900599ecd911" name="aa2bd678647ee7c097628900599ecd911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bd678647ee7c097628900599ecd911">&#9670;&#160;</a></span>CsgUnionOp</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa2bd678647ee7c097628900599ecd911">CsgUnionOp</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1CsgUnionOrIntersectionOp.html">CsgUnionOrIntersectionOp</a>&lt;TreeT, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0b5eb564884170a157dd5ea34c183f5" name="ae0b5eb564884170a157dd5ea34c183f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b5eb564884170a157dd5ea34c183f5">&#9670;&#160;</a></span>ParticleIndexAtlas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae0b5eb564884170a157dd5ea34c183f5">ParticleIndexAtlas</a> = <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ParticleAtlas.html">ParticleAtlas</a>&lt;<a class="el" href="#acfb828103bf471f9c51ea65d156e4498">PointIndexGrid</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acfb828103bf471f9c51ea65d156e4498" name="acfb828103bf471f9c51ea65d156e4498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb828103bf471f9c51ea65d156e4498">&#9670;&#160;</a></span>PointIndexGrid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acfb828103bf471f9c51ea65d156e4498">PointIndexGrid</a> = <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html">Grid</a>&lt;<a class="el" href="#aa8f0da3a97a2a253d68f2ab76545121c">PointIndexTree</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Point index grid. </p>

</div>
</div>
<a id="aa8f0da3a97a2a253d68f2ab76545121c" name="aa8f0da3a97a2a253d68f2ab76545121c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f0da3a97a2a253d68f2ab76545121c">&#9670;&#160;</a></span>PointIndexTree</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa8f0da3a97a2a253d68f2ab76545121c">PointIndexTree</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1tree_1_1Tree.html">tree::Tree</a>&lt;<a class="code hl_class" href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">tree::RootNode</a>&lt;tree::InternalNode&lt;tree::InternalNode</div>
<div class="line">    &lt;<a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1tools_1_1PointIndexLeafNode.html">PointIndexLeafNode&lt;PointIndex32, 3&gt;</a>, 4&gt;, 5&gt;&gt;&gt;</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1tree_1_1RootNode_html"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1tree_1_1RootNode.html">openvdb::v13_0::tree::RootNode</a></div><div class="ttdef"><b>Definition</b> RootNode.h:40</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1tree_1_1Tree_html"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1tree_1_1Tree.html">openvdb::v13_0::tree::Tree</a></div><div class="ttdef"><b>Definition</b> Tree.h:195</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1tools_1_1PointIndexLeafNode_html"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1tools_1_1PointIndexLeafNode.html">openvdb::v13_0::tools::PointIndexLeafNode</a></div><div class="ttdef"><b>Definition</b> PointIndexGrid.h:1359</div></div>
</div><!-- fragment -->
<p>Point index tree configured to match the default OpenVDB tree configuration. </p>

</div>
</div>
<a id="a48d92c3835e9c28ed5fd3c9a416d3585" name="a48d92c3835e9c28ed5fd3c9a416d3585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d92c3835e9c28ed5fd3c9a416d3585">&#9670;&#160;</a></span>PointList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a48d92c3835e9c28ed5fd3c9a416d3585">PointList</a> = std::unique_ptr&lt;<a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">openvdb::Vec3s</a>[]&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Point and primitive list types. </p>

</div>
</div>
<a id="aa4c6e4a427196ef80116eb8fd76a62b6" name="aa4c6e4a427196ef80116eb8fd76a62b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c6e4a427196ef80116eb8fd76a62b6">&#9670;&#160;</a></span>PolygonPoolList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa4c6e4a427196ef80116eb8fd76a62b6">PolygonPoolList</a> = std::unique_ptr&lt;<a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1PolygonPool.html">PolygonPool</a>[]&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Point and primitive list types. </p>

</div>
</div>
<a id="a52bc789f19484fd8102225765173f548" name="a52bc789f19484fd8102225765173f548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bc789f19484fd8102225765173f548">&#9670;&#160;</a></span>UInt32PointPartitioner</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a52bc789f19484fd8102225765173f548">UInt32PointPartitioner</a> = <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1PointPartitioner.html">PointPartitioner</a>&lt;uint32_t, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a4135bb0acbab0219a18f9ee33c079475" name="a4135bb0acbab0219a18f9ee33c079475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4135bb0acbab0219a18f9ee33c079475">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polygon flags, used for reference based meshing. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4135bb0acbab0219a18f9ee33c079475aa911a2c909b228a84da11c9e7ec8d6f4" name="a4135bb0acbab0219a18f9ee33c079475aa911a2c909b228a84da11c9e7ec8d6f4"></a>POLYFLAG_EXTERIOR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4135bb0acbab0219a18f9ee33c079475a6162751648b85f251927667c2b51ca67" name="a4135bb0acbab0219a18f9ee33c079475a6162751648b85f251927667c2b51ca67"></a>POLYFLAG_FRACTURE_SEAM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4135bb0acbab0219a18f9ee33c079475acbee21124fa14157f6c0c992c4728c7b" name="a4135bb0acbab0219a18f9ee33c079475acbee21124fa14157f6c0c992c4728c7b"></a>POLYFLAG_SUBDIVIDED&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a4af148611e5ef140a0121ee996fb8321" name="a4af148611e5ef140a0121ee996fb8321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af148611e5ef140a0121ee996fb8321">&#9670;&#160;</a></span>DSCompositeOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a4af148611e5ef140a0121ee996fb8321">DSCompositeOp</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We currrently support the following operations when compositing sparse data into a dense grid. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4af148611e5ef140a0121ee996fb8321a812485f135c6cee2586b34b814cddc6a" name="a4af148611e5ef140a0121ee996fb8321a812485f135c6cee2586b34b814cddc6a"></a>DS_OVER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4af148611e5ef140a0121ee996fb8321a8d4beb09c71b751771158b53d1cf99c3" name="a4af148611e5ef140a0121ee996fb8321a8d4beb09c71b751771158b53d1cf99c3"></a>DS_ADD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4af148611e5ef140a0121ee996fb8321afa18e1086c47d6d467d2ca6e708f739b" name="a4af148611e5ef140a0121ee996fb8321afa18e1086c47d6d467d2ca6e708f739b"></a>DS_SUB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4af148611e5ef140a0121ee996fb8321a85f583b7144fce0c85930f1a01c25a72" name="a4af148611e5ef140a0121ee996fb8321a85f583b7144fce0c85930f1a01c25a72"></a>DS_MIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4af148611e5ef140a0121ee996fb8321abab98682392bb93a93278797f8db5d75" name="a4af148611e5ef140a0121ee996fb8321abab98682392bb93a93278797f8db5d75"></a>DS_MAX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4af148611e5ef140a0121ee996fb8321a697b1fa695bcb46b82bc1f22ff61855a" name="a4af148611e5ef140a0121ee996fb8321a697b1fa695bcb46b82bc1f22ff61855a"></a>DS_MULT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4af148611e5ef140a0121ee996fb8321ab5356cf273f92049213e30c3444f149b" name="a4af148611e5ef140a0121ee996fb8321ab5356cf273f92049213e30c3444f149b"></a>DS_SET&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a6416fa916f48d91455ce7bad5b0a33bf" name="a6416fa916f48d91455ce7bad5b0a33bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6416fa916f48d91455ce7bad5b0a33bf">&#9670;&#160;</a></span>FastSweepingDomain</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bf">FastSweepingDomain</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast Sweeping update mode. This is useful to determine narrow-band extension or field extension in one side of a signed distance field. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6416fa916f48d91455ce7bad5b0a33bfa3203264a0a3fd2d90d15ee76eeb62f40" name="a6416fa916f48d91455ce7bad5b0a33bfa3203264a0a3fd2d90d15ee76eeb62f40"></a>SWEEP_ALL&#160;</td><td class="fielddoc"><p>Update all voxels affected by the sweeping algorithm. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6416fa916f48d91455ce7bad5b0a33bfa245516447de3b999aeb0a36124ca6b70" name="a6416fa916f48d91455ce7bad5b0a33bfa245516447de3b999aeb0a36124ca6b70"></a>SWEEP_GREATER_THAN_ISOVALUE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6416fa916f48d91455ce7bad5b0a33bfa38b255d809f149cd5ae87b46c45905e6" name="a6416fa916f48d91455ce7bad5b0a33bfa38b255d809f149cd5ae87b46c45905e6"></a>SWEEP_LESS_THAN_ISOVALUE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="af9f5e36eb8e66aa36883fc3ef727e687" name="af9f5e36eb8e66aa36883fc3ef727e687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f5e36eb8e66aa36883fc3ef727e687">&#9670;&#160;</a></span>InteriorTestStrategy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687">InteriorTestStrategy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different staregies how to determine sign of an SDF when using interior test. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af9f5e36eb8e66aa36883fc3ef727e687a4db3075e87b5663df255817c35275e4d" name="af9f5e36eb8e66aa36883fc3ef727e687a4db3075e87b5663df255817c35275e4d"></a>EVAL_EVERY_VOXEL&#160;</td><td class="fielddoc"><p>Evaluates interior test at every voxel. This is usefull when we rebuild already existing SDF where evaluating previous grid is cheap </p>
</td></tr>
<tr><td class="fieldname"><a id="af9f5e36eb8e66aa36883fc3ef727e687aa02d9d741becb09d7aaeb8f32bdb2338" name="af9f5e36eb8e66aa36883fc3ef727e687aa02d9d741becb09d7aaeb8f32bdb2338"></a>EVAL_EVERY_TILE&#160;</td><td class="fielddoc"><p>Evaluates interior test at least once per tile and flood fills within the tile. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8206a04f26f57965d9cb369acafa33d7" name="a8206a04f26f57965d9cb369acafa33d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8206a04f26f57965d9cb369acafa33d7">&#9670;&#160;</a></span>MemoryLayout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a8206a04f26f57965d9cb369acafa33d7">MemoryLayout</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We currently support the following two 3D memory layouts for dense volumes: XYZ, i.e. x is the fastest moving index, and ZYX, i.e. z is the fastest moving index. The ZYX memory layout leads to nested for-loops of the order x, y, z, which we find to be the most intuitive. Hence, ZYX is the layout used throughout VDB. However, other data structures, e.g. Houdini and Maya, employ the XYZ layout. Clearly a dense volume with the ZYX layout converts more efficiently to a VDB, but we support both for convenience. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8206a04f26f57965d9cb369acafa33d7a696de54548c230cf353790fc1f73117f" name="a8206a04f26f57965d9cb369acafa33d7a696de54548c230cf353790fc1f73117f"></a>LayoutXYZ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8206a04f26f57965d9cb369acafa33d7ac4b2238a60f4ee86d9ed5a72a13fe814" name="a8206a04f26f57965d9cb369acafa33d7ac4b2238a60f4ee86d9ed5a72a13fe814"></a>LayoutZYX&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a2623bf4797b966b29fbe45c87e60481c" name="a2623bf4797b966b29fbe45c87e60481c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2623bf4797b966b29fbe45c87e60481c">&#9670;&#160;</a></span>MeshToVolumeFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a2623bf4797b966b29fbe45c87e60481c">MeshToVolumeFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mesh to volume conversion flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2623bf4797b966b29fbe45c87e60481ca99d80e217668e63e75cbd0591f034f70" name="a2623bf4797b966b29fbe45c87e60481ca99d80e217668e63e75cbd0591f034f70"></a>UNSIGNED_DISTANCE_FIELD&#160;</td><td class="fielddoc"><p>Switch from the default signed distance field conversion that classifies regions as either inside or outside the mesh boundary to a unsigned distance field conversion that only computes distance values. This conversion type does not require a closed watertight mesh. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2623bf4797b966b29fbe45c87e60481ca145012afd1cbb669fe4c8c94b041abc4" name="a2623bf4797b966b29fbe45c87e60481ca145012afd1cbb669fe4c8c94b041abc4"></a>DISABLE_INTERSECTING_VOXEL_REMOVAL&#160;</td><td class="fielddoc"><p>Disable the cleanup step that removes voxels created by self intersecting portions of the mesh. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2623bf4797b966b29fbe45c87e60481ca414a054233ec27d0ec60800ea7e73332" name="a2623bf4797b966b29fbe45c87e60481ca414a054233ec27d0ec60800ea7e73332"></a>DISABLE_RENORMALIZATION&#160;</td><td class="fielddoc"><p>Disable the distance renormalization step that smooths out bumps caused by self intersecting or overlapping portions of the mesh </p>
</td></tr>
<tr><td class="fieldname"><a id="a2623bf4797b966b29fbe45c87e60481ca4d48077f5cf6edf9cb34cf66d4d88505" name="a2623bf4797b966b29fbe45c87e60481ca4d48077f5cf6edf9cb34cf66d4d88505"></a>DISABLE_NARROW_BAND_TRIMMING&#160;</td><td class="fielddoc"><p>Disable the cleanup step that removes active voxels that exceed the narrow band limits. (Only relevant for small limits) </p>
</td></tr>
</table>

</div>
</div>
<a id="a31d3cd59d1264144ae21e5250166cfc2" name="a31d3cd59d1264144ae21e5250166cfc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d3cd59d1264144ae21e5250166cfc2">&#9670;&#160;</a></span>NearestNeighbors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Voxel topology of nearest neighbors. </p>
<dl>
<dt><b>NN_FACE</b> </dt>
<dd><p class="startdd">face adjacency (6 nearest neighbors, defined as all neighbor voxels connected along one of the primary axes)</p>
<p class="enddd"></p>
</dd>
<dt><b>NN_FACE_EDGE</b> </dt>
<dd><p class="startdd">face and edge adjacency (18 nearest neighbors, defined as all neighbor voxels connected along either one or two of the primary axes)</p>
<p class="enddd"></p>
</dd>
<dt><b>NN_FACE_EDGE_VERTEX</b> </dt>
<dd>face, edge and vertex adjacency (26 nearest neighbors, defined as all neighbor voxels connected along either one, two or all three of the primary axes) </dd>
</dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59" name="a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59"></a>NN_FACE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31d3cd59d1264144ae21e5250166cfc2a6d84698cb77f59ae061433cbb1313bbf" name="a31d3cd59d1264144ae21e5250166cfc2a6d84698cb77f59ae061433cbb1313bbf"></a>NN_FACE_EDGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31d3cd59d1264144ae21e5250166cfc2a2cbda8f22b738858b06cb668117278ee" name="a31d3cd59d1264144ae21e5250166cfc2a2cbda8f22b738858b06cb668117278ee"></a>NN_FACE_EDGE_VERTEX&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ac7a17ca003c7f18f411cab4e8b4f6e74" name="ac7a17ca003c7f18f411cab4e8b4f6e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a17ca003c7f18f411cab4e8b4f6e74">&#9670;&#160;</a></span>TilePolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ac7a17ca003c7f18f411cab4e8b4f6e74">TilePolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different policies when dilating trees with active tiles. </p>
<dl>
<dt><b>IGNORE_TILES</b> </dt>
<dd><p class="startdd">Active tiles are ignores. For dilation, only active voxels are dilated. For erosion, active tiles still appear as neighboring activity however will themselves not be eroded.</p>
<p class="enddd"></p>
</dd>
<dt><b>EXPAND_TILES</b> </dt>
<dd><p class="startdd">For dilation and erosion, active tiles are voxelized (expanded), dilated or eroded and left in their voxelized state irrespective of their final state.</p>
<p class="enddd"></p>
</dd>
<dt><b>PRESERVE_TILES</b> </dt>
<dd>For dilation, active tiles remain unchanged but they still contribute to the dilation as if they were active voxels. For erosion, active tiles are only eroded should the erosion wavefront reach them, otherwise they are left unchanged. Additionally, dense or empty nodes with constant values are pruned. </dd>
</dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac7a17ca003c7f18f411cab4e8b4f6e74ab6e5cc3f7167ba290c413016ae105d99" name="ac7a17ca003c7f18f411cab4e8b4f6e74ab6e5cc3f7167ba290c413016ae105d99"></a>IGNORE_TILES&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac7a17ca003c7f18f411cab4e8b4f6e74ab3c4d64060dcfe7f0949fb11f8ad789c" name="ac7a17ca003c7f18f411cab4e8b4f6e74ab3c4d64060dcfe7f0949fb11f8ad789c"></a>EXPAND_TILES&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac7a17ca003c7f18f411cab4e8b4f6e74ab963e977b12771992aceaf779527c26f" name="ac7a17ca003c7f18f411cab4e8b4f6e74ab963e977b12771992aceaf779527c26f"></a>PRESERVE_TILES&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ada7a0b56d443666f8e378e9df7a9a5df" name="ada7a0b56d443666f8e378e9df7a9a5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7a0b56d443666f8e378e9df7a9a5df">&#9670;&#160;</a></span>TubeRadiiPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ada7a0b56d443666f8e378e9df7a9a5df">TubeRadiiPolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different policies when creating a tube complex with varying radii. </p>
<dl>
<dt><b>TUBE_VERTEX_RADII</b> </dt>
<dd><p class="startdd">Specify that the tube complex radii are per-vertex, meaning each tube has different radii at its two endpoints and the complex is a collection of tapered capsules.</p>
<p class="enddd"></p>
</dd>
<dt><b>TUBE_SEGMENT_RADII</b> </dt>
<dd><p class="startdd">Specify that the tube complex radii are per-segment, meaning each tube has a constant radius and the complex is a collection of capsules.</p>
<p class="enddd"></p>
</dd>
<dt><b>TUBE_AUTOMATIC</b> </dt>
<dd>Specify that the only valid setting is to be chosen, defaulting to the per-vertex policy if both are valid. </dd>
</dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ada7a0b56d443666f8e378e9df7a9a5dfa1564590332bb2919066afe3cd01eacc7" name="ada7a0b56d443666f8e378e9df7a9a5dfa1564590332bb2919066afe3cd01eacc7"></a>TUBE_AUTOMATIC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ada7a0b56d443666f8e378e9df7a9a5dfa067b6aa26d743b55e1338178e41b7ece" name="ada7a0b56d443666f8e378e9df7a9a5dfa067b6aa26d743b55e1338178e41b7ece"></a>TUBE_VERTEX_RADII&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ada7a0b56d443666f8e378e9df7a9a5dfa9eeb65784dfcf77b0b4101a184d4dda9" name="ada7a0b56d443666f8e378e9df7a9a5dfa9eeb65784dfcf77b0b4101a184d4dda9"></a>TUBE_SEGMENT_RADII&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a42ca9de20063a42244190f7ebbb68914" name="a42ca9de20063a42244190f7ebbb68914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ca9de20063a42244190f7ebbb68914">&#9670;&#160;</a></span>Abs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1MeshToVoxelEdgeData_1_1EdgeData.html">MeshToVoxelEdgeData::EdgeData</a> Abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1MeshToVoxelEdgeData_1_1EdgeData.html">MeshToVoxelEdgeData::EdgeData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e31fdabdae973490731a7be4f31d9ad" name="a8e31fdabdae973490731a7be4f31d9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e31fdabdae973490731a7be4f31d9ad">&#9670;&#160;</a></span>accumulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterT, typename XformOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void accumulate </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XformOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterate over a grid and at each step call <code>op(iter)</code>. If threading is enabled, call <code>op.join(otherOp)</code> to accumulate intermediate results from pairs of threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over a grid or its tree (<code><a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::NodeIter</code>, etc.) </td></tr>
    <tr><td class="paramname">op</td><td>a functor with a join method of the form <span class="tt">void join(XformOp&amp;)</span> and a call method of the form <span class="tt">void op(const IterT&amp;)</span>, where <code>IterT</code> is the type of <em class="arg">iter</em> </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, transform multiple values of the grid in parallel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <em class="arg">threaded</em> is true, each thread gets its own copy of the <em>original</em> functor. The order in which threads are joined is unspecified. </dd>
<dd>
If <em class="arg">threaded</em> is false, the join method is never called.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Compute the average of the active values of a scalar, floating-point grid using the <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html" title="This class computes statistics (minimum value, maximum value, mean, variance and standard deviation) ...">math::Stats</a> class. <div class="fragment"><div class="line"><span class="keyword">namespace </span>{</div>
<div class="line">    <span class="keyword">struct </span>Average {</div>
<div class="line">        <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html">math::Stats</a> stats;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Accumulate voxel and tile values into this functor&#39;s Stats object.</span></div>
<div class="line">        <span class="keyword">inline</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">FloatGrid::ValueOnCIter</a>&amp; iter) {</div>
<div class="line">            <span class="keywordflow">if</span> (iter.isVoxelValue()) stats.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html#a1c762a4059fc92d21d53c05f268227b1">add</a>(*iter);</div>
<div class="line">            <span class="keywordflow">else</span> stats.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html#a1c762a4059fc92d21d53c05f268227b1">add</a>(*iter, iter.getVoxelCount());</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Accumulate another functor&#39;s Stats object into this functor&#39;s.</span></div>
<div class="line">        <span class="keyword">inline</span> <span class="keywordtype">void</span> join(Average&amp; other) { stats.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html#a1c762a4059fc92d21d53c05f268227b1">add</a>(other.stats); }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Return the cumulative result.</span></div>
<div class="line">        <span class="keyword">inline</span> <span class="keywordtype">double</span> average()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> stats.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html#a602edc19b448a24d0f2a891e446f3f85">mean</a>(); }</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> grid = ...;</div>
<div class="line">    Average op;</div>
<div class="line">    <a class="code hl_function" href="#a8e31fdabdae973490731a7be4f31d9ad">tools::accumulate</a>(grid.cbeginValueOn(), op);</div>
<div class="line">    <span class="keywordtype">double</span> average = op.average();</div>
<div class="line">}</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1Grid_html_a7ccc223c434beb0d880d1675bd716b12"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">openvdb::v13_0::Grid&lt; FloatTree &gt;::ValueOnCIter</a></div><div class="ttdeci">typename FloatTree::ValueOnCIter ValueOnCIter</div><div class="ttdef"><b>Definition</b> Grid.h:583</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1Stats_html"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html">openvdb::v13_0::math::Stats</a></div><div class="ttdoc">This class computes statistics (minimum value, maximum value, mean, variance and standard deviation) ...</div><div class="ttdef"><b>Definition</b> Stats.h:180</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1Stats_html_a1c762a4059fc92d21d53c05f268227b1"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html#a1c762a4059fc92d21d53c05f268227b1">openvdb::v13_0::math::Stats::add</a></div><div class="ttdeci">void add(double val)</div><div class="ttdoc">Add a single sample.</div><div class="ttdef"><b>Definition</b> Stats.h:190</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1Stats_html_a602edc19b448a24d0f2a891e446f3f85"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html#a602edc19b448a24d0f2a891e446f3f85">openvdb::v13_0::math::Stats::mean</a></div><div class="ttdeci">double mean() const</div><div class="ttdef"><b>Definition</b> Stats.h:223</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tools_html_a8e31fdabdae973490731a7be4f31d9ad"><div class="ttname"><a href="#a8e31fdabdae973490731a7be4f31d9ad">openvdb::v13_0::tools::accumulate</a></div><div class="ttdeci">void accumulate(const IterT &amp;iter, XformOp &amp;op, bool threaded=true)</div><div class="ttdef"><b>Definition</b> ValueTransformer.h:683</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_html_a2ae45d4df056c7d0d936a496fec925ee"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0.html#a2ae45d4df056c7d0d936a496fec925ee">openvdb::v13_0::FloatGrid</a></div><div class="ttdeci">Grid&lt; FloatTree &gt; FloatGrid</div><div class="ttdef"><b>Definition</b> openvdb.h:76</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>For more complex operations that require finer control over threading, consider using <code>tbb::parallel_for()</code> or <code>tbb::parallel_reduce()</code> in conjunction with a <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1IteratorRange.html">tree::IteratorRange</a> that wraps a grid or tree iterator. </dd></dl>

</div>
</div>
<a id="afbad51b90ae8354757fa735b4d2058b0" name="afbad51b90ae8354757fa735b4d2058b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbad51b90ae8354757fa735b4d2058b0">&#9670;&#160;</a></span>activate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void activate </td>
          <td>(</td>
          <td class="paramtype">GridOrTree &amp;</td>          <td class="paramname"><span class="paramname"><em>gridOrTree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridOrTree::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridOrTree::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b">zeroVal</a>&lt;typename&#160;GridOrTree::ValueType&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark as active any inactive tiles or voxels in the given grid or tree whose values are equal to <em class="arg">value</em> (optionally to within the given <em class="arg">tolerance</em>). </p>

</div>
</div>
<a id="a5662e54e5608edc934c09c8bac2ec3ea" name="a5662e54e5608edc934c09c8bac2ec3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5662e54e5608edc934c09c8bac2ec3ea">&#9670;&#160;</a></span>activeTiles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1TileData.html">TileData</a>&lt; typename TreeT::ValueType &gt; &gt; activeTiles </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector with bounding boxes that represents all the intersections between active tiles in the tree and the specified bounding box. </p>
<dl class="section warning"><dt>Warning</dt><dd>For repeated calls to this method consider instead creating an instance of <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1FindActiveValues.html" title="Finds the active values in a tree which intersects a bounding box.">FindActiveValues</a> and then repeatedly call count(). This assumes the tree to be constant between calls but is slightly faster.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>const tree to be tested for active tiles. </td></tr>
    <tr><td class="paramname">bbox</td><td>index bounding box which is intersected against the active tiles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b0a2e1f38b296a8dd5f1494efb51bed" name="a7b0a2e1f38b296a8dd5f1494efb51bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0a2e1f38b296a8dd5f1494efb51bed">&#9670;&#160;</a></span>anyActiveTiles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool anyActiveTiles </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the bounding box intersects any of the active tiles in a tree, i.e. ignores active leaf values. </p>
<dl class="section warning"><dt>Warning</dt><dd>For repeated calls to this method consider instead creating an instance of <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1FindActiveValues.html" title="Finds the active values in a tree which intersects a bounding box.">FindActiveValues</a> and then repeatedly call <a class="el" href="#a7b0a2e1f38b296a8dd5f1494efb51bed" title="Returns true if the bounding box intersects any of the active tiles in a tree, i.e....">anyActiveTiles()</a>. This assumes the tree to be constant between calls but is slightly faster.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>const tree to be tested for active tiles. </td></tr>
    <tr><td class="paramname">bbox</td><td>index bounding box which is intersected against the active tiles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1562d5f6c1e6d39636666756be0234a3" name="a1562d5f6c1e6d39636666756be0234a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1562d5f6c1e6d39636666756be0234a3">&#9670;&#160;</a></span>anyActiveValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool anyActiveValues </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the bounding box intersects any of the active values in a tree, i.e. either active voxels or active tiles. </p>
<dl class="section warning"><dt>Warning</dt><dd>For repeated calls to this method consider instead creating an instance of <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1FindActiveValues.html" title="Finds the active values in a tree which intersects a bounding box.">FindActiveValues</a> and then repeatedly call <a class="el" href="#a1562d5f6c1e6d39636666756be0234a3" title="Returns true if the bounding box intersects any of the active values in a tree, i....">anyActiveValues()</a>. This assumes the tree to be constant between calls but is slightly faster.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>const tree to be tested for active values. </td></tr>
    <tr><td class="paramname">bbox</td><td>index bounding box which is intersected against the active values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ddfbc3ca506b15623bcffd355f2e749" name="a8ddfbc3ca506b15623bcffd355f2e749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddfbc3ca506b15623bcffd355f2e749">&#9670;&#160;</a></span>anyActiveVoxels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool anyActiveVoxels </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the bounding box intersects any of the active voxels in a tree, i.e. ignores active tile values. </p>
<dl class="section note"><dt>Note</dt><dd>In VDB voxels by definition reside in the leaf nodes ONLY. So this method ignores active tile values that reside higher up in the VDB tree structure.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For repeated calls to this method consider instead creating an instance of <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1FindActiveValues.html" title="Finds the active values in a tree which intersects a bounding box.">FindActiveValues</a> and then repeatedly call <a class="el" href="#a8ddfbc3ca506b15623bcffd355f2e749" title="Returns true if the bounding box intersects any of the active voxels in a tree, i....">anyActiveVoxels()</a>. This assumes the tree to be constant between calls but is slightly faster.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>const tree to be tested for active voxels. </td></tr>
    <tr><td class="paramname">bbox</td><td>index bounding box which is intersected against the active voxels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7573006df5786ba9cd6c564e4bd589ac" name="a7573006df5786ba9cd6c564e4bd589ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7573006df5786ba9cd6c564e4bd589ac">&#9670;&#160;</a></span>changeAsymmetricLevelSetBackground()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeOrLeafManagerT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void changeAsymmetricLevelSetBackground </td>
          <td>(</td>
          <td class="paramtype">TreeOrLeafManagerT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeOrLeafManagerT::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>outsideWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeOrLeafManagerT::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>insideWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">32</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the background values in all the nodes of a floating-point tree containing a possibly asymmetric narrow-band level set. </p>
<p>All inactive values will be set to +| <em class="arg">outsideWidth</em> | if outside and -| <em class="arg">insideWidth</em> | if inside, where <em class="arg">outsideWidth</em> is the outside width of the narrow band and <em class="arg">insideWidth</em> is its inside width.</p>
<dl class="section note"><dt>Note</dt><dd>This method is faster than changeBackground since it does not perform tests to see if inactive values are equal to the old background value. </dd>
<dd>
If a LeafManager is used the cached leaf nodes are reused, resulting in slightly better overall performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree (or LeafManager) that will have its background value changed </td></tr>
    <tr><td class="paramname">outsideWidth</td><td>The width of the outside of the narrow band </td></tr>
    <tr><td class="paramname">insideWidth</td><td>The width of the inside of the narrow band </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1ValueError.html">ValueError</a></td><td>if <em class="arg">outsideWidth</em> is negative or <em class="arg">insideWidth</em> is not negative (as defined by <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a942957f1908446c00fcb1196189aaaba" title="Return true if x is less than zero.">math::isNegative</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad795f2f3910144753a5e03d12f4703de" name="ad795f2f3910144753a5e03d12f4703de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad795f2f3910144753a5e03d12f4703de">&#9670;&#160;</a></span>changeBackground()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeOrLeafManagerT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void changeBackground </td>
          <td>(</td>
          <td class="paramtype">TreeOrLeafManagerT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeOrLeafManagerT::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>background</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">32</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the background value in all the nodes of a tree. </p>
<p>The sign of the background value is preserved, and only inactive values equal to the old background value are replaced.</p>
<dl class="section note"><dt>Note</dt><dd>If a LeafManager is used the cached leaf nodes are reused, resulting in slightly better overall performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree (or LeafManager) that will have its background value changed </td></tr>
    <tr><td class="paramname">background</td><td>the new background value </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 32) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9b9e9c02f534160f2571613f2d67ef5" name="ae9b9e9c02f534160f2571613f2d67ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b9e9c02f534160f2571613f2d67ef5">&#9670;&#160;</a></span>changeLevelSetBackground()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeOrLeafManagerT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void changeLevelSetBackground </td>
          <td>(</td>
          <td class="paramtype">TreeOrLeafManagerT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeOrLeafManagerT::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">32</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the background value in all the nodes of a floating-point tree containing a symmetric narrow-band level set. </p>
<p>All inactive values will be set to +| <em class="arg">halfWidth</em> | if outside and -| <em class="arg">halfWidth</em> | if inside, where <em class="arg">halfWidth</em> is half the width of the symmetric narrow band.</p>
<dl class="section note"><dt>Note</dt><dd>This method is faster than changeBackground since it does not perform tests to see if inactive values are equal to the old background value. </dd>
<dd>
If a LeafManager is used the cached leaf nodes are reused, resulting in slightly better overall performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree (or LeafManager) that will have its background value changed </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half of the width of the symmetric narrow band </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1ValueError.html">ValueError</a></td><td>if <em class="arg">halfWidth</em> is negative (as defined by <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a942957f1908446c00fcb1196189aaaba" title="Return true if x is less than zero.">math::isNegative</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab03bd92afef729f144e63f37f417c96d" name="ab03bd92afef729f144e63f37f417c96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03bd92afef729f144e63f37f417c96d">&#9670;&#160;</a></span>checkFogVolume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string checkFogVolume </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>number</em></span><span class="paramdefsep"> = </span><span class="paramdefval">6</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform checks on a grid to see if it is a valid fog volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td><a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata.">Grid</a> to be checked </td></tr>
    <tr><td class="paramname">number</td><td>Number of the checks to be performed (see below) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string with a message indicating the nature of the issue. If no issue is detected the return string is empty.</dd></dl>
<p><em class="arg">number</em> refers to the following ordered list of checks - always starting from the top. Fast checks 1: value type is floating point 2: has FOG volume class type 3: background value is zero</p>
<p>Slower checks 4: all the values are finite, i.e not NaN or infinite 5: inactive values are zero 6: active values are in the range [0,1] </p>

</div>
</div>
<a id="ae07091e4e6f1cfb869111d233da6d9b9" name="ae07091e4e6f1cfb869111d233da6d9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07091e4e6f1cfb869111d233da6d9b9">&#9670;&#160;</a></span>checkLevelSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string checkLevelSet </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>number</em></span><span class="paramdefsep"> = </span><span class="paramdefval">9</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform checks on a grid to see if it is a valid symmetric, narrow-band level set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td><a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata.">Grid</a> to be checked </td></tr>
    <tr><td class="paramname">number</td><td>Number of the checks to be performed (see below) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string with a message indicating the nature of the issue. If no issue is detected the return string is empty.</dd></dl>
<p><em class="arg">number</em> refers to the following ordered list of checks - always starting from the top. Fast checks 1: value type is floating point 2: has level set class type 3: has uniform scale 4: background value is positive and n*dx</p>
<p>Slower checks 5: no active tiles 6: all the values are finite, i.e not NaN or infinite 7: active values in range between +-background 8: abs of inactive values = background, i.e. assuming a symmetric narrow band!</p>
<p>Relatively slow check (however multithreaded) 9: norm gradient is close to one, i.e. satisfied the Eikonal equation. </p>

</div>
</div>
<a id="a9a2667c6fe1ab087fded41b3b3f1fa4b" name="a9a2667c6fe1ab087fded41b3b3f1fa4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2667c6fe1ab087fded41b3b3f1fa4b">&#9670;&#160;</a></span>clip() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr clip </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#aa7e17f708810f66dc1d195abaf1e9dbf">BBoxd</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepInterior</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clip the given grid against a world-space bounding box and return a new grid containing the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the grid to be clipped </td></tr>
    <tr><td class="paramname">bbox</td><td>a world-space bounding box </td></tr>
    <tr><td class="paramname">keepInterior</td><td>if true, discard voxels that lie outside the bounding box; if false, discard voxels that lie inside the bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Clipping a level set will likely produce a grid that is no longer a valid level set. </dd></dl>

</div>
</div>
<a id="aec14940922fdf39c1fb55f83b017a721" name="aec14940922fdf39c1fb55f83b017a721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec14940922fdf39c1fb55f83b017a721">&#9670;&#160;</a></span>clip() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskTreeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr clip </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html">Grid</a>&lt; MaskTreeType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepInterior</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clip a grid against the active voxels of another grid and return a new grid containing the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the grid to be clipped </td></tr>
    <tr><td class="paramname">mask</td><td>a grid whose active voxels form a boolean clipping mask </td></tr>
    <tr><td class="paramname">keepInterior</td><td>if true, discard voxels that do not intersect the mask; if false, discard voxels that intersect the mask</td></tr>
  </table>
  </dd>
</dl>
<p>The mask grid need not have the same transform as the source grid. Also, if the mask grid is a level set, consider using <a class="el" href="#a59b83096927350f3324cba935be37717" title="Threaded method to construct a boolean mask that represents interior regions in a signed distance fie...">tools::sdfInteriorMask</a> to construct a new mask comprising the interior (rather than the narrow band) of the level set. </p><dl class="section warning"><dt>Warning</dt><dd>Clipping a level set will likely produce a grid that is no longer a valid level set. </dd></dl>

</div>
</div>
<a id="a92b28ca7a4cb9e950e833fac3988a28b" name="a92b28ca7a4cb9e950e833fac3988a28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b28ca7a4cb9e950e833fac3988a28b">&#9670;&#160;</a></span>clip() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr clip </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1NonlinearFrustumMap.html">math::NonlinearFrustumMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>frustum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keepInterior</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clip the given grid against a frustum and return a new grid containing the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the grid to be clipped </td></tr>
    <tr><td class="paramname">frustum</td><td>a frustum map </td></tr>
    <tr><td class="paramname">keepInterior</td><td>if true, discard voxels that lie outside the frustum; if false, discard voxels that lie inside the frustum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Clipping a level set will likely produce a grid that is no longer a valid level set. </dd></dl>

</div>
</div>
<a id="ac447a41bd0a7eedf0cf3401300b09fcd" name="ac447a41bd0a7eedf0cf3401300b09fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac447a41bd0a7eedf0cf3401300b09fcd">&#9670;&#160;</a></span>compActiveLeafVoxels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT, typename OpT = composite::CopyOp&lt;TreeT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compActiveLeafVoxels </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>srcTree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>dstTree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OpT</td>          <td class="paramname"><span class="paramname"><em>op</em></span><span class="paramdefsep"> = </span><span class="paramdefval">composite::CopyOp&lt;TreeT&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composite the active values in leaf nodes, i.e. active voxels, of a source tree into a destination tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcTree</td><td>source tree from which active voxels are composited.</td></tr>
    <tr><td class="paramname">dstTree</td><td>destination tree into which active voxels are composited.</td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <span class="tt">void op(T&amp; dst, const T&amp; src)</span>, where <code>T</code> is the <code>ValueType</code> of the tree, that composites a source value into a destination value. By default it copies the value from src to dst.</td></tr>
  </table>
  </dd>
</dl>
<p>All active voxels in the source tree will be active in the destination tree, and their value is determined by a use-defined functor (OpT op) that operates on the source and destination values. The only exception is when the tree type is <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4ac363eedfcf7a254676555417b15fe2">MaskTree</a>, in which case no functor is needed since by defintion a <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4ac363eedfcf7a254676555417b15fe2">MaskTree</a> has no values (only topology).</p>
<dl class="section warning"><dt>Warning</dt><dd>This function only operated on leaf node values, i.e. tile values are ignored. </dd></dl>

</div>
</div>
<a id="a001d3e901a369bb50ed1b4e78e57b303" name="a001d3e901a369bb50ed1b4e78e57b303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001d3e901a369bb50ed1b4e78e57b303">&#9670;&#160;</a></span>compDiv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compDiv </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given grids A and B, compute a / b per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty. </p>

</div>
</div>
<a id="ab89a5ef4e61074f401e72aef834afda1" name="ab89a5ef4e61074f401e72aef834afda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89a5ef4e61074f401e72aef834afda1">&#9670;&#160;</a></span>compMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compMax </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given grids A and B, compute max(a, b) per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty. </p>

</div>
</div>
<a id="ad0f06ce463a63898a09fea378ac6912e" name="ad0f06ce463a63898a09fea378ac6912e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f06ce463a63898a09fea378ac6912e">&#9670;&#160;</a></span>compMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compMin </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given grids A and B, compute min(a, b) per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty. </p>

</div>
</div>
<a id="abdd7d6918702cd795e831789812c9ac1" name="abdd7d6918702cd795e831789812c9ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd7d6918702cd795e831789812c9ac1">&#9670;&#160;</a></span>compMul()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compMul </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given grids A and B, compute a * b per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty. </p>

</div>
</div>
<a id="ac53b377981f3baf29cef347335e3588b" name="ac53b377981f3baf29cef347335e3588b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53b377981f3baf29cef347335e3588b">&#9670;&#160;</a></span>compositeToDense()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a4af148611e5ef140a0121ee996fb8321">DSCompositeOp</a>, typename TreeT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compositeToDense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Dense.html">Dense</a>&lt; typename TreeT::ValueType, <a class="el" href="#a8206a04f26f57965d9cb369acafa33d7ac4b2238a60f4ee86d9ed5a72a13fe814">LayoutZYX</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dense</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType</td>          <td class="paramname"><span class="paramname"><em>beta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType</td>          <td class="paramname"><span class="paramname"><em>strength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composite data from a sparse tree into a dense array of the same value type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dense</td><td><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Dense.html" title="Dense is a simple dense grid API used by the CopyToDense and CopyFromDense classes defined below.">Dense</a> grid to be altered by the operation </td></tr>
    <tr><td class="paramname">source</td><td>Sparse data to composite into <code>dense</code> </td></tr>
    <tr><td class="paramname">alpha</td><td>Sparse Alpha mask used in compositing operations. </td></tr>
    <tr><td class="paramname">beta</td><td>Constant multiplier on src </td></tr>
    <tr><td class="paramname">strength</td><td>Constant multiplier on alpha </td></tr>
    <tr><td class="paramname">threaded</td><td>Enable threading for this operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a7784bcd2c95e7b015e6fc2c3c9d5d9" name="a0a7784bcd2c95e7b015e6fc2c3c9d5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7784bcd2c95e7b015e6fc2c3c9d5d9">&#9670;&#160;</a></span>compReplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compReplace </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the active voxels of B into A. </p>

</div>
</div>
<a id="ab3e57293906eddd0c42c4df3e64cc800" name="ab3e57293906eddd0c42c4df3e64cc800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e57293906eddd0c42c4df3e64cc800">&#9670;&#160;</a></span>compSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compSum </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given grids A and B, compute a + b per voxel (using sparse traversal). Store the result in the A grid and leave the B grid empty. </p>

</div>
</div>
<a id="acec6a2371219a981e94291a793ba0685" name="acec6a2371219a981e94291a793ba0685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec6a2371219a981e94291a793ba0685">&#9670;&#160;</a></span>computePotentialFlow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vec3GridT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vec3GridT::Ptr computePotentialFlow </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarGrid.html">VectorToScalarGrid</a>&lt; Vec3GridT &gt;::Type &amp;</td>          <td class="paramname"><span class="paramname"><em>potential</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec3GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>neumann</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Vec3GridT::ValueType</td>          <td class="paramname"><span class="paramname"><em>backgroundVelocity</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b">zeroVal</a>&lt;typename&#160;Vec3GridT::TreeType::ValueType&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a vector Flow Field comprising the gradient of the potential with Neumann boundary conditions applied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">potential</td><td>scalar potential, typically computed from <a class="el" href="#a248e7393549aaba7fcb758f85d6c4e0d" title="Compute the Potential on the domain using the Neumann boundary conditions on solid boundaries.">computeScalarPotential()</a> </td></tr>
    <tr><td class="paramname">neumann</td><td>the topology of this grid defines where the solid boundaries are and grid values give the Neumann boundaries that should be applied there </td></tr>
    <tr><td class="paramname">backgroundVelocity</td><td>a background velocity value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a248e7393549aaba7fcb758f85d6c4e0d" name="a248e7393549aaba7fcb758f85d6c4e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248e7393549aaba7fcb758f85d6c4e0d">&#9670;&#160;</a></span>computeScalarPotential()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vec3GridT, typename MaskT, typename InterrupterT = util::NullInterrupter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarGrid.html">VectorToScalarGrid</a>&lt; Vec3GridT &gt;::Ptr computeScalarPotential </td>
          <td>(</td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec3GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>neumann</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v13__0_1_1math_1_1pcg_1_1State.html">math::pcg::State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Potential on the domain using the Neumann boundary conditions on solid boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>a mask to represent the domain in which to perform the solve </td></tr>
    <tr><td class="paramname">neumann</td><td>the topology of this grid defines where the solid boundaries are and grid values give the Neumann boundaries that should be applied there </td></tr>
    <tr><td class="paramname">state</td><td>the solver parameters for computing the solution </td></tr>
    <tr><td class="paramname">interrupter</td><td>pointer to an optional interrupter adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<p>On input, the State object should specify convergence criteria (minimum error and maximum number of iterations); on output, it gives the actual termination conditions. </p>

</div>
</div>
<a id="a718fc3e33310680728f4fbf04db240c0" name="a718fc3e33310680728f4fbf04db240c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718fc3e33310680728f4fbf04db240c0">&#9670;&#160;</a></span>copyFromDense()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DenseT, typename GridOrTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void copyFromDense </td>
          <td>(</td>
          <td class="paramtype">const DenseT &amp;</td>          <td class="paramname"><span class="paramname"><em>dense</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>sparse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridOrTreeT::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>serial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate a sparse grid with the values of all of the voxels of a dense grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dense</td><td>the dense grid from which to copy values </td></tr>
    <tr><td class="paramname">sparse</td><td>an OpenVDB grid or tree into which to copy values </td></tr>
    <tr><td class="paramname">tolerance</td><td>values in the dense grid that are within this tolerance of the sparse grid's background value become inactive background voxels or tiles in the sparse grid </td></tr>
    <tr><td class="paramname">serial</td><td>if false, process voxels in parallel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbd41a08ed8ea7c1a7d33146b8d17ce1" name="acbd41a08ed8ea7c1a7d33146b8d17ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd41a08ed8ea7c1a7d33146b8d17ce1">&#9670;&#160;</a></span>copyToDense()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DenseT, typename GridOrTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void copyToDense </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>sparse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseT &amp;</td>          <td class="paramname"><span class="paramname"><em>dense</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>serial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate a dense grid with the values of voxels from a sparse grid, where the sparse grid intersects the dense grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sparse</td><td>an OpenVDB grid or tree from which to copy values </td></tr>
    <tr><td class="paramname">dense</td><td>the dense grid into which to copy values </td></tr>
    <tr><td class="paramname">serial</td><td>if false, process voxels in parallel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a073b47486ac79130a4de5210a44cc022" name="a073b47486ac79130a4de5210a44cc022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073b47486ac79130a4de5210a44cc022">&#9670;&#160;</a></span>countActiveLeafVoxels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> countActiveLeafVoxels </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total number of active voxels stored in leaf nodes. </p>

</div>
</div>
<a id="aaec2cca19ae239e38c2424709547eac5" name="aaec2cca19ae239e38c2424709547eac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec2cca19ae239e38c2424709547eac5">&#9670;&#160;</a></span>countActiveLeafVoxels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> countActiveLeafVoxels </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total number of active voxels stored in leaf nodes that intersects a bounding box. </p>

</div>
</div>
<a id="af3ce5e60836ad5cd560c698266e2104b" name="af3ce5e60836ad5cd560c698266e2104b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ce5e60836ad5cd560c698266e2104b">&#9670;&#160;</a></span>countActiveTiles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> countActiveTiles </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total number of active tiles in the tree. </p>

</div>
</div>
<a id="a0d05f8d7abe330825f886373991c52e3" name="a0d05f8d7abe330825f886373991c52e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d05f8d7abe330825f886373991c52e3">&#9670;&#160;</a></span>countActiveValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> countActiveValues </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of active values that intersects a bounding box intersects, i.e. the count includes both active voxels and virtual voxels in active tiles. </p>
<dl class="section warning"><dt>Warning</dt><dd>For repeated calls to this method consider instead creating an instance of <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1FindActiveValues.html" title="Finds the active values in a tree which intersects a bounding box.">FindActiveValues</a> and then repeatedly call count(). This assumes the tree to be constant between calls but is slightly faster.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>const tree to be tested for active values. </td></tr>
    <tr><td class="paramname">bbox</td><td>index bounding box which is intersected against the active values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cbb0a8d7e0521cc4165bb7e2d1081d3" name="a9cbb0a8d7e0521cc4165bb7e2d1081d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbb0a8d7e0521cc4165bb7e2d1081d3">&#9670;&#160;</a></span>countActiveVoxels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> countActiveVoxels </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total number of active voxels in the tree. </p>

</div>
</div>
<a id="a98cf0abafb6bb3dbaeefcd10f319aa71" name="a98cf0abafb6bb3dbaeefcd10f319aa71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cf0abafb6bb3dbaeefcd10f319aa71">&#9670;&#160;</a></span>countActiveVoxels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> countActiveVoxels </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total number of active voxels in the tree that intersects a bounding box. </p>

</div>
</div>
<a id="ae97f0db6ef147e3f02a5ebec9f360e3d" name="ae97f0db6ef147e3f02a5ebec9f360e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97f0db6ef147e3f02a5ebec9f360e3d">&#9670;&#160;</a></span>countInactiveLeafVoxels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> countInactiveLeafVoxels </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total number of inactive voxels stored in leaf nodes. </p>

</div>
</div>
<a id="a4d6ddf0e0a760645d2590f9b2be1c4de" name="a4d6ddf0e0a760645d2590f9b2be1c4de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6ddf0e0a760645d2590f9b2be1c4de">&#9670;&#160;</a></span>countInactiveVoxels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> countInactiveVoxels </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total number of inactive voxels in the tree. </p>

</div>
</div>
<a id="aea23457a3376d6fb611bd3f46fdffd61" name="aea23457a3376d6fb611bd3f46fdffd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea23457a3376d6fb611bd3f46fdffd61">&#9670;&#160;</a></span>cpt() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr cpt </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Closest-Point Transform (CPT) from a distance field. </p>
<dl class="section return"><dt>Returns</dt><dd>a new vector-valued grid with the same numerical precision as the input grid (for example, if the input grid is a <a class="el" href="namespaceopenvdb_1_1v13__0.html#ae4044ab7ef1bfe752d228fe84ecd996e">DoubleGrid</a>, the output grid will be a <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4047846203d0b9bcb5b7c0d3a6c7164f">Vec3DGrid</a>)</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a id="af4a1df11b58f53666af405f1c0d08f6a" name="af4a1df11b58f53666af405f1c0d08f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a1df11b58f53666af405f1c0d08f6a">&#9670;&#160;</a></span>cpt() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr cpt </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a4a7dc00308e20a77a2dfd6cb598fb4" name="a0a4a7dc00308e20a77a2dfd6cb598fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4a7dc00308e20a77a2dfd6cb598fb4">&#9670;&#160;</a></span>cpt() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr cpt </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3106d65068cff4ee14dcd7197065b11" name="ae3106d65068cff4ee14dcd7197065b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3106d65068cff4ee14dcd7197065b11">&#9670;&#160;</a></span>cpt() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr cpt </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a314c42b9d506bd60c1acdd6f41aac7" name="a9a314c42b9d506bd60c1acdd6f41aac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a314c42b9d506bd60c1acdd6f41aac7">&#9670;&#160;</a></span>createLevelSetBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename <a class="el" href="namespaceopenvdb_1_1v13__0.html#ae93f92d10730a52ed3b207d5811f6a6e">VecType</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1BBox.html">math::BBox</a>&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ae93f92d10730a52ed3b207d5811f6a6e">VecType</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename VecType::ValueType</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>a bounding box in world units </td></tr>
    <tr><td class="paramname">xform</td><td>world-to-index-space transform </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3616c88603aae7a8b19056b2af5dffcf" name="a3616c88603aae7a8b19056b2af5dffcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3616c88603aae7a8b19056b2af5dffcf">&#9670;&#160;</a></span>createLevelSetCapsule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename ScalarType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetCapsule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pt1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pt2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a capsule (tube with constant radius and sphere caps). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt1</td><td>First capsule endpoint in world units. </td></tr>
    <tr><td class="paramname">pt2</td><td>Second capsule endpoint in world units. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the capsule in world units. </td></tr>
    <tr><td class="paramname">voxelSize</td><td>Voxel size in world units. </td></tr>
    <tr><td class="paramname">halfWidth</td><td><a class="el" href="namespaceopenvdb_1_1v13__0.html#a22a8e71efc9fdc0f1f152e647c13be9d">Half</a> the width of the narrow band, in voxel units. </td></tr>
    <tr><td class="paramname">threaded</td><td>If true multi-threading is enabled (true by default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd>
<dd>
<code>ScalarType</code> represents the capsule endpoint and radius type and must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a83135743b7302d8c90a3c5c374d91d83" name="a83135743b7302d8c90a3c5c374d91d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83135743b7302d8c90a3c5c374d91d83">&#9670;&#160;</a></span>createLevelSetCapsule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename ScalarType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetCapsule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pt1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pt2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a capsule (tube with constant radius and sphere caps). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt1</td><td>First capsule endpoint in world units. </td></tr>
    <tr><td class="paramname">pt2</td><td>Second capsule endpoint in world units. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the capsule in world units. </td></tr>
    <tr><td class="paramname">voxelSize</td><td>Voxel size in world units. </td></tr>
    <tr><td class="paramname">halfWidth</td><td><a class="el" href="namespaceopenvdb_1_1v13__0.html#a22a8e71efc9fdc0f1f152e647c13be9d">Half</a> the width of the narrow band, in voxel units. </td></tr>
    <tr><td class="paramname">interrupter</td><td>Interrupter adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface. </td></tr>
    <tr><td class="paramname">threaded</td><td>If true multi-threading is enabled (true by default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd>
<dd>
<code>ScalarType</code> represents the capsule endpoint and radius type and must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a61d32f576304fe36916e2a79edb7331e" name="a61d32f576304fe36916e2a79edb7331e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d32f576304fe36916e2a79edb7331e">&#9670;&#160;</a></span>createLevelSetCube() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetCube </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a cube. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a35119954a57d54beaa1f95b9414d263f" name="a35119954a57d54beaa1f95b9414d263f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35119954a57d54beaa1f95b9414d263f">&#9670;&#160;</a></span>createLevelSetCube() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetCube </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a cube. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">interrupt</td><td>a pointer adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a9ad632e423b8d292ebea856832cd37ae" name="a9ad632e423b8d292ebea856832cd37ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad632e423b8d292ebea856832cd37ae">&#9670;&#160;</a></span>createLevelSetDilatedMesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename ScalarType, typename InterruptT = util::NullInterrupter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetDilatedMesh </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vertices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a dilated triangle &amp; quad surface mesh (dilated by a radius in all directions). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Vertices of the mesh in world units. </td></tr>
    <tr><td class="paramname">triangles</td><td>Triangle indices of the mesh. </td></tr>
    <tr><td class="paramname">quads</td><td>Quad indices of the mesh. </td></tr>
    <tr><td class="paramname">radius</td><td>Dilation radius in world units. </td></tr>
    <tr><td class="paramname">voxelSize</td><td>Voxel size in world units. </td></tr>
    <tr><td class="paramname">halfWidth</td><td><a class="el" href="namespaceopenvdb_1_1v13__0.html#a22a8e71efc9fdc0f1f152e647c13be9d">Half</a> the width of the narrow band, in voxel units. </td></tr>
    <tr><td class="paramname">interrupter</td><td>Interrupter adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd>
<dd>
<code>ScalarType</code> represents the mesh vertex and radius type and must be a floating-point scalar. </dd>
<dd>
The input mesh is always treated as a surface, and so dilation occurs in every direction. This includes meshes that could represent valid BRep solids, dilation occurs both inward and outward, forming a 'shell' rather than only expanding outward. </dd></dl>

</div>
</div>
<a id="ad4580749f12e9c314033b414a7b9a4e8" name="ad4580749f12e9c314033b414a7b9a4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4580749f12e9c314033b414a7b9a4e8">&#9670;&#160;</a></span>createLevelSetDilatedMesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename ScalarType, typename InterruptT = util::NullInterrupter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetDilatedMesh </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vertices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a dilated triangle surface mesh (dilated by a radius in all directions). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Vertices of the mesh in world units. </td></tr>
    <tr><td class="paramname">triangles</td><td>Triangle indices of the mesh. </td></tr>
    <tr><td class="paramname">radius</td><td>Dilation radius in world units. </td></tr>
    <tr><td class="paramname">voxelSize</td><td>Voxel size in world units. </td></tr>
    <tr><td class="paramname">halfWidth</td><td><a class="el" href="namespaceopenvdb_1_1v13__0.html#a22a8e71efc9fdc0f1f152e647c13be9d">Half</a> the width of the narrow band, in voxel units. </td></tr>
    <tr><td class="paramname">interrupter</td><td>Interrupter adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd>
<dd>
<code>ScalarType</code> represents the mesh vertex and radius type and must be a floating-point scalar. </dd>
<dd>
The input mesh is always treated as a surface, and so dilation occurs in every direction. This includes meshes that could represent valid BRep solids, dilation occurs both inward and outward, forming a 'shell' rather than only expanding outward. </dd></dl>

</div>
</div>
<a id="ac4bc55f527507e7844b4bf94c7ffb62b" name="ac4bc55f527507e7844b4bf94c7ffb62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bc55f527507e7844b4bf94c7ffb62b">&#9670;&#160;</a></span>createLevelSetDilatedMesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename ScalarType, typename InterruptT = util::NullInterrupter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetDilatedMesh </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vertices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a dilated quad surface mesh (dilated by a radius in all directions). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Vertices of the mesh in world units. </td></tr>
    <tr><td class="paramname">quads</td><td>Quad indices of the mesh. </td></tr>
    <tr><td class="paramname">radius</td><td>Dilation radius in world units. </td></tr>
    <tr><td class="paramname">voxelSize</td><td>Voxel size in world units. </td></tr>
    <tr><td class="paramname">halfWidth</td><td><a class="el" href="namespaceopenvdb_1_1v13__0.html#a22a8e71efc9fdc0f1f152e647c13be9d">Half</a> the width of the narrow band, in voxel units. </td></tr>
    <tr><td class="paramname">interrupter</td><td>Interrupter adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd>
<dd>
<code>ScalarType</code> represents the mesh vertex and radius type and must be a floating-point scalar. </dd>
<dd>
The input mesh is always treated as a surface, and so dilation occurs in every direction. This includes meshes that could represent valid BRep solids, dilation occurs both inward and outward, forming a 'shell' rather than only expanding outward. </dd></dl>

</div>
</div>
<a id="a8db01473589e28e24d730eb16917e782" name="a8db01473589e28e24d730eb16917e782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db01473589e28e24d730eb16917e782">&#9670;&#160;</a></span>createLevelSetDodecahedron() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetDodecahedron </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a dodecahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a404240912628b77f41fe0cae96ea9f73" name="a404240912628b77f41fe0cae96ea9f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404240912628b77f41fe0cae96ea9f73">&#9670;&#160;</a></span>createLevelSetDodecahedron() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetDodecahedron </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a dodecahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">interrupt</td><td>a pointer adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a97e50414d14e865e6622d79afdfe0169" name="a97e50414d14e865e6622d79afdfe0169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e50414d14e865e6622d79afdfe0169">&#9670;&#160;</a></span>createLevelSetIcosahedron() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetIcosahedron </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an icosahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="ab31c68df3261085a0968b539e2a911c6" name="ab31c68df3261085a0968b539e2a911c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31c68df3261085a0968b539e2a911c6">&#9670;&#160;</a></span>createLevelSetIcosahedron() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetIcosahedron </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an icosahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">interrupt</td><td>a pointer adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a650cbfe748c4a60a7910d409b4481c05" name="a650cbfe748c4a60a7910d409b4481c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650cbfe748c4a60a7910d409b4481c05">&#9670;&#160;</a></span>createLevelSetOctahedron() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetOctahedron </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an octahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a8452b0792a6c58796974e9d8ec16119e" name="a8452b0792a6c58796974e9d8ec16119e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8452b0792a6c58796974e9d8ec16119e">&#9670;&#160;</a></span>createLevelSetOctahedron() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetOctahedron </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of an octahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">interrupt</td><td>a pointer adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a567bfd74409cb75f4b724cd48b17c688" name="a567bfd74409cb75f4b724cd48b17c688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567bfd74409cb75f4b724cd48b17c688">&#9670;&#160;</a></span>createLevelSetPlatonic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetPlatonic </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>faceCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a platonic solid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faceCount</td><td>number of faces of the platonic solid, i.e. 4, 6, 8, 12 or 20 </td></tr>
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units</td></tr>
  </table>
  </dd>
</dl>
<p>Faces: TETRAHEDRON=4, CUBE=6, OCTAHEDRON=8, DODECAHEDRON=12, ICOSAHEDRON=20</p>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a55629b59f05b1a45ea3edf5f4303b7d2" name="a55629b59f05b1a45ea3edf5f4303b7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55629b59f05b1a45ea3edf5f4303b7d2">&#9670;&#160;</a></span>createLevelSetPlatonic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetPlatonic </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>faceCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a platonic solid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faceCount</td><td>number of faces of the platonic solid, i.e. 4, 6, 8, 12 or 20 </td></tr>
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">interrupt</td><td>a pointer adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<p>Faces: TETRAHEDRON=4, CUBE=6, OCTAHEDRON=8, DODECAHEDRON=12, ICOSAHEDRON=20</p>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a7e88a56fc4d07052e30bbd775dee066e" name="a7e88a56fc4d07052e30bbd775dee066e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e88a56fc4d07052e30bbd775dee066e">&#9670;&#160;</a></span>createLevelSetSphere() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetSphere </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">openvdb::Vec3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a sphere. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>radius of the sphere in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the sphere in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">threaded</td><td>if true multi-threading is enabled (true by default)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd>
<dd>
The leapfrog algorithm employed in this method is best suited for a single large sphere. For multiple small spheres consider using the faster algorithm in <a class="el" href="ParticlesToLevelSet_8h.html" title="Rasterize particles with position, radius and velocity into either a boolean mask grid or a narrow-ba...">ParticlesToLevelSet.h</a> </dd></dl>

</div>
</div>
<a id="a47e7b3c363d0d3a15b5859c4b06e9d8b" name="a47e7b3c363d0d3a15b5859c4b06e9d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e7b3c363d0d3a15b5859c4b06e9d8b">&#9670;&#160;</a></span>createLevelSetSphere() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetSphere </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">openvdb::Vec3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a sphere. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>radius of the sphere in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the sphere in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">interrupt</td><td>a pointer adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface </td></tr>
    <tr><td class="paramname">threaded</td><td>if true multi-threading is enabled (true by default)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd>
<dd>
The leapfrog algorithm employed in this method is best suited for a single large sphere. For multiple small spheres consider using the faster algorithm in <a class="el" href="ParticlesToLevelSet_8h.html" title="Rasterize particles with position, radius and velocity into either a boolean mask grid or a narrow-ba...">ParticlesToLevelSet.h</a> </dd></dl>

</div>
</div>
<a id="a9d5f0a44c56915ab82ebcbc9ac57b993" name="a9d5f0a44c56915ab82ebcbc9ac57b993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5f0a44c56915ab82ebcbc9ac57b993">&#9670;&#160;</a></span>createLevelSetTaperedCapsule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename ScalarType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetTaperedCapsule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pt1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pt2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType</td>          <td class="paramname"><span class="paramname"><em>radius1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType</td>          <td class="paramname"><span class="paramname"><em>radius2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tapered capsule (tube with sphere caps and different radii at both ends, or equivalently the convex hull of two spheres with possibly different centers and radii). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt1</td><td>First tapered capsule endpoint in world units. </td></tr>
    <tr><td class="paramname">pt2</td><td>Second tapered capsule endpoint in world units. </td></tr>
    <tr><td class="paramname">radius1</td><td>Radius of the tapered capsule at <code>pt1</code> in world units. </td></tr>
    <tr><td class="paramname">radius2</td><td>Radius of the tapered capsule at <code>pt2</code> in world units. </td></tr>
    <tr><td class="paramname">voxelSize</td><td>Voxel size in world units. </td></tr>
    <tr><td class="paramname">halfWidth</td><td><a class="el" href="namespaceopenvdb_1_1v13__0.html#a22a8e71efc9fdc0f1f152e647c13be9d">Half</a> the width of the narrow band, in voxel units. </td></tr>
    <tr><td class="paramname">threaded</td><td>If true multi-threading is enabled (true by default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd>
<dd>
<code>ScalarType</code> represents the tapered capsule endpoint and radius type and must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a8d76b118f5d20d00f08363c791b5485f" name="a8d76b118f5d20d00f08363c791b5485f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d76b118f5d20d00f08363c791b5485f">&#9670;&#160;</a></span>createLevelSetTaperedCapsule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename ScalarType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetTaperedCapsule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pt1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pt2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType</td>          <td class="paramname"><span class="paramname"><em>radius1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType</td>          <td class="paramname"><span class="paramname"><em>radius2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tapered capsule (tube with sphere caps and different radii at both ends, or equivalently the convex hull of two spheres with possibly different centers and radii). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt1</td><td>First tapered capsule endpoint in world units. </td></tr>
    <tr><td class="paramname">pt2</td><td>Second tapered capsule endpoint in world units. </td></tr>
    <tr><td class="paramname">radius1</td><td>Radius of the tapered capsule at <code>pt1</code> in world units. </td></tr>
    <tr><td class="paramname">radius2</td><td>Radius of the tapered capsule at <code>pt2</code> in world units. </td></tr>
    <tr><td class="paramname">voxelSize</td><td>Voxel size in world units. </td></tr>
    <tr><td class="paramname">halfWidth</td><td><a class="el" href="namespaceopenvdb_1_1v13__0.html#a22a8e71efc9fdc0f1f152e647c13be9d">Half</a> the width of the narrow band, in voxel units. </td></tr>
    <tr><td class="paramname">interrupter</td><td>Interrupter adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface. </td></tr>
    <tr><td class="paramname">threaded</td><td>If true multi-threading is enabled (true by default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd>
<dd>
<code>ScalarType</code> represents the tapered capsule endpoint and radius type and must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a9ff4e929ac667fa98535559637af4390" name="a9ff4e929ac667fa98535559637af4390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff4e929ac667fa98535559637af4390">&#9670;&#160;</a></span>createLevelSetTetrahedron() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetTetrahedron </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tetrahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a936b35f5b9d02bd416ecf9bbf9606305" name="a936b35f5b9d02bd416ecf9bbf9606305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936b35f5b9d02bd416ecf9bbf9606305">&#9670;&#160;</a></span>createLevelSetTetrahedron() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetTetrahedron </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4873ae29d5d8d4f1cb7c7717af41a993">Vec3f</a>(0.0f)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.1f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tetrahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>scale of the platonic solid in world units </td></tr>
    <tr><td class="paramname">center</td><td>center of the platonic solid in world units </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
    <tr><td class="paramname">interrupt</td><td>a pointer adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="ae5b0443bbddb654773e6ce9c36ecb49f" name="ae5b0443bbddb654773e6ce9c36ecb49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b0443bbddb654773e6ce9c36ecb49f">&#9670;&#160;</a></span>createLevelSetTubeComplex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename ScalarType, typename InterruptT = util::NullInterrupter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetTubeComplex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vertices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a5dcf138ef7ecb1aee6f424d6f38dfc16">Vec2I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>segments</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ScalarType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>radii</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ada7a0b56d443666f8e378e9df7a9a5df">TubeRadiiPolicy</a></td>          <td class="paramname"><span class="paramname"><em>radii_policy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ada7a0b56d443666f8e378e9df7a9a5dfa1564590332bb2919066afe3cd01eacc7">TUBE_AUTOMATIC</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tube complex (a collection of tubes defined by endpoint coordinates, segment indices, and radii). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Endpoint vertices in the tube complex in world units. </td></tr>
    <tr><td class="paramname">segments</td><td>Segment indices in the tube complex. </td></tr>
    <tr><td class="paramname">radii</td><td>Radii specification for all tubes in world units. </td></tr>
    <tr><td class="paramname">voxelSize</td><td>Voxel size in world units. </td></tr>
    <tr><td class="paramname">halfWidth</td><td><a class="el" href="namespaceopenvdb_1_1v13__0.html#a22a8e71efc9fdc0f1f152e647c13be9d">Half</a> the width of the narrow band, in voxel units. </td></tr>
    <tr><td class="paramname">radii_policy</td><td>Policies: per-segment, per-vertex, or automatic (default). </td></tr>
    <tr><td class="paramname">interrupter</td><td>Interrupter adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd>
<dd>
<code>ScalarType</code> represents the capsule complex vertex and radius type and must be a floating-point scalar. </dd>
<dd>
The automatic <code><a class="el" href="#ada7a0b56d443666f8e378e9df7a9a5df" title="Different policies when creating a tube complex with varying radii.">TubeRadiiPolicy</a></code> chooses the valid per-segment or per-vertex policy, defaulting to per-vertex if both are valid. </dd></dl>

</div>
</div>
<a id="ae49ac1292b6a77eb02e19d2fa056f1ee" name="ae49ac1292b6a77eb02e19d2fa056f1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49ac1292b6a77eb02e19d2fa056f1ee">&#9670;&#160;</a></span>createLevelSetTubeComplex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename ScalarType, typename InterruptT = util::NullInterrupter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr createLevelSetTubeComplex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Vec3.html">math::Vec3</a>&lt; ScalarType &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vertices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a5dcf138ef7ecb1aee6f424d6f38dfc16">Vec2I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>segments</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a grid of type <code>GridType</code> containing a narrow-band level set representation of a tube complex (a collection of capsules defined by endpoint coordinates and segment indices). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Endpoint vertices in the tube complex in world units. </td></tr>
    <tr><td class="paramname">segments</td><td>Segment indices in the tube complex. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of all tubes in world units. </td></tr>
    <tr><td class="paramname">voxelSize</td><td>Voxel size in world units. </td></tr>
    <tr><td class="paramname">halfWidth</td><td><a class="el" href="namespaceopenvdb_1_1v13__0.html#a22a8e71efc9fdc0f1f152e647c13be9d">Half</a> the width of the narrow band, in voxel units. </td></tr>
    <tr><td class="paramname">interrupter</td><td>Interrupter adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>GridType::ValueType</code> must be a floating-point scalar. </dd>
<dd>
<code>ScalarType</code> represents the capsule complex vertex and radius type and must be a floating-point scalar. </dd></dl>

</div>
</div>
<a id="a271fec55592c87ddf1f04a02207cfb34" name="a271fec55592c87ddf1f04a02207cfb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271fec55592c87ddf1f04a02207cfb34">&#9670;&#160;</a></span>createPointIndexGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename PointArrayT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr createPointIndexGrid </td>
          <td>(</td>
          <td class="paramtype">const PointArrayT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition points into a point index grid to accelerate range and nearest-neighbor searches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>world-space point array conforming to the <a class="el" href="interfacePointArray.html" title="Partitions points into BucketLog2Dim aligned buckets using a parallel radix-based sorting algorithm.">PointArray</a> interface </td></tr>
    <tr><td class="paramname">xform</td><td>world-to-index-space transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec6960746cc5165cf6ac1252ad7bc5d4" name="aec6960746cc5165cf6ac1252ad7bc5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6960746cc5165cf6ac1252ad7bc5d4">&#9670;&#160;</a></span>createPointIndexGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename PointArrayT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr createPointIndexGrid </td>
          <td>(</td>
          <td class="paramtype">const PointArrayT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>voxelSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partition points into a point index grid to accelerate range and nearest-neighbor searches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>world-space point array conforming to the <a class="el" href="interfacePointArray.html" title="Partitions points into BucketLog2Dim aligned buckets using a parallel radix-based sorting algorithm.">PointArray</a> interface </td></tr>
    <tr><td class="paramname">voxelSize</td><td>voxel size in world units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1a9e6032ccf9b1c6e96407559797fa3" name="af1a9e6032ccf9b1c6e96407559797fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a9e6032ccf9b1c6e96407559797fa3">&#9670;&#160;</a></span>createPointMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointListT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">MaskGrid::Ptr</a> createPointMask </td>
          <td>(</td>
          <td class="paramtype">const PointListT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab26e09c39606fb93509615cd9120d4b0">MaskGrid</a> where each binary voxel value is on if the voxel contains one (or more) points (i.e. the 3D position of a point is closer to this voxel than any other voxels). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>points that active the voxels in the returned grid. </td></tr>
    <tr><td class="paramname">xform</td><td>transform from world space to voxels in grid space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f99dbe0666280f607a4473ddf15d891" name="a1f99dbe0666280f607a4473ddf15d891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f99dbe0666280f607a4473ddf15d891">&#9670;&#160;</a></span>createPotentialFlowMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename MaskT = typename GridT::template ValueConverter&lt;ValueMask&gt;::Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MaskT::Ptr createPotentialFlowMask </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dilation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">5</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a mask for the Potential Flow domain. </p>
<p>For a level set, this represents a rebuilt exterior narrow band. For any other grid it is a new region that surrounds the active voxels. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>source grid to use for computing the mask </td></tr>
    <tr><td class="paramname">dilation</td><td>dilation in voxels of the source grid to form the new potential flow mask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cc4a744d5c9f2fd9c0e2a0d176861c4" name="a1cc4a744d5c9f2fd9c0e2a0d176861c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc4a744d5c9f2fd9c0e2a0d176861c4">&#9670;&#160;</a></span>createPotentialFlowNeumannVelocities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vec3T, typename GridT, typename MaskT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridT::template ValueConverter&lt; Vec3T &gt;::Type::Ptr createPotentialFlowNeumannVelocities </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>collider</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridT::template ValueConverter&lt; Vec3T &gt;::Type::ConstPtr</td>          <td class="paramname"><span class="paramname"><em>boundaryVelocity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec3T &amp;</td>          <td class="paramname"><span class="paramname"><em>backgroundVelocity</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Potential Flow velocities grid for the Neumann boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collider</td><td>a level set that represents the boundary </td></tr>
    <tr><td class="paramname">domain</td><td>a mask to represent the potential flow domain </td></tr>
    <tr><td class="paramname">boundaryVelocity</td><td>an optional grid pointer to stores the velocities of the boundary </td></tr>
    <tr><td class="paramname">backgroundVelocity</td><td>a background velocity value</td></tr>
  </table>
  </dd>
</dl>
<p>Typically this method involves supplying a velocity grid for the collider boundary, however it can also be used for a global wind field around the collider by supplying an empty boundary Velocity and a non-zero background velocity. </p>

</div>
</div>
<a id="a5036d3edb7e1ed7d23072b179e5dd190" name="a5036d3edb7e1ed7d23072b179e5dd190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5036d3edb7e1ed7d23072b179e5dd190">&#9670;&#160;</a></span>csgDifference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void csgDifference </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>prune</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>pruneCancelledTiles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two level set grids, replace the A grid with the difference A / B. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1ValueError.html">ValueError</a></td><td>if the background value of either grid is not greater than zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation always leaves the B grid empty. </dd>
<dd>
cancelled tiles only pruned if pruning is also enabled. </dd></dl>

</div>
</div>
<a id="a7029f32f9814fd95e23d202c37b8da5b" name="a7029f32f9814fd95e23d202c37b8da5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7029f32f9814fd95e23d202c37b8da5b">&#9670;&#160;</a></span>csgDifferenceCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridOrTreeT::Ptr csgDifferenceCopy </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Threaded CSG difference operation that produces a new grid or tree from immutable inputs. </p>
<dl class="section return"><dt>Returns</dt><dd>The CSG difference of the <em class="arg">and</em> <b>level</b> set inputs. </dd></dl>

</div>
</div>
<a id="aaf596141cf503b859d1feb5dd8445086" name="aaf596141cf503b859d1feb5dd8445086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf596141cf503b859d1feb5dd8445086">&#9670;&#160;</a></span>csgIntersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void csgIntersection </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>prune</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>pruneCancelledTiles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two level set grids, replace the A grid with the intersection of A and B. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1ValueError.html">ValueError</a></td><td>if the background value of either grid is not greater than zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation always leaves the B grid empty. </dd>
<dd>
cancelled tiles only pruned if pruning is also enabled. </dd></dl>

</div>
</div>
<a id="add41b6c432f26145649e640fa76dc25d" name="add41b6c432f26145649e640fa76dc25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add41b6c432f26145649e640fa76dc25d">&#9670;&#160;</a></span>csgIntersectionCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridOrTreeT::Ptr csgIntersectionCopy </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Threaded CSG intersection operation that produces a new grid or tree from immutable inputs. </p>
<dl class="section return"><dt>Returns</dt><dd>The CSG intersection of the <em class="arg">and</em> <b>level</b> set inputs. </dd></dl>

</div>
</div>
<a id="ae37591a3bab226d3b1be74030d1fcc21" name="ae37591a3bab226d3b1be74030d1fcc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37591a3bab226d3b1be74030d1fcc21">&#9670;&#160;</a></span>csgUnion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void csgUnion </td>
          <td>(</td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>prune</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>pruneCancelledTiles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two level set grids, replace the A grid with the union of A and B. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1ValueError.html">ValueError</a></td><td>if the background value of either grid is not greater than zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation always leaves the B grid empty. </dd>
<dd>
cancelled tiles only pruned if pruning is also enabled. </dd></dl>

</div>
</div>
<a id="a99a3bda1cab85509556b73d1467a004f" name="a99a3bda1cab85509556b73d1467a004f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a3bda1cab85509556b73d1467a004f">&#9670;&#160;</a></span>csgUnionCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridOrTreeT::Ptr csgUnionCopy </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridOrTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Threaded CSG union operation that produces a new grid or tree from immutable inputs. </p>
<dl class="section return"><dt>Returns</dt><dd>The CSG union of the <em class="arg">and</em> <b>level</b> set inputs. </dd></dl>

</div>
</div>
<a id="a1d7270767850c4f3241bce09b730d84a" name="a1d7270767850c4f3241bce09b730d84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7270767850c4f3241bce09b730d84a">&#9670;&#160;</a></span>curl() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr curl </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the curl of the given vector-valued grid. </p>
<dl class="section return"><dt>Returns</dt><dd>a new vector-valued grid</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a id="afadb45bd23efe58eba201eb0d6c3ef82" name="afadb45bd23efe58eba201eb0d6c3ef82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afadb45bd23efe58eba201eb0d6c3ef82">&#9670;&#160;</a></span>curl() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr curl </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b2279de4cd703914497d7733aefbb6e" name="a8b2279de4cd703914497d7733aefbb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2279de4cd703914497d7733aefbb6e">&#9670;&#160;</a></span>curl() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr curl </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72a59fb29e19148b3554c0700509356d" name="a72a59fb29e19148b3554c0700509356d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a59fb29e19148b3554c0700509356d">&#9670;&#160;</a></span>curl() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr curl </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95818e0902bf2d721182aea060c98a39" name="a95818e0902bf2d721182aea060c98a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95818e0902bf2d721182aea060c98a39">&#9670;&#160;</a></span>deactivate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void deactivate </td>
          <td>(</td>
          <td class="paramtype">GridOrTree &amp;</td>          <td class="paramname"><span class="paramname"><em>gridOrTree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridOrTree::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridOrTree::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b">zeroVal</a>&lt;typename&#160;GridOrTree::ValueType&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark as inactive any active tiles or voxels in the given grid or tree whose values are equal to <em class="arg">value</em> (optionally to within the given <em class="arg">tolerance</em>). </p>

</div>
</div>
<a id="a7eeeface33ebfe532fc9a4675e79afec" name="a7eeeface33ebfe532fc9a4675e79afec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eeeface33ebfe532fc9a4675e79afec">&#9670;&#160;</a></span>dilateActiveValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeOrLeafManagerT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dilateActiveValues </td>
          <td>(</td>
          <td class="paramtype">TreeOrLeafManagerT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a></td>          <td class="paramname"><span class="paramname"><em>nn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ac7a17ca003c7f18f411cab4e8b4f6e74">TilePolicy</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ac7a17ca003c7f18f411cab4e8b4f6e74ab963e977b12771992aceaf779527c26f">PRESERVE_TILES</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Topologically dilate all active values (i.e. both voxels and tiles) in a tree using one of three nearest neighbor connectivity patterns. </p>
<p>If the input is <em>not</em> a <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4ac363eedfcf7a254676555417b15fe2">MaskTree</a> OR if tiles are being preserved, this algorithm will copy the input tree topology onto a <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4ac363eedfcf7a254676555417b15fe2">MaskTree</a>, performs the dilation on the mask and copies the resulting topology back. This algorithm guarantees topology preservation (non-pruned leaf nodes will persists) EXCEPT for direct <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4ac363eedfcf7a254676555417b15fe2">MaskTree</a> dilation. <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4ac363eedfcf7a254676555417b15fe2">MaskTree</a> dilation is optimised for performance and may replace existing leaf nodes i.e. any held leaf node pointers may become invalid. See the Morphology class for more granular control. </p><dl class="section note"><dt>Note</dt><dd>This method is fully multi-threaded and support active tiles, however only the PRESERVE_TILES policy ensures a pruned topology. The values of any voxels are unchanged.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>tree or leaf manager to be dilated. The leaf manager will be synchronized with the result. </td></tr>
    <tr><td class="paramname">iterations</td><td>number of iterations to apply the dilation </td></tr>
    <tr><td class="paramname">nn</td><td>connectivity pattern of the dilation: either face-adjacent (6 nearest neighbors), face- and edge-adjacent (18 nearest neighbors) or face-, edge- and vertex-adjacent (26 nearest neighbors). </td></tr>
    <tr><td class="paramname">mode</td><td>Defined the policy for handling active tiles (see above for details) </td></tr>
    <tr><td class="paramname">threaded</td><td>Whether to multi-thread execution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ae8e943f814b22fa057d8e4e4f82e30" name="a3ae8e943f814b22fa057d8e4e4f82e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae8e943f814b22fa057d8e4e4f82e30">&#9670;&#160;</a></span>dilateSdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr dilateSdf </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>sdfGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dilation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a></td>          <td class="paramname"><span class="paramname"><em>nn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nIter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bf">FastSweepingDomain</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bfa3203264a0a3fd2d90d15ee76eeb62f40">FastSweepingDomain::SWEEP_ALL</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dilates the narrow band of an existing signed distance field by a specified number of voxels (like adding "onion-rings"). </p>
<dl class="section note"><dt>Note</dt><dd>This operation is not to be confused with morphological dilation of a level set, which is implemented in <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1LevelSetFilter.html#ac39f5f86ebd5df29525fec79bdff9f48" title="Offset the level set by the specified (world) distance.">LevelSetFilter::offset</a>, and involves actual interface tracking of the narrow band.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the dilated signed distance field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdfGrid</td><td>Input signed distance field to be dilated.</td></tr>
    <tr><td class="paramname">dilation</td><td>Numer of voxels that the narrow band of the input SDF will be dilated.</td></tr>
    <tr><td class="paramname">nn</td><td>Stencil-pattern used for dilation</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
    <tr><td class="paramname">mode</td><td>Determines the direction of the dilation. SWEEP_ALL will dilate in both sides of the signed distance function, SWEEP_GREATER_THAN_ISOVALUE will dilate in the positive side of the iso-surface, SWEEP_LESS_THAN_ISOVALUE will dilate in the negative side of the iso-surface.</td></tr>
  </table>
  </dd>
</dl>
<p>Topology will change as a result of this dilation. E.g. if sdfGrid has a width of 3 and <em class="arg">dilation</em> = 6 then the grid returned by this method is a narrow band signed distance field with a total width of 9 units. </p>

</div>
</div>
<a id="ad9d4adc505e30de4684d20efdcb66512" name="ad9d4adc505e30de4684d20efdcb66512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d4adc505e30de4684d20efdcb66512">&#9670;&#160;</a></span>divergence() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr divergence </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the divergence of the given vector-valued grid. </p>
<dl class="section return"><dt>Returns</dt><dd>a new scalar-valued grid with the same numerical precision as the input grid (for example, if the input grid is a <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4047846203d0b9bcb5b7c0d3a6c7164f">Vec3DGrid</a>, the output grid will be a <a class="el" href="namespaceopenvdb_1_1v13__0.html#ae4044ab7ef1bfe752d228fe84ecd996e">DoubleGrid</a>)</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a id="a0e9b692b04d219b618f0079fea6565cc" name="a0e9b692b04d219b618f0079fea6565cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9b692b04d219b618f0079fea6565cc">&#9670;&#160;</a></span>divergence() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr divergence </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4342922999466ca1d2481c6c0d083b1" name="ab4342922999466ca1d2481c6c0d083b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4342922999466ca1d2481c6c0d083b1">&#9670;&#160;</a></span>divergence() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr divergence </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af934f12048c3caff364d2dab06d3801e" name="af934f12048c3caff364d2dab06d3801e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af934f12048c3caff364d2dab06d3801e">&#9670;&#160;</a></span>divergence() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr divergence </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2c1177d6976c4d235583089b2947ba8" name="af2c1177d6976c4d235583089b2947ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c1177d6976c4d235583089b2947ba8">&#9670;&#160;</a></span>doResampleToMatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler.html">Sampler</a>, typename Interrupter, typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void doResampleToMatch </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>inGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>outGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Interrupter &amp;</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The normal entry points for resampling are the <a class="el" href="#ae190c2befe2b252b8d930bd632964ab7" title="Resample an input grid into an output grid of the same type such that, after resampling,...">resampleToMatch()</a> functions, which correctly handle level set grids under scaling and shearing. <a class="el" href="#af2c1177d6976c4d235583089b2947ba8">doResampleToMatch()</a> is mainly for internal use but is typically faster for level sets, and correct provided that no scaling or shearing is needed.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not use this function to scale or shear a level set grid. </dd></dl>

</div>
</div>
<a id="a6872c2dd6da764c5600bd8ad2a126060" name="a6872c2dd6da764c5600bd8ad2a126060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6872c2dd6da764c5600bd8ad2a126060">&#9670;&#160;</a></span>erodeActiveValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeOrLeafManagerT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void erodeActiveValues </td>
          <td>(</td>
          <td class="paramtype">TreeOrLeafManagerT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2">NearestNeighbors</a></td>          <td class="paramname"><span class="paramname"><em>nn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a31d3cd59d1264144ae21e5250166cfc2a8b7234ad92f6feba2725d890a38fdd59">NN_FACE</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ac7a17ca003c7f18f411cab4e8b4f6e74">TilePolicy</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ac7a17ca003c7f18f411cab4e8b4f6e74ab963e977b12771992aceaf779527c26f">PRESERVE_TILES</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Topologically erode all active values (i.e. both voxels and tiles) in a tree using one of three nearest neighbor connectivity patterns. </p>
<p>If tiles are being preserve, this algorithm will copy the input tree topology onto a <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4ac363eedfcf7a254676555417b15fe2">MaskTree</a>, performs the erosion on the mask and intersects the resulting topology back. This algorithm guarantees topology preservation (non-pruned leaf nodes will persists). See the Morphology class for more granular control. </p><dl class="section note"><dt>Note</dt><dd>This method is fully multi-threaded and support active tiles, however only the PRESERVE_TILES policy ensures a pruned topology. The values of any voxels are unchanged. Erosion by NN_FACE neighbors is usually faster than other neighbor schemes. NN_FACE_EDGE and NN_FACE_EDGE_VERTEX operate at comparable dilation speeds.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>tree or leaf manager to be eroded. The leaf manager will be synchronized with the result. </td></tr>
    <tr><td class="paramname">iterations</td><td>number of iterations to apply the erosion </td></tr>
    <tr><td class="paramname">nn</td><td>connectivity pattern of the erosion: either face-adjacent (6 nearest neighbors), face- and edge-adjacent (18 nearest neighbors) or face-, edge- and vertex-adjacent (26 nearest neighbors). </td></tr>
    <tr><td class="paramname">mode</td><td>Defined the policy for handling active tiles (see above for details) </td></tr>
    <tr><td class="paramname">threaded</td><td>Whether to multi-thread execution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae978aa770a5f2b90f560356b83fed3d1" name="ae978aa770a5f2b90f560356b83fed3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae978aa770a5f2b90f560356b83fed3d1">&#9670;&#160;</a></span>evaluateInteriorTest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatTreeT, typename InteriorTest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void evaluateInteriorTest </td>
          <td>(</td>
          <td class="paramtype">FloatTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InteriorTest</td>          <td class="paramname"><span class="paramname"><em>interiorTest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687">InteriorTestStrategy</a></td>          <td class="paramname"><span class="paramname"><em>interiorTestStrategy</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the sign of voxel values of <span class="tt">tree</span> based on the <span class="tt">interiorTest</span> </p>
<p>Inside is set to positive and outside to negative. This is in reverse to the usual level set convention, but <span class="tt">meshToVolume</span> uses the opposite convention at certain point.</p>
<p>InteriorTest has to be a function <span class="tt"><a class="el" href="classopenvdb_1_1v13__0_1_1Coord.html" title="Signed (x, y, z) 32-bit integer coordinates.">Coord</a> -&gt; bool</span> which evaluates true inside of the mesh and false outside.</p>
<p>Furthermore, InteriorTest does not have to be thread-safe, but it has to be copy constructible and evaluating different coppy has to be thread-safe.</p>
<p>Example of a interior test</p>
<p>auto acc = tree-&gt;getAccessor();</p>
<p>auto test = [acc = grid.getConstAccessor()](const Cood&amp; coord) -&gt; bool { return acc-&gt;get(coord) &lt;= 0 ? true : false; } </p>

</div>
</div>
<a id="a3b522dd56a467487d4b16d0f1d16c0d6" name="a3b522dd56a467487d4b16d0f1d16c0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b522dd56a467487d4b16d0f1d16c0d6">&#9670;&#160;</a></span>extractActiveVoxelSegmentMasks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void extractActiveVoxelSegmentMasks </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeType &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>masks</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mask for each connected component of the given grid's active voxels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>Input grid or tree </td></tr>
    <tr><td class="paramname">masks</td><td>Output set of disjoint active topology masks sorted in descendingorder based on the active voxel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a3ef894d7a7eaf47a03d2508d2d95d3" name="a1a3ef894d7a7eaf47a03d2508d2d95d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3ef894d7a7eaf47a03d2508d2d95d3">&#9670;&#160;</a></span>extractEnclosedRegion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr extractEnclosedRegion </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeType &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridOrTreeType::ValueType</td>          <td class="paramname"><span class="paramname"><em>isovalue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">lsutilGridZero&lt;GridOrTreeType&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structopenvdb_1_1v13__0_1_1TreeAdapter.html">TreeAdapter</a>&lt; GridOrTreeType &gt;::TreeType::template ValueConverter&lt; bool &gt;::Type *</td>          <td class="paramname"><span class="paramname"><em>fillMask</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the interior regions of a signed distance field and topologically enclosed (watertight) regions of value greater than the <em class="arg">isovalue</em> (cavities) that can arise as the result of CSG union operations between different shapes where at least one of the shapes has a concavity that is capped. </p>
<p>For example the enclosed region of a capped bottle would include the walls and the interior cavity.</p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to either a boolean grid or tree with the same tree configuration and potentially transform as the input <code>volume</code> and whose active and <code>true</code> values correspond to the interior and enclosed regions in the input signed distance field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>Signed distance field / level set volume. </td></tr>
    <tr><td class="paramname">isovalue</td><td>Threshold below which values are considered part of the interior region. </td></tr>
    <tr><td class="paramname">fillMask</td><td>Optional boolean tree, when provided enclosed cavity regions that are not completely filled by this mask are ignored.</td></tr>
  </table>
  </dd>
</dl>
<p>For instance if the fill mask does not completely fill the bottle in the previous example only the walls and cap are returned and the interior cavity will be ignored. </p>

</div>
</div>
<a id="a39bfe53eeb50b4ffdc96c90af7e1de1b" name="a39bfe53eeb50b4ffdc96c90af7e1de1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bfe53eeb50b4ffdc96c90af7e1de1b">&#9670;&#160;</a></span>extractIsosurfaceMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr extractIsosurfaceMask </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeType &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridOrTreeType::ValueType</td>          <td class="paramname"><span class="paramname"><em>isovalue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mask of the voxels that intersect the implicit surface with the given <em class="arg">isovalue</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>Signed distance field / level set volume. </td></tr>
    <tr><td class="paramname">isovalue</td><td>The crossing point that is considered the surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a586a786ed67c81b31e7bcc11c70df047" name="a586a786ed67c81b31e7bcc11c70df047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586a786ed67c81b31e7bcc11c70df047">&#9670;&#160;</a></span>extractSparseTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType, typename DenseType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpType::ResultTreeType::Ptr extractSparseTree </td>
          <td>(</td>
          <td class="paramtype">const DenseType &amp;</td>          <td class="paramname"><span class="paramname"><em>dense</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OpType &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename OpType::ResultValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>background</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selectively extract and transform data from a dense grid, producing a sparse tree with leaf nodes only (e.g. create a tree from the square of values greater than a cutoff.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dense</td><td>A dense grid that acts as a data source </td></tr>
    <tr><td class="paramname">functor</td><td>A functor that selects and transforms data for output </td></tr>
    <tr><td class="paramname">background</td><td>The background value of the resulting sparse grid </td></tr>
    <tr><td class="paramname">threaded</td><td>Option to use threaded or serial code path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>Ptr</code> to tree with the valuetype and configuration defined by typedefs in the <code>functor</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>To achieve optimal sparsity consider calling the <a class="el" href="#a8057e1165c928a37703f90eb9496083c" title="Reduce the memory footprint of a tree by replacing with tiles any nodes whose values are all the same...">prune()</a> method on the result. </dd>
<dd>
To simply copy the all the data from a <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Dense.html" title="Dense is a simple dense grid API used by the CopyToDense and CopyFromDense classes defined below.">Dense</a> grid to a OpenVDB <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html" title="Container class that associates a tree with a transform and metadata.">Grid</a>, use <a class="el" href="#a718fc3e33310680728f4fbf04db240c0" title="Populate a sparse grid with the values of all of the voxels of a dense grid.">tools::copyFromDense()</a> for better performance.</dd></dl>
<p>The type of the sparse tree is determined by the specified OtpType functor by means of the typedef OptType::ResultTreeType</p>
<p>The OptType function is responsible for the the transformation of dense grid data to sparse grid data on a per-voxel basis.</p>
<p>Only leaf nodes with active values will be added to the sparse grid.</p>
<p>The OpType must struct that defines a the minimal form </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ExampleOp</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>ResultTreeType = DesiredTreeType;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> IndexOrCoord&gt;</div>
<div class="line">     <span class="keywordtype">void</span> OpType::operator() (<span class="keyword">const</span> DenseValueType a, <span class="keyword">const</span> IndexOrCoord&amp; ijk,</div>
<div class="line">                   ResultTreeType::LeafNodeType* leaf);</div>
<div class="line">};</div>
</div><!-- fragment --><p>For example, to generate a &lt;ValueType, 5, 4, 3&gt; tree with valuesOn at locations greater than a given maskvalue </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt;</div>
<div class="line"><span class="keyword">class </span>Rule</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Standard tree type (e.g. MaskTree or FloatTree in openvdb.h)</span></div>
<div class="line">    <span class="keyword">using </span>ResultTreeType = <span class="keyword">typename</span> openvdb::tree::Tree4&lt;ValueType, 5, 4, 3&gt;::Type;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>ResultLeafNodeType = <span class="keyword">typename</span> ResultTreeType::LeafNodeType;</div>
<div class="line">    <span class="keyword">using </span>ResultValueType = <span class="keyword">typename</span> ResultTreeType::ValueType;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>DenseValueType = float;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span><a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> = <a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html#a022bcc3eb3f9cecf521256a81d4be874">openvdb::Coord::ValueType</a>;</div>
<div class="line"> </div>
<div class="line">    Rule(<span class="keyword">const</span> DenseValueType&amp; value): mMaskValue(value){};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> IndexOrCoord&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> DenseValueType&amp; a, <span class="keyword">const</span> IndexOrCoord&amp; offset,</div>
<div class="line">                ResultLeafNodeType* leaf)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">            <span class="keywordflow">if</span> (a &gt; mMaskValue) {</div>
<div class="line">                leaf-&gt;setValueOn(offset, a);</div>
<div class="line">            }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> DenseValueType mMaskValue;</div>
<div class="line">};</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1Coord_html_a022bcc3eb3f9cecf521256a81d4be874"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html#a022bcc3eb3f9cecf521256a81d4be874">openvdb::v13_0::math::Coord::ValueType</a></div><div class="ttdeci">Int32 ValueType</div><div class="ttdef"><b>Definition</b> Coord.h:33</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_html_a1a68fb76e3d6897fa878760b6bcbda7a"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">openvdb::v13_0::Index</a></div><div class="ttdeci">Index32 Index</div><div class="ttdef"><b>Definition</b> Types.h:34</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae1e62f3b18a1d40b3195c83b4d76c1e5" name="ae1e62f3b18a1d40b3195c83b4d76c1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e62f3b18a1d40b3195c83b4d76c1e5">&#9670;&#160;</a></span>extractSparseTreeWithMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DenseType, typename MaskTreeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1DSConverter.html">DSConverter</a>&lt; DenseType, MaskTreeType &gt;::Type::Ptr extractSparseTreeWithMask </td>
          <td>(</td>
          <td class="paramtype">const DenseType &amp;</td>          <td class="paramname"><span class="paramname"><em>dense</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskTreeType &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DenseType::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>background</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from the intersection of a sparse tree and a dense input grid. The resulting tree has the same configuration as the sparse tree, but holds the data type specified by the dense input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dense</td><td>A dense grid that acts as a data source </td></tr>
    <tr><td class="paramname">mask</td><td>The active voxels and tiles intersected with dense define iteration mask </td></tr>
    <tr><td class="paramname">background</td><td>The background value of the resulting sparse grid </td></tr>
    <tr><td class="paramname">threaded</td><td>Option to use threaded or serial code path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>Ptr</code> to tree with the same configuration as <code>mask</code> but of value type defined by <code>dense</code>. </dd></dl>

</div>
</div>
<a id="ac6aea86a2df380225a3b3c8553efe4e3" name="ac6aea86a2df380225a3b3c8553efe4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6aea86a2df380225a3b3c8553efe4e3">&#9670;&#160;</a></span>extrema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Extrema.html">math::Extrema</a> extrema </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over a scalar grid and compute extrema (min/max) of the values of the voxels that are visited, or iterate over a vector-valued grid and compute extrema of the magnitudes of the vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over the values of a grid or its tree (<code><a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::ValueOffIter</code>, etc.) </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, iterate over the grid in parallel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafcd95f6d9da81e339aab75465ee4e22" name="aafcd95f6d9da81e339aab75465ee4e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcd95f6d9da81e339aab75465ee4e22">&#9670;&#160;</a></span>extrema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterT, typename ValueOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Extrema.html">math::Extrema</a> extrema </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over a grid and compute extrema (min/max) of the values produced by applying the given functor at each voxel that is visited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over the values of a grid or its tree (<code><a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::ValueOffIter</code>, etc.) </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <span class="tt">void op(const IterT&amp;, math::Stats&amp;)</span>, where <code>IterT</code> is the type of <em class="arg">iter</em>, that inserts zero or more floating-point values into the provided <code><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html" title="This class computes statistics (minimum value, maximum value, mean, variance and standard deviation) ...">math::Stats</a></code> object </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, iterate over the grid in parallel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When <em class="arg">threaded</em> is true, each thread gets its own copy of the functor.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Compute statistics of just the active and positive-valued voxels of a scalar, floating-point grid. <div class="fragment"><div class="line"><span class="keyword">struct </span>Local {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span></div>
<div class="line">    <span class="keywordtype">void</span> addIfPositive(<span class="keyword">const</span> <a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">FloatGrid::ValueOnCIter</a>&amp; iter, <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1math_1_1Extrema.html">math::Extrema</a>&amp; ex)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> f = *iter;</div>
<div class="line">        <span class="keywordflow">if</span> (f &gt; 0.0) {</div>
<div class="line">            <span class="keywordflow">if</span> (iter.isVoxelValue()) ex.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Extrema.html#a1c762a4059fc92d21d53c05f268227b1">add</a>(f);</div>
<div class="line">            <span class="keywordflow">else</span> ex.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Extrema.html#a1c762a4059fc92d21d53c05f268227b1">add</a>(f, iter.getVoxelCount());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> grid = ...;</div>
<div class="line">math::Extrema stats =</div>
<div class="line">    <a class="code hl_function" href="#ac6aea86a2df380225a3b3c8553efe4e3">tools::extrema</a>(grid.cbeginValueOn(), Local::addIfPositive, <span class="comment">/*threaded=*/</span><span class="keyword">true</span>);</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1Extrema_html"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1Extrema.html">openvdb::v13_0::math::Extrema</a></div><div class="ttdoc">This class computes the minimum and maximum values of a population of floating-point values.</div><div class="ttdef"><b>Definition</b> Stats.h:90</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1Extrema_html_a1c762a4059fc92d21d53c05f268227b1"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1Extrema.html#a1c762a4059fc92d21d53c05f268227b1">openvdb::v13_0::math::Extrema::add</a></div><div class="ttdeci">void add(double val)</div><div class="ttdoc">Add a single sample.</div><div class="ttdef"><b>Definition</b> Stats.h:103</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tools_html_ac6aea86a2df380225a3b3c8553efe4e3"><div class="ttname"><a href="#ac6aea86a2df380225a3b3c8553efe4e3">openvdb::v13_0::tools::extrema</a></div><div class="ttdeci">math::Extrema extrema(const IterT &amp;iter, bool threaded=true)</div><div class="ttdoc">Iterate over a scalar grid and compute extrema (min/max) of the values of the voxels that are visited...</div><div class="ttdef"><b>Definition</b> Statistics.h:354</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af3f0e9f42ab322b7dd0f54dfb5b28556" name="af3f0e9f42ab322b7dd0f54dfb5b28556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f0e9f42ab322b7dd0f54dfb5b28556">&#9670;&#160;</a></span>fillWithSpheres()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename InterrupterT = util::NullInterrupter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void fillWithSpheres </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a5ac9cf81cc2f815e160e3ed02ff551b7">openvdb::Vec4s</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>spheres</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a117a07b9e7c47a4975f94512a951bd73">Vec2i</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sphereCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a117a07b9e7c47a4975f94512a951bd73">Vec2i</a>(1,&#160;50)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>overlapping</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>minRadius</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>maxRadius</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;float&gt;::max()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>isovalue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>instanceCount</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a closed level set or fog volume with adaptively-sized spheres. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar grid that defines the surface to be filled with spheres </td></tr>
    <tr><td class="paramname">spheres</td><td>an output array of 4-tuples representing the fitted spheres<br  />
 The first three components of each tuple specify the sphere center, and the fourth specifies the radius. The spheres are ordered by radius, from largest to smallest. </td></tr>
    <tr><td class="paramname">sphereCount</td><td>lower and upper bounds on the number of spheres to be generated<br  />
 The actual number will be somewhere within the bounds. </td></tr>
    <tr><td class="paramname">overlapping</td><td>toggle to allow spheres to overlap/intersect </td></tr>
    <tr><td class="paramname">minRadius</td><td>the smallest allowable sphere size, in voxel units<br  />
 </td></tr>
    <tr><td class="paramname">maxRadius</td><td>the largest allowable sphere size, in voxel units </td></tr>
    <tr><td class="paramname">isovalue</td><td>the voxel value that determines the surface of the volume<br  />
 The default value of zero works for signed distance fields, while fog volumes require a larger positive value (0.5 is a good initial guess). </td></tr>
    <tr><td class="paramname">instanceCount</td><td>the number of interior points to consider for the sphere placement<br  />
 Increasing this count increases the chances of finding optimal sphere sizes. </td></tr>
    <tr><td class="paramname">interrupter</td><td>pointer to an object adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The minimum sphere count takes precedence over the minimum radius. </dd></dl>

</div>
</div>
<a id="aff2004f746efe615a376354f56ae3c6e" name="aff2004f746efe615a376354f56ae3c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2004f746efe615a376354f56ae3c6e">&#9670;&#160;</a></span>findFeaturePoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">Vec3d</a> findFeaturePoint </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">Vec3d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">Vec3d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>normals</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a set of tangent elements, <code>points</code> with corresponding <code>normals</code>, this method returns the intersection point of all tangent elements. </p>
<dl class="section note"><dt>Note</dt><dd>Used to extract surfaces with sharp edges and corners from volume data, see the following paper for details: "Feature Sensitive Surface
        Extraction from Volume Data, Kobbelt et al. 2001". </dd></dl>

</div>
</div>
<a id="a39ed6a1f7837b590e94d1511398c924f" name="a39ed6a1f7837b590e94d1511398c924f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ed6a1f7837b590e94d1511398c924f">&#9670;&#160;</a></span>floodFillLeafNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> Log2Dim, typename InteriorTest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void floodFillLeafNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1LeafNode.html">tree::LeafNode</a>&lt; T, Log2Dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>leafNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InteriorTest &amp;</td>          <td class="paramname"><span class="paramname"><em>interiorTest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8ed1bbf2e2647988fbc7eed71bed073" name="ab8ed1bbf2e2647988fbc7eed71bed073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ed1bbf2e2647988fbc7eed71bed073">&#9670;&#160;</a></span>fogToExt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FogGridT, typename ExtOpT, typename ExtValueT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FogGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr fogToExt </td>
          <td>(</td>
          <td class="paramtype">const FogGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>fogGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtOpT &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtValueT &amp;</td>          <td class="paramname"><span class="paramname"><em>background</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename FogGridT::ValueType</td>          <td class="paramname"><span class="paramname"><em>isoValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nIter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bf">FastSweepingDomain</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bfa3203264a0a3fd2d90d15ee76eeb62f40">FastSweepingDomain::SWEEP_ALL</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename FogGridT::template ValueConverter&lt; ExtValueT &gt;::Type::ConstPtr</td>          <td class="paramname"><span class="paramname"><em>extGrid</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the extension of a field (scalar, vector, or int are supported), defined by the specified functor, off an iso-surface from an input FOG volume. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the extension field defined from the active values in the input fog volume.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fogGrid</td><td>Scalar (floating-point) volume from which an iso-surface can be defined.</td></tr>
    <tr><td class="paramname">op</td><td>Functor with signature [](const <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab8753c49a176ce809a70ac12896682e3">Vec3R</a> &amp;xyz)-&gt;ExtValueT that defines the Dirichlet boundary condition, on the iso-surface, of the field to be extended.</td></tr>
    <tr><td class="paramname">background</td><td>Background value of return grid with the extension field.</td></tr>
    <tr><td class="paramname">isoValue</td><td>A value which defines a smooth iso-surface that intersects active voxels in <em class="arg">fogGrid</em>.</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
    <tr><td class="paramname">mode</td><td>Determines the mode of updating the extension field. SWEEP_ALL will update all voxels of the extension field affected by the fast sweeping algorithm. SWEEP_GREATER_THAN_ISOVALUE will update all voxels corresponding to fog values that are greater than a given isovalue. SWEEP_LESS_THAN_ISOVALUE will update all voxels corresponding to fog values that are less than a given isovalue. If a mode other than SWEEP_ALL is chosen, a user needs to supply <em class="arg">extGrid</em>.</td></tr>
    <tr><td class="paramname">extGrid</td><td>Optional parameter required to supply a default value for the extension field when SWEEP_GREATER_THAN_ISOVALUE or SWEEP_LESS_THAN_ISOVALUE mode is picked for <em class="arg">mode</em>. When SWEEP_GREATER_THAN_ISOVALUE is supplied as an argument for <em class="arg">mode</em>, the extension field voxel will default to the value of the <em class="arg">extGrid</em> in that position if it corresponds to a fog value that is less than the isovalue. Otherwise, the extension field voxel value will be computed by the Fast Sweeping algorithm. The opposite convention is implemented when SWEEP_LESS_THAN_ISOVALUE is supplied as an argument for <em class="arg">mode</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Strictly speaking a fog volume is normalized to the range [0,1] but this method accepts a scalar volume with an arbritary range, as long as the it includes the <em class="arg">isoValue</em>.</dd></dl>
<p>Topology of output grid is identical to that of the input grid, except active tiles in the input grid will be converted to active voxels in the output grid!</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em class="arg">isoValue</em> does not intersect any active values in <em class="arg">fogGrid</em> then the returned grid has all its active values set to <em class="arg">background</em>. </dd></dl>

</div>
</div>
<a id="a09b0661a0aaa5a3b5badaf557459dcc8" name="a09b0661a0aaa5a3b5badaf557459dcc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b0661a0aaa5a3b5badaf557459dcc8">&#9670;&#160;</a></span>fogToSdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr fogToSdf </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>fogGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridT::ValueType</td>          <td class="paramname"><span class="paramname"><em>isoValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nIter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a scalar fog volume into a signed distance function. Active input voxels with scalar values above the given isoValue will have NEGATIVE distance values on output, i.e. they are assumed to be INSIDE the iso-surface. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a signed-distance field defined on the active values of the input fog volume.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fogGrid</td><td>Scalar (floating-point) volume from which an iso-surface can be defined.</td></tr>
    <tr><td class="paramname">isoValue</td><td>A value which defines a smooth iso-surface that intersects active voxels in <em class="arg">fogGrid</em>.</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Strictly speaking a fog volume is normalized to the range [0,1] but this method accepts a scalar volume with an arbritary range, as long as the it includes the <em class="arg">isoValue</em>.</dd></dl>
<p>Topology of output grid is identical to that of the input grid, except active tiles in the input grid will be converted to active voxels in the output grid!</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em class="arg">isoValue</em> does not intersect any active values in <em class="arg">fogGrid</em> then the returned grid has all its active values set to plus or minus infinity, depending on if the input values are larger or smaller than <em class="arg">isoValue</em>. </dd></dl>

</div>
</div>
<a id="a8e07459625611ff0d4f386f601aa1e3e" name="a8e07459625611ff0d4f386f601aa1e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e07459625611ff0d4f386f601aa1e3e">&#9670;&#160;</a></span>fogToSdfAndExt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FogGridT, typename ExtOpT, typename ExtValueT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename FogGridT::Ptr, typename FogGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr &gt; fogToSdfAndExt </td>
          <td>(</td>
          <td class="paramtype">const FogGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>fogGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtOpT &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtValueT &amp;</td>          <td class="paramname"><span class="paramname"><em>background</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename FogGridT::ValueType</td>          <td class="paramname"><span class="paramname"><em>isoValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nIter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bf">FastSweepingDomain</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bfa3203264a0a3fd2d90d15ee76eeb62f40">FastSweepingDomain::SWEEP_ALL</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename FogGridT::template ValueConverter&lt; ExtValueT &gt;::Type::ConstPtr</td>          <td class="paramname"><span class="paramname"><em>extGrid</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the signed distance field and the extension of a field (scalar, vector, or int are supported), defined by the specified functor, off an iso-surface from an input FOG volume. </p>
<dl class="section return"><dt>Returns</dt><dd>An pair of two shared pointers to respectively the SDF and extension field</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fogGrid</td><td>Scalar (floating-point) volume from which an iso-surface can be defined.</td></tr>
    <tr><td class="paramname">op</td><td>Functor with signature [](const <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab8753c49a176ce809a70ac12896682e3">Vec3R</a> &amp;xyz)-&gt;ExtValueT that defines the Dirichlet boundary condition, on the iso-surface, of the field to be extended.</td></tr>
    <tr><td class="paramname">background</td><td>Background value of return grid with the extension field.</td></tr>
    <tr><td class="paramname">isoValue</td><td>A value which defines a smooth iso-surface that intersects active voxels in <em class="arg">fogGrid</em>.</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
    <tr><td class="paramname">mode</td><td>Determines the mode of updating the extension field. SWEEP_ALL will update all voxels of the extension field affected by the fast sweeping algorithm. SWEEP_GREATER_THAN_ISOVALUE will update all voxels corresponding to fog values that are greater than a given isovalue. SWEEP_LESS_THAN_ISOVALUE will update all voxels corresponding to fog values that are less than a given isovalue. If a mode other than SWEEP_ALL is chosen, a user needs to supply <em class="arg">extGrid</em>.</td></tr>
    <tr><td class="paramname">extGrid</td><td>Optional parameter required to supply a default value for the extension field when SWEEP_GREATER_THAN_ISOVALUE or SWEEP_LESS_THAN_ISOVALUE mode is picked for <em class="arg">mode</em>. When SWEEP_GREATER_THAN_ISOVALUE is supplied as an argument for <em class="arg">mode</em>, the extension field voxel will default to the value of the <em class="arg">extGrid</em> in that position if it corresponds to a fog value that is less than the isovalue. Otherwise, the extension field voxel value will be computed by the Fast Sweeping algorithm. The opposite convention is implemented when SWEEP_LESS_THAN_ISOVALUE is supplied as an argument for <em class="arg">mode</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Strictly speaking a fog volume is normalized to the range [0,1] but this method accepts a scalar volume with an arbritary range, as long as the it includes the <em class="arg">isoValue</em>.</dd></dl>
<p>Topology of output grids are identical to that of the input grid, except active tiles in the input grid will be converted to active voxels in the output grids!</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em class="arg">isoValue</em> does not intersect any active values in <em class="arg">fogGrid</em> then a pair of the following grids is returned: The first is a signed distance grid with its active values set to plus or minus infinity depending of whether its input values are above or below <em class="arg">isoValue</em>. The second grid, which represents the extension field, has all its active values set to <em class="arg">background</em>. </dd></dl>

</div>
</div>
<a id="aa1dd9695ed106fdc71856355b0bfc1b6" name="aa1dd9695ed106fdc71856355b0bfc1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1dd9695ed106fdc71856355b0bfc1b6">&#9670;&#160;</a></span>foreach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterT, typename XformOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void foreach </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XformOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>shareOp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada1c7e219f36d148510ce22d7599171b" name="ada1c7e219f36d148510ce22d7599171b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1c7e219f36d148510ce22d7599171b">&#9670;&#160;</a></span>foreach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterT, typename XformOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void foreach </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XformOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>shareOp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over a grid and at each step call <code>op(iter)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over a grid or its tree (<code><a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::NodeIter</code>, etc.) </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <span class="tt">void op(const IterT&amp;)</span>, where <code>IterT</code> is the type of <em class="arg">iter</em> </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, transform multiple values of the grid in parallel </td></tr>
    <tr><td class="paramname">shareOp</td><td>if true and <em class="arg">threaded</em> is true, all threads use the same functor; otherwise, each thread gets its own copy of the <em>original</em> functor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd>Multiply all values (both set and unset) of a scalar, floating-point grid by two. <div class="fragment"><div class="line"><span class="keyword">struct </span>Local {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> op(<span class="keyword">const</span> <a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#ae60f7ec90327837088fbe58242f78745">FloatGrid::ValueAllIter</a>&amp; iter) {</div>
<div class="line">        iter.setValue(*iter * 2);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> grid = ...;</div>
<div class="line"><a class="code hl_function" href="#ada1c7e219f36d148510ce22d7599171b">tools::foreach</a>(grid.beginValueAll(), Local::op);</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1Grid_html_ae60f7ec90327837088fbe58242f78745"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1Grid.html#ae60f7ec90327837088fbe58242f78745">openvdb::v13_0::Grid&lt; FloatTree &gt;::ValueAllIter</a></div><div class="ttdeci">typename FloatTree::ValueAllIter ValueAllIter</div><div class="ttdef"><b>Definition</b> Grid.h:586</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tools_html_ada1c7e219f36d148510ce22d7599171b"><div class="ttname"><a href="#ada1c7e219f36d148510ce22d7599171b">openvdb::v13_0::tools::foreach</a></div><div class="ttdeci">void foreach(const IterT &amp;iter, XformOp &amp;op, bool threaded=true, bool shareOp=true)</div><div class="ttdoc">Iterate over a grid and at each step call op(iter).</div><div class="ttdef"><b>Definition</b> ValueTransformer.h:382</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Rotate all active vectors of a vector grid by 45 degrees about the y axis. <div class="fragment"><div class="line"><span class="keyword">namespace </span>{</div>
<div class="line">    <span class="keyword">struct </span><a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1tools_1_1MatMul.html">MatMul</a> {</div>
<div class="line">        <a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0_1_1math.html#a85b140686e0a81e6b7e47e021428005e">math::Mat3s</a> M;</div>
<div class="line">        <a class="code hl_function" href="structopenvdb_1_1v13__0_1_1tools_1_1MatMul.html#a59cf6c732ef2e69040ccffa439bc0409">MatMul</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0_1_1math.html#a85b140686e0a81e6b7e47e021428005e">math::Mat3s</a>&amp; <a class="code hl_variable" href="structopenvdb_1_1v13__0_1_1tools_1_1MatMul.html#a5c83e050fc2b2e0f06288f74cde5d715">mat</a>): M(<a class="code hl_variable" href="structopenvdb_1_1v13__0_1_1tools_1_1MatMul.html#a5c83e050fc2b2e0f06288f74cde5d715">mat</a>) {}</div>
<div class="line">        <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code hl_function" href="structopenvdb_1_1v13__0_1_1tools_1_1MatMul.html#a87214a5219106ea9a0189bee8da5f4da">operator()</a>(<span class="keyword">const</span> <a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#aa20792587df8cc92cff821e68e70ace7">VectorGrid::ValueOnIter</a>&amp; iter)<span class="keyword"> const </span>{</div>
<div class="line">            iter.setValue(M.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Mat3.html#ac39e3ba86f7eda7145ada75808791db0">transform</a>(*iter));</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0.html#a34f04b5087af8e271f07c3665c9593b7">VectorGrid</a> grid = ...;</div>
<div class="line">    <a class="code hl_function" href="#ada1c7e219f36d148510ce22d7599171b">tools::foreach</a>(grid.beginValueOn(),</div>
<div class="line">        <a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1tools_1_1MatMul.html">MatMul</a>(<a class="code hl_function" href="namespaceopenvdb_1_1v13__0_1_1math.html#aa9d5bef64dbc83b0ba069e4febe82b21">math::rotation&lt;math::Mat3s&gt;</a>(math::Y, openvdb::math::pi&lt;double&gt;()/4.0)));</div>
<div class="line">}</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1Grid_html_aa20792587df8cc92cff821e68e70ace7"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1Grid.html#aa20792587df8cc92cff821e68e70ace7">openvdb::v13_0::Grid&lt; Vec3STree &gt;::ValueOnIter</a></div><div class="ttdeci">typename Vec3STree::ValueOnIter ValueOnIter</div><div class="ttdef"><b>Definition</b> Grid.h:582</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1Mat3_html_ac39e3ba86f7eda7145ada75808791db0"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1Mat3.html#ac39e3ba86f7eda7145ada75808791db0">openvdb::v13_0::math::Mat3::transform</a></div><div class="ttdeci">Vec3&lt; T0 &gt; transform(const Vec3&lt; T0 &gt; &amp;v) const</div><div class="ttdef"><b>Definition</b> Mat3.h:505</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1math_html_a85b140686e0a81e6b7e47e021428005e"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0_1_1math.html#a85b140686e0a81e6b7e47e021428005e">openvdb::v13_0::math::Mat3s</a></div><div class="ttdeci">Mat3&lt; float &gt; Mat3s</div><div class="ttdef"><b>Definition</b> Mat3.h:832</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1math_html_aa9d5bef64dbc83b0ba069e4febe82b21"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0_1_1math.html#aa9d5bef64dbc83b0ba069e4febe82b21">openvdb::v13_0::math::rotation</a></div><div class="ttdeci">MatType rotation(const Quat&lt; typename MatType::value_type &gt; &amp;q, typename MatType::value_type eps=static_cast&lt; typename MatType::value_type &gt;(1.0e-8))</div><div class="ttdoc">Return the rotation matrix specified by the given quaternion.</div><div class="ttdef"><b>Definition</b> Mat.h:172</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_html_a34f04b5087af8e271f07c3665c9593b7"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0.html#a34f04b5087af8e271f07c3665c9593b7">openvdb::v13_0::VectorGrid</a></div><div class="ttdeci">Vec3fGrid VectorGrid</div><div class="ttdef"><b>Definition</b> openvdb.h:88</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1tools_1_1MatMul_html"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1tools_1_1MatMul.html">openvdb::v13_0::tools::MatMul</a></div><div class="ttdef"><b>Definition</b> VectorTransformer.h:47</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1tools_1_1MatMul_html_a59cf6c732ef2e69040ccffa439bc0409"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1tools_1_1MatMul.html#a59cf6c732ef2e69040ccffa439bc0409">openvdb::v13_0::tools::MatMul::MatMul</a></div><div class="ttdeci">MatMul(const Mat4d &amp;_mat)</div><div class="ttdef"><b>Definition</b> VectorTransformer.h:49</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1tools_1_1MatMul_html_a5c83e050fc2b2e0f06288f74cde5d715"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1tools_1_1MatMul.html#a5c83e050fc2b2e0f06288f74cde5d715">openvdb::v13_0::tools::MatMul::mat</a></div><div class="ttdeci">const Mat4d mat</div><div class="ttdef"><b>Definition</b> VectorTransformer.h:48</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1tools_1_1MatMul_html_a87214a5219106ea9a0189bee8da5f4da"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1tools_1_1MatMul.html#a87214a5219106ea9a0189bee8da5f4da">openvdb::v13_0::tools::MatMul::operator()</a></div><div class="ttdeci">void operator()(const TreeIterT &amp;it) const</div><div class="ttdef"><b>Definition</b> VectorTransformer.h:51</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>For more complex operations that require finer control over threading, consider using <code>tbb::parallel_for()</code> or <code>tbb::parallel_reduce()</code> in conjunction with a <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1IteratorRange.html">tree::IteratorRange</a> that wraps a grid or tree iterator. </dd></dl>

</div>
</div>
<a id="ab2dc20cbb018eddb5d26c53bf8cf83ab" name="ab2dc20cbb018eddb5d26c53bf8cf83ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2dc20cbb018eddb5d26c53bf8cf83ab">&#9670;&#160;</a></span>getValidPointIndexGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename PointArrayT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::ConstPtr getValidPointIndexGrid </td>
          <td>(</td>
          <td class="paramtype">const PointArrayT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridT::ConstPtr &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repartition the <em class="arg">points</em> if needed, otherwise return the input <em class="arg">grid</em>. </p>

</div>
</div>
<a id="afb27ad923a88ee58220750ffc3914c03" name="afb27ad923a88ee58220750ffc3914c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb27ad923a88ee58220750ffc3914c03">&#9670;&#160;</a></span>getValidPointIndexGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename PointArrayT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr getValidPointIndexGrid </td>
          <td>(</td>
          <td class="paramtype">const PointArrayT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GridT::Ptr &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repartition the <em class="arg">points</em> if needed, otherwise return the input <em class="arg">grid</em>. </p>

</div>
</div>
<a id="a61d4d89cd34db1794e9a615dec11dc0f" name="a61d4d89cd34db1794e9a615dec11dc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d4d89cd34db1794e9a615dec11dc0f">&#9670;&#160;</a></span>gradient() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr gradient </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient of the given scalar grid. </p>
<dl class="section return"><dt>Returns</dt><dd>a new vector-valued grid with the same numerical precision as the input grid (for example, if the input grid is a <a class="el" href="namespaceopenvdb_1_1v13__0.html#ae4044ab7ef1bfe752d228fe84ecd996e">DoubleGrid</a>, the output grid will be a <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4047846203d0b9bcb5b7c0d3a6c7164f">Vec3DGrid</a>)</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a id="a137349cb5217d39ad7a961d7dec8e499" name="a137349cb5217d39ad7a961d7dec8e499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137349cb5217d39ad7a961d7dec8e499">&#9670;&#160;</a></span>gradient() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr gradient </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8cad07124b4f4d6a7b15021ee86b2c2f" name="a8cad07124b4f4d6a7b15021ee86b2c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cad07124b4f4d6a7b15021ee86b2c2f">&#9670;&#160;</a></span>gradient() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr gradient </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a446af08bc16b4a82e996a4111a2f3c19" name="a446af08bc16b4a82e996a4111a2f3c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446af08bc16b4a82e996a4111a2f3c19">&#9670;&#160;</a></span>gradient() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1ScalarToVectorConverter.html">ScalarToVectorConverter</a>&lt; GridType &gt;::Type::Ptr gradient </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a705b035d27c69d566009424697c36a65" name="a705b035d27c69d566009424697c36a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705b035d27c69d566009424697c36a65">&#9670;&#160;</a></span>histogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Histogram.html">math::Histogram</a> histogram </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>minVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>maxVal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numBins</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over a scalar grid and compute a histogram of the values of the voxels that are visited, or iterate over a vector-valued grid and compute a histogram of the magnitudes of the vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over the values of a grid or its tree (<code><a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::ValueOffIter</code>, etc.) </td></tr>
    <tr><td class="paramname">minVal</td><td>the smallest value that can be added to the histogram </td></tr>
    <tr><td class="paramname">maxVal</td><td>the largest value that can be added to the histogram </td></tr>
    <tr><td class="paramname">numBins</td><td>the number of histogram bins </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, iterate over the grid in parallel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d5182249f0ff2cd4584ec24b09300a0" name="a5d5182249f0ff2cd4584ec24b09300a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5182249f0ff2cd4584ec24b09300a0">&#9670;&#160;</a></span>interiorMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::template ValueConverter&lt; bool &gt;::Type::Ptr interiorMask </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>isovalue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input grid of any type, return a new, boolean grid whose active voxel topology matches the input grid's or, if the input grid is a level set, matches the input grid's interior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the grid from which to construct a mask </td></tr>
    <tr><td class="paramname">isovalue</td><td>for a level set grid, the isovalue that defines the grid's interior </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a59b83096927350f3324cba935be37717" title="Threaded method to construct a boolean mask that represents interior regions in a signed distance fie...">tools::sdfInteriorMask()</a> </dd></dl>

</div>
</div>
<a id="af2c25ce7b65fe2e22209dce0b5eae646" name="af2c25ce7b65fe2e22209dce0b5eae646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c25ce7b65fe2e22209dce0b5eae646">&#9670;&#160;</a></span>isValidPartition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointArrayT, typename GridT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValidPartition </td>
          <td>(</td>
          <td class="paramtype">const PointArrayT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given point index grid represents a valid partitioning of the given point array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>world-space point array conforming to the <a class="el" href="interfacePointArray.html" title="Partitions points into BucketLog2Dim aligned buckets using a parallel radix-based sorting algorithm.">PointArray</a> interface </td></tr>
    <tr><td class="paramname">grid</td><td>point index grid to validate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af55f3361b55d27809c1da5bf33db393a" name="af55f3361b55d27809c1da5bf33db393a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55f3361b55d27809c1da5bf33db393a">&#9670;&#160;</a></span>laplacian() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr laplacian </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Laplacian.html">Laplacian</a> of the given scalar grid. </p>
<dl class="section return"><dt>Returns</dt><dd>a new scalar grid</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a id="a0c40f63d5ab24d2984f88fa28580bb57" name="a0c40f63d5ab24d2984f88fa28580bb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c40f63d5ab24d2984f88fa28580bb57">&#9670;&#160;</a></span>laplacian() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr laplacian </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c8b10bc1b3daa909a50c4b1a68c1c79" name="a2c8b10bc1b3daa909a50c4b1a68c1c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8b10bc1b3daa909a50c4b1a68c1c79">&#9670;&#160;</a></span>laplacian() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr laplacian </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69b1334cfe0490c146fa60e4901242d7" name="a69b1334cfe0490c146fa60e4901242d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b1334cfe0490c146fa60e4901242d7">&#9670;&#160;</a></span>laplacian() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr laplacian </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adef98c0da043876358e6ab7e671cb9a7" name="adef98c0da043876358e6ab7e671cb9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef98c0da043876358e6ab7e671cb9a7">&#9670;&#160;</a></span>levelSetArea() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> levelSetArea </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useWorldUnits</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a193752a35b6ebe80e04dcd72e371525c" name="a193752a35b6ebe80e04dcd72e371525c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193752a35b6ebe80e04dcd72e371525c">&#9670;&#160;</a></span>levelSetArea() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> levelSetArea </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useWorldSpace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the surface area of a narrow-band level set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar, floating-point grid with one or more disjoint, closed level set surfaces </td></tr>
    <tr><td class="paramname">useWorldSpace</td><td>if true the area is computed in world space units, else in voxel units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if <em class="arg">grid</em> is not scalar or not floating-point or not a level set or empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48ac6dfcdf9c770ae87b34ec35393ba7" name="a48ac6dfcdf9c770ae87b34ec35393ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ac6dfcdf9c770ae87b34ec35393ba7">&#9670;&#160;</a></span>levelSetEulerCharacteristic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int levelSetEulerCharacteristic </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac25a1928b2ba9be46cdec2a46f5b9a10" name="ac25a1928b2ba9be46cdec2a46f5b9a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25a1928b2ba9be46cdec2a46f5b9a10">&#9670;&#160;</a></span>levelSetEulerCharacteristic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int levelSetEulerCharacteristic </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Euler Characteristics of a narrow-band level set surface (possibly disconnected). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar, floating-point grid with one or more disjoint, closed level set surfaces</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if <em class="arg">grid</em> is not scalar or not floating-point or not a level set or empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba001fefd40d3b10797edf0318256ecf" name="aba001fefd40d3b10797edf0318256ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba001fefd40d3b10797edf0318256ecf">&#9670;&#160;</a></span>levelSetGenus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int levelSetGenus </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65b03b0e9c115b31fac31ff8cdcf9404" name="a65b03b0e9c115b31fac31ff8cdcf9404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b03b0e9c115b31fac31ff8cdcf9404">&#9670;&#160;</a></span>levelSetGenus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int levelSetGenus </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the genus of a narrow-band level set surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar, floating-point grid with one or more disjoint, closed level set surfaces </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The genus is only well defined for a single connected surface</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if <em class="arg">grid</em> is not scalar or not floating-point or not a level set or empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ce3a230f06d4e222727e1046bc6ae3c" name="a9ce3a230f06d4e222727e1046bc6ae3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce3a230f06d4e222727e1046bc6ae3c">&#9670;&#160;</a></span>levelSetRebuild() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr levelSetRebuild </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>isovalue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>exBandWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>inBandWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> *</td>          <td class="paramname"><span class="paramname"><em>xform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new grid of type <code>GridType</code> that contains a narrow-band level set representation of an isosurface of a given grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar, floating-point grid with one or more disjoint, closed isosurfaces at the given <em class="arg">isovalue</em> </td></tr>
    <tr><td class="paramname">isovalue</td><td>the isovalue that defines the implicit surface </td></tr>
    <tr><td class="paramname">exBandWidth</td><td>the exterior narrow-band width in voxel units </td></tr>
    <tr><td class="paramname">inBandWidth</td><td>the interior narrow-band width in voxel units </td></tr>
    <tr><td class="paramname">xform</td><td>optional transform for the output grid (if not provided, the transform of the input <em class="arg">grid</em> will be matched)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if <em class="arg">grid</em> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the input grid contains overlapping isosurfaces, interior edges will be lost. </dd></dl>

</div>
</div>
<a id="a9b42eee5e13c85a68dfad82c21d510a1" name="a9b42eee5e13c85a68dfad82c21d510a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b42eee5e13c85a68dfad82c21d510a1">&#9670;&#160;</a></span>levelSetRebuild() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr levelSetRebuild </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>isovalue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>exBandWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>inBandWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> *</td>          <td class="paramname"><span class="paramname"><em>xform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new grid of type <code>GridType</code> that contains a narrow-band level set representation of an isosurface of a given grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar, floating-point grid with one or more disjoint, closed isosurfaces at the given <em class="arg">isovalue</em> </td></tr>
    <tr><td class="paramname">isovalue</td><td>the isovalue that defines the implicit surface </td></tr>
    <tr><td class="paramname">exBandWidth</td><td>the exterior narrow-band width in voxel units </td></tr>
    <tr><td class="paramname">inBandWidth</td><td>the interior narrow-band width in voxel units </td></tr>
    <tr><td class="paramname">xform</td><td>optional transform for the output grid (if not provided, the transform of the input <em class="arg">grid</em> will be matched) </td></tr>
    <tr><td class="paramname">interrupter</td><td>optional interrupter object</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if <em class="arg">grid</em> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the input grid contains overlapping isosurfaces, interior edges will be lost. </dd></dl>

</div>
</div>
<a id="af574939742ed86a148731292520c8e30" name="af574939742ed86a148731292520c8e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af574939742ed86a148731292520c8e30">&#9670;&#160;</a></span>levelSetRebuild() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr levelSetRebuild </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>isovalue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> *</td>          <td class="paramname"><span class="paramname"><em>xform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new grid of type <code>GridType</code> that contains a narrow-band level set representation of an isosurface of a given grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar, floating-point grid with one or more disjoint, closed isosurfaces at the given <em class="arg">isovalue</em> </td></tr>
    <tr><td class="paramname">isovalue</td><td>the isovalue that defines the implicit surface (defaults to zero, which is typical if the input grid is already a level set or a SDF). </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units (defaults to 3 voxels, which is required for some level set operations) </td></tr>
    <tr><td class="paramname">xform</td><td>optional transform for the output grid (if not provided, the transform of the input <em class="arg">grid</em> will be matched)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if <em class="arg">grid</em> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the input grid contains overlapping isosurfaces, interior edges will be lost. </dd></dl>

</div>
</div>
<a id="a874ec1fde6ce878c9a8d479e5ad67653" name="a874ec1fde6ce878c9a8d479e5ad67653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874ec1fde6ce878c9a8d479e5ad67653">&#9670;&#160;</a></span>levelSetVolume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> levelSetVolume </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useWorldUnits</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca27933ae9c1d5489a5c89377b382230" name="aca27933ae9c1d5489a5c89377b382230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca27933ae9c1d5489a5c89377b382230">&#9670;&#160;</a></span>levelSetVolume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a> levelSetVolume </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useWorldSpace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the volume of a narrow-band level set surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar, floating-point grid with one or more disjoint, closed level set surfaces </td></tr>
    <tr><td class="paramname">useWorldSpace</td><td>if true the volume is computed in world space units, else in voxel units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if <em class="arg">grid</em> is not scalar or not floating-point or not a level set or empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9370eee6dbb6de354a68a54b9cdd1dba" name="a9370eee6dbb6de354a68a54b9cdd1dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9370eee6dbb6de354a68a54b9cdd1dba">&#9670;&#160;</a></span>magnitude() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr magnitude </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the magnitudes of the vectors of the given vector-valued grid. </p>
<dl class="section return"><dt>Returns</dt><dd>a new scalar-valued grid with the same numerical precision as the input grid (for example, if the input grid is a <a class="el" href="namespaceopenvdb_1_1v13__0.html#a4047846203d0b9bcb5b7c0d3a6c7164f">Vec3DGrid</a>, the output grid will be a <a class="el" href="namespaceopenvdb_1_1v13__0.html#ae4044ab7ef1bfe752d228fe84ecd996e">DoubleGrid</a>)</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a id="aafe157b22738d7e56d30ae3cf62c1524" name="aafe157b22738d7e56d30ae3cf62c1524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe157b22738d7e56d30ae3cf62c1524">&#9670;&#160;</a></span>magnitude() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr magnitude </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06fe38fb2a95969530d664ef92f7dcae" name="a06fe38fb2a95969530d664ef92f7dcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fe38fb2a95969530d664ef92f7dcae">&#9670;&#160;</a></span>magnitude() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr magnitude </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f7f0791195ec365f99b2df45484bd25" name="a0f7f0791195ec365f99b2df45484bd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7f0791195ec365f99b2df45484bd25">&#9670;&#160;</a></span>magnitude() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1VectorToScalarConverter.html">VectorToScalarConverter</a>&lt; GridType &gt;::Type::Ptr magnitude </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fffee59d3b2f6dceb2ad8e9ac53a4b7" name="a6fffee59d3b2f6dceb2ad8e9ac53a4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fffee59d3b2f6dceb2ad8e9ac53a4b7">&#9670;&#160;</a></span>maskPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointListT, typename GridT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void maskPoints </td>
          <td>(</td>
          <td class="paramtype">const PointListT &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes every voxel of the <code>grid</code> active if it contains a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>points that active the voxels of <code>grid</code> </td></tr>
    <tr><td class="paramname">grid</td><td>on out its voxels with points are active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa310f2f224f5b386b70dd8645b39b133" name="aa310f2f224f5b386b70dd8645b39b133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa310f2f224f5b386b70dd8645b39b133">&#9670;&#160;</a></span>maskSdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename MaskTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr maskSdf </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>sdfGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html">Grid</a>&lt; MaskTreeT &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignoreActiveTiles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nIter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills mask by extending an existing signed distance field into the active values of this input ree of arbitrary value type. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the masked signed distance field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdfGrid</td><td>Input signed distance field to be extended into the mask.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask used to identify the topology of the output SDF. Note this mask is assume to overlap with the sdfGrid.</td></tr>
    <tr><td class="paramname">ignoreActiveTiles</td><td>If false, active tiles in the mask are treated as active voxels. Else they are ignored.</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
  </table>
  </dd>
</dl>
<p>Topology of the output SDF is determined by the union of the active voxels (or optionally values) in <em class="arg">sdfGrid</em> and <em class="arg">mask</em>. </p>

</div>
</div>
<a id="a5ad8501c4e8a1e0f613d880f3431d6ca" name="a5ad8501c4e8a1e0f613d880f3431d6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad8501c4e8a1e0f613d880f3431d6ca">&#9670;&#160;</a></span>meanCurvature() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meanCurvature </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean curvature of the given grid. </p>
<dl class="section return"><dt>Returns</dt><dd>a new grid</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a id="a9ea197a148972454409d2667cfa154d0" name="a9ea197a148972454409d2667cfa154d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea197a148972454409d2667cfa154d0">&#9670;&#160;</a></span>meanCurvature() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meanCurvature </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85e0a1a825212802a6a672420f1be648" name="a85e0a1a825212802a6a672420f1be648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e0a1a825212802a6a672420f1be648">&#9670;&#160;</a></span>meanCurvature() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meanCurvature </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae898df07e6e473da3f66a791c384bdad" name="ae898df07e6e473da3f66a791c384bdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae898df07e6e473da3f66a791c384bdad">&#9670;&#160;</a></span>meanCurvature() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meanCurvature </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad03704a13261822b75a2d5385bffbf41" name="ad03704a13261822b75a2d5385bffbf41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03704a13261822b75a2d5385bffbf41">&#9670;&#160;</a></span>memUsage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> memUsage </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total amount of memory in bytes occupied by this tree. </p>
<p>This method returns the total in-core memory usage which can be different to the maximum possible memory usage for trees which have not been fully deserialized (via delay-loading). Thus, this is the current true memory consumption. </p>

</div>
</div>
<a id="a81a7af5b71d8a4c94feaaff3b70b1418" name="a81a7af5b71d8a4c94feaaff3b70b1418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a7af5b71d8a4c94feaaff3b70b1418">&#9670;&#160;</a></span>memUsageIfLoaded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> memUsageIfLoaded </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the deserialized memory usage of this tree. This is not necessarily equal to the current memory usage (returned by <a class="el" href="#ad03704a13261822b75a2d5385bffbf41" title="Return the total amount of memory in bytes occupied by this tree.">tools::memUsage</a>) if delay-loading is enabled. See File::open. </p>

</div>
</div>
<a id="a88550f83eda208f6a4efd332735bb215" name="a88550f83eda208f6a4efd332735bb215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88550f83eda208f6a4efd332735bb215">&#9670;&#160;</a></span>meshToLevelSet() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToLevelSet </td>
          <td>(</td>
          <td class="paramtype">const openvdb::math::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a triangle and quad mesh to a level set volume. </p>
<dl class="section return"><dt>Returns</dt><dd>a grid of type <code>GridType</code> containing a narrow-band level set representation of the input mesh.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if <code>GridType</code> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Requires a closed surface but not necessarily a manifold surface. Supports surfaces with self intersections and degenerate faces and is independent of mesh surface normals.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xform</td><td>transform for the output grid </td></tr>
    <tr><td class="paramname">points</td><td>list of world space point positions </td></tr>
    <tr><td class="paramname">triangles</td><td>triangle index list </td></tr>
    <tr><td class="paramname">quads</td><td>quad index list </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49d6517666da8e1ec1175651ebf12f32" name="a49d6517666da8e1ec1175651ebf12f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d6517666da8e1ec1175651ebf12f32">&#9670;&#160;</a></span>meshToLevelSet() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToLevelSet </td>
          <td>(</td>
          <td class="paramtype">const openvdb::math::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a triangle mesh to a level set volume. </p>
<dl class="section return"><dt>Returns</dt><dd>a grid of type <code>GridType</code> containing a narrow-band level set representation of the input mesh.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if <code>GridType</code> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Requires a closed surface but not necessarily a manifold surface. Supports surfaces with self intersections and degenerate faces and is independent of mesh surface normals.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xform</td><td>transform for the output grid </td></tr>
    <tr><td class="paramname">points</td><td>list of world space point positions </td></tr>
    <tr><td class="paramname">triangles</td><td>triangle index list </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb69abc32d73ce0e3cd67b569bed65b8" name="afb69abc32d73ce0e3cd67b569bed65b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb69abc32d73ce0e3cd67b569bed65b8">&#9670;&#160;</a></span>meshToLevelSet() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToLevelSet </td>
          <td>(</td>
          <td class="paramtype">const openvdb::math::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a quad mesh to a level set volume. </p>
<dl class="section return"><dt>Returns</dt><dd>a grid of type <code>GridType</code> containing a narrow-band level set representation of the input mesh.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if <code>GridType</code> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Requires a closed surface but not necessarily a manifold surface. Supports surfaces with self intersections and degenerate faces and is independent of mesh surface normals.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xform</td><td>transform for the output grid </td></tr>
    <tr><td class="paramname">points</td><td>list of world space point positions </td></tr>
    <tr><td class="paramname">quads</td><td>quad index list </td></tr>
    <tr><td class="paramname">halfWidth</td><td>half the width of the narrow band, in voxel units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63becdf83d644c0cbc00213390201f97" name="a63becdf83d644c0cbc00213390201f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63becdf83d644c0cbc00213390201f97">&#9670;&#160;</a></span>meshToLevelSet() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename Interrupter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToLevelSet </td>
          <td>(</td>
          <td class="paramtype">Interrupter &amp;</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds support for a <em class="arg">interrupter</em> callback used to cancel the conversion. </p>

</div>
</div>
<a id="a564d13cfab9796e72f62f51f991d05af" name="a564d13cfab9796e72f62f51f991d05af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564d13cfab9796e72f62f51f991d05af">&#9670;&#160;</a></span>meshToLevelSet() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename Interrupter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToLevelSet </td>
          <td>(</td>
          <td class="paramtype">Interrupter &amp;</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds support for a <em class="arg">interrupter</em> callback used to cancel the conversion. </p>

</div>
</div>
<a id="a6eb7e6e46e2f3d080031f499863d3ba9" name="a6eb7e6e46e2f3d080031f499863d3ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb7e6e46e2f3d080031f499863d3ba9">&#9670;&#160;</a></span>meshToLevelSet() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename Interrupter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToLevelSet </td>
          <td>(</td>
          <td class="paramtype">Interrupter &amp;</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">float(<a class="el" href="namespaceopenvdb_1_1v13__0.html#a04f60dd7b4a065a54f873613ff8df50f">LEVEL_SET_HALF_WIDTH</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds support for a <em class="arg">interrupter</em> callback used to cancel the conversion. </p>

</div>
</div>
<a id="ab994dead75e3d110e11eb64dce6ca65a" name="ab994dead75e3d110e11eb64dce6ca65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab994dead75e3d110e11eb64dce6ca65a">&#9670;&#160;</a></span>meshToSignedDistanceField() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToSignedDistanceField </td>
          <td>(</td>
          <td class="paramtype">const openvdb::math::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>exBandWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>inBandWidth</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a triangle and quad mesh to a signed distance field with an asymmetrical narrow band. </p>
<dl class="section return"><dt>Returns</dt><dd>a grid of type <code>GridType</code> containing a narrow-band signed distance field representation of the input mesh.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if <code>GridType</code> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Requires a closed surface but not necessarily a manifold surface. Supports surfaces with self intersections and degenerate faces and is independent of mesh surface normals.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xform</td><td>transform for the output grid </td></tr>
    <tr><td class="paramname">points</td><td>list of world space point positions </td></tr>
    <tr><td class="paramname">triangles</td><td>triangle index list </td></tr>
    <tr><td class="paramname">quads</td><td>quad index list </td></tr>
    <tr><td class="paramname">exBandWidth</td><td>the exterior narrow-band width in voxel units </td></tr>
    <tr><td class="paramname">inBandWidth</td><td>the interior narrow-band width in voxel units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee8b90b4bf51a0a1d6f02a769787b415" name="aee8b90b4bf51a0a1d6f02a769787b415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8b90b4bf51a0a1d6f02a769787b415">&#9670;&#160;</a></span>meshToSignedDistanceField() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename Interrupter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToSignedDistanceField </td>
          <td>(</td>
          <td class="paramtype">Interrupter &amp;</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>exBandWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>inBandWidth</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds support for a <em class="arg">interrupter</em> callback used to cancel the conversion. </p>

</div>
</div>
<a id="a7a77a75ddf87809699a67916ea172add" name="a7a77a75ddf87809699a67916ea172add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a77a75ddf87809699a67916ea172add">&#9670;&#160;</a></span>meshToUnsignedDistanceField() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToUnsignedDistanceField </td>
          <td>(</td>
          <td class="paramtype">const openvdb::math::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>bandWidth</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a triangle and quad mesh to an unsigned distance field. </p>
<dl class="section return"><dt>Returns</dt><dd>a grid of type <code>GridType</code> containing a narrow-band unsigned distance field representation of the input mesh.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if <code>GridType</code> is not scalar or not floating-point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does not requires a closed surface.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xform</td><td>transform for the output grid </td></tr>
    <tr><td class="paramname">points</td><td>list of world space point positions </td></tr>
    <tr><td class="paramname">triangles</td><td>triangle index list </td></tr>
    <tr><td class="paramname">quads</td><td>quad index list </td></tr>
    <tr><td class="paramname">bandWidth</td><td>the width of the narrow band, in voxel units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacc72d314893ef0b6ad5cda65ded5255" name="aacc72d314893ef0b6ad5cda65ded5255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc72d314893ef0b6ad5cda65ded5255">&#9670;&#160;</a></span>meshToUnsignedDistanceField() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename Interrupter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToUnsignedDistanceField </td>
          <td>(</td>
          <td class="paramtype">Interrupter &amp;</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;</td>          <td class="paramname"><span class="paramname"><em>xform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>bandWidth</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds support for a <em class="arg">interrupter</em> callback used to cancel the conversion. </p>

</div>
</div>
<a id="a981f3d490ed2b917883704da916b6994" name="a981f3d490ed2b917883704da916b6994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981f3d490ed2b917883704da916b6994">&#9670;&#160;</a></span>meshToVolume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename <a class="el" href="interfaceMeshDataAdapter.html">MeshDataAdapter</a>, typename InteriorTest = std::nullptr_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="interfaceMeshDataAdapter.html">MeshDataAdapter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>exteriorBandWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>interiorBandWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridType::template ValueConverter&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac524bdfeb5d781872485d9321c881920">Int32</a> &gt;::Type *</td>          <td class="paramname"><span class="paramname"><em>polygonIndexGrid</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InteriorTest</td>          <td class="paramname"><span class="paramname"><em>interiorTest</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687">InteriorTestStrategy</a></td>          <td class="paramname"><span class="paramname"><em>interiorTestStrat</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687a4db3075e87b5663df255817c35275e4d">EVAL_EVERY_VOXEL</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0f20b1852e5a2e365191b27ac6b3e4d" name="ac0f20b1852e5a2e365191b27ac6b3e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f20b1852e5a2e365191b27ac6b3e4d">&#9670;&#160;</a></span>meshToVolume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename <a class="el" href="interfaceMeshDataAdapter.html">MeshDataAdapter</a>, typename Interrupter, typename InteriorTest = std::nullptr_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr meshToVolume </td>
          <td>(</td>
          <td class="paramtype">Interrupter &amp;</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="interfaceMeshDataAdapter.html">MeshDataAdapter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html">math::Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>exteriorBandWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>interiorBandWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridType::template ValueConverter&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ac524bdfeb5d781872485d9321c881920">Int32</a> &gt;::Type *</td>          <td class="paramname"><span class="paramname"><em>polygonIndexGrid</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InteriorTest</td>          <td class="paramname"><span class="paramname"><em>interiorTest</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687">InteriorTestStrategy</a></td>          <td class="paramname"><span class="paramname"><em>interiorTestStrat</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687a4db3075e87b5663df255817c35275e4d">EVAL_EVERY_VOXEL</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert polygonal meshes that consist of quads and/or triangles into signed or unsigned distance field volumes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interrupter</td><td>a callback to interrupt the conversion process that conforms to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface </td></tr>
    <tr><td class="paramname">mesh</td><td>mesh data access class that conforms to the <a class="el" href="interfaceMeshDataAdapter.html" title="Convert polygonal meshes that consist of quads and/or triangles into signed or unsigned distance fiel...">MeshDataAdapter</a> interface </td></tr>
    <tr><td class="paramname">transform</td><td>world-to-index-space transform </td></tr>
    <tr><td class="paramname">exteriorBandWidth</td><td>exterior narrow band width in voxel units </td></tr>
    <tr><td class="paramname">interiorBandWidth</td><td>interior narrow band width in voxel units (set this value to std::numeric_limits&lt;float&gt;::max() to fill interior regions with distance values) </td></tr>
    <tr><td class="paramname">flags</td><td>optional conversion flags defined in <code><a class="el" href="#a2623bf4797b966b29fbe45c87e60481c" title="Mesh to volume conversion flags.">MeshToVolumeFlags</a></code> </td></tr>
    <tr><td class="paramname">polygonIndexGrid</td><td>optional grid output that will contain the closest-polygon index for each voxel in the active narrow band region </td></tr>
    <tr><td class="paramname">interiorTest</td><td>function <span class="tt"><a class="el" href="classopenvdb_1_1v13__0_1_1Coord.html" title="Signed (x, y, z) 32-bit integer coordinates.">Coord</a> -&gt; Bool</span> that evaluates to true inside of the mesh and false outside, for more see evaluatInteriorTest </td></tr>
    <tr><td class="paramname">interiorTestStrat</td><td>determines how the interiorTest is used, see <a class="el" href="#af9f5e36eb8e66aa36883fc3ef727e687" title="Different staregies how to determine sign of an SDF when using interior test.">InteriorTestStrategy</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36ee086a1c07bfb390ebe92257e266ec" name="a36ee086a1c07bfb390ebe92257e266ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ee086a1c07bfb390ebe92257e266ec">&#9670;&#160;</a></span>minMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1MinMax.html">math::MinMax</a>&lt; typename TreeT::ValueType &gt; minMax </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum and maximum active values in this tree. </p>
<dl class="section note"><dt>Note</dt><dd>Returns zeroVal&lt;ValueType&gt; for empty trees. </dd></dl>

</div>
</div>
<a id="add8ca0caf60c323917088490510fa8e8" name="add8ca0caf60c323917088490510fa8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8ca0caf60c323917088490510fa8e8">&#9670;&#160;</a></span>noActiveValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool noActiveValues </td>
          <td>(</td>
          <td class="paramtype">const TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the bounding box intersects none of the active values in a tree, i.e. neither active voxels or active tiles. </p>
<dl class="section warning"><dt>Warning</dt><dd>For repeated calls to this method consider instead creating an instance of <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1FindActiveValues.html" title="Finds the active values in a tree which intersects a bounding box.">FindActiveValues</a> and then repeatedly call <a class="el" href="#add8ca0caf60c323917088490510fa8e8" title="Returns true if the bounding box intersects none of the active values in a tree, i....">noActiveValues()</a>. This assumes the tree to be constant between calls but is slightly faster.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>const tree to be tested for active values. </td></tr>
    <tr><td class="paramname">bbox</td><td>index bounding box which is intersected against the active values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5c0227e6c84797a06542df58c2b564d" name="af5c0227e6c84797a06542df58c2b564d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c0227e6c84797a06542df58c2b564d">&#9670;&#160;</a></span>normalize() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr normalize </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Normalize.html">Normalize</a> the vectors of the given vector-valued grid. </p>
<dl class="section return"><dt>Returns</dt><dd>a new vector-valued grid</dd></dl>
<p>When a mask grid is specified, the solution is calculated only in the intersection of the mask active topology and the input active topology independent of the transforms associated with either grid. </p>

</div>
</div>
<a id="a3504dc47e0cb735b8b4455fa1ab8b532" name="a3504dc47e0cb735b8b4455fa1ab8b532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3504dc47e0cb735b8b4455fa1ab8b532">&#9670;&#160;</a></span>normalize() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr normalize </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1b083e3b964ba0f08ff56bf2d50981e" name="ac1b083e3b964ba0f08ff56bf2d50981e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b083e3b964ba0f08ff56bf2d50981e">&#9670;&#160;</a></span>normalize() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT, typename InterruptT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr normalize </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c42f6e6d04dc1d033b449cb05c4406e" name="a5c42f6e6d04dc1d033b449cb05c4406e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c42f6e6d04dc1d033b449cb05c4406e">&#9670;&#160;</a></span>normalize() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType, typename MaskT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridType::Ptr normalize </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MaskT &amp;</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81e43d965ad641e0651ac9a39fa7c722" name="a81e43d965ad641e0651ac9a39fa7c722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e43d965ad641e0651ac9a39fa7c722">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>ostr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1MeshToVoxelEdgeData_1_1EdgeData.html">MeshToVoxelEdgeData::EdgeData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4a308e2e6c2d283bfafb3bd80c8ca43" name="ab4a308e2e6c2d283bfafb3bd80c8ca43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a308e2e6c2d283bfafb3bd80c8ca43">&#9670;&#160;</a></span>opExtrema()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OperatorT, typename IterT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Extrema.html">math::Extrema</a> opExtrema </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OperatorT &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span><span class="paramdefsep"> = </span><span class="paramdefval">OperatorT()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as opStatistics except it returns a <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Extrema.html" title="This class computes the minimum and maximum values of a population of floating-point values.">math::Extrema</a> vs a <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html" title="This class computes statistics (minimum value, maximum value, mean, variance and standard deviation) ...">math::Stats</a>. </p>

</div>
</div>
<a id="a35876c2d474f3ed28fc6a6aa4b4f5678" name="a35876c2d474f3ed28fc6a6aa4b4f5678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35876c2d474f3ed28fc6a6aa4b4f5678">&#9670;&#160;</a></span>opStatistics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OperatorT, typename IterT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html">math::Stats</a> opStatistics </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OperatorT &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span><span class="paramdefsep"> = </span><span class="paramdefval">OperatorT()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over a grid and compute statistics (mean, variance, etc.) of the values produced by applying a given operator (see <a class="el" href="Operators_8h.html">math/Operators.h</a>) at each voxel that is visited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over the values of a grid or its tree (<code><a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::ValueOffIter</code>, etc.) </td></tr>
    <tr><td class="paramname">op</td><td>an operator object with a method of the form <span class="tt">double result(Accessor&amp;, const Coord&amp;)</span> </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, iterate over the grid in parallel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>World-space operators, whose <code>result()</code> methods are of the form <span class="tt">double result(const Map&amp;, Accessor&amp;, const Coord&amp;)</span>, must be wrapped in a <a class="el" href="structopenvdb_1_1v13__0_1_1math_1_1MapAdapter.html" title="Adapter to associate a map with a world-space operator, giving it the same call signature as an index...">math::MapAdapter</a>. </dd>
<dd>
Vector-valued operators like <a class="el" href="structopenvdb_1_1v13__0_1_1math_1_1Gradient.html" title="Center difference gradient operators, defined with respect to the range-space of the map.">math::Gradient</a> must be wrapped in an adapter such as <a class="el" href="structopenvdb_1_1v13__0_1_1math_1_1OpMagnitude.html" title="Adapter for vector-valued world-space operators to return the vector magnitude.">math::OpMagnitude</a>.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Compute statistics of the magnitude of the gradient at the active voxels of a scalar, floating-point grid. (Note the use of the <a class="el" href="structopenvdb_1_1v13__0_1_1math_1_1MapAdapter.html" title="Adapter to associate a map with a world-space operator, giving it the same call signature as an index...">math::MapAdapter</a> and <a class="el" href="structopenvdb_1_1v13__0_1_1math_1_1OpMagnitude.html" title="Adapter for vector-valued world-space operators to return the vector magnitude.">math::OpMagnitude</a> adapters.) <div class="fragment"><div class="line"><a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> grid = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assume that we know that the grid has a uniform scale map.</span></div>
<div class="line"><span class="keyword">using </span>MapType = <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1math_1_1UniformScaleMap.html">math::UniformScaleMap</a>;</div>
<div class="line"><span class="comment">// Specify a world-space gradient operator that uses first-order differencing.</span></div>
<div class="line"><span class="keyword">using </span>GradientOp = <a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1math_1_1Gradient.html">math::Gradient&lt;MapType, math::FD_1ST&gt;</a>;</div>
<div class="line"><span class="comment">// Wrap the operator with an adapter that computes the magnitude of the gradient.</span></div>
<div class="line"><span class="keyword">using </span>MagnitudeOp = <a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1math_1_1OpMagnitude.html">math::OpMagnitude&lt;GradientOp, MapType&gt;</a>;</div>
<div class="line"><span class="comment">// Wrap the operator with an adapter that associates a map with it.</span></div>
<div class="line"><span class="keyword">using </span>CompoundOp = <a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1math_1_1MapAdapter.html">math::MapAdapter&lt;MapType, GradientOp, double&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (MapType::Ptr map = grid.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1GridBase.html#a30cb9de18535e7be48cd08b600fe0769">constTransform</a>().<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html#a9865c49adbbf958e867e4021533ddc86">constMap</a>&lt;MapType&gt;()) {</div>
<div class="line">    <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html">math::Stats</a> stats = <a class="code hl_function" href="#a35876c2d474f3ed28fc6a6aa4b4f5678">tools::opStatistics</a>(grid.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1Grid.html#a9141b760807bdde0cad1e9bee1cc137a">cbeginValueOn</a>(), CompoundOp(*map));</div>
<div class="line">}</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1GridBase_html_a30cb9de18535e7be48cd08b600fe0769"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1GridBase.html#a30cb9de18535e7be48cd08b600fe0769">openvdb::v13_0::GridBase::constTransform</a></div><div class="ttdeci">const math::Transform &amp; constTransform() const</div><div class="ttdoc">Return a pointer to this grid&#39;s transform, which might be shared with other grids.</div><div class="ttdef"><b>Definition</b> Grid.h:413</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1Grid_html_a9141b760807bdde0cad1e9bee1cc137a"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1Grid.html#a9141b760807bdde0cad1e9bee1cc137a">openvdb::v13_0::Grid::cbeginValueOn</a></div><div class="ttdeci">ValueOnCIter cbeginValueOn() const</div><div class="ttdoc">Return an iterator over all of this grid&#39;s active values (tile and voxel).</div><div class="ttdef"><b>Definition</b> Grid.h:759</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1Transform_html_a9865c49adbbf958e867e4021533ddc86"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html#a9865c49adbbf958e867e4021533ddc86">openvdb::v13_0::math::Transform::constMap</a></div><div class="ttdeci">MapType::ConstPtr constMap() const</div><div class="ttdef"><b>Definition</b> Transform.h:189</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1UniformScaleMap_html"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1UniformScaleMap.html">openvdb::v13_0::math::UniformScaleMap</a></div><div class="ttdoc">A specialized Affine transform that scales along the principal axis the scaling is uniform in the thr...</div><div class="ttdef"><b>Definition</b> Maps.h:906</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tools_html_a35876c2d474f3ed28fc6a6aa4b4f5678"><div class="ttname"><a href="#a35876c2d474f3ed28fc6a6aa4b4f5678">openvdb::v13_0::tools::opStatistics</a></div><div class="ttdeci">math::Stats opStatistics(const IterT &amp;iter, const OperatorT &amp;op=OperatorT(), bool threaded=true)</div><div class="ttdoc">Iterate over a grid and compute statistics (mean, variance, etc.) of the values produced by applying ...</div><div class="ttdef"><b>Definition</b> Statistics.h:398</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1math_1_1Gradient_html"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1math_1_1Gradient.html">openvdb::v13_0::math::Gradient</a></div><div class="ttdoc">Center difference gradient operators, defined with respect to the range-space of the map.</div><div class="ttdef"><b>Definition</b> Operators.h:620</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1math_1_1MapAdapter_html"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1math_1_1MapAdapter.html">openvdb::v13_0::math::MapAdapter</a></div><div class="ttdoc">Adapter to associate a map with a world-space operator, giving it the same call signature as an index...</div><div class="ttdef"><b>Definition</b> Operators.h:35</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1math_1_1OpMagnitude_html"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1math_1_1OpMagnitude.html">openvdb::v13_0::math::OpMagnitude</a></div><div class="ttdoc">Adapter for vector-valued world-space operators to return the vector magnitude.</div><div class="ttdef"><b>Definition</b> Operators.h:66</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Compute statistics of the divergence at the active voxels of a vector-valued grid. <div class="fragment"><div class="line"><a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0.html#a77ff1a3a38ec99a56b4d99a15a2970bf">Vec3SGrid</a> grid = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assume that we know that the grid has a uniform scale map.</span></div>
<div class="line"><span class="keyword">using </span>MapType = <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1math_1_1UniformScaleMap.html">math::UniformScaleMap</a>;</div>
<div class="line"><span class="comment">// Specify a world-space divergence operator that uses first-order differencing.</span></div>
<div class="line"><span class="keyword">using </span>DivergenceOp = <a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1math_1_1Divergence.html">math::Divergence&lt;MapType, math::FD_1ST&gt;</a>;</div>
<div class="line"><span class="comment">// Wrap the operator with an adapter that associates a map with it.</span></div>
<div class="line"><span class="keyword">using </span>CompoundOp = <a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1math_1_1MapAdapter.html">math::MapAdapter&lt;MapType, DivergenceOp, double&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (MapType::Ptr map = grid.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1GridBase.html#a30cb9de18535e7be48cd08b600fe0769">constTransform</a>().<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html#a9865c49adbbf958e867e4021533ddc86">constMap</a>&lt;MapType&gt;()) {</div>
<div class="line">    <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html">math::Stats</a> stats = <a class="code hl_function" href="#a35876c2d474f3ed28fc6a6aa4b4f5678">tools::opStatistics</a>(grid.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1Grid.html#a9141b760807bdde0cad1e9bee1cc137a">cbeginValueOn</a>(), CompoundOp(*map));</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_html_a77ff1a3a38ec99a56b4d99a15a2970bf"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0.html#a77ff1a3a38ec99a56b4d99a15a2970bf">openvdb::v13_0::Vec3SGrid</a></div><div class="ttdeci">Grid&lt; Vec3STree &gt; Vec3SGrid</div><div class="ttdef"><b>Definition</b> openvdb.h:83</div></div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1math_1_1Divergence_html"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1math_1_1Divergence.html">openvdb::v13_0::math::Divergence</a></div><div class="ttdoc">Compute the divergence of a vector-valued grid using differencing of various orders,...</div><div class="ttdef"><b>Definition</b> Operators.h:950</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Example:</dt><dd>As above, but computing the divergence in index space. <div class="fragment"><div class="line"><a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0.html#a77ff1a3a38ec99a56b4d99a15a2970bf">Vec3SGrid</a> grid = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Specify an index-space divergence operator that uses first-order differencing.</span></div>
<div class="line"><span class="keyword">using </span>DivergenceOp = <a class="code hl_struct" href="structopenvdb_1_1v13__0_1_1math_1_1ISDivergence.html">math::ISDivergence&lt;math::FD_1ST&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html">math::Stats</a> stats = <a class="code hl_function" href="#a35876c2d474f3ed28fc6a6aa4b4f5678">tools::opStatistics</a>(grid.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1Grid.html#a9141b760807bdde0cad1e9bee1cc137a">cbeginValueOn</a>(), DivergenceOp());</div>
<div class="ttc" id="astructopenvdb_1_1v13__0_1_1math_1_1ISDivergence_html"><div class="ttname"><a href="structopenvdb_1_1v13__0_1_1math_1_1ISDivergence.html">openvdb::v13_0::math::ISDivergence</a></div><div class="ttdoc">Divergence operator defined in index space using various first derivative schemes.</div><div class="ttdef"><b>Definition</b> Operators.h:473</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a9feb86e4311db3ba962b9d19eb5569be" name="a9feb86e4311db3ba962b9d19eb5569be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9feb86e4311db3ba962b9d19eb5569be">&#9670;&#160;</a></span>particlesToMask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename ParticleListT, typename InterrupterT = util::NullInterrupter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void particlesToMask </td>
          <td>(</td>
          <td class="paramtype">const ParticleListT &amp;</td>          <td class="paramname"><span class="paramname"><em>plist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activate a boolean grid wherever it intersects the spheres described by the given particle positions and radii. </p>
<p>For more control over the output, including attribute transfer, use the <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ParticlesToLevelSet.html">ParticlesToLevelSet</a> class directly. </p>

</div>
</div>
<a id="a6227a77a20fcc91e570b959710b930d2" name="a6227a77a20fcc91e570b959710b930d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6227a77a20fcc91e570b959710b930d2">&#9670;&#160;</a></span>particlesToMask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename ParticleListT, typename InterrupterT = util::NullInterrupter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void particlesToMask </td>
          <td>(</td>
          <td class="paramtype">const ParticleListT &amp;</td>          <td class="paramname"><span class="paramname"><em>plist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a></td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activate a boolean grid wherever it intersects the fixed-size spheres described by the given particle positions and the specified radius. </p>
<p>For more control over the output, including attribute transfer, use the <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ParticlesToLevelSet.html">ParticlesToLevelSet</a> class directly. </p>

</div>
</div>
<a id="ae29bb93f486d96bd91cad919e623dab0" name="ae29bb93f486d96bd91cad919e623dab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29bb93f486d96bd91cad919e623dab0">&#9670;&#160;</a></span>particlesToSdf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename ParticleListT, typename InterrupterT = util::NullInterrupter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void particlesToSdf </td>
          <td>(</td>
          <td class="paramtype">const ParticleListT &amp;</td>          <td class="paramname"><span class="paramname"><em>plist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a scalar, floating-point grid with CSG-unioned level set spheres described by the given particle positions and radii. </p>
<p>For more control over the output, including attribute transfer, use the <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ParticlesToLevelSet.html">ParticlesToLevelSet</a> class directly. </p>

</div>
</div>
<a id="ad924a8ad2838440370b1c80a599794d8" name="ad924a8ad2838440370b1c80a599794d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad924a8ad2838440370b1c80a599794d8">&#9670;&#160;</a></span>particlesToSdf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename ParticleListT, typename InterrupterT = util::NullInterrupter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void particlesToSdf </td>
          <td>(</td>
          <td class="paramtype">const ParticleListT &amp;</td>          <td class="paramname"><span class="paramname"><em>plist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a></td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a scalar, floating-point grid with fixed-size, CSG-unioned level set spheres described by the given particle positions and the specified radius. </p>
<p>For more control over the output, including attribute transfer, use the <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ParticlesToLevelSet.html">ParticlesToLevelSet</a> class directly. </p>

</div>
</div>
<a id="af4039b2222a88a7e4ed8e3f47490eecb" name="af4039b2222a88a7e4ed8e3f47490eecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4039b2222a88a7e4ed8e3f47490eecb">&#9670;&#160;</a></span>particleTrailsToMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename ParticleListT, typename InterrupterT = util::NullInterrupter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void particleTrailsToMask </td>
          <td>(</td>
          <td class="paramtype">const ParticleListT &amp;</td>          <td class="paramname"><span class="paramname"><em>plist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a></td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activate a boolean grid wherever it intersects trails of spheres with decreasing radius, where the starting position and radius and the direction of each trail is given by particle attributes. </p>
<p>For more control over the output, including attribute transfer, use the <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ParticlesToLevelSet.html">ParticlesToLevelSet</a> class directly. </p><dl class="section note"><dt>Note</dt><dd>The <em class="arg">delta</em> parameter controls the distance between spheres in a trail. Be careful not to use too small a value. </dd></dl>

</div>
</div>
<a id="adcddfc57ef94f93ff3806a45c26ca7d0" name="adcddfc57ef94f93ff3806a45c26ca7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcddfc57ef94f93ff3806a45c26ca7d0">&#9670;&#160;</a></span>particleTrailsToSdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename ParticleListT, typename InterrupterT = util::NullInterrupter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void particleTrailsToSdf </td>
          <td>(</td>
          <td class="paramtype">const ParticleListT &amp;</td>          <td class="paramname"><span class="paramname"><em>plist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a4b04262b81aa7d31eb5d2f607e2a35de">Real</a></td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a scalar, floating-point grid with CSG-unioned trails of level set spheres with decreasing radius, where the starting position and radius and the direction of each trail is given by particle attributes. </p>
<p>For more control over the output, including attribute transfer, use the <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1ParticlesToLevelSet.html">ParticlesToLevelSet</a> class directly. </p><dl class="section note"><dt>Note</dt><dd>The <em class="arg">delta</em> parameter controls the distance between spheres in a trail. Be careful not to use too small a value. </dd></dl>

</div>
</div>
<a id="a8057e1165c928a37703f90eb9496083c" name="a8057e1165c928a37703f90eb9496083c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8057e1165c928a37703f90eb9496083c">&#9670;&#160;</a></span>prune()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void prune </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename TreeT::ValueType</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b">zeroVal</a>&lt;typename&#160;TreeT::ValueType&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce the memory footprint of a <em class="arg">tree</em> by replacing with tiles any nodes whose values are all the same (optionally to within a tolerance) and have the same active state. </p>
<dl class="section note"><dt>Note</dt><dd>For trees with non-boolean values a child node with (approximately) constant values are replaced with a tile value corresponding to the median of the values in said child node.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree to be pruned </td></tr>
    <tr><td class="paramname">tolerance</td><td>tolerance within which values are considered to be equal </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae81e76930df0c635a4e175887352257e" name="ae81e76930df0c635a4e175887352257e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81e76930df0c635a4e175887352257e">&#9670;&#160;</a></span>pruneInactive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pruneInactive </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce the memory footprint of a <em class="arg">tree</em> by replacing with background tiles any nodes whose values are all inactive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree to be pruned </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad68447719ca38904491830b5c1caefa8" name="ad68447719ca38904491830b5c1caefa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68447719ca38904491830b5c1caefa8">&#9670;&#160;</a></span>pruneInactiveWithValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pruneInactiveWithValue </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce the memory footprint of a <em class="arg">tree</em> by replacing any nodes whose values are all inactive with tiles of the given <em class="arg">value</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree to be pruned </td></tr>
    <tr><td class="paramname">value</td><td>value assigned to inactive tiles created during pruning </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a467d50f8a53357977d5720498a88d72c" name="a467d50f8a53357977d5720498a88d72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467d50f8a53357977d5720498a88d72c">&#9670;&#160;</a></span>pruneLevelSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pruneLevelSet </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce the memory footprint of a <em class="arg">tree</em> by replacing nodes whose values are all inactive with inactive tiles having a value equal to the first value encountered in the (inactive) child. </p>
<p>This method is faster than tolerance-based prune and useful for narrow-band level set applications where inactive values are limited to either an inside or an outside value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree to be pruned </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1ValueError.html">ValueError</a></td><td>if the background of the <em class="arg">tree</em> is negative (as defined by <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a942957f1908446c00fcb1196189aaaba" title="Return true if x is less than zero.">math::isNegative</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac57eaa5cdb5f7180a68b88901e9421ad" name="ac57eaa5cdb5f7180a68b88901e9421ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57eaa5cdb5f7180a68b88901e9421ad">&#9670;&#160;</a></span>pruneLevelSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pruneLevelSet </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>outsideWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>insideWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce the memory footprint of a <em class="arg">tree</em> by replacing nodes whose voxel values are all inactive with inactive tiles having the value -| <em class="arg">insideWidth</em> | if the voxel values are negative and | <em class="arg">outsideWidth</em> | otherwise. </p>
<p>This method is faster than tolerance-based prune and useful for narrow-band level set applications where inactive values are limited to either an inside or an outside value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree to be pruned </td></tr>
    <tr><td class="paramname">outsideWidth</td><td>the width of the outside of the narrow band </td></tr>
    <tr><td class="paramname">insideWidth</td><td>the width of the inside of the narrow band </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1ValueError.html">ValueError</a></td><td>if <em class="arg">outsideWidth</em> is negative or <em class="arg">insideWidth</em> is not negative (as defined by <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#a942957f1908446c00fcb1196189aaaba" title="Return true if x is less than zero.">math::isNegative</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8ffdc3cdd984ae9e4c0742406cfdaee" name="ab8ffdc3cdd984ae9e4c0742406cfdaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ffdc3cdd984ae9e4c0742406cfdaee">&#9670;&#160;</a></span>pruneTiles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pruneTiles </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename TreeT::ValueType</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a734ccd1d3c67a1ab1da81817137b2e1b">zeroVal</a>&lt;typename&#160;TreeT::ValueType&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce the memory footprint of a <em class="arg">tree</em> by replacing with tiles any non-leaf nodes whose values are all the same (optionally to within a tolerance) and have the same active state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree to be pruned </td></tr>
    <tr><td class="paramname">tolerance</td><td>tolerance within which values are considered to be equal </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8642ecf09da68f9d3d16f606be7ae301" name="a8642ecf09da68f9d3d16f606be7ae301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8642ecf09da68f9d3d16f606be7ae301">&#9670;&#160;</a></span>rayTrace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rayTrace </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1BaseShader.html">BaseShader</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shader</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1BaseCamera.html">BaseCamera</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>camera</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pixelSamples</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ray-trace a volume. </p>

</div>
</div>
<a id="a02be13fa85c9edfa183b39d1255ff6c4" name="a02be13fa85c9edfa183b39d1255ff6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02be13fa85c9edfa183b39d1255ff6c4">&#9670;&#160;</a></span>rayTrace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename IntersectorT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rayTrace </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntersectorT &amp;</td>          <td class="paramname"><span class="paramname"><em>inter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1BaseShader.html">BaseShader</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shader</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1BaseCamera.html">BaseCamera</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>camera</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pixelSamples</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>seed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ray-trace a volume using a given ray intersector. </p>

</div>
</div>
<a id="af4c63aac5d546c4e73dd5f2e8bf734ca" name="af4c63aac5d546c4e73dd5f2e8bf734ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c63aac5d546c4e73dd5f2e8bf734ca">&#9670;&#160;</a></span>resampleToMatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler.html">Sampler</a>, typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void resampleToMatch </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>inGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>outGrid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resample an input grid into an output grid of the same type such that, after resampling, the input and output grids coincide (apart from sampling artifacts), but the output grid's transform is unchanged. </p>
<p>Specifically, this function resamples the input grid into the output grid's index space, using a sampling kernel like <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1PointSampler.html">PointSampler</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1BoxSampler.html">BoxSampler</a>, or <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1QuadraticSampler.html">QuadraticSampler</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inGrid</td><td>the grid to be resampled </td></tr>
    <tr><td class="paramname">outGrid</td><td>the grid into which to write the resampled voxel data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="comment">// Create an input grid with the default identity transform</span></div>
<div class="line"><span class="comment">// and populate it with a level-set sphere.</span></div>
<div class="line"><a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#a84f71739738652d0987c7456128389be">FloatGrid::ConstPtr</a> src = tools::makeSphere(...);</div>
<div class="line"><span class="comment">// Create an output grid and give it a uniform-scale transform.</span></div>
<div class="line"><a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">FloatGrid::Ptr</a> dest = <a class="code hl_function" href="classopenvdb_1_1v13__0_1_1Grid.html#afed9748b2280ee9155aa1033cc583bc7">FloatGrid::create</a>();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> voxelSize = 0.5;</div>
<div class="line">dest-&gt;setTransform(<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html#ae35abe5d5592d24a97725f90eb3ce3f1">math::Transform::createLinearTransform</a>(voxelSize));</div>
<div class="line"><span class="comment">// Resample the input grid into the output grid, reproducing</span></div>
<div class="line"><span class="comment">// the level-set sphere at a smaller voxel size.</span></div>
<div class="line"><a class="code hl_function" href="#ae190c2befe2b252b8d930bd632964ab7">tools::resampleToMatch&lt;tools::QuadraticSampler&gt;</a>(*src, *dest);</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1Grid_html_a84f71739738652d0987c7456128389be"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1Grid.html#a84f71739738652d0987c7456128389be">openvdb::v13_0::Grid&lt; FloatTree &gt;::ConstPtr</a></div><div class="ttdeci">SharedPtr&lt; const Grid &gt; ConstPtr</div><div class="ttdef"><b>Definition</b> Grid.h:574</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1Grid_html_afc0f397bf0d1638f08250c19bc02d39e"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::v13_0::Grid&lt; FloatTree &gt;::Ptr</a></div><div class="ttdeci">SharedPtr&lt; Grid &gt; Ptr</div><div class="ttdef"><b>Definition</b> Grid.h:573</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1Grid_html_afed9748b2280ee9155aa1033cc583bc7"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1Grid.html#afed9748b2280ee9155aa1033cc583bc7">openvdb::v13_0::Grid&lt; FloatTree &gt;::create</a></div><div class="ttdeci">static Ptr create()</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1Transform_html_ae35abe5d5592d24a97725f90eb3ce3f1"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html#ae35abe5d5592d24a97725f90eb3ce3f1">openvdb::v13_0::math::Transform::createLinearTransform</a></div><div class="ttdeci">static Transform::Ptr createLinearTransform(double voxelSize=1.0)</div><div class="ttdoc">Create and return a shared pointer to a new transform.</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tools_html_ae190c2befe2b252b8d930bd632964ab7"><div class="ttname"><a href="#ae190c2befe2b252b8d930bd632964ab7">openvdb::v13_0::tools::resampleToMatch</a></div><div class="ttdeci">void resampleToMatch(const GridType &amp;inGrid, GridType &amp;outGrid, Interrupter &amp;interrupter)</div><div class="ttdoc">Resample an input grid into an output grid of the same type such that, after resampling,...</div><div class="ttdef"><b>Definition</b> GridTransformer.h:486</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae190c2befe2b252b8d930bd632964ab7" name="ae190c2befe2b252b8d930bd632964ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae190c2befe2b252b8d930bd632964ab7">&#9670;&#160;</a></span>resampleToMatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1Sampler.html">Sampler</a>, typename Interrupter, typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void resampleToMatch </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>inGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>outGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Interrupter &amp;</td>          <td class="paramname"><span class="paramname"><em>interrupter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resample an input grid into an output grid of the same type such that, after resampling, the input and output grids coincide (apart from sampling artifacts), but the output grid's transform is unchanged. </p>
<p>Specifically, this function resamples the input grid into the output grid's index space, using a sampling kernel like <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1PointSampler.html">PointSampler</a>, <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1BoxSampler.html">BoxSampler</a>, or <a class="el" href="structopenvdb_1_1v13__0_1_1tools_1_1QuadraticSampler.html">QuadraticSampler</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inGrid</td><td>the grid to be resampled </td></tr>
    <tr><td class="paramname">outGrid</td><td>the grid into which to write the resampled voxel data </td></tr>
    <tr><td class="paramname">interrupter</td><td>an object adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="comment">// Create an input grid with the default identity transform</span></div>
<div class="line"><span class="comment">// and populate it with a level-set sphere.</span></div>
<div class="line"><a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#a84f71739738652d0987c7456128389be">FloatGrid::ConstPtr</a> src = tools::makeSphere(...);</div>
<div class="line"><span class="comment">// Create an output grid and give it a uniform-scale transform.</span></div>
<div class="line"><a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">FloatGrid::Ptr</a> dest = <a class="code hl_function" href="classopenvdb_1_1v13__0_1_1Grid.html#afed9748b2280ee9155aa1033cc583bc7">FloatGrid::create</a>();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> voxelSize = 0.5;</div>
<div class="line">dest-&gt;setTransform(<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Transform.html#ae35abe5d5592d24a97725f90eb3ce3f1">math::Transform::createLinearTransform</a>(voxelSize));</div>
<div class="line"><span class="comment">// Resample the input grid into the output grid, reproducing</span></div>
<div class="line"><span class="comment">// the level-set sphere at a smaller voxel size.</span></div>
<div class="line">MyInterrupter interrupter = ...;</div>
<div class="line"><a class="code hl_function" href="#ae190c2befe2b252b8d930bd632964ab7">tools::resampleToMatch&lt;tools::QuadraticSampler&gt;</a>(*src, *dest, interrupter);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a59b83096927350f3324cba935be37717" name="a59b83096927350f3324cba935be37717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b83096927350f3324cba935be37717">&#9670;&#160;</a></span>sdfInteriorMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridOrTreeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridOrTreeType::template ValueConverter&lt; bool &gt;::Type::Ptr sdfInteriorMask </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeType &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridOrTreeType::ValueType</td>          <td class="paramname"><span class="paramname"><em>isovalue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">lsutilGridZero&lt;GridOrTreeType&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Threaded method to construct a boolean mask that represents interior regions in a signed distance field. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to either a boolean grid or tree with the same tree configuration and potentially transform as the input <code>volume</code> and whose active and <code>true</code> values correspond to the interior of the input signed distance field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>Signed distance field / level set volume. </td></tr>
    <tr><td class="paramname">isovalue</td><td>Threshold below which values are considered part of the interior region. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3760ea31156ab4cb20897041e37c22b7" name="a3760ea31156ab4cb20897041e37c22b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3760ea31156ab4cb20897041e37c22b7">&#9670;&#160;</a></span>sdfToExt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SdfGridT, typename ExtOpT, typename ExtValueT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr sdfToExt </td>
          <td>(</td>
          <td class="paramtype">const SdfGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>sdfGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtOpT &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtValueT &amp;</td>          <td class="paramname"><span class="paramname"><em>background</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename SdfGridT::ValueType</td>          <td class="paramname"><span class="paramname"><em>isoValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nIter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bf">FastSweepingDomain</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bfa3203264a0a3fd2d90d15ee76eeb62f40">FastSweepingDomain::SWEEP_ALL</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::ConstPtr</td>          <td class="paramname"><span class="paramname"><em>extGrid</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the extension of a field (scalar, vector, or int are supported), defined by the specified functor, off an iso-surface from an input SDF volume. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the extension field defined on the active values in the input signed distance field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdfGrid</td><td>An approximate signed distance field to the specified iso-surface.</td></tr>
    <tr><td class="paramname">op</td><td>Functor with signature [](const <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab8753c49a176ce809a70ac12896682e3">Vec3R</a> &amp;xyz)-&gt;ExtValueT that defines the Dirichlet boundary condition, on the iso-surface, of the field to be extended.</td></tr>
    <tr><td class="paramname">background</td><td>Background value of return grid with the extension field.</td></tr>
    <tr><td class="paramname">isoValue</td><td>A value which defines a smooth iso-surface that intersects active voxels in <em class="arg">sdfGrid</em>.</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
    <tr><td class="paramname">mode</td><td>Determines the mode of updating the extension field. SWEEP_ALL will update all voxels of the extension field affected by the fast sweeping algorithm. SWEEP_GREATER_THAN_ISOVALUE will update all voxels corresponding to level set values that are greater than a given isovalue. SWEEP_LESS_THAN_ISOVALUE will update all voxels corresponding to level set values that are less than a given isovalue. If a mode other than SWEEP_ALL is chosen, a user needs to supply <em class="arg">extGrid</em>.</td></tr>
    <tr><td class="paramname">extGrid</td><td>Optional parameter required to supply a default value for the extension field when SWEEP_GREATER_THAN_ISOVALUE or SWEEP_LESS_THAN_ISOVALUE mode is picked for <em class="arg">mode</em>. When SWEEP_GREATER_THAN_ISOVALUE is supplied as an argument for <em class="arg">mode</em>, the extension field voxel will default to the value of the <em class="arg">extGrid</em> in that position if it corresponds to a level-set value that is less than the isovalue. Otherwise, the extension field voxel value will be computed by the Fast Sweeping algorithm. The opposite convention is implemented when SWEEP_LESS_THAN_ISOVALUE is supplied as an argument for <em class="arg">mode</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The only difference between this method and fogToExt, defined above, is the convention of the sign of the signed distance field.</dd></dl>
<p>Topology of output grid is identical to that of the input grid, except active tiles in the input grid will be converted to active voxels in the output grid!</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em class="arg">isoValue</em> does not intersect any active values in <em class="arg">sdfGrid</em> then the returned grid has all its active values set to <em class="arg">background</em>. </dd></dl>

</div>
</div>
<a id="aebd5f9aa2d3c6e190a88f46e43590105" name="aebd5f9aa2d3c6e190a88f46e43590105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd5f9aa2d3c6e190a88f46e43590105">&#9670;&#160;</a></span>sdfToExt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SdfGridT, typename OpT, typename ExtValueT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr sdfToExt </td>
          <td>(</td>
          <td class="paramtype">const SdfGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>sdfGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OpT &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtValueT &amp;</td>          <td class="paramname"><span class="paramname"><em>background</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename SdfGridT::ValueType</td>          <td class="paramname"><span class="paramname"><em>isoValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nIter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bf">FastSweepingDomain</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::ConstPtr</td>          <td class="paramname"><span class="paramname"><em>extGrid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a392050cd0aa310bd6dc02ff96a23f07c" name="a392050cd0aa310bd6dc02ff96a23f07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392050cd0aa310bd6dc02ff96a23f07c">&#9670;&#160;</a></span>sdfToFogVolume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OPENVDB_DOCS_INTERNAL void sdfToFogVolume </td>
          <td>(</td>
          <td class="paramtype">GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridType::ValueType</td>          <td class="paramname"><span class="paramname"><em>cutoffDistance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">lsutilGridMax&lt;&#160;GridType&#160;&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Threaded method to convert a sparse level set/SDF into a sparse fog volume. </p>
<p>For a level set, the active and negative-valued interior half of the narrow band becomes a linear ramp from 0 to 1; the inactive interior becomes active with a constant value of 1; and the exterior, including the background and the active exterior half of the narrow band, becomes inactive with a constant value of 0. The interior, though active, remains sparse.</p>
<p>For a generic SDF, a specified cutoff distance determines the width of the ramp, but otherwise the result is the same as for a level set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>level set/SDF grid to transform </td></tr>
    <tr><td class="paramname">cutoffDistance</td><td>optional world space cutoff distance for the ramp (automatically clamped if greater than the interior narrow band width) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad82d1b0039598209bc21cd9aa4511a0" name="aad82d1b0039598209bc21cd9aa4511a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad82d1b0039598209bc21cd9aa4511a0">&#9670;&#160;</a></span>sdfToFogVolume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sdfToFogVolume </td>
          <td>(</td>
          <td class="paramtype">GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridType::ValueType</td>          <td class="paramname"><span class="paramname"><em>cutoffDistance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">lsutilGridMax&lt;&#160;GridType&#160;&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Threaded method to convert a sparse level set/SDF into a sparse fog volume. </p>
<p>For a level set, the active and negative-valued interior half of the narrow band becomes a linear ramp from 0 to 1; the inactive interior becomes active with a constant value of 1; and the exterior, including the background and the active exterior half of the narrow band, becomes inactive with a constant value of 0. The interior, though active, remains sparse.</p>
<p>For a generic SDF, a specified cutoff distance determines the width of the ramp, but otherwise the result is the same as for a level set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>level set/SDF grid to transform </td></tr>
    <tr><td class="paramname">cutoffDistance</td><td>optional world space cutoff distance for the ramp (automatically clamped if greater than the interior narrow band width) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ec6859a45f6b4fa6c0beb9687eabacd" name="a5ec6859a45f6b4fa6c0beb9687eabacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec6859a45f6b4fa6c0beb9687eabacd">&#9670;&#160;</a></span>sdfToSdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr sdfToSdf </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>sdfGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename GridT::ValueType</td>          <td class="paramname"><span class="paramname"><em>isoValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nIter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an existing approximate SDF it solves the Eikonal equation for all its active voxels. Active input voxels with a signed distance value above the given isoValue will have POSITIVE distance values on output, i.e. they are assumed to be OUTSIDE the iso-surface. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a signed-distance field defined on the active values of the input sdf volume.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdfGrid</td><td>An approximate signed distance field to the specified iso-surface.</td></tr>
    <tr><td class="paramname">isoValue</td><td>A value which defines a smooth iso-surface that intersects active voxels in <em class="arg">sdfGrid</em>.</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The only difference between this method and fogToSdf, defined above, is the convention of the sign of the output distance field.</dd></dl>
<p>Topology of output grid is identical to that of the input grid, except active tiles in the input grid will be converted to active voxels in the output grid!</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em class="arg">isoValue</em> does not intersect any active values in <em class="arg">sdfGrid</em> then the returned grid has all its active values set to plus or minus infinity, depending on if the input values are larger or smaller than <em class="arg">isoValue</em>. </dd></dl>

</div>
</div>
<a id="a27d97ccaebf36560da30e5c9c5389d48" name="a27d97ccaebf36560da30e5c9c5389d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d97ccaebf36560da30e5c9c5389d48">&#9670;&#160;</a></span>sdfToSdfAndExt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SdfGridT, typename ExtOpT, typename ExtValueT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename SdfGridT::Ptr, typename SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::Ptr &gt; sdfToSdfAndExt </td>
          <td>(</td>
          <td class="paramtype">const SdfGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>sdfGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtOpT &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExtValueT &amp;</td>          <td class="paramname"><span class="paramname"><em>background</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename SdfGridT::ValueType</td>          <td class="paramname"><span class="paramname"><em>isoValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nIter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bf">FastSweepingDomain</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a6416fa916f48d91455ce7bad5b0a33bfa3203264a0a3fd2d90d15ee76eeb62f40">FastSweepingDomain::SWEEP_ALL</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SdfGridT::template ValueConverter&lt; ExtValueT &gt;::Type::ConstPtr</td>          <td class="paramname"><span class="paramname"><em>extGrid</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the signed distance field and the extension of a field (scalar, vector, or int are supported), defined by the specified functor, off an iso-surface from an input SDF volume. </p>
<dl class="section return"><dt>Returns</dt><dd>A pair of two shared pointers to respectively the SDF and extension field</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sdfGrid</td><td>Scalar (floating-point) volume from which an iso-surface can be defined.</td></tr>
    <tr><td class="paramname">op</td><td>Functor with signature [](const <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab8753c49a176ce809a70ac12896682e3">Vec3R</a> &amp;xyz)-&gt;ExtValueT that defines the Dirichlet boundary condition, on the iso-surface, of the field to be extended.</td></tr>
    <tr><td class="paramname">background</td><td>Background value of return grid with the extension field.</td></tr>
    <tr><td class="paramname">isoValue</td><td>A value which defines a smooth iso-surface that intersects active voxels in <em class="arg">sdfGrid</em>.</td></tr>
    <tr><td class="paramname">nIter</td><td>Number of iterations of the fast sweeping algorithm. Each iteration performs 2^3 = 8 individual sweeps.</td></tr>
    <tr><td class="paramname">mode</td><td>Determines the mode of updating the extension field. SWEEP_ALL will update all voxels of the extension field affected by the fast sweeping algorithm. SWEEP_GREATER_THAN_ISOVALUE will update all voxels corresponding to level set values that are greater than a given isovalue. SWEEP_LESS_THAN_ISOVALUE will update all voxels corresponding to level set values that are less than a given isovalue. If a mode other than SWEEP_ALL is chosen, a user needs to supply <em class="arg">extGrid</em>.</td></tr>
    <tr><td class="paramname">extGrid</td><td>Optional parameter required to supply a default value for the extension field when SWEEP_GREATER_THAN_ISOVALUE or SWEEP_LESS_THAN_ISOVALUE mode is picked for <em class="arg">mode</em>. When SWEEP_GREATER_THAN_ISOVALUE is supplied as an argument for <em class="arg">mode</em>, the extension field voxel will default to the value of the <em class="arg">extGrid</em> in that position if it corresponds to a level-set value that is less than the isovalue. Otherwise, the extension field voxel value will be computed by the Fast Sweeping algorithm. The opposite convention is implemented when SWEEP_LESS_THAN_ISOVALUE is supplied as an argument for <em class="arg">mode</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Strictly speaking a fog volume is normalized to the range [0,1] but this method accepts a scalar volume with an arbritary range, as long as the it includes the <em class="arg">isoValue</em>.</dd></dl>
<p>Topology of output grids are identical to that of the input grid, except active tiles in the input grid will be converted to active voxels in the output grids!</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em class="arg">isoValue</em> does not intersect any active values in <em class="arg">sdfGrid</em> then a pair of the following grids is returned: The first is a signed distance grid with its active values set to plus or minus infinity depending of whether its input values are above or below <em class="arg">isoValue</em>. The second grid, which represents the extension field, has all its active values set to <em class="arg">background</em>. </dd></dl>

</div>
</div>
<a id="a1cc2d4f60d561afd2fb248e386ca67d8" name="a1cc2d4f60d561afd2fb248e386ca67d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc2d4f60d561afd2fb248e386ca67d8">&#9670;&#160;</a></span>segmentActiveVoxels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void segmentActiveVoxels </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeType &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename GridOrTreeType::Ptr &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>segments</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separates disjoint active topology components into distinct grids or trees. </p>
<p>Supports volumes with active tiles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>Input grid or tree </td></tr>
    <tr><td class="paramname">segments</td><td>Output set of disjoint active topology components sorted in descendingorder based on the active voxel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9f4df82ed92eb746d439ce4721ea8a5" name="ac9f4df82ed92eb746d439ce4721ea8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f4df82ed92eb746d439ce4721ea8a5">&#9670;&#160;</a></span>segmentSDF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridOrTreeType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void segmentSDF </td>
          <td>(</td>
          <td class="paramtype">const GridOrTreeType &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename GridOrTreeType::Ptr &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>segments</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separates disjoint SDF surfaces into distinct grids or trees. </p>
<p>Supports asymmetric interior / exterior narrowband widths and SDF volumes with dense interior regions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>Input signed distance field / level set volume </td></tr>
    <tr><td class="paramname">segments</td><td>Output set of disjoint SDF surfaces found in <em class="arg">volume</em> sorted in descendingorder based on the surface intersecting voxel count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c76dc587d3f1735c0113f04ace2f257" name="a7c76dc587d3f1735c0113f04ace2f257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c76dc587d3f1735c0113f04ace2f257">&#9670;&#160;</a></span>setValueOnMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnMax </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates in <em class="arg">tree</em> to the maximum of its current value and <em class="arg">value</em>, and mark the voxel as active. </p>
<p>This is typically significantly faster than calling getValue() followed by setValueOn(). </p><dl class="section note"><dt>Note</dt><dd><em class="arg">TreeT</em> can be either a Tree or a ValueAccessor. </dd></dl>

</div>
</div>
<a id="adbdcf782cb40fcb514524737e2f8e070" name="adbdcf782cb40fcb514524737e2f8e070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbdcf782cb40fcb514524737e2f8e070">&#9670;&#160;</a></span>setValueOnMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnMin </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates in <em class="arg">tree</em> to the minimum of its current value and <em class="arg">value</em>, and mark the voxel as active. </p>
<p>This is typically significantly faster than calling getValue() followed by setValueOn(). </p><dl class="section note"><dt>Note</dt><dd><em class="arg">TreeT</em> can be either a Tree or a ValueAccessor. </dd></dl>

</div>
</div>
<a id="a2fa019501d9dddd1891421935c31efba" name="a2fa019501d9dddd1891421935c31efba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa019501d9dddd1891421935c31efba">&#9670;&#160;</a></span>setValueOnMult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnMult </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates in <em class="arg">tree</em> to the product of its current value and <em class="arg">value</em>, and mark the voxel as active. </p>
<p>This is typically significantly faster than calling getValue() followed by setValueOn(). </p><dl class="section note"><dt>Note</dt><dd><em class="arg">TreeT</em> can be either a Tree or a ValueAccessor. </dd></dl>

</div>
</div>
<a id="a92d1e43e1896e1a7fa9548c4fd4a2988" name="a92d1e43e1896e1a7fa9548c4fd4a2988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d1e43e1896e1a7fa9548c4fd4a2988">&#9670;&#160;</a></span>setValueOnSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnSum </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeT::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates in <em class="arg">tree</em> to the sum of its current value and <em class="arg">value</em>, and mark the voxel as active. </p>
<p>This is typically significantly faster than calling getValue() followed by setValueOn(). </p><dl class="section note"><dt>Note</dt><dd><em class="arg">TreeT</em> can be either a Tree or a ValueAccessor. </dd></dl>

</div>
</div>
<a id="ab8c1921d688e3c65c71aac5405f155a9" name="ab8c1921d688e3c65c71aac5405f155a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c1921d688e3c65c71aac5405f155a9">&#9670;&#160;</a></span>signedFloodFill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeOrLeafManagerT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void signedFloodFill </td>
          <td>(</td>
          <td class="paramtype">TreeOrLeafManagerT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>minLevel</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the values of all inactive voxels and tiles of a narrow-band level set from the signs of the active voxels, setting outside values to +background and inside values to -background. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method should only be used on closed, symmetric narrow-band level sets.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If a LeafManager is used the cached leaf nodes are reused, resulting in slightly better overall performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree or LeafManager that will be flood filled. </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1) </td></tr>
    <tr><td class="paramname">minLevel</td><td>Specify the lowest tree level to process (leafnode level = 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if the ValueType of <em class="arg">tree</em> is not floating-point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a059130a68dd01092e7db04afa0f2580e" name="a059130a68dd01092e7db04afa0f2580e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059130a68dd01092e7db04afa0f2580e">&#9670;&#160;</a></span>signedFloodFillWithValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeOrLeafManagerT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void signedFloodFillWithValues </td>
          <td>(</td>
          <td class="paramtype">TreeOrLeafManagerT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeOrLeafManagerT::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>outsideWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename TreeOrLeafManagerT::ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>insideWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>grainSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a></td>          <td class="paramname"><span class="paramname"><em>minLevel</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the values of all inactive voxels and tiles of a narrow-band level set from the signs of the active voxels, setting exterior values to <em class="arg">outsideWidth</em> and interior values to <em class="arg">insideWidth</em>. Set the background value of this tree to <em class="arg">outsideWidth</em>. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method should only be used on closed, narrow-band level sets.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If a LeafManager is used the cached leaf nodes are reused resulting in slightly better overall performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>Tree or LeafManager that will be flood filled </td></tr>
    <tr><td class="paramname">outsideWidth</td><td>the width of the outside of the narrow band </td></tr>
    <tr><td class="paramname">insideWidth</td><td>the width of the inside of the narrow band </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
    <tr><td class="paramname">grainSize</td><td>used to control the threading granularity (default is 1) </td></tr>
    <tr><td class="paramname">minLevel</td><td>Specify the lowest tree level to process (leafnode level = 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if the ValueType of <em class="arg">tree</em> is not floating-point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0298e9e5b5b3a443d321bd24825f1d5a" name="a0298e9e5b5b3a443d321bd24825f1d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0298e9e5b5b3a443d321bd24825f1d5a">&#9670;&#160;</a></span>statistics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html">math::Stats</a> statistics </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over a scalar grid and compute statistics (mean, variance, etc.) of the values of the voxels that are visited, or iterate over a vector-valued grid and compute statistics of the magnitudes of the vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over the values of a grid or its tree (<code><a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::ValueOffIter</code>, etc.) </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, iterate over the grid in parallel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada341f0cb3d7e02cb30f563ae58d77b8" name="ada341f0cb3d7e02cb30f563ae58d77b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada341f0cb3d7e02cb30f563ae58d77b8">&#9670;&#160;</a></span>statistics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterT, typename ValueOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html">math::Stats</a> statistics </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;</td>          <td class="paramname"><span class="paramname"><em>iter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over a grid and compute statistics (mean, variance, etc.) of the values produced by applying the given functor at each voxel that is visited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>an iterator over the values of a grid or its tree (<code><a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::ValueOffIter</code>, etc.) </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <span class="tt">void op(const IterT&amp;, math::Stats&amp;)</span>, where <code>IterT</code> is the type of <em class="arg">iter</em>, that inserts zero or more floating-point values into the provided <code><a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html" title="This class computes statistics (minimum value, maximum value, mean, variance and standard deviation) ...">math::Stats</a></code> object </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, iterate over the grid in parallel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When <em class="arg">threaded</em> is true, each thread gets its own copy of the functor.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd>Compute statistics of just the active and positive-valued voxels of a scalar, floating-point grid. <div class="fragment"><div class="line"><span class="keyword">struct </span>Local {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span></div>
<div class="line">    <span class="keywordtype">void</span> addIfPositive(<span class="keyword">const</span> <a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">FloatGrid::ValueOnCIter</a>&amp; iter, <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html">math::Stats</a>&amp; stats)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> f = *iter;</div>
<div class="line">        <span class="keywordflow">if</span> (f &gt; 0.0) {</div>
<div class="line">            <span class="keywordflow">if</span> (iter.isVoxelValue()) stats.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html#a1c762a4059fc92d21d53c05f268227b1">add</a>(f);</div>
<div class="line">            <span class="keywordflow">else</span> stats.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Stats.html#a1c762a4059fc92d21d53c05f268227b1">add</a>(f, iter.getVoxelCount());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> grid = ...;</div>
<div class="line">math::Stats stats =</div>
<div class="line">    <a class="code hl_function" href="#a0298e9e5b5b3a443d321bd24825f1d5a">tools::statistics</a>(grid.cbeginValueOn(), Local::addIfPositive, <span class="comment">/*threaded=*/</span><span class="keyword">true</span>);</div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tools_html_a0298e9e5b5b3a443d321bd24825f1d5a"><div class="ttname"><a href="#a0298e9e5b5b3a443d321bd24825f1d5a">openvdb::v13_0::tools::statistics</a></div><div class="ttdeci">math::Stats statistics(const IterT &amp;iter, bool threaded=true)</div><div class="ttdoc">Iterate over a scalar grid and compute statistics (mean, variance, etc.) of the values of the voxels ...</div><div class="ttdef"><b>Definition</b> Statistics.h:362</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aabbae85c9cdcbfc824ca7222995f16ca" name="aabbae85c9cdcbfc824ca7222995f16ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbae85c9cdcbfc824ca7222995f16ca">&#9670;&#160;</a></span>topologyToLevelSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridT::template ValueConverter&lt; float &gt;::Type::Ptr topologyToLevelSet </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>closingSteps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dilation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>smoothingSteps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the narrow-band signed distance to the interface between active and inactive voxels in the input grid. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new sdf / level set grid of type <code>float</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>Input grid of arbitrary type whose active voxels are used in constructing the level set. </td></tr>
    <tr><td class="paramname">halfWidth</td><td><a class="el" href="namespaceopenvdb_1_1v13__0.html#a22a8e71efc9fdc0f1f152e647c13be9d">Half</a> the width of the narrow band in voxel units. </td></tr>
    <tr><td class="paramname">closingSteps</td><td>Number of morphological closing steps used to fill gaps in the active voxel region. </td></tr>
    <tr><td class="paramname">dilation</td><td>Number of voxels to expand the active voxel region. </td></tr>
    <tr><td class="paramname">smoothingSteps</td><td>Number of smoothing interations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07e2f42e7a8c6243963b70dece2f8113" name="a07e2f42e7a8c6243963b70dece2f8113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e2f42e7a8c6243963b70dece2f8113">&#9670;&#160;</a></span>topologyToLevelSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridT, typename InterrupterT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GridT::template ValueConverter&lt; float &gt;::Type::Ptr topologyToLevelSet </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>halfWidth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>closingSteps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dilation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>smoothingSteps</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *</td>          <td class="paramname"><span class="paramname"><em>interrupt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the narrow-band signed distance to the interface between active and inactive voxels in the input grid. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new sdf / level set grid of type <code>float</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>Input grid of arbitrary type whose active voxels are used in constructing the level set. </td></tr>
    <tr><td class="paramname">halfWidth</td><td><a class="el" href="namespaceopenvdb_1_1v13__0.html#a22a8e71efc9fdc0f1f152e647c13be9d">Half</a> the width of the narrow band in voxel units. </td></tr>
    <tr><td class="paramname">closingSteps</td><td>Number of morphological closing steps used to fill gaps in the active voxel region. </td></tr>
    <tr><td class="paramname">dilation</td><td>Number of voxels to expand the active voxel region. </td></tr>
    <tr><td class="paramname">smoothingSteps</td><td>Number of smoothing interations. </td></tr>
    <tr><td class="paramname">interrupt</td><td>Optional object adhering to the <a class="el" href="structopenvdb_1_1v13__0_1_1util_1_1NullInterrupter.html" title="Base class for interrupters.">util::NullInterrupter</a> interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c971c289dca66c2e8500e01aac41bdf" name="a5c971c289dca66c2e8500e01aac41bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c971c289dca66c2e8500e01aac41bdf">&#9670;&#160;</a></span>traceExteriorBoundaries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FloatTreeT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void traceExteriorBoundaries </td>
          <td>(</td>
          <td class="paramtype">FloatTreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traces the exterior voxel boundary of closed objects in the input volume <em class="arg">tree</em>. Exterior voxels are marked with a negative sign, voxels with a value below <code>0.75</code> are left unchanged and act as the boundary layer. </p>
<dl class="section note"><dt>Note</dt><dd>Does not propagate sign information into tile regions. </dd></dl>

</div>
</div>
<a id="a920d389abe08e3a0f9638390702e370a" name="a920d389abe08e3a0f9638390702e370a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920d389abe08e3a0f9638390702e370a">&#9670;&#160;</a></span>transformDense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, typename OpType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void transformDense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Dense.html">Dense</a>&lt; ValueT, openvdb::tools::LayoutZYX &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dense</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">openvdb::CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OpType &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>parallel</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a point-wise functor to the intersection of a dense grid and a given bounding box </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dense</td><td>A dense grid to be transformed </td></tr>
    <tr><td class="paramname">bbox</td><td><a class="el" href="namespaceopenvdb_1_1v13__0.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> space bounding box, define region where the transformation is applied </td></tr>
    <tr><td class="paramname">op</td><td>A functor that acts on the dense grid value type </td></tr>
    <tr><td class="paramname">parallel</td><td>Used to select multithreaded or single threaded Minimally, the <code>op</code> class has to support a <code>operator()</code> method, <div class="fragment"><div class="line"><span class="comment">// Square values in a grid</span></div>
<div class="line"><span class="keyword">struct </span>Op</div>
<div class="line">{</div>
<div class="line">    ValueT operator()(<span class="keyword">const</span> ValueT&amp; in)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="comment">// do work</span></div>
<div class="line">      ValueT result = in * in;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --> NB: only <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Dense.html" title="Dense is a simple dense grid API used by the CopyToDense and CopyFromDense classes defined below.">Dense</a> grids with memory layout zxy are supported </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26f3ee890378845af008e8acfb9783fd" name="a26f3ee890378845af008e8acfb9783fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f3ee890378845af008e8acfb9783fd">&#9670;&#160;</a></span>transformDense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT, typename PointwiseOpT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void transformDense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1Dense.html">Dense</a>&lt; ValueT, openvdb::tools::LayoutZYX &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dense</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">openvdb::CoordBBox</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bbox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointwiseOpT &amp;</td>          <td class="paramname"><span class="paramname"><em>functor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>parallel</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a point-wise functor to the intersection of a dense grid and a given bounding box. </p>

</div>
</div>
<a id="ac86a388007dc41bc538d796f34047d45" name="ac86a388007dc41bc538d796f34047d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86a388007dc41bc538d796f34047d45">&#9670;&#160;</a></span>transformValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InIterT, typename OutGridT, typename XformOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">undefined void transformValues </td>
          <td>(</td>
          <td class="paramtype">const InIterT &amp;</td>          <td class="paramname"><span class="paramname"><em>inIter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>outGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XformOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>shareOp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ade9c95ac55c647839e6f3e9b462c0575">MergePolicy</a></td>          <td class="paramname"><span class="paramname"><em>merge</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ade9c95ac55c647839e6f3e9b462c0575a89c44945b26534bc1d5ede51c342400e">MERGE_ACTIVE_STATES</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7aba10043b96fad10e7d79a26de0bd0" name="ae7aba10043b96fad10e7d79a26de0bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7aba10043b96fad10e7d79a26de0bd0">&#9670;&#160;</a></span>transformValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InIterT, typename OutGridT, typename XformOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">undefined void transformValues </td>
          <td>(</td>
          <td class="paramtype">const InIterT &amp;</td>          <td class="paramname"><span class="paramname"><em>inIter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutGridT &amp;</td>          <td class="paramname"><span class="paramname"><em>outGrid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XformOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>threaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>shareOp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ade9c95ac55c647839e6f3e9b462c0575">MergePolicy</a></td>          <td class="paramname"><span class="paramname"><em>merge</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespaceopenvdb_1_1v13__0.html#ade9c95ac55c647839e6f3e9b462c0575a89c44945b26534bc1d5ede51c342400e">MERGE_ACTIVE_STATES</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over a grid and at each step call <span class="tt">op(iter, accessor)</span> to populate (via the accessor) the given output grid, whose <code>ValueType</code> need not be the same as the input grid's. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inIter</td><td>a non-<span class="tt">const</span> or (preferably) <code>const</code> iterator over an input grid or its tree (<code><a class="el" href="classopenvdb_1_1v13__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Grid::ValueOnCIter</a></code>, <code>Tree::NodeIter</code>, etc.) </td></tr>
    <tr><td class="paramname">outGrid</td><td>an empty grid to be populated </td></tr>
    <tr><td class="paramname">op</td><td>a functor of the form <span class="tt">void op(const InIterT&amp;, OutGridT::ValueAccessor&amp;)</span>, where <code>InIterT</code> is the type of <em class="arg">inIter</em> </td></tr>
    <tr><td class="paramname">threaded</td><td>if true, transform multiple values of the input grid in parallel </td></tr>
    <tr><td class="paramname">shareOp</td><td>if true and <em class="arg">threaded</em> is true, all threads use the same functor; otherwise, each thread gets its own copy of the <em>original</em> functor </td></tr>
    <tr><td class="paramname">merge</td><td>how to merge intermediate results from multiple threads (see Types.h)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd>Populate a scalar floating-point grid with the lengths of the vectors from all active voxels of a vector-valued input grid. <div class="fragment"><div class="line"><span class="keyword">struct </span>Local {</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> op(</div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_typedef" href="classopenvdb_1_1v13__0_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">Vec3fGrid::ValueOnCIter</a>&amp; iter,</div>
<div class="line">        FloatGrid::ValueAccessor&amp; accessor)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (iter.isVoxelValue()) { <span class="comment">// set a single voxel</span></div>
<div class="line">            accessor.setValue(iter.getCoord(), iter-&gt;length());</div>
<div class="line">        } <span class="keywordflow">else</span> { <span class="comment">// fill an entire tile</span></div>
<div class="line">            <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">CoordBBox</a> bbox;</div>
<div class="line">            iter.getBoundingBox(bbox);</div>
<div class="line">            accessor.getTree()-&gt;fill(bbox, iter-&gt;length());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0.html#a58332e5bdbbdb5a926507027db318e5b">Vec3fGrid</a> inGrid = ...;</div>
<div class="line"><a class="code hl_typedef" href="namespaceopenvdb_1_1v13__0.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> outGrid;</div>
<div class="line"><a class="code hl_function" href="#ae7aba10043b96fad10e7d79a26de0bd0">tools::transformValues</a>(inGrid.cbeginValueOn(), outGrid, Local::op);</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1CoordBBox_html"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">openvdb::v13_0::math::CoordBBox</a></div><div class="ttdoc">Axis-aligned bounding box of signed integer coordinates.</div><div class="ttdef"><b>Definition</b> Coord.h:252</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tools_html_ae7aba10043b96fad10e7d79a26de0bd0"><div class="ttname"><a href="#ae7aba10043b96fad10e7d79a26de0bd0">openvdb::v13_0::tools::transformValues</a></div><div class="ttdeci">undefined void transformValues(const InIterT &amp;inIter, OutGridT &amp;outGrid, XformOp &amp;op, bool threaded=true, bool shareOp=true, MergePolicy merge=MERGE_ACTIVE_STATES)</div><div class="ttdoc">Iterate over a grid and at each step call op(iter, accessor) to populate (via the accessor) the given...</div><div class="ttdef"><b>Definition</b> ValueTransformer.h:591</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_html_a58332e5bdbbdb5a926507027db318e5b"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0.html#a58332e5bdbbdb5a926507027db318e5b">openvdb::v13_0::Vec3fGrid</a></div><div class="ttdeci">Vec3SGrid Vec3fGrid</div><div class="ttdef"><b>Definition</b> openvdb.h:87</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>For more complex operations that require finer control over threading, consider using <code>tbb::parallel_for()</code> or <code>tbb::parallel_reduce()</code> in conjunction with a <a class="el" href="classopenvdb_1_1v13__0_1_1tree_1_1IteratorRange.html">tree::IteratorRange</a> that wraps a grid or tree iterator. </dd></dl>

</div>
</div>
<a id="a642190ccc3febe94d8b07ac37f892349" name="a642190ccc3febe94d8b07ac37f892349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642190ccc3febe94d8b07ac37f892349">&#9670;&#160;</a></span>transformVectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void transformVectors </td>
          <td>(</td>
          <td class="paramtype">GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#abaf7f913bf1752b9157259ffa32704ca">Mat4d</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply an affine transform to the voxel values of a vector-valued grid in accordance with the grid's vector type (covariant, contravariant, etc.). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if the grid is not vector-valued </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a136006bbdda1e616071dba827c34be79" name="a136006bbdda1e616071dba827c34be79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136006bbdda1e616071dba827c34be79">&#9670;&#160;</a></span>uniqueInactiveValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool uniqueInactiveValues </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename GridType::ValueType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numValues</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Threaded method to find unique inactive values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>A VDB volume. </td></tr>
    <tr><td class="paramname">values</td><td>List of unique inactive values, returned by this method. </td></tr>
    <tr><td class="paramname">numValues</td><td>Number of values to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the <em class="arg">grid</em> has more than <em class="arg">numValues</em> inactive values. </dd></dl>

</div>
</div>
<a id="ac3d8c9dd7eda32f2e44bbcdef93457bd" name="ac3d8c9dd7eda32f2e44bbcdef93457bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d8c9dd7eda32f2e44bbcdef93457bd">&#9670;&#160;</a></span>visitNodesDepthFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TreeT, typename OpT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t visitNodesDepthFirst </td>
          <td>(</td>
          <td class="paramtype">TreeT &amp;</td>          <td class="paramname"><span class="paramname"><em>tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OpT &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visit all nodes in the tree depth-first and apply a user-supplied functor to each node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>tree to be visited. </td></tr>
    <tr><td class="paramname">op</td><td>user-supplied functor, see examples for interface details. </td></tr>
    <tr><td class="paramname">idx</td><td>optional offset to start sequential node indexing from a non-zero index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is single-threaded. Use the NodeManager or DynamicNodeManager for much greater threaded performance.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">Functor to offset all the active values of a <a class="code hl_namespace" href="namespaceopenvdb_1_1v13__0_1_1tree.html">tree</a>.</div>
<div class="line">struct OffsetOp</div>
<div class="line">{</div>
<div class="line">    OffsetOp(<span class="keywordtype">float</span> v): <a class="code hl_variable" href="#a5844baaab66cb9519db44a85d8cc0fd7">mOffset</a>(v) { }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> NodeT&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(NodeT&amp; node, <span class="keywordtype">size_t</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> iter = node.beginValueOn(); iter; ++iter) {</div>
<div class="line">            iter.setValue(iter.getValue() + <a class="code hl_variable" href="#a5844baaab66cb9519db44a85d8cc0fd7">mOffset</a>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> <a class="code hl_variable" href="#a5844baaab66cb9519db44a85d8cc0fd7">mOffset</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// usage:</span></div>
<div class="line">OffsetOp op(3.0f);</div>
<div class="line"><a class="code hl_function" href="#ac3d8c9dd7eda32f2e44bbcdef93457bd">visitNodesDepthFirst</a>(tree, op);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Functor to offset all the active values of a tree. Note</span></div>
<div class="line"><span class="comment">// this implementation also illustrates how different</span></div>
<div class="line"><span class="comment">// computation can be applied to the different node types.</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TreeT&gt;</div>
<div class="line"><span class="keyword">struct </span>OffsetByLevelOp</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>ValueT = <span class="keyword">typename</span> TreeT::ValueType;</div>
<div class="line">    <span class="keyword">using </span>RootT = <span class="keyword">typename</span> TreeT::RootNodeType;</div>
<div class="line">    <span class="keyword">using </span>LeafT = <span class="keyword">typename</span> TreeT::LeafNodeType;</div>
<div class="line">    OffsetByLevelOp(<span class="keyword">const</span> ValueT&amp; v) : mOffset(v) {}</div>
<div class="line">    <span class="comment">// Processes the root node.</span></div>
<div class="line">    <span class="keywordtype">void</span> operator()(RootT&amp; root, <span class="keywordtype">size_t</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> iter = root.beginValueOn(); iter; ++iter) {</div>
<div class="line">            iter.setValue(iter.getValue() + mOffset);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Processes the leaf nodes.</span></div>
<div class="line">    <span class="keywordtype">void</span> operator()(LeafT&amp; leaf, <span class="keywordtype">size_t</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> iter = leaf.beginValueOn(); iter; ++iter) {</div>
<div class="line">            iter.setValue(iter.getValue() + mOffset);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Processes the internal nodes.</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> NodeT&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(NodeT&amp; node, <span class="keywordtype">size_t</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> iter = node.beginValueOn(); iter; ++iter) {</div>
<div class="line">            iter.setValue(iter.getValue() + mOffset);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">const</span> ValueT mOffset;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// usage:</span></div>
<div class="line">OffsetByLevelOp&lt;FloatTree&gt; op(3.0f);</div>
<div class="line"><a class="code hl_function" href="#ac3d8c9dd7eda32f2e44bbcdef93457bd">visitNodesDepthFirst</a>(tree, op);</div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tools_html_a5844baaab66cb9519db44a85d8cc0fd7"><div class="ttname"><a href="#a5844baaab66cb9519db44a85d8cc0fd7">openvdb::v13_0::tools::mOffset</a></div><div class="ttdeci">const Coord FastSweeping&lt; SdfGridT, ExtValueT &gt;::mOffset[6]</div><div class="ttdef"><b>Definition</b> FastSweeping.h:714</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tools_html_ac3d8c9dd7eda32f2e44bbcdef93457bd"><div class="ttname"><a href="#ac3d8c9dd7eda32f2e44bbcdef93457bd">openvdb::v13_0::tools::visitNodesDepthFirst</a></div><div class="ttdeci">size_t visitNodesDepthFirst(TreeT &amp;tree, OpT &amp;op, size_t idx=0)</div><div class="ttdoc">Visit all nodes in the tree depth-first and apply a user-supplied functor to each node.</div><div class="ttdef"><b>Definition</b> NodeVisitor.h:229</div></div>
<div class="ttc" id="anamespaceopenvdb_1_1v13__0_1_1tree_html"><div class="ttname"><a href="namespaceopenvdb_1_1v13__0_1_1tree.html">openvdb::v13_0::tree</a></div><div class="ttdef"><b>Definition</b> PointDataGrid.h:170</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Here is an example when migrating from using the deprecated Tree::visit()</dt><dd>method. The main difference between the Tree::visit() method and this new method is that the Tree::visit() method expected an object that can visit tiles, values and nodes. In contrast, the <a class="el" href="#ac3d8c9dd7eda32f2e44bbcdef93457bd" title="Visit all nodes in the tree depth-first and apply a user-supplied functor to each node.">visitNodesDepthFirst()</a> method visits only nodes and expects you to provide iteration over tiles and voxels.</dd></dl>
<dl class="section user"><dt>Tree::visit() operator methods:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</div>
<div class="line"><span class="keywordtype">bool</span> operator()(IterT &amp;iter)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typename</span> IterT::NonConstValueType value;</div>
<div class="line">    <span class="keyword">typename</span> IterT::ChildNodeType *child = iter.probeChild(value);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (child)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// If it is a leaf, process it now</span></div>
<div class="line">        <span class="keywordflow">if</span> (child-&gt;getLevel() == 0)</div>
<div class="line">        {</div>
<div class="line">            processNode(*child);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Otherwise, we want to keep digging down</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// No child, this is a constant node!</span></div>
<div class="line">    <span class="keywordflow">if</span> (iter.isValueOn())</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">openvdb::CoordBBox</a>  b;</div>
<div class="line">        b.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html#a7132dc61617b69ed3c447021b1f7c12c">min</a>() = iter.getCoord();</div>
<div class="line">        b.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html#a773a39c4785388b82551df3cfaee2fd1">max</a>() = b.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html#a7132dc61617b69ed3c447021b1f7c12c">min</a>().<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html#a346f761fd6ac48d8804f6b77fcc7026b">offsetBy</a>(IterT::ChildNodeType::DIM);</div>
<div class="line"> </div>
<div class="line">        processNodeBlock(b);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// No need to dig further as there is no child.</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> operator()(<span class="keyword">typename</span> GridType::TreeType::LeafNodeType::ChildAllIter &amp;)</div>
<div class="line">{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line"><span class="keywordtype">bool</span> operator()(<span class="keyword">typename</span> GridType::TreeType::LeafNodeType::ChildAllCIter &amp;)</div>
<div class="line">{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1CoordBBox_html_a7132dc61617b69ed3c447021b1f7c12c"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html#a7132dc61617b69ed3c447021b1f7c12c">openvdb::v13_0::math::CoordBBox::min</a></div><div class="ttdeci">const Coord &amp; min() const</div><div class="ttdef"><b>Definition</b> Coord.h:324</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1CoordBBox_html_a773a39c4785388b82551df3cfaee2fd1"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html#a773a39c4785388b82551df3cfaee2fd1">openvdb::v13_0::math::CoordBBox::max</a></div><div class="ttdeci">const Coord &amp; max() const</div><div class="ttdef"><b>Definition</b> Coord.h:325</div></div>
<div class="ttc" id="aclassopenvdb_1_1v13__0_1_1math_1_1Coord_html_a346f761fd6ac48d8804f6b77fcc7026b"><div class="ttname"><a href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html#a346f761fd6ac48d8804f6b77fcc7026b">openvdb::v13_0::math::Coord::offsetBy</a></div><div class="ttdeci">Coord offsetBy(Int32 dx, Int32 dy, Int32 dz) const</div><div class="ttdef"><b>Definition</b> Coord.h:92</div></div>
</div><!-- fragment --><dl class="section user"><dt>tools::visitNodesDepthFirst() operator methods:</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">using </span>LeafT = <span class="keyword">typename</span> GridType::TreeType::LeafNodeType;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodeT&gt;</div>
<div class="line"><span class="keywordtype">void</span> operator()(<span class="keyword">const</span> NodeT &amp;node, <span class="keywordtype">size_t</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// iterate over active tiles</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> iter = node.beginValueOn(); iter; ++iter)</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_class" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html">openvdb::CoordBBox</a>  b;</div>
<div class="line">        b.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html#a7132dc61617b69ed3c447021b1f7c12c">min</a>() = iter.getCoord();</div>
<div class="line">        b.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html#a773a39c4785388b82551df3cfaee2fd1">max</a>() = b.<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1CoordBBox.html#a7132dc61617b69ed3c447021b1f7c12c">min</a>().<a class="code hl_function" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html#a346f761fd6ac48d8804f6b77fcc7026b">offsetBy</a>(NodeT::ChildNodeType::DIM);</div>
<div class="line"> </div>
<div class="line">        processNodeBlock(b);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> operator()(<span class="keyword">const</span> LeafT &amp;leaf, <span class="keywordtype">size_t</span>)</div>
<div class="line">{</div>
<div class="line">    processNode(leaf);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a576ce1469c40253573f9c3ad65369806" name="a576ce1469c40253573f9c3ad65369806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576ce1469c40253573f9c3ad65369806">&#9670;&#160;</a></span>volumeToMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void volumeToMesh </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#ab407b3d357305019c37259d8f5d7f1a7">Vec3I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>triangles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>isovalue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>adaptivity</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>relaxDisorientedTriangles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adaptively mesh any scalar grid that has a continuous isosurface. </p>
<p>When converting to polygons, the adaptivity threshold determines how closely the isosurface is matched by the resulting mesh. Higher thresholds will allow more variation in polygon size, using fewer polygons to express the surface. Triangles will only be created for areas of the mesh which hit the adaptivity threshold and can't be represented as quads. </p><dl class="section note"><dt>Note</dt><dd>Do not use this method just to get a triangle mesh - use the above method and post process the quad index list.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar grid to mesh </td></tr>
    <tr><td class="paramname">points</td><td>output list of world space points </td></tr>
    <tr><td class="paramname">triangles</td><td>output triangle index list </td></tr>
    <tr><td class="paramname">quads</td><td>output quad index list </td></tr>
    <tr><td class="paramname">isovalue</td><td>determines which isosurface to mesh </td></tr>
    <tr><td class="paramname">adaptivity</td><td>surface adaptivity threshold [0 to 1] </td></tr>
    <tr><td class="paramname">relaxDisorientedTriangles</td><td>toggle relaxing disoriented triangles during adaptive meshing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if <em class="arg">grid</em> does not have a scalar value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2641c8c08ca3ed3bf4cea4d9b52434b5" name="a2641c8c08ca3ed3bf4cea4d9b52434b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2641c8c08ca3ed3bf4cea4d9b52434b5">&#9670;&#160;</a></span>volumeToMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GridType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void volumeToMesh </td>
          <td>(</td>
          <td class="paramtype">const GridType &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0_1_1math.html#ae60b991a87c83e25ec51e0576209be11">Vec3s</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v13__0.html#a1b3b3d39bd0af138296a8de32155eadb">Vec4I</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quads</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>isovalue</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uniformly mesh any scalar grid that has a continuous isosurface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a scalar grid to mesh </td></tr>
    <tr><td class="paramname">points</td><td>output list of world space points </td></tr>
    <tr><td class="paramname">quads</td><td>output quad index list </td></tr>
    <tr><td class="paramname">isovalue</td><td>determines which isosurface to mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v13__0_1_1TypeError.html">TypeError</a></td><td>if <em class="arg">grid</em> does not have a scalar value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a5844baaab66cb9519db44a85d8cc0fd7" name="a5844baaab66cb9519db44a85d8cc0fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5844baaab66cb9519db44a85d8cc0fd7">&#9670;&#160;</a></span>FastSweeping&lt; SdfGridT, ExtValueT &gt;::mOffset</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SdfGridT, typename ExtValueT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v13__0_1_1math_1_1Coord.html">Coord</a> <a class="el" href="classopenvdb_1_1v13__0_1_1tools_1_1FastSweeping.html">FastSweeping</a>&lt; SdfGridT, ExtValueT &gt;::mOffset[6]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{-1,0,0},{1,0,0},</div>
<div class="line">                                                             {0,-1,0},{0,1,0},</div>
<div class="line">                                                             {0,0,-1},{0,0,1}}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0.html">v13_0</a></li><li class="navelem"><a href="namespaceopenvdb_1_1v13__0_1_1tools.html">tools</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
